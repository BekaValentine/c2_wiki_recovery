<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Engineering Envy
      </h1>
      <p>
        "What do you lack that they have? A diploma." -- <a href="TheWizardOfOz.html">TheWizardOfOz</a>
      </p>
      <p>
        What do engineers have that we don't, but wish we did?
      </p>
      <p>
        Two things that I really envy civil engineers:
      </p>
      <ul>
        <li>
           A common understanding of acceptable practice. You don't get to be a civil engineer unless you persuade working civil engineers that you know what you are doing and can be trusted with other people's lives. I have no idea how to certify software competence; every attempt I've seen has certified platform knowledge <em>[$$$]</em>, at best. I don't think we understand what we're doing well enough to certify it yet.
        </li>
      </ul>
      <ul>
        <li>
           Review boards. When a building falls down, a review board is called in to figure out why and update the acceptable practice so that it doesn't happen again. In software, we bury our mistakes; when a $10-million project is cancelled after coming in 2 years late with unusable deliverables, everybody says "That's software for you" and moves on to do something else.	But is it possible to have a review board before you have a common understanding of acceptable practice?
        </li>
      </ul>
      <ul>
        <li>
           Something external and objective to test ideas against. See <a href="DisciplineEnvy.html">DisciplineEnvy</a>. Most software engineering metrics are too closely tied to psychology, and psychology is a very immature discipline compared to chemistry and physics. See <a href="MostHolyWarsTiedToPsychology.html">MostHolyWarsTiedToPsychology</a>. -- top
        </li>
      </ul>
      <p>
        I think that we, as a discipline, are missing an invaluable learning opportunity because we don't have formal <a href="PostProjectReview.html">PostProjectReview</a>(s) on all projects, successful and unsuccessful.
      </p>
      <p>
        Credit: This idea first came to me when reading <a href="WhyBuildingsFallDown.html">WhyBuildingsFallDown</a>.
      </p>
      <p>
        -- <a href="BetsyHanesPerry.html">BetsyHanesPerry</a>
      </p>
      <hr/>
      <p>
        <strong>Discussion:</strong>
      </p>
      <p>
        Is it possible that these two things are easier to bring about in disciplines with more stable user expectations? I may be very wrong here, but I feel that the answer to "What can software do?" has changed rather significantly over my lifetime, but the answer to "What can a building do?" has stayed much more stable. If a civil engineer stumbles across this page, I'd be very interested in their thoughts. -- <a href="DavidSaff.html">DavidSaff</a>
      </p>
      <hr/>
      <p>
        One thing that software does not have is recourse to natural laws - a civil engineer can always make a beam slightly smaller, and s/he knows that it will behave <strong>almost</strong> the same as the thicker one. Software seems at times to be chaotic - slight changes in the initial conditions have great and unpredictable effects on the outcome. And few customers of a building want as many structural changes as software customers want - they know it's hard to change concrete, but software is <a href="OnlyOnesAndZeros.html">OnlyOnesAndZeros</a>.
        -- <a href="PeteHardie.html">PeteHardie</a>
      </p>
      <p>
        Exactly, because software can only <em>simulate</em> a beam of light...provide a metaphor for light by exploiting a video monitor. The simulator is <strong>not</strong> the beam of light, so it acts unpredictably. It does not <em>have the nature of a physical beam of light.</em> However, we can write software that <em>controls</em> a real beam of light, but even that method of control will be another metaphor for some phsyical kind of controller. The software can never be the <em>phsyical entity</em> it models. It will be cool when software starts creating new constructs that aren't even based on the physical world. This has started but is still in its infancy. -- rad
      </p>
      <p>
        Yikes, no! Small changes in engineering can have radical effects on not only the structure itself (how about that bridge that collapsed, simply because they added a small windbreak for the pedestrian traffic?) but things around it (an entire city situated on an island, connected to the Oregon Coast by an isthmus disappeared when the Army Corps of Engineers put up a seawall for a neighboring harbor). Oftentimes these civil engineers don't know what their changes will produce, of course these results may be the most dramatic, and thereby get books written about them, whereas software crises seem much more common. I think this whole discussion misses the point that we can never be like civil engineers, everything we do, succeses and failures, rarely is even widely known within an organization, let alone to the world. -- anon 
      </p>
      <hr/>
      <p>
        <em>One thing that software does not have is recourse to natural laws... -- Pete Hardie</em>
      </p>
      <p>
        Isn't information theory subject to, or even part of, natural law? And don't we regularly exploit the continuities of that discipline? I'm striving to put my finger on just where software departs, and I know that it does. Can anyone help me?
      </p>
      <p>
        -- <a href="WaldenMathews.html">WaldenMathews</a>
      </p>
      <p>
        Everthing we develop in software is metaphorical. Every software system is representative, symbolic, or analogous to something else physical. This doesn't mean it has to <em>look</em> like something else, just be a level of indirection to it - an <em>interface</em> or a <em>conduit</em>. This is the essential difference between Software Engineering and almost <strong>everything</strong> else in Civil Engineering. Software <em>must</em> be metaphorical. Other mediums, can be, but don't <em>have</em> to be. When a Civil Engineer designs a bridge, it is a <em>real</em> and <em>tactile</em> bridge and people can move across it. It is not <em>a metaphorical bridge</em> or <em>a representation of a bridge</em>. It does not <em>symbolize</em> a bridge. I went off on this for a while in <a href="ArchitectingWord.html">ArchitectingWord</a>. <em>For example, Quicken provides a metaphor of your checkbook (i.e. your actual Checking Account not the timy pieces of paper that are themselves an indirection). A Wordprocessor provides a metaphor for writing a document. Even a real-time control system is metaphorical of the system it is controlling!!</em> For me, this is something that is very unique about software, maybe its most unique attribute. It is <em>always</em> indirection. Software inhabits the <em>machine</em>. It is never tactile but it may <em>control</em> something tactile - indirectly. It may enumulate, be analogous to, or mimic something tactile (even as much as in <a href="VirtualReality.html">VirtualReality</a>) or not, but it is still an indirection. The software system <em>itself</em> is never the <em>entity or process it is representing</em> - software is never the <em>final intention</em>. It is always the metaphor of something else, like a payroll system or a 401K plan. This doesn't mean it has to <em>look</em> like or <em>emulate</em> a traditional payroll system or 401K plan. That misses my point. The point is that <strong>you can look through the software to the payroll system</strong>. This is the really wonderful thing about Software. <em>Software is allegory.</em> Here, allegory refers to characters, user and programmer interfaces, and expression that represent abstract ideas and concepts. -- <a href="RobertDiFalco.html">RobertDiFalco</a>
      </p>
      <p>
        A computer program is a blueprint for a virtual machine. The computer automatically translates that blueprint into a machine. The machine obeys the physical laws of the computer. What makes software seem different from a bridge is our repeated misunderstanding of it - we keep thinking that the software is the <em>machine itself.</em> -- <a href="AnonymousDonor.html">AnonymousDonor</a>
      </p>
      <p>
        <em>This is exactly </em>'why<strong> I say that software is allegory. We can't even describe it without entering into allegory. This is why we say </strong>virtual<strong> machine, it's not a <em>real</em> machine - only the hardware is a physical and tactile machine. Software by definition </strong>runs in the allegorical world<strong> - its home is metaphor-land and its strengths are indirection!! Cool. If we build a bridge in software using a </strong><a href="BridgePattern.html">BridgePattern</a> or are making a virtual bridge in a game - two VERY different things - neither is tactile, a person cannot walk across it. Both are created to represent something else. To provide a view on to some other concept. Only ideas, objects, or virtual characters can span our software bridges. This is cool, something to be embraced. Software is always a tool. Nothing else resembles this aspect of software in that it is only used for indirection. I can't think of a single entity in the software realm that is not symbolic - that is not a <em>concept</em>. If we think about the hardware that runs software, we <em>can</em> find reality, but not in the software itself. It's just ideas. I almost prefer to use the analogy of allegory or the analogy of metaphor but both work well for communicating that idea of <em>indirection</em>. -- <a href="RobertDiFalco.html">RobertDiFalco</a><em></em>
      </p>
      <p>
        <em>Always expect what I write to change as I refine my wording and ideas... I don't have my mind made up about anything and am constantly evolving my points of view. -- </em>TheEmptyRiceBowl<em></em>
      </p>
      <hr/>
      <p>
        Robert, I think you're close with this, but I'm still missing something. While it's true that Quicken <em>used to be</em> a metaphor for my checkbook, it now <em>is</em> my checkbook. The difference is just some network links. And while a real-time control program may use an internal model of its environment, I believe the control mechanism is just that, not a metaphor for a control mechanism. But I definitely see the rampant use of metaphor in what we as a programming community tend to do when we ply our craft (and talk about it). I wonder: is the metaphor essential, or is it maybe a large part of what stands between us and credible engineering?
      </p>
      <p>
        Thanks for your generous contribution.
      </p>
      <p>
        -- <a href="WaldenMathews.html">WaldenMathews</a>
      </p>
      <p>
        I understand <a href="TheMapHasReplacedTheTerritory.html">TheMapHasReplacedTheTerritory</a>, but this isn't the case in Quicken. I'm going to attempt to peel one layer at a time since there are so many ways to view metaphor and something like Quicken actually uses them all! First, is the most outer layer - the relationship between Quicken and the look and use of a traditional Checkbook. Most of us use Quicken <em>with</em> our Checkbooks. We haven't ceased to write <em>any</em> traditional checks, just fewer. Even when Quicken does completely supplant the Check Book and move on to not simulate the Check Book in its user interface, there are still other, even more important metaphorical attributes of Quicken. The next level to this is the <em>balancing</em> of our checking accounts. Quicken has indeed replaced the manual way of <em>balancing</em> your checkbook with a paper and pen. However, that doesn't stop Quicken from being a metaphor of your checking account. We have to go in another layer to see that even the tradition <em>paper</em> based ledger it replaces was already just a device we could look through to <em>see</em> what is <em>at the bank</em>. So, Quicken did what commercial products sometimes do. They replaced an existing metaphor with a much more powerful, software based one. Unfortunately, they chose to <em>emulate</em> the old metaphor in their User Interface. However, the important point I'm trying to make is that while Quicken may base its look and workflow on your checkbook - both the check book and Quicken are really just metaphors of your banking data. Go to the next layer and we find that what is <em>at the bank</em> (their software, databases, and paper ledgers) are just a layer of indirection to <em>paper money</em>. Is there yet another layer of indirection? Of course. I'm sure everyone has guessed it. It is the <em>paper money</em> itself! Money is simply a symbol for the exchange of goods and services. So, even if we go to a system devoid of paper money, even the electronic records will be markers and not the <em>final</em> layer. Just a different metaphor. Just a better way to <em>represent</em> the exchange of goods and services. 
      </p>
      <p>
        It <em>seems</em> to us like a real-time control system is more than just a way to interact with (i.e. monitor and control) physical sensors and actuators. But no matter how complex the control <em>software</em> becomes, it will never become the physical sensors and actuators. <em>Software will always be </em>'a level of indirection to something else<em></em>'. There may be fringe cases, but as a rule, software only exists to <em>model</em> or provide a way to <em>control</em> something else. For me the best software designs are those that recognize this and view themselves as allegorical - lots of symbolism, characters, and events - instead of a world unto themselves. -- <a href="RobertDiFalco.html">RobertDiFalco</a> 
      </p>
      <p>
        <em>..is the metaphor essential, or is it maybe a large part of what stands between us and credible engineering?</em>
      </p>
      <p>
        Walden, I'm not even sure what this <em>means</em>. What is <em>credible</em> engineering? Do you mean <em>good</em> software engineering? I have no idea. However, I think what stands between programmers and great software systems is ignoring the metaphorical attributes of what they do. Don't confuse this with <a href="ArchitecturalStyle.html">ArchitecturalStyle</a>'s, <a href="SystemMetaphor.html">SystemMetaphor</a>, or even the emulation of real-world entities. This is <strong>not</strong> what I mean when I say metaphor or allegory. Most software developers get so caught up in what they are creating that they loose sight of the fact that they are creating a <em>conduit</em>. They begin to think their software is the <em>finality</em>. Loosing sight of the fact that they are providing a representation of something else, like a 401K plan or payroll system, immeadiately hurts the <em>user</em>. <strong>The user does not care about your software, they care about what your softare allows them to do.</strong> This doesn't mean that a word processor must look like a piece of paper. That's missing the point. Rather, it means that the designer of the word procesor should understand that they are not writing a word processor but are designing a tool for writing - something that will serve as a conduit for the human process of writing. -- <a href="RobertDiFalco.html">RobertDiFalco</a>
      </p>
      <hr/>
      <p>
        Robert (Rob?), up above, you said <em>"Nothing else resembles this aspect of software."</em> But here (just above) you've discovered that monetary systems have been that way for a long time. I'll go with your later discovery; software systems are not unique for their generous use of symbolism.
      </p>
      <p>
        A generally accepted and modern definition for "engineering" is "the use of science or scientific method as applied to building things". The fact that software developers are "building things" is not worth challenging, but the use of scientific method certainly draws doubts. The Tarot reader recently pronounced that "everything will be okay" in my family, but I don't put too much stock in that. The reading, by the way, was based on level after level of metaphor, most of it well beyond my intellectual or spiritual means.
      </p>
      <p>
        I think what I come away from this with is as follows. Much of what we build computer systems for is stuff where human thought reigns without any solid mass to evince it. The fact that someone walked through my front door five seconds ago is a critical piece of information to the home alarm system, but go look for some physical state that that represents, and you won't find it. We imagine the concept of time, and create symbols for it. Human symbology is imperfect, and subject to perversion by minds that insist on "seeing" things in a way that suits the current (often survival) purpose. This is just a human condition, not a computer thing...
      </p>
      <p>
        Enter the computer. What do we use it for? To record transactions, count how much time elapsed since a particular sensor was activated, etc. In other words, we use it to extend our own memories and temporal awarenesses, stuff that's already a sea of uncertainty. When software developers talk architecture bullshit (some do, admit it) they're doing the same thing the Tarot reader does, but directing it towards the building of software. I repeat: Is this necessary?
      </p>
      <p>
        "All the world's a stage." That's metaphor. The speaker didn't build the world, nor did he build the stage. He just equated them. You make a distinction between the software and the computer, the computer and the sensors and actuators. What are we talking about here, just software? If so, software alone is not a metaphor for anything. And at best, when Quicken pretends to be your checkbook, that's purely intentional on the part of the Quicken builders. So it's not metaphor, it's "metaphor". Know what I mean?
      </p>
      <p>
        Thanks for an interesting discussion.
      </p>
      <p>
        -- <a href="WaldenMathews.html">WaldenMathews</a>
      </p>
      <p>
        <em>Robert (Rob?), up above, you said </em>"Nothing else resembles this aspect of software."<em></em>
      </p>
      <p>
        I prefer Robert, thanks for asking most people don't and end up calling me Bob (which is fine for some Roberts). First I should have said - <em>nothing else in Civil Engineering</em>. Most of my initial comments were meant to be compared with traditional engineering and architecture. But even so, what I meant is unique is not that software systems <em>can</em> be representative, it is that indirection is an immutable attribute <strong>of</strong> software. Anything <em>can</em> be used for indirection to something else. Software is unique in that is almost always is this. (Clearly, I'm not talking about electronic pulses here.) I think as designers we too often mistake our software for the final subject matter instead of a representation of it. As Tom points out, a great analogy for this is <em>mistaking money for value</em>. -- <a href="RobertDiFalco.html">RobertDiFalco</a>
      </p>
      <p>
        <em>...but go look for some physical state that that represents, and you won't find it</em>
      </p>
      <p>
        Actually there is and it is staring us right in the face! It is <em>someone walking through my door</em>. That is the state the software of your alarm system is representing. -- rad
      </p>
      <p>
        <em>So it's not metaphor, it's "metaphor". Know what I mean?</em>
      </p>
      <p>
        I'm not sure. But I do NOT think that metaphor, symbolism, or indirection means that a software program for playing CD's needs to look like a Stereo System. Not at all! It <strong>does mean</strong> that a good software system for playing audio will do an excellent job of symbolizing the users interaction with the audio stored on that CD. Further, it will understand its role in this. Because it understands this, it may even do such a good job that the user forgets the audio files and the CD altogether. This is what I meant when I said Quicken isn't representing your ledger, its representing your account activity. Is this what you mean by "metaphor" as opposed to metaphor? -- <a href="RobertDiFalco.html">RobertDiFalco</a>
      </p>
      <hr/>
      <p>
        Well I'm confused. A couple of thoughts:
      </p>
      <p>
        Computer programs are real, they have physical existence as electrical potentials in circuits. We may 'think' in metaphor when we design and build software but the software still has physical reality. I assume this is not really the reality under discussion. Certainly most software development models a system. In many cases this modelling is so important that the software 'becomes' the system, this can happen in other metaphorical systems, too (The confusion of 'money with value' led to the collapse of the Spanish empire).
      </p>
      <p>
        So we are talking about two relationships with reality:
      </p>
      <ul>
        <li>
           Software's physical reality (electrical and magnetic fields in circuits and media) and its metaphorical reality as a metaphor? The first is not interesting to most software developers except for performance and sizing exercises - The last 'make it fast' stage of software development - or the odd pissing match. (I think Robert missed this one; his description of software seems almost dualist.)
        </li>
        <li>
           Software's metaphorical reality or how well it models something for us.
        </li>
      </ul>
      <p>
        I think the problem with most software development is that it's a metaphor for a metaphor for a metaphor. Layer upon layer of systems built by arbitrary decisions before the software engineer gets a look in. A payroll isn't real (it's just a load of squiggles in a book that maps to another metaphor, monetary payments. That's one of the reasons that it is so hard to become a domain expert and why so many users don't know what their system should do.
      </p>
      <p>
        That may also be why real-time mechanical control developers and business system developers have so many communication problems. One works with maybe two levels of metaphor, the other with dozens.
      </p>
      <p>
        My head hurts now. -- <a href="TomAyerst.html">TomAyerst</a>
      </p>
      <hr/>
      <p>
        Tom, you took the words out of my mouth with that last bit about real-time mechanical control. I was thinking as I was writing above that these systems have something special, as compared with the rest of software systems, and you've explained what that is. -- <a href="WaldenMathews.html">WaldenMathews</a>
      </p>
      <hr/>
      <p>
        To take the thought further this may be why some programmers like languages such as C and C++ where they can drop into 'close to the metal' mode. In this mode they stop having to worry about interpreting someones interpretation of a business metaphor. Building a better threading library is hard, but the victory conditions are more obvious than understanding the implications of reimplementing <em>soft-dollar vs hard-dollar charging regimes in a pure-agency, correspondent trade flow</em> (to take an example close to my heart).
      </p>
      <p>
        I'm tempted to make some comment about Smalltalk developers managing this better but I won't. ;-) -- <a href="TomAyerst.html">TomAyerst</a>
      </p>
      <hr/>
      <p>
        Off-topic request for info: what is "Quicken" and what is the "balancing" of a cheque-book? 
      </p>
      <p>
        <em>See </em><a href="WhatIsQuicken.html">WhatIsQuicken</a><em></em>
      </p>
      <hr/>
      <p>
        There's much discussion above of <em>metaphor</em>. Bringing this back to the topic <a href="EngineeringEnvy.html">EngineeringEnvy</a>, it occurs to me that in other engineering fields, it's possible to dispense with imprecise, metaphorical reasoning when deemed necessary, and I'm not sure we can do that in software, but I wish we could. The metaphorical application of software-based products (like thinking of Quicken as your checkbook) is not the issue. The issue is whether we allow fuzzy, metaphorical thinking to crowd out semantically precise specifications when we're making software. Precise semantics is harder, so our bias should come as no surprise. Please see <a href="WhatIsMetaphor.html">WhatIsMetaphor</a>.
      </p>
      <p>
        Much of the discussion above should probably be moved to a different page, or deleted. Tom and Robert, would you care to summarize?
      </p>
      <p>
        -- <a href="WaldenMathews.html">WaldenMathews</a>
      </p>
      <hr/>
      <p>
        Discussion has lapsed. I may be restating some of the thoughts above:
      </p>
      <p>
        In an increasing number of cases (typically <a href="RealTime.html">RealTime</a> environments) software is being used in a real Engineering sense. If the firmware used to control a car, pumping station, or other critical system is screwed up, then you get the real life equivalent of collapsing bridges and falling buildings (differing only in scale).
      </p>
      <p>
        Yes, <a href="SoftwareIsModeling.html">SoftwareIsModeling</a>, and software is really only an abstraction of the related reality, but because of the "leverage" provided by electronic controls (think servos and relays), the amount of <a href="FirstDomino.html">FirstDomino</a> voltage is at or below TTL. This means that the signal resulting from a "store" (or "out") instruction can cause real life events (open doors, raise/lower elevators, open/close valves, etc.), making it the unique case of map-controls-the-territory.
      </p>
      <p>
        Consequently, it becomes necessary for programmers (some, at least) to think and behave like engineers.
      </p>
      <p>
        I currently write firmware that gathers and relays data in <a href="NearRealTime.html">NearRealTime</a>. It's not mechanical control, so if I screw up nobody dies, but my employers or their customers stand to lose substantial sums. The risks are "only financial" but clearly it's worth adopting an engineering approach to counter those risks.
      </p>
      <p>
        Some software has no real world risks (e.g. games - never mind impacts on vision and tendonitis), while some has fairly low risks. Some software companies recognize that it's possible to draw credible causal relationships between their software and real world risks, and so write ponderous disclaimers as their way out of that.
      </p>
      <p>
        As software becomes more and more embedded in the real world, its practitioners must become engineers, if not in name, then at least in practice. Some <em>common understanding of acceptable practice</em> is, or will be, an unavoidable requirement. I understand (first hand) the problems in defining the complete set of criteria for validating given software, but when it controls your car's brakes, you need to get it right.
      </p>
      <p>
        -- <a href="GarryHamilton.html">GarryHamilton</a>
      </p>
      <hr/>
      <p>
        Like I stated above, if a bridge falls down, everyone knows, it's on the news, in the paper, etc. If a software project fails (or succeeds) many, many times, hardly anyone knows. Everything must be hidden behind a cloak of intellectual property, copyright, trade secret, and Non-Disclosure Agreements (or another country's equivalents). We can never have the same accountatbility, or even work the same way as civil engineering while we function in this way, so why bother trying to make the comparison? I'm asking a legitimate question here, if someone knows a valid reason that engineering is a good metaphor for what I do (my resume and job title say Software Engineer after all), I'd love to hear it.
      </p>
      <hr/>
      <p>
        Wow guys. Great discussion. I'm not a regular visitor to this site so I don't know if I'll be able to read any of the follow-ups to this post, but wanted to add this.
      </p>
      <p>
        Remember, we could all be brains in a jar!
      </p>
      <p>
        As a software engineer, we manipulate the states and rules that define our cyber-worlds just as civil engineers manipulate the states and rules that define the "physical" world (though generally they have less control over the rules). But of course the physical world may just be someone else's cyber world. There's no way to really know and I don't think it really matters. We *know* that both worlds, what we call physical and what we call cyber, exist. They are sets of rules and states of quarks/electrons/bytes, and that state is held in someone's computer or someone's mind or someone's space-time manifold or elaborate system of strings and pulleys; which in turn may be hosted in some other mind/computer/space-time manifold.
      </p>
      <p>
        You suggest that the work of a software engineer is less important and visible than the work of civil engineers. This is generally true, probably because the world of buildings and bridges is still so important to people. But in the future what we are currently calling the cyber-world may become more important that what we're calling the physical world; as more and more important stuff, such as bank account balances and google page rankings becomes housed entirely within the cyber world. We may end up spending more and more time in virtual reality, hooking wires to our brains. The singularity may arrive and every bit of matter in the world may be refined and converted into a sort of cyber-soup in which intereseting things like people and bridges are represented much more efficiently as arrangements of light and electrons instead of the gross old-fashioned way of representing things as arrangements of atoms and molecules (such a waste of space!). Or we may find a way to hack into the computer that is hosting our physical universe and learn to program bridges into existence.
      </p>
    </div>
  </body>
</html>