<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Runtime Polymorphism
      </h1>
      <p>
        <a href="RunTime.html">RunTime</a> polymorphism is a form of <a href="PolyMorphism.html">PolyMorphism</a> (see <a href="PolymorphismExample.html">PolymorphismExample</a>) at which FunctionBinding occurs at runtime. This means that the exact function that is bound to need not be known at <a href="CompileTime.html">CompileTime</a>.
      </p>
      <p>
        Typically, runtime polymorphism is implemented in <a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a> by requiring the programmer to define <a href="BaseClass.html">BaseClass</a>es or InterfaceClasses that contain at least the FunctionSignatures of one or more ClassMethods. Interfaces are analogous to <a href="AbstractClass.html">AbstractClass</a>es in languages that do not differentiate between interface classes and "real" classes, e.g., <a href="CeePlusPlus.html">CeePlusPlus</a>.
      </p>
      <p>
        A function can then accept an <a href="ObjectPointer.html">ObjectPointer</a> or ObjectReference of the base class or interface and call its methods as if they were monomorphic methods. Code that uses the function can instantiate a DerivedClass and pass a reference of the new object to this function, and the calls to the base class methods will be properly dispatched to the derived class. Usually, the compiler forbids the instantiation of a class that does not provide FunctionDefinitions for all inherited method signatures, where method definitions aren't also inherited as well. In some languages, like <a href="JavaLanguage.html">JavaLanguage</a> and <a href="CeeSharp.html">CeeSharp</a>, the compiler is even stricter and requires that all real classes must implement all method signatures obtained from DirectInheritance of interface classes, while interface classes must never provide method definitions, and cannot be instantiated.
      </p>
      <p>
        Some languages, for example <a href="PerlLanguage.html">PerlLanguage</a>, do not use any kind of StaticTypeChecking for runtime polymorphism. In these languages, trying to call a method for which no suitable definition is found will result in a RuntimeError.  <em>Other examples are </em><a href="SmalltalkLanguage.html">SmalltalkLanguage</a>, <a href="RubyLanguage.html">RubyLanguage</a>, and <a href="ObjectiveCee.html">ObjectiveCee</a>.<em></em>
      </p>
      <p>
        <a href="LispLanguage.html">LispLanguage</a>, in turn, does not use the ObjectMetaphor at all and permits polymorphism in more than one parameter (the object reference in object-oriented languages counts as a parameter), called <a href="MultiMethods.html">MultiMethods</a>.
      </p>
      <p>
        Runtime polymorphism is often interchangeable with CompiletimePolymorphism. Runtime polymorphism can be substituted almost anywhere that compile time polymorphism is employed, though the converse is not true. On the other hand, in situations where compile time polymorphism can be used, it is often regarded as superior because of more thorough StaticTypeChecking, higher efficiency, and/or higher convenience (in particular, to avoid having to use a lot of DownCasts).
      </p>
    </div>
  </body>
</html>