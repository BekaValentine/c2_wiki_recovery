<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Finite State Machine
      </h1>
      <p>
        Definition: A <a href="ModelOfComputation.html">ModelOfComputation</a> consisting of a set of states, a start state, an input alphabet, and a transition function which maps input symbols and current states to a next state. Computation begins in the start state with an input string. It changes to new states depending on the transition function. There are many variants, for instance, machines having actions (outputs) associated transitions (MealyMachine) or states (MooreMachine), multiple start states, transitions conditioned on no input symbol (a null) or more than one transition for a given symbol and state (nondeterministic finite state machine), one or more states designated as accepting states (recognizer), etc. 
      </p>
      <p>
        Also known as <a href="FiniteStateAutomaton.html">FiniteStateAutomaton</a> or FiniteAutomaton. Part of the <a href="ChomskyHierarchy.html">ChomskyHierarchy</a>.
      </p>
      <p>
        Parroted from <a href="http://www.nist.gov/dads/HTML/finiteStateMachine.html">http://www.nist.gov/dads/HTML/finiteStateMachine.html</a>
      </p>
      <p>
        All digital electronics (wristwatches, CPUs, RAM, pacemakers, etc.) are finite state machines.
        Some people speculate that the entire universe is a finite state machine.
      </p>
      <hr/>
      <p>
        One studies FSMs and other machines in AutomataTheory, a college class with no shortage of greek letters.
      </p>
      <p>
        Finite state machines find practical application in lexical analyzers and parsers, where they may have tens or even hundreds of states. 
      </p>
      <p>
        <em>Most parsers are implemented using </em>PushdownAutomata, not <a href="FiniteStateMachine.html">FiniteStateMachine</a>s. FSMs cannot handle context-free grammars; virtually all high-level languages have a grammar which (ignoring semantic actions) is context-free.<em></em>
      </p>
      <p>
        (Really? But I thought a computer <em>is</em> a FSM, and it seems to handle ContextFreeGrammar just fine.)
      </p>
      <ul>
        <li>
           Technically, a computer is a <a href="FiniteStateMachine.html">FiniteStateMachine</a>, but one with an incredibly large number of states. As such, it can be used to model <a href="TuringMachine.html">TuringMachine</a>s and PushdownAutomata, and the modelling is exact--that is, until you get an out of memory error. (At which point, if you add more memory, the illusion will be again preserved until <em>that</em> memory is exhausted). For many practical problems, the spell is never broken.
        </li>
      </ul>
      <p>
        Do you know where I could find a diagram of one of these lexical finite state machines?
      </p>
      <p>
        <em>You can write one yourself with a tool such as lex.</em>
      </p>
      <p>
        You can find a <a href="FiniteStateMachine.html">FiniteStateMachine</a> simulator at <a href="http://www.belgarath.org/java/fsme.html.">http://www.belgarath.org/java/fsme.html.</a>
      </p>
      <p>
        See also State Machine Compiler at <a href="http://smc.sf.net">http://smc.sf.net</a>
      </p>
      <p>
        Just Gotta see <a href="TheDragonBook.html">TheDragonBook</a>: <em>Principles of Compiler Design</em> Aho, Ulmann, and crew. --gl
      </p>
      <hr/>
      <p>
        RAM can be thought of as a (very simple) finite state machine, with a vast number of states. A CPU can be thought of as a (somewhat more complex) finite state machine, but with fewer internal states. A ROM can be considered an even more complicated FSM (MealyMachine) with only one state.
      </p>
      <p>
        At times it is convenient to think of 2 or more interacting finite state machines ("CPU" and "RAM" for example) as a single larger finite state machine ("a computer").
      </p>
      <p>
        In theory, a computer is a finite state machine where the state space is the total possible configurations of memory. This would be two raised to the power of the total number of bits of storage.
      </p>
      <p>
        When actually building hardware, it's usually easier/cheaper to build several smaller FSMs and link them together than to build the large machine directly. For example, CPUs are usually designed as a collection of little bits of RAM and ROM and ALUs and other FSMs glued together with the "control logic" finite state machine -- each FSM fairly trivial when considered by itself.
      </p>
      <p>
        <em>But a computer is modeled as a </em><a href="TuringMachine.html">TuringMachine</a>, even though they do have finite memory. Until you run OUT of memory, there isn't much of a difference.<em></em>
      </p>
      <hr/>
      <p>
        See: <a href="InfiniteStateMachine.html">InfiniteStateMachine</a>, <a href="StateMachine.html">StateMachine</a>, <a href="StateMachinesAreBetter.html">StateMachinesAreBetter</a>
      </p>
    </div>
  </body>
</html>