<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Quick Sort
      </h1>
      <p>
        Quick Sort is a sorting algorithm invented by <a href="CarHoare.html">CarHoare</a> in 1960 and published in 1961; it's really simple, and probably it's the most efficient sorting algorithm.  Not a <a href="StableSort.html">StableSort</a>.
      </p>
      <p>
        Quicksort works by "partitioning" the array to be sorted, then recursively sorting each partition. Here is the pseudocode.
      </p>
      <code>
        procedure QuickSort (array A, int L, int N)<br/>
        if L < N<br/>
        M := Partition (A, L, N)<br/>
        QuickSort (A, L, M - 1)<br/>
        QuickSort (A, M + 1, N)<br/>
        endif<br/>
        endprocedure<br/>
      </code>
      <code>
        Int function Partition (array A, int L, int N)<br/>
        select M, where L <= M <= N<br/>
        reorder A(L) ... A(N) so that I < M implies A(I) <= A(M), and I > M implies A(I) >= A(M) <br/>
        return M<br/>
        endfunction<br/>
      </code>
      <p>
        Note that how M is selected is omitted as an implementation detail! To improve efficiency, use a more efficient procedure when N - L is small.
      </p>
      <p>
        Here you'll find some quicksort code in C and C++:
        <a href="http://theory.stanford.edu/~amitp/rants/c++-vs-c/.">http://theory.stanford.edu/~amitp/rants/c++-vs-c/.</a>
      </p>
      <p>
        Also see <a href="QuickSortInHaskell.html">QuickSortInHaskell</a>,<a href="QuickSortInPython.html">QuickSortInPython</a>, <a href="QuickSortInRuby.html">QuickSortInRuby</a> for sample implementations of the algorithm.
      </p>
      <p>
        See <a href="SortingAlgorithms.html">SortingAlgorithms</a>
      </p>
      <hr/>
      <p>
        Moved here from <a href="SortingAlgorithms.html">SortingAlgorithms</a> (<a href="RefactorMe.html">RefactorMe</a>):
      </p>
      <p>
        <strong></strong><a href="QuickSort.html">QuickSort</a><strong>: pick an element at random (or in some other more or less sophisticated way), rearrange your array so that the smaller elements all come at the start, all the equal elements come in the middle, and the larger elements all come at the end (surprisingly difficult to get this both efficient and right) and then recurse on the smaller and larger elements. Expected time-complexity is <em>O(n log n)</em> with little overhead, but if you choose bad pivots either by luck or design then you can get <em>n^2</em> time. If you always recurse on the smaller sub-array and iterate (i.e., eliminate a tail call) for the larger one, then you only need O(log n) space however bad the pivots are. It's also worth stopping early and using one of the simple-minded sorts when your pieces are small (about 10 or 16 elements). Alternatively, stop early and do a final pass of </strong><a href="InsertionSort.html">InsertionSort</a> at the end; this imposes less overhead in cycles than doing lots of separate little insertion sorts, but may interact less well with cache (for moderate datasets) or VM (for immoderate ones). Considerable care required to ensure it's stable.
      </p>
      <p>
        <em>I don't see how switching from </em><a href="QuickSort.html">QuickSort</a> to <a href="InsertionSort.html">InsertionSort</a> would ever be faster than switching from <a href="QuickSort.html">QuickSort</a> to <a href="SelectionSort.html">SelectionSort</a> at the same point. Am I missing something ?<em> -- </em><a href="DavidCary.html">DavidCary</a> -- <a href="AnswerMe.html">AnswerMe</a>  <em>Simple answer: insertion sort sorts sorted data in linear time (best case), selection sort comparisons are quadratic in all cases. -- shellreef </em>
      </p>
      <p>
        <strong></strong>SampleSort<strong>: a generalization of </strong><a href="QuickSort.html">QuickSort</a>. Choose a substantial sample from the dataset (the original paper suggests about n/10 items for n up to 50000; probably the sample size should in fact grow more slowly than O(n)). Sort it into order. Partition the dataset into blocks "between" the elements of the sample, and recurse. The sample can be chosen at random (giving expected time O(n log n) and some very low-probability O(n^2) cases) or deterministically (so that some datasets will reliably cause O(n^2) time). As with quicksort (but even more so), you want to stop "early" and switch to a simpler, lower-overhead algorithm once the pieces are small. <a href="QuickSort.html">QuickSort</a> is SampleSort limited to 1 sample.
      </p>
      <hr/>
      <p>
        Essentially everyone is astonished to learn the moderately recent results of RobertSedgewick <a href="JonBentley.html">JonBentley</a> (two incredibly bright and famous CS guys, not random people): "QUICKSORT IS OPTIMAL" (given their new, very simple and extremely elegant improvement - in a certain sense, naturally). See e.g. <a href="http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf">http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf</a> (relates to a "recent talk" of January 2002).
      </p>
      <p>
        (Better references should be inserted here once Citeseer comes back to life again.)
      </p>
      <p>
        This is really, really brilliant work. Astonishing, even. And yet simple. Elegant. To find such a thing in such a basic area of algorithms when no one else had after decades almost speaks for itself. Words fail me.
      </p>
      <p>
        It's easy to implement, too (I've done so).
      </p>
      <p>
        Everyone should know who <a href="JonBentley.html">JonBentley</a> is; RobertSedgewick was a grad student of <a href="DonKnuth.html">DonKnuth</a>'s, did his PhD thesis on <a href="QuickSort.html">QuickSort</a>, wrote a highly readable algorithms textbook, and I should probably know more than that about him. Smart guy. -- <a href="DougMerritt.html">DougMerritt</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryAlgorithm.html">CategoryAlgorithm</a>
      </p>
    </div>
  </body>
</html>