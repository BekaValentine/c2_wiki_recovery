<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Algol Sixty Syndrome
      </h1>
      <p>
        <a href="AlgolSixty.html">AlgolSixty</a> was (and is) widely known as an elegant and concise language; a trait which its creators (<a href="TonyHoare.html">TonyHoare</a> and others - <a href="TonyHoareOnAlgolSixty.html">TonyHoareOnAlgolSixty</a>) were rightly proud of.
      </p>
      <p>
        However, it had a fundamental flaw which limited its use; the language proper provided no I/O facilities. I/O was deemed to be an implementation-defined feature; and many implementations defined it - but it was impossible to write a program in <a href="AlgolSixty.html">AlgolSixty</a> which was both <em>portable</em> (avoiding any feature not guaranteed to work in all implementations) and <em>useful</em> (in this case, capable of interfacing to the outside world).
      </p>
      <p>
        In short, the language was <em>too</em> minimalistic.
      </p>
      <p>
        Today, <a href="AlgolSixty.html">AlgolSixty</a> is pretty much a historical footnote; however numerous other languages have taken a minimalist approach (though not to the extent of <a href="AlgolSixty.html">AlgolSixty</a>) - resulting in criticism that such languages, though elegant and pretty, are not suitable for "real" work. Much real work does get done in these languages, but the results often don't port between implementations.
      </p>
      <ul>
        <li>
           <a href="PascalLanguage.html">PascalLanguage</a>.  Provided I/O, and some basic (though severely crippled) collection types; but not much else. Coupled with very rigorous typechecking (the variant record hole notwithstanding), this gives Pascal a reputation as a <a href="BondageAndDisciplineLanguage.html">BondageAndDisciplineLanguage</a>. Didn't provide lots of things needed for production code (especially considering the time):  bitwise arithmetic (making systems programming difficult; Pascal is otherwise a good systems programming language, with quite a few advantages over C); any portable way of writing libraries and the like. The paper <a href="WhyPascalIsNotMyFavoriteProgrammingLanguage.html">WhyPascalIsNotMyFavoriteProgrammingLanguage</a> contains much spicy criticism.  In fairness to Pascal; it was being used for things it wasn't designed for, and Pascal has spawned many derivatives. PascalSyntax is arguably one of the most-often-reused syntaxes of any programming language.
        </li>
      </ul>
      <ul>
        <li>
           <a href="SchemeLanguage.html">SchemeLanguage</a>.  In many ways, the spiritual successor to <a href="AlgolSixty.html">AlgolSixty</a>.  A wonderfully concise Lisp dialect, widely regarded as elegant.  Also has a reputation for being unsuitable for "real-world" programming (though Scheme is nowhere near as limiting as Pascal is).  Perhaps that's true in the days of GUIs and networking; OTOH <a href="SchemeLanguage.html">SchemeLanguage</a>'s standard library isn't any less comprehensive than that of <a href="CeeLanguage.html">CeeLanguage</a>.  (Of course, C is regarded as a low-level language for systems tasks, so portability isn't an issue; plus many de-facto standard extension libraries (Berkeley sockets, POSIX, Win32) exist for C - and it's the native language for the two most important <a href="OperatingSystem.html">OperatingSystem</a>s these days.  Scheme doesn't have this amount of infrastructure and inertia...)  <a href="SchemeLanguage.html">SchemeLanguage</a> also seems to elicit much derision from the <a href="CommonLisp.html">CommonLisp</a> community, which is unfortunate.
        </li>
      </ul>
      <ul>
        <li>
           <a href="ForthLanguage.html">ForthLanguage</a>. The language is small, and in fact many Forthers have a try at implementing their own Forth. As the joke goes: if you've seen one Forth, then you've seen one Forth.
        </li>
      </ul>
    </div>
  </body>
</html>