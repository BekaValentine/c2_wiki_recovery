<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        You Arent Gonna Need It
      </h1>
      <p>
        <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a> (often abbreviated YAGNI, or <a href="YagNi.html">YagNi</a> on this wiki) is an <a href="ExtremeProgramming.html">ExtremeProgramming</a> practice which states:
      </p>
      <dl>
        <dt> </dt>
        <dd>"Always implement things when you <strong>actually</strong> need them, never when you just <strong>foresee</strong> that you need them."</dd>
      </dl>
      <p>
        Even if you're totally, totally, totally sure that you'll need a feature <em>later on</em>, don't implement it now. Usually, it'll turn out either a) you don't need it after all, or b) what you actually need is quite different from what you foresaw needing earlier.
      </p>
      <p>
        This doesn't mean you should avoid building flexibility into your code. It means you shouldn't overengineer something based on what you <strong>think you might need later on</strong>.
      </p>
      <p>
        This also follows the KISS theorem: Keep it simple, stupid!
      </p>
      <p>
        There are two main reasons to practise <a href="YagNi.html">YagNi</a>:
      </p>
      <ul>
        <li>
           You save time, because you avoid writing code that you turn out not to need.
        </li>
        <li>
           Your code is better, because you avoid polluting it with 'guesses' that turn out to be more or less wrong but stick around anyway.
        </li>
      </ul>
      <p>
        A scenario from <a href="RonJeffries.html">RonJeffries</a> explains the practices:
      </p>
      <p>
        You're working on some class. You have just added some functionality that you need. You realize that you are going to need some other bit of functionality.
        If you don't need it now, don't add it now. Why not?
      </p>
      <dl>
        <dt> </dt>
        <dd>"OK, Sam, why do you want to add it now?"</dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd>"Well, Ron, it will save time later."</dd>
      </dl>
      <p>
        But unless your <strong>universe</strong> is very different from mine, you can't 'save' time by doing the work now, <em>unless</em> it will take more time to do it later than it will to do now. So you are saying:
      </p>
      <dl>
        <dt> </dt>
        <dd>"We will be able to do less work overall, at the cost of doing more work now."</dd>
      </dl>
      <p>
        But unless your <strong>project</strong> is very different from mine, you already have too much to do right now. Doing more now is a very bad thing when you already have too much to do.
      </p>
      <p>
        And unless your <strong>mind</strong> is very different from mine, there is a high chance that you won't need it after all, or that you'll need to rewrite or fix it once you <strong>do</strong> need it. If either of these happens, not only will you waste time overall, you will prevent yourself from adding things that you <em>do</em> need right now.
      </p>
      <dl>
        <dt> </dt>
        <dd>"But Ron, I know how to do it right now, and later I might not."</dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd>"So, Sam, you're telling me that this class you're writing is so complex that even <strong>you</strong> won't be able to maintain it?"</dd>
      </dl>
      <p>
        Keep it simple. If you need it, you can put it in later. If you don't need it, you won't have to do the work at all. Take that day off.
      </p>
      <hr/>
      <p>
        To the tune of "We're Not Gonna Take It" by The Who, from the classic rock opera "Tommy", which is highly recommended.
      </p>
      <code>
        You ain't gonna need it!<br/>
        Never did and never will!<br/>
        Don't need featuritis<br/>
        And the users will never tell.<br/>
      </code>
      <code>
        You ain't gonna need it<br/>
        Half a feature's <br/>
        better than <br/>
        none...<br/>
      </code>
      <code>
        ||: Test me... Code me.. Refactor me... In'grate me... :|| <br/>
        (x8)<br/>
      </code>
      <code>
        List'ning to you, we get the features<br/>
        Planning with you, we get priorit-eees<br/>
        Coding for you, we build releases<br/>
        Pairing for you, we make deliver-eees<br/>
      </code>
      <code>
        - Phlip (on the XP mailing list)<br/>
      </code>
      <p>
        P.S. There is another song with the same name, featured in the teen testosterone flick "Iron Eagle", "Twisted Sister". <em>Both bands did (</em>'rather<strong> different) songs of that name; the takeoff here is based on the rather earlier one by The Who.</strong>
      </p>
      <hr/>
      <p>
        <strong></strong><a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a> in the context of the other <a href="ExtremeProgramming.html">ExtremeProgramming</a> practices<strong></strong>
      </p>
      <p>
        You have a <a href="ReleasePlan.html">ReleasePlan</a>: each <a href="UserStory.html">UserStory</a> has been assigned to an Iteration where it will be done. Under the current <a href="IterationPlan.html">IterationPlan</a>, you are working on an <a href="EngineeringTask.html">EngineeringTask</a> that you signed up for, in support of one of the Iteration's <a href="UserStories.html">UserStories</a>. As always, you have signed up for as much <a href="IdealProgrammingTime.html">IdealProgrammingTime</a> as your <a href="LoadFactor.html">LoadFactor</a> indicates you can accomplish.
      </p>
      <p>
        You are evolving the system to have the new functionality required by the <a href="UserStory.html">UserStory</a>, defined in the <a href="EngineeringTask.html">EngineeringTask</a>. You add capability to any class we need to, directly growing from the requirement. If you find yourself writing duplicate code, you refactor to eliminate it, even (perhaps) adding an abstract class, or making a subclass, etc. You and your co-programmers always keep the code clean.
      </p>
      <p>
        You're building a class, and suddenly you get an idea for a feature you could add to it. You don't need it right now, but "Someday we're gonna need ...", you say to yourself.
      </p>
      <p>
        Keep in mind that you are employing other <a href="ExtremeProgramming.html">ExtremeProgramming</a> practices that allow you to deal with the future when it happens. <a href="CollectiveCodeOwnership.html">CollectiveCodeOwnership</a> allows you to change anybody else's code to give it the functionality you want. <a href="RefactorMercilessly.html">RefactorMercilessly</a> and <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a> make it easier to understand the best way to add your functionality. <a href="UnitTest.html">UnitTest</a>s help ensure that your added functionality won't break any past functionality. So if you do need to implement this feature in the future, it probably won't be much harder than it would be to implement now.
      </p>
      <p>
        At this moment, you have a choice: continue working on what you signed up to do, or begin working on something you didn't sign up to do, and that isn't needed in this Iteration.
      </p>
      <p>
        Therefore, tell yourself <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a>. Set aside your thoughts and fears about tomorrow and get back to work on today. Without a clear use for the feature, you don't know enough about what is really needed. Spending time on it is speculative at best.
      </p>
      <hr/>
      <p>
        How serious are we about this? Here's how serious: if a developer finds a method in the system that is not sent, she should remove it. Ditto unused classes, in spades.
      </p>
      <p>
        The upside in a nutshell: it keeps the system small and understandable.
      </p>
      <p>
        The downside would seem to be that it may take longer in the future to do something that would have taken less time now. <strong>This turns out not to be the case. It has never happened in two years on the C3 project that we wish we had added functionality we didn't need at the time.</strong> <em>There's something of the self-fulfilling prophecy about this argument. I've been trying to persuade myself to adopt YAGNI more rigorously for several years, but I haven't managed it yet. As a result, I occasionally come across cases where I think I'm glad I didn't.</em> <strong>On the other hand, if you've gone bankrupt implementing features you didn't actually need, you'll self-fulfill in the other direction.</strong>
      </p>
      <p>
        Replacement/paraphrase of deleted comment: "Ummm...but the C3 project didn't turn out so well, as I understand it, so how well does it really serve as an anecdote?"
      </p>
      <p>
        <em>That depends on whether or not </em><a href="CthreeProjectTerminated.html">CthreeProjectTerminated</a> due to a lack of unforeseen future functionality and if <a href="WasChryslerComprehensiveCompensationSuccess.html">WasChryslerComprehensiveCompensationSuccess</a> even though it was terminated early.<em></em>
      </p>
      <p>
        There are, on the other hand, places where the system isn't what it ought to be. These are mostly due to these causes:
      </p>
      <ol>
        <li>
           Use of a framework that's bigger than the actual problem we have;
        </li>
        <li>
           Over-engineering, resulting in classes that are too complex but hard to refactor down to reasonable;
        </li>
        <li>
           Delay in refactoring something that needed it.
        </li>
      </ol>
      <p>
        There <strong>are</strong>, therefore, cases where we wish we had done better engineering of what we had ... but not cases where we wish we had put in things to be used later.
      </p>
      <p>
        Contributors: <a href="KielHodges.html">KielHodges</a> <a href="RonJeffries.html">RonJeffries</a> and many many others
      </p>
      <hr/>
      <p>
        Traditionally, ordering your implementation efforts has been done by subsystem - you implement everything in a subsystem's interface, and then move on to implementing the next subsystem, and that makes for a lot of useless overhead with a <a href="BigBang.html">BigBang</a> at the end where you do all your testing and QA. <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a> is suited to an iterative or evolutionary development method whereby you do a fair amount of planning and architecture definition up front, and then implement by feature-set rather than by subsystem.
        -- <a href="PeterMerel.html">PeterMerel</a>
      </p>
      <hr/>
      <p>
        As I just wrote in <a href="ShieldPattern.html">ShieldPattern</a>, I think this is an example of a force, not a pattern. There are circumstances where premature work would be wasted. There are also circumstances where a little bit of forethought and planning has saved me enormous effort further down the line. The best way to balance conflicting forces may not be to yield to one of them. (PS. I think identifying forces, and their strengths, is a valuable contribution - see <a href="PatternComponent.html">PatternComponent</a>.)
        -- <a href="DaveHarris.html">DaveHarris</a>
      </p>
      <p>
        <em>I suggest that the forces are the cost of investing now, vs savings then, or something like that. The pattern would be "Do it now" or "Do it later", perhaps?</em>
      </p>
      <hr/>
      <p>
        Not only might you not need it in the future - even if you do, it might not take the exact form then, that you can anticipate now. Also, how are you going to test it, if you don't need it now?
      </p>
      <p>
        The one exception that I would make to this is consistency with standards. For example, if I have a standard that I always provide a getter for any setter, I will add it immediately, even if I don't need it now, lest someone trying to maintain the class later assume that I really intended the attribute to be write-only.
        -- <a href="RussellGold.html">RussellGold</a>
      </p>
      <ul>
        <li>
           I don't always provide getters for setters. I'd say your second paragraph here should be in the opposing column, because it advocates writing stuff you don't need. -- <a href="DaveHarris.html">DaveHarris</a>
        </li>
      </ul>
      <ul>
        <li>
           I would first take a careful look at any code that requires a "setter." Directly changing a class variable is a strong hint you have an encapsulation problem.
        </li>
      </ul>
      <hr/>
      <p>
        I've been meaning to say this for a while. Here goes. I think that much of the conversation that we have been having about <a href="ExtremeProgramming.html">ExtremeProgramming</a> practices, and many of the contentions, have been because of <a href="PrematureGeneralization.html">PrematureGeneralization</a>. Not in code, but in concepts. <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a> has spawned an incredible number of subpages and back and forth discussions. I'm now convinced that this is because the words <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a> themselves have no context. At first glance, that is <em>without reading further and looking at Ron's page and much of the discussion</em>, the words can be used to justify just about any form of avoidance right down to hacking.
      </p>
      <p>
        That said, I understand what is intended by the words <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a>, but it is only through context and example. The words themselves are aphorism that can be taken to be very general. I am excited about <a href="ExtremeProgramming.html">ExtremeProgramming</a> and I hope that descriptions are published, but I also hope that enough context is published to prevent misunderstanding. -- <a href="MichaelFeathers.html">MichaelFeathers</a> 
      </p>
      <p>
        <em>This is an interesting and important point, IMO. Kent and I both like strong statements, memorable phrases. "</em><a href="ExtremeProgramming.html">ExtremeProgramming</a>" for example. To try to learn what a pattern is from its name, however evocative, is perilous. <a href="ExtremeProgramming.html">ExtremeProgramming</a> and <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a> aren't even patterns yet, they are characterizations of a philosophy that is undergoing change and testing every day. We XPers may be generalizing prematurely in thinking we know what we are doing: our readers are certainly generalizing prematurely if they assume that a phrase like <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a> justifies hacking or writing only half a function. Thanks for putting this idea so clearly. Rewrote the lead-in in response. -- <a href="RonJeffries.html">RonJeffries</a><em></em>
      </p>
      <hr/>
      <p>
        Twice, in different organizations that practiced traditional <a href="CodeOwnership.html">CodeOwnership</a>, I've seen situations where a developer got ahead of the rest of the team, and, rather than helping the team catch up, spent time making their yet-to-be-used code "reusable," adding features that would <em>certainly</em> be needed. But by the time the team caught up, more was known about the problem, requirements had drifted, the design had changed, <em>etc.</em> But there sat the developer with the work of art into which he'd poured all of his talents, unwilling
        to acknowledge that it wasn't quite what the rest of the team needed after all, and resisting requests for changes. -- <a href="DaveSmith.html">DaveSmith</a>
      </p>
      <ul>
        <li>
           Agreed. I don't think anyone is advocating this. -- <a href="DaveHarris.html">DaveHarris</a>
        </li>
      </ul>
      <p>
        <a href="PrematureGeneralization.html">PrematureGeneralization</a> can be a triple whammy:
      </p>
      <ul>
        <li>
           time that could have been spent helping the team reach a milestone is lost
        </li>
        <li>
           the code base gets bloated
        </li>
        <li>
           enflamed egos weaken the team.
        </li>
      </ul>
      <p>
        Better to build what you need as you need it, avoiding unused clutter, and discovering and harvesting reusable components as you go.
        -- <a href="DaveSmith.html">DaveSmith</a>
      </p>
      <p>
        The "did you finish high priority task X?", "No, but I wrote this neat new feature" conversation doesn't just happen between programmer and PMs. More than a few times as a programmer I've had to prod my fellow coders to complete work I'm dependent on for my progress. As much as I might like to do mine and my co-workers tasks, I've never found that conducive to meeting schedules. -- <a href="StevenNewton.html">StevenNewton</a>
      </p>
      <hr/>
      <p>
        In the large C and C++ projects I've worked on, the implied message is often "we don't want to <em>touch</em> that part again," since touching often means recompiling, and touching the lower levels may imply rebuilding most or all of the product. The fear I perceive in my co-workers is that if you don't do the lower levels right the first time, you're going to spend 60+% of your time just waiting for the product to build.
      </p>
      <p>
        <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a> is a lot easier in Smalltalk than it is in C++. -- <a href="DaveSmith.html">DaveSmith</a>
      </p>
      <p>
        <em>Change can be difficult when the tools don't support it. When it's possible you should choose your tools and processes to make change easy, but you don't always have that luxury, and the practices must bend accordingly. Nonetheless, all things being equal, a process that invests less in unnecessary futures will have more to spend on necessary presents (for the staff). The question becomes: what's necessary.</em>
      </p>
      <p>
        <em>You can refactor C++, but it takes focus. The less people are allowed to refactor, the more the "get it right" fear takes hold. But if you have comprehensive unit tests for every part of the system, and you work hard all the time to reduce the compile time impact of changes - tightening up use of forward declarations, narrowing the interfaces between different packages - you can make it easier to have highly changeable C++.</em>
      </p>
      <p>
        <em>People can refactor in C++. The perception that it's hard to do so is most of the problem.</em>
      </p>
      <p>
        <em>And how large does a system have to be before you can't build it every day anyway?</em>
      </p>
      <hr/>
      <p>
        If I was applying <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a> while I was implementing #isLeapYear in Date, and I knew, from previous difficult experience, about all the various flavors of leap years, and I was acting as a moral developer (or if I was tempted not to, at least my partner was acting moral), <strong>then</strong> I would implement <a href="UnitTest.html">UnitTest</a>s representing all the interesting problems I knew about and I wouldn't be done with the <a href="EngineeringTask.html">EngineeringTask</a> until they worked. If I didn't know about such problem, but I suspected them, I would do the necessary research before starting.
      </p>
      <p>
        <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a> is not the same as forgetting experience, acting stupid, or abandoning morals. It is a challenge to developers to abandon their fears of a far-flung future that may never happen and do an absolutely stellar job of solving today's problems today. Actually, when I violate this rule, it is typically because I am overwhelmed by my fears of not being good enough for today's task. Solving tomorrow's problem is an excellent avoidance strategy, because you can't be proven wrong.
      </p>
      <p>
        -- <a href="KentBeck.html">KentBeck</a> <em></em><a href="BeBraveLittlePiglet.html">BeBraveLittlePiglet</a><em></em>
      </p>
      <p>
        A consistent thread here is that there are two different time periods, <strong>now</strong> and <strong>later</strong>. The anti-YAGNI folks seem to believe that in <strong>now</strong>, there is enough time to implement the needed features plus extra time to add possibly-desired future features (including generality and flexibility). This is good thing, because <strong>later</strong> there won't be enough time to add the newly-needed features, and only the efficient use of the extra <strong>now</strong> time allows <strong>later</strong> work to be successful.
      </p>
      <p>
        If this is true, then what happens when it's <strong>even later</strong>? Does the project collapse under it's own weight? Does there need to be more time spent <strong>now</strong> to plan for the features needed <strong>even later</strong> (since there certainly isn't extra time <strong>later</strong>)?
      </p>
      <p>
        The YAGNI rebuttal is that since there will always be an <strong>even later</strong>, treat <strong>now</strong> the same as <strong>later</strong> by doing <strong>now's</strong> work <strong>now</strong> and <strong>later's</strong> work <strong>later</strong>. -- <a href="JeremyCromwell.html">JeremyCromwell</a>
      </p>
      <hr/>
      <p>
        At times, I've seen the idea of leaving extra unused fields in data structures to be useful for expansion and backward compatibility. I'm not sure how to reconcile it with <a href="ExtremeProgramming.html">ExtremeProgramming</a>, but in my experience it can work. Of course, empty space is not functionality.
        -- <a href="CayteLindner.html">CayteLindner</a>
      </p>
      <p>
        When I have an "inspiration" to add a method to a class that isn't needed right away, I create it, but the body just throws an exception. That way I "save" the idea, don't spend the time writing the method, and it's easily caught in testing when it _is_ used.
      </p>
      <p>
        -- <a href="RobCrawford.html">RobCrawford</a>
      </p>
      <p>
        <em>Kind of like eating carrots when you really want a smoke. On C3, we would have to build a special convention. One of the ways we remind ourselves </em><a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a> is that all engineers routinely remove methods that have no senders. -- <a href="RonJeffries.html">RonJeffries</a><em></em>
      </p>
      <p>
        ... Bit aggressive that: do you dispense with backing up if you don't have a crash for a while too? :-o -- <a href="AndrewCates.html">AndrewCates</a>
      </p>
      <ul>
        <li>
           I think that YAGNI applied to backups would be: "Don't start doing backups until you have crashed". And no, I wouldn't seriously advocate that either. (But when <strong>do</strong> you first need it?) Nothing about YAGNI calls upon the removal of function that was added when it was needed: that would be YouNoLongerNeedIt.
        </li>
      </ul>
      <p>
        <em>I think the principle applied to backups is "Don't do them until you need them", where "you need them" equates to "you are storing important data" rather than "you have crashed" - </em><a href="JohnJamesIrvine.html">JohnJamesIrvine</a><em></em>
      </p>
      <ul>
        <li>
           I find that some XP practices, notably Yagni and <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a>, are supposed to only really apply to the code. With code, it's easy to add stuff when you need it (or at least no harder). In the physical world, the cost of change is usually much higher. This is why we have backups, insurance, and fire-proof safes. It is also why many xp practices <em>seem</em> silly if you think about them with a physical metaphor.
        </li>
      </ul>
      <p>
        I tend to use comments for the same purpose, though the 'method that throws an exception' idea seems useful. If YAGNI, but you know _now_ how to do it, why not install the method as either an exception-thrower or a comment, and comment heavily on how to do it? Documenting thoughts, plans and possibilities doesn't take long - certainly less time than implementing and thoroughly testing - but ensures that whatever you're worried about is written down for the next person to consider.
      </p>
      <hr/>
      <p>
        How about an example: A client asks for a system to hold ten objects, so I write code using an array of size ten. A week later the client says that they want to add more objects on the fly. So I rebuild using a Vector (I'm programming in Java). I could've used a Vector first time 'round, but didn't because of YAGNI, and an array is by most definitions simpler. And now I've got to start from scratch. Is this a problem with YAGNI, or how I'm interpreting it?
      </p>
      <p>
        <em>When the client changes, amends, or further explains a requirements, some changes are to be expected. The point is to keep the roots of a change shallow to make it easy to pull out later. To guess and guess wrong about what a client's future intentions may be only grows those entwining roots deeper and make the choice even harder to rip out later.</em>
      </p>
      <p>
        <em>In the example you've got, there's three sets of objects. They are the container, the objects to go into the container, and the clients to the container. The last two wouldn't have to be changed, assuming you've got decent encapsulation.</em>
      </p>
      <p>
        <em>But if you choose the Vector to begin with, you might not be so careful about enforcing encapsulation. So if the customer asks you to store a list of Strings along with objects, and you have to change your container from Vector to </em><a href="HashMap.html">HashMap</a>, the change might be difficult.<em></em>
      </p>
      <p>
        <em>The point is that the requirements are always going to change in unpredictable ways, so trying to design for that unpredictable future is a losing proposition. But you'll always need flexibility, so designing for flexibility is a winning proposition. If you have flexibility, then the cost of putting in the feature when it's actually needed shouldn't be much higher than putting it in at the start.</em>
      </p>
      <p>
        <em>And is an array necessarily simpler than a container class? </em><a href="DoTheSimplestThingThatCouldPossiblyWork.html">DoTheSimplestThingThatCouldPossiblyWork</a> is a subjective standard and will vary somewhat individual to individual. (See <a href="WhatIsSimplest.html">WhatIsSimplest</a> for more.)<em></em>
      </p>
      <p>
        <strong>Concur.</strong> The "simplest" thing is not a license to implement an under-designed solution to a system, particularly when your vision of the client's needs may extend beyond his own.
      </p>
      <p>
        In other words, there is another pattern at work here: TheCustomerWillAlwaysWantMore. No, really. Every single time.
      </p>
      <p>
        <em>No, you miss the point. If you put the customer's objects into a </em><a href="TreeMap.html">TreeMap</a> instead of an <a href="ArrayList.html">ArrayList</a>, just because you thought he would eventually ask you to index them by string, you're screwing the pooch. Do what is right for right now, and write good code. That's all.<em></em>
      </p>
      <hr/>
      <p>
        I exercise forethought when we go on a car trip. I run around grabbing everything we might need or want on the road -- food, six different things to read, umbrellas, and of course baby stuff: the stroller, some blankets, toys, two snuglis, lots of formula, one diaper per hour, a whole big package of wipes...
      </p>
      <p>
        My wife, on the other hand, exercises <em>more</em> forethought: she points out that we don't actually need most of the stuff, and that there's a lot of benefit to traveling light - we get going faster, we have room to bring stuff back with us, we don't have a bunch of stuff to bring in from the car when we get home late at night.
      </p>
      <p>
        I wonder how she'd react to a new nickname: "Yagni". -- <a href="GeorgePaci.html">GeorgePaci</a>
      </p>
      <hr/>
      <p>
        Perhaps, if you <strong>know</strong> that you're going to need to do X, then adding X isn't a violation of YAGNI or DTSTTCPW.
      </p>
      <p>
        <em>But suppose you implement </em><strong> X </strong><em> (needed now) and </em><strong> Y </strong><em> (you claim (correctly) that you'll need it) and the time taken to implement </em><strong> Y </strong><em> now takes you beyond a time limit of which you weren't aware. The project is cancelled, so you really didn't need </em><strong> Y </strong><em> after all. What's more, if you hadn't spent the time on </em><strong> Y </strong><em> you would have satisfied the </em><a href="GoldOwner.html">GoldOwner</a>/<a href="GoalDonor.html">GoalDonor</a> enough that the project would not have been cancelled.<em></em>
      </p>
      <hr/>
      <p>
        <em>I've worked with "balls out, get the job done quickly" programmers, and while that seems to be very YAGNI, it wasn't very Good.</em>
      </p>
      <p>
        That may seem to be very YAGNI but I don't think it's what the pro-YAGNI folks are talking about. YAGNI is a principle meant to be applied within the context of XP, or at the very least a set of practices that includes refactoring. As <a href="KentBeck.html">KentBeck</a> points out toward the top of the page, adhering to YAGNI without the pairing, unit testing and refactoring (i.e. balls out, get the job done quickly) "clearly doesn't work." -- <a href="JasonArhart.html">JasonArhart</a>  <em>Huh?  Blowing off mental masturbation and avoiding issues that aren't actually pressing doesn't require XP at all.  YAGNI, and the sky ain't gonna fall!</em>
      </p>
      <hr/>
      <p>
        I can't help thinking that there are essentially a set of well known exceptions to <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a> where no experienced developer would seriously consider waiting until later on to implement a probable requirement. At the moment the only one I can can think of is internationalization. Would you really write a large financial application for a European multi-national with hard coded messages everywhere and worry about internationalization later? -- <a href="DavidPlumpton.html">DavidPlumpton</a>
      </p>
      <p>
        If the client is deploying this application around the world, then you are going to need it, and it will be reflected in the <a href="UserStories.html">UserStories</a> to prove it. If the client is only deploying it in one office in the US, you aren't gonna need it. In the latter case, many would (and have) argue that you should put it in anyway; YAGNI disagrees.
      </p>
      <p>
        <em>There's no question that i18n is difficult. The question is: Is it much more difficult if you wait to do it when you need it? If somebody gave me pre-existing software and told me to internationalize it, the first thing I would do would be search all the code for instances of text-delimiting characters like ", ', and (if your language uses "here" documents) <<. I wonder if that would take care of the problem ... -- francis</em>
      </p>
      <p>
        No, I think i18n is a good example of something you would want to start doing from the beginning (or not too far into development). There are many considerations to be made throughout the development. However, YAGNI still holds if the client doesn't make it a priority.
      </p>
      <p>
        <em>It seems to me that hard-coded constants of any kind - messages, magic numbers, whatever - are inherently inflexible and should be avoided on general principles. You can make it possible to internationalize later without taking the time to fully implement your interface in ten different languages.</em> 
      </p>
      <hr/>
      <p>
        I think what causes much confusion for the readers (ok, I admit it: I talk about myself here) is where to draw the line between "foresightment" and "programming unneeded features".
      </p>
      <p>
        Hardcoding messages for the user into the code does not sound smart - but it would apply to the YAGNI rule. I know when I write a program, that with high probability there will be an point in the future when someone wants a change to a message. Be it that the program is released in another language, or just that there is an spelling error.
      </p>
      <p>
        If you used the YAGNI rule, you would have to search through the code for every message. If you had foreseen that (from experience), and written something to make messages easily accessible, you could have saved a lot of time. Or am I wrong here?
      </p>
      <p>
        So is foreseeing later problems always bad?
      </p>
      <p>
        Aren't <a href="UnitTest.html">UnitTest</a>s in some way breaking the YAGNI rule? Since you write something you only need if you write bad code?
      </p>
      <dl>
        <dt> </dt>
        <dd><em>Possible sources for an answer: </em><a href="EconomicsOfYagni.html">EconomicsOfYagni</a>, <a href="WhenAreWeGonnaNeedIt.html">WhenAreWeGonnaNeedIt</a>, <a href="YagniIsBologna.html">YagniIsBologna</a>, <a href="XpSimplicityRules.html">XpSimplicityRules</a><em> and </em><a href="TestDrivenDevelopment.html">TestDrivenDevelopment</a></dd>
      </dl>
      <p>
        In XP you need Unit Tests in this iteration, because you will do continuous integration and probably also some refactoring.
      </p>
      <hr/>
      <p>
        From my experience trying to explain YAGNI to less XP-enlightened developers, I have come to deprecate "YAGNI", in favour of <a href="WdNiy.html">WdNiy</a> (<a href="WeDontNeedItYet.html">WeDontNeedItYet</a>)
        -- <a href="DouglasDickinson.html">DouglasDickinson</a>
      </p>
      <hr/>
      <p>
        <strong></strong><a href="ProblemDomain.html">ProblemDomain</a> and applicability<strong></strong>
      </p>
      <p>
        May I make a suggestion. I think YAGNI, like most XP policies, is a good set of ideas to keep in mind, but another is "know your problem space". YAGNI doesn't mean you should choose an array of 10 spaces over a Vector. Most programmers know that if you need two, you need many, so if you have the choice, you choose a solution with the ability to expand. [A]
      </p>
      <p>
        My motto has always been more along the lines of: Understand the problem space to the best of your abilities including required, optional and possible requirements. Once you have done this, program so as not to preclude the optional/possible requirements wherever possible.
      </p>
      <p>
        -- BillKress
      </p>
      <p>
        There are exceptions. Twos may just be binary splitting; threes are almost always manys. -- Joshua Hudson [B]
      </p>
      <hr/>
      <p>
        I've very recently had an <a href="AhaMoment.html">AhaMoment</a> regarding this topic. For ages I've considered YAGNI harmful for various reasons, but what if we shift the emphasis to the YOU, as in <em>YOU aren't gonna need it</em>. Suddenly, we can drop all these discussions about time as YAGNI ceases to be a statment about <em>now</em> and <em>then</em>, and becomes a statement about <em>you</em> and <em>them</em>. This formulation sits a lot better with me, though of course it is very open ended as to who exactly you are (developer, team, or company?). -- <a href="RichardCordova.html">RichardCordova</a>
      </p>
      <hr/>
      <p>
        What is the <a href="OppositeOfYagni.html">OppositeOfYagni</a>? 
      </p>
      <p>
        <em>Would </em><a href="CoupleLeapingWithLooking.html">CoupleLeapingWithLooking</a> serve the purpose?<em></em>
      </p>
      <hr/>
      <p>
        Sometimes <a href="YouAreGonnaNeedIt.html">YouAreGonnaNeedIt</a> (a good solution) because if you start out with something bad and continue to hack the bad solution (<a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a>), it might end up worse than if you had done some thoughtful design first. 
      </p>
      <hr/>
      <p>
        HowDoYouKnowYouArentGonnaNeedItEh (HdykYagniE) and SoYouReallyThinkYourArentGonnaNeedItHa (SyrtYagniH):
      </p>
      <p>
        Yagni is often applied as a principle to justify failure (hesitation, decision) to partition or to separate fully (see <a href="PrinciplesOfObjectOrientedDesign.html">PrinciplesOfObjectOrientedDesign</a> and <a href="SeparationOfConcerns.html">SeparationOfConcerns</a>).  
      </p>
      <p>
        However, HdykYagni and SyrtYagni are applicable as principles to counter such justification.  I suppose that such a counter could get into even more questionable principles such as ButWeHaveNeverNeededItBefore or EvenIfWeMayNeedItWeCantMessWithItNow.
      </p>
      <p>
        All of this may have more to do with OrganizationalPsychology than <a href="ObjectOrientation.html">ObjectOrientation</a>.
      </p>
      <p>
        -- CarlCastro (Carl R Castro)
      </p>
      <hr/>
      <p>
        Several people on this page have mentioned something I believe to be key to understanding YAGNI. Every programmer makes judgment calls all the time about whether to invest now for the future, or delay work to the future. The programmer must evaluate the costs of implementing more general and reusable code vs the cost of doing that more powerful implementation. It's the simple standard question of investment, which every programmer does on a daily basis. These things play out when deciding if you should invest in code: 
      </p>
      <ol>
        <li>
          - What's the cost of the investment, of writing the "better" code now? 
        </li>
      </ol>
      <ol>
        <li>
          - What's the cost of delaying? AKA How much harder would it be to write later vs now? 
        </li>
      </ol>
      <ol>
        <li>
          - What's the likelihood of the investment being used, and how much value would having this investment be? 
        </li>
      </ol>
      <ol>
        <li>
          - What is your time horizon? Do we need something now, and the future is less important? This is a very normative question which depends on the company, share holders, etc. 
        </li>
      </ol>
      <ol>
        <li>
          - Opportunity cost. Could your time be better spent elsewhere? 
        </li>
      </ol>
      <p>
        YAGNI is simply an observation that many people do not base their designs on cost benefit analysis. They program for fun, for academic reasons, etc., and not for the company's bottom line, and this is a very bad kind of programmer to have in a company. 
      </p>
      <p>
        For example: the aforementioned case of using Java built-in array vs Java Vector. It's a simple decision. There is no cost to invest in the better implementation, the implementation using Java Vector, thus you should invest. You may or may not use the more powerful aspects of a dynamically resizing container, but you lose nothing by using Vector over an array. 
      </p>
      <p>
        However, you might have a case where you need to decide between single threaded, multi threaded, or distributed. There are definite costs in implementing the "better" system over the simpler system, so you need to do the proper cost benefit analysis as outlined above in order to reach a reasonable conclusion. 
      </p>
      <p>
        As a vague claim unsupported by facts, I tend to believe that a <em>little</em> investment up front for a cleaner design almost always pays off in the end. Not very YAGNI I know. However, in my current company, I see many many places where I wish people did practice YAGNI, instead of producing overcomplicated designs that are a pain to debug, enhance, and maintain. 
      </p>
      <hr/>
      <p>
        Someone added the following text to the original story. I removed it to here because I think we reserve the first section for arguments in favor of an article. Maybe create <a href="YouAreGonnaNeedIt.html">YouAreGonnaNeedIt</a> if you feel the need to embellish the story.
      </p>
      <p>
        "Ron, stop being a dramatic prick.  Let me explain this in terms even your feeble mind can understand.  I have spent the last few days concentrating on this issue, and it is fresh in my mind.  The probability of me generating bugs by adding the feature now is much lower than if I came back to this in a year or two and attempted to do it with imperfect understanding.  Any programmer with any experience in the field understands this concept.  If you don't understand this, you have no business being a programmer.  Furthermore, there is some non-zero probability that it won't be me maintaining this code.  It might even be--God help us--<strong>you</strong> maintaining the code.  I know you'll get it wrong in various and subtle ways, so I'm saving the company from that."
      </p>
      <hr/>
      <p>
        <strong>See Also</strong>
      </p>
      <p>
        <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a> has generated many related pages. If you have comments or questions about YAGNI, please consider using one of the pages below rather than adding new comments to this page.
      </p>
      <p>
        You might or might not need it:
      </p>
      <dl>
        <dt> </dt>
        <dd><a href="YouAreGonnaNeedIt.html">YouAreGonnaNeedIt</a>, <a href="YouMightNeedIt.html">YouMightNeedIt</a>, <a href="YouReallyArentGonnaNeedThis.html">YouReallyArentGonnaNeedThis</a>, <a href="WhenAreWeGonnaNeedIt.html">WhenAreWeGonnaNeedIt</a>, <a href="DavesRealExampleWhereThinkingAheadWouldHaveHelped.html">DavesRealExampleWhereThinkingAheadWouldHaveHelped</a>, <a href="YagniExceptions.html">YagniExceptions</a></dd>
      </dl>
      <p>
        Organizational and methodological issues:
      </p>
      <dl>
        <dt> </dt>
        <dd><a href="OaooBalancesYagni.html">OaooBalancesYagni</a>, <a href="EconomicsOfYagni.html">EconomicsOfYagni</a>, <a href="YagniAndCompanyAssets.html">YagniAndCompanyAssets</a>, <a href="YagniAndReuse.html">YagniAndReuse</a>, <a href="YagniAndTeamDynamics.html">YagniAndTeamDynamics</a>, <a href="ElicitingRequirements.html">ElicitingRequirements</a></dd>
      </dl>
      <p>
        YAGNI as applied to specific domains:
      </p>
      <dl>
        <dt> </dt>
        <dd><a href="YouArentGonnaNeedItAndYtwok.html">YouArentGonnaNeedItAndYtwok</a>, <a href="YagniAndLogging.html">YagniAndLogging</a>, <a href="NeedingBinarySearch.html">NeedingBinarySearch</a>, <a href="NotNeedingBinarySearch.html">NotNeedingBinarySearch</a>, <a href="YagniAndDatabases.html">YagniAndDatabases</a>, <a href="YagniAndCpp.html">YagniAndCpp</a>, <a href="YagniAndCostOfChange.html">YagniAndCostOfChange</a></dd>
      </dl>
      <p>
        Pages with related philosophies:
      </p>
      <dl>
        <dt> </dt>
        <dd><a href="DoTheSimplestThingThatCouldPossiblyWork.html">DoTheSimplestThingThatCouldPossiblyWork</a>, <a href="JustSufficientImplementation.html">JustSufficientImplementation</a>, <a href="PrematureGeneralization.html">PrematureGeneralization</a>, <a href="JustInTimeProgramming.html">JustInTimeProgramming</a>, <a href="ForthValues.html">ForthValues</a></dd>
      </dl>
      <p>
        Others:
      </p>
      <dl>
        <dt> </dt>
        <dd>	<a href="ExtremeNeed.html">ExtremeNeed</a>, RefactoringYagni, <a href="YagniIsBologna.html">YagniIsBologna</a>, <a href="DoesYagniInterruptFlow.html">DoesYagniInterruptFlow</a>, <a href="YagniAndDeleting.html">YagniAndDeleting</a>, <a href="DecisionMathAndYagni.html">DecisionMathAndYagni</a>, <a href="FutureDiscounting.html">FutureDiscounting</a></dd>
      </dl>
      <hr/>
      <p>
        <a href="CategoryExtremeProgramming.html">CategoryExtremeProgramming</a>, <a href="CategoryDecisionMaking.html">CategoryDecisionMaking</a>, <a href="CategoryJargon.html">CategoryJargon</a>
      </p>
    </div>
  </body>
</html>