<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Py Py
      </h1>
      <p>
        <a href="PyPy.html">PyPy</a> is a self hosting implementation of the <a href="PythonLanguage.html">PythonLanguage</a> with various innovative features. It is developed in a open source fashion. Development is pushed forward with sprints (<a href="PythonSprint.html">PythonSprint</a>).
      </p>
      <hr/>
      <p>
        <em>How is this project doing now? Anything downloadable yet?</em>
      </p>
      <hr/>
      <p>
        We are writing a Python interpreter in Python, using Python's well known ability to step behind the algorithmic problems as language. At first glance, one might think this achieves nothing but a better understanding for everybody how the interpreter works. This alone would make it worth doing, but we have much larger goals.
      </p>
      <p>
        CeePython vs. <a href="PyPy.html">PyPy</a>
      </p>
      <p>
        Compared to the CPython implementation, Python takes the role of the C Code. So actually, we describe something by Python, which has been coded in C already, with all the restrictions that are implied by C. We are not trying to make the structures of the CPython interpreter more flexible by rewriting things in C, but we want to use Python to give an alternative description of the interpreter.
      </p>
      <p>
        The clear advantage is that this description is probably shorter and simpler to read, and many implementation details vanish. The drawback of this approach is that this interpreter will be unbearably slow.
      </p>
      <p>
        To get to a useful interpreter again, we need to apply some mappings to the implementation, later. One rather straight-forward is to do a whole program analysis of the <a href="PyPy.html">PyPy</a> interpreter and create a C source, again. There are many other ways, but let's stick with the easiest approach, first.
      </p>
      <p>
        In order to make a C code generator simple, we restrict ourselves to a subset of the Python language, and we adhere to some rules, which make code generation obvious and easy.
      </p>
      <p>
        Now <a href="PyPy.html">PyPy</a> is already working for Python 2.7, and it's faster than CPython for many workloads (but it tends to use more memory - fortunately overhead is more or less constant).
      </p>
      <hr/>
      <p>
        Speed comparision: <a href="http://speed.pypy.org/">http://speed.pypy.org/</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryPython.html">CategoryPython</a>
      </p>
    </div>
  </body>
</html>