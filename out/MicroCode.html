<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Micro Code
      </h1>
      <p>
        <a href="MicroCode.html">MicroCode</a> is a means of implementing a hardware CPU with some assistance from software rather than purely in hardware; typically a user cannot tell whether microcoding was used in implementing a CPU (although there have been some user-modifiable microcoded CPUs).
      </p>
      <p>
        There is a range of kinds of microcode ranging from "vertical" to "horizontal".
      </p>
      <p>
        Vertical microcoding means that the underlying CPU is a straightforward one-thing-at-a-time instruction set roughly similar to a RISC processor like a Sparc.
      </p>
      <p>
        Horizontal microcoding means that the underlying CPU presents <strong>many</strong> fields per instruction, which each individually control some part of the ALU directly. So one 1-bit field might enable output from register 12 while another 1-bit field enabled input to the AND operation.
      </p>
      <p>
        This approach gives very precise control over the workings of the ALU, with the ability to specify quite a few things in parallel, but consumes a large number of bits per micro-instruction, since the control fields, in extreme cases, are all just on-off rather than multiplexed.
      </p>
      <p>
        In the middle of the spectrum, a microcoded CPU might have instructions with only a moderate number of control fields, each multiplexed (e.g. a single 4-bit field might specify one of 16 registers to use as output), and hence take up less space than a purely horizontal microcoded engine, but still more than a highly vertical one.
      </p>
      <p>
        All other things being equal, a purely vertical microcoded CPU will be slow, and implemented only for prototyping or compatibility, while a highly horizontal microcoded CPU is potentially very fast, but can consume a surprisingly large amount of expensive (in terms of real estate) microcode store.
      </p>
      <p>
        Microcoding seemed to fall out of favor for some years with the advent of microprocessors, but eventually came into use again as an implementation technique for microprocessor cores.
      </p>
      <p>
        -- <a href="DougMerritt.html">DougMerritt</a>
      </p>
      <hr/>
      <p>
        <em>(although there have been some user-modifiable microcoded CPUs)</em>
      </p>
      <p>
        also known as "<a href="WritableInstructionSetComputer.html">WritableInstructionSetComputer</a>s" (WISC).
      </p>
      <p>
        (moved to page <a href="WritableInstructionSetComputer.html">WritableInstructionSetComputer</a>)
      </p>
      <p>
        <em>What about the </em><a href="TransMeta.html">TransMeta</a> processors?<em></em>
      </p>
      <p>
        Given the market niches they eventually decided to target, changing microcode dynamically isn't part of their business plan. I had the impression that it's all stored on-chip, perhaps in factory-masked ROM, rather than being read from PROM off-chip, let alone from RAM, but I'm not 100% sure.
      </p>
      <p>
        If their market niche changed, they could easily make a RAM-swappable microcoded version of their cpu...
      </p>
      <p>
        Of course, these days even things like the Pentium use microcode to drive a RISC-like internal core. Once they got beyond a certain level of complexity, the alternative was insanity. :-)
      </p>
    </div>
  </body>
</html>