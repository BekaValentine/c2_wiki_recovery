<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Most Programmers Dont Grok Objects
      </h1>
      <p>
        Just a couple of datapoints based on personal experience:
      </p>
      <ul>
        <li>
           I worked with a VP at a large media outlet who was an old-school programmer who once wrote a page-layout system in assembler.  He didn't think much of objects and it was common to hear him say he could write more functional code in assembly than in any OO language.
        </li>
      </ul>
      <ul>
        <li>
           At the same job I tried to mentor a co-worker moving to OO.  He never did get it -- he didn't see anything as abstractions, everything was  procedural/functional in his world view.
        </li>
        <li>
           <em>Objection raised below under "Noun Vs. Verb Abstraction".</em>
        </li>
      </ul>
      <ul>
        <li>
           Based on some Java servlet code I recently worked on (read: followed up after the initial programmer moved on to another job) some VB-style programming habits seem to have become associated with OO.  The code was event-driven, and the 'objects' were all in the respond-to-this-event-do-something model.  Which is OK except that every event was handled in isolation, even though there was really a great deal of commonality of function across the dozen or so 'events'.  A straightforward candidate for <a href="CommandPattern.html">CommandPattern</a>, but generally each source file was a poster child for <a href="CopyAndPasteProgramming.html">CopyAndPasteProgramming</a>. 
        </li>
        <li>
           <em>Objection raised below under "Reducing Code".</em>
        </li>
      </ul>
      <p>
        -- <a href="StevenNewton.html">StevenNewton</a>
      </p>
      <hr/>
      <p>
        I was training two inexperienced C++ programmers <em>(who, effectively, only knew C)</em>...
        One who wanted to learn, and the other who really didn't seem to want to be bothered.
      </p>
      <p>
        From the one who didn't want to be bothered:
      </p>
      <ul>
        <li>
           <em>"Why should I put this in a class?  I can make it work with functions."</em>  [I said that, likewise, I could do it in assembly instead of C, and make it work, but he didn't seem to understand the comparison.]
        </li>
        <li>
           <em>"You can't have more than one object [instance] in a program!!!"</em>
        </li>
        <li>
           He was really confused by COM, even after taking the week long <a href="DevelopMentor.html">DevelopMentor</a> class:  He insisted that object can and must only be created with <a href="QueryInterface.html">QueryInterface</a>, because that was the "standard method" taught in the class.
        </li>
      </ul>
      <p>
        The other was more interested in learning, and we made a lot of progress.
        -- <a href="JeffGrigg.html">JeffGrigg</a>
      </p>
      <p>
        <em>Confused by the COM example.  What was he calling </em><a href="QueryInterface.html">QueryInterface</a> on, if not an object he got through some other route?<em></em>
      </p>
      <hr/>
      <p>
        <strong>So how did <em>we</em> come to grok objects?</strong>
      </p>
      <p>
        See <a href="HowiLearnedToLoveObjects.html">HowiLearnedToLoveObjects</a>
      </p>
      <hr/>
      <p>
        <strong>Noun Vs. Verb Abstraction</strong>
      </p>
      <p>
        Re: "At the same job I tried to mentor a co-worker moving to OO.  He never did get it -- he didn't see anything as abstractions, everything was  procedural/functional in his world view."
      </p>
      <ul>
        <li>
           <em>How are verb-oriented abstractions "worse" or "lessor" than noun-oriented ones? "Linear" textual  code forces us to group by only one or the other as the primary "sort". One is not inherently better or worse, but merely the chosen primary grouping by which which we choose to manage our code. (I tend to use an RDBMS to model and manage my domain "nouns", by the way.) --top</em>
        </li>
      </ul>
      <hr/>
      <p>
        <strong>OOP and Code Size</strong>
      </p>
      <p>
        Re: "Based on some Java servlet code I recently worked on (read: followed up after the initial programmer moved on to another job) some VB-style programming habits seem to have become associated with OO.  The code was event-driven, and the 'objects' were all in the respond-to-this-event-do-something model.  Which is OK except that every event was handled in isolation, even though there was really a great deal of commonality of function across the dozen or so 'events'.  A straightforward candidate for <a href="CommandPattern.html">CommandPattern</a>, but generally each source file was a poster child for <a href="CopyAndPasteProgramming.html">CopyAndPasteProgramming</a>." 
      </p>
      <ul>
        <li>
           <em>Why couldn't shared functions be used to factor out the commonalities? General statements like this do not help the ongoing OO debates. We need specific examples with example "bad" non-OO code being fixed by "good" OO. Note that I have never ever seen an example, toy or real, of OOP reducing code size by any significant amount. And most differences could be chalked up to specific languages. I challenge anyone to produce a code sample that clearly shows OO reducing code that procedural/relational cannot. This seems to be a case of </em><a href="OopSelfFullfillingProphecies.html">OopSelfFullfillingProphecies</a>.<em></em>
        </li>
      </ul>
      <hr/>
      <p>
        See also: <a href="ObjectOrientedDesignIsDifficult.html">ObjectOrientedDesignIsDifficult</a>
      </p>
    </div>
  </body>
</html>