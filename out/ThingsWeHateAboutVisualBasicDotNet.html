<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Things We Hate About Visual Basic Dot Net
      </h1>
      <p>
        Things we hate about <a href="VisualBasicDotNet.html">VisualBasicDotNet</a>:
      </p>
      <p>
        <em>(...a good healthy rant inspired by </em><a href="ThingsWeHateAboutVbClassic.html">ThingsWeHateAboutVbClassic</a>.  <strong>New!  Improved!</strong>  And updated for <a href="VisualBasicDotNet.html">VisualBasicDotNet</a>.  ;-)<em></em>
      </p>
      <p>
        <em>Not to be confused with </em><a href="ThingsWeLoveAboutVisualBasicDotNet.html">ThingsWeLoveAboutVisualBasicDotNet</a>.<em></em>
      </p>
      <p>
        (Scope question: I assume this is about MS's new BASIC language dialect and not the "dot net" framework and excludes C-sharp?) 
      </p>
      <hr/>
      <p>
        <strong>List:</strong>
      </p>
      <ul>
        <li>
           Overrides, Overloads and Shadows confusion.
        </li>
        <li>
           Lack of C#(<a href="CsharpLanguage.html">CsharpLanguage</a>)-style auto-properties.
        </li>
        <li>
           <a href="CodeSnippetsEncourageDuplicatedCode.html">CodeSnippetsEncourageDuplicatedCode</a>!
        </li>
        <li>
           "<a href="ByVal.html">ByVal</a>" should be the default so that we don't have to clutter code with it since it's roughly the 90% case.
          <ul>
            <li>
               [It is the default. You may be thinking of <a href="VbClassic.html">VbClassic</a>.]
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <hr/>
      <p>
        <strong>Discussion:</strong>
      </p>
      <hr/>
      <ul>
        <li>
           <strong>Overrides, Overloads and Shadows confusion.</strong>
        </li>
      </ul>
      <p>
        Perhaps it is too early to tell, or maybe it is just me.
      </p>
      <p>
        Anyway, <a href="MicroSoft.html">MicroSoft</a> has chosen a strange implementation of <a href="VbDotNet.html">VbDotNet</a>'s OO features. They have this new keyword Shadows which is related to the keyword Overloads (see VB.NET spec 4.3.3).
      </p>
      <p>
        Shadows override by name, Overloads by signature. Shadows override all members of the same name, Overloads only the matching signature. One might think that if the name and signature is identical and appears only once, then there is no difference?
      </p>
      <p>
        That is "of course" wrong. When you shadow an inherited member you actually have two members of the same name. The inherited one is accessible only through an interface higher in the class hierarchy, the implemented one is accessible only through the interface of the implementing class. I think this breaks polymorphism. 
      </p>
      <p>
        Worse is that Shadows is implied when no keywords are specified.
      </p>
      <p>
        I really see no practical difference between Overrides, Overloads and Shadows, except that Shadows hides the member from higher classes. But with all these keywords there is a mix that rather contradict clarity than improve it:
      </p>
      <ol>
        <li>
           If you override one member then you specify 'Overrides'.
        </li>
        <li>
           If you override two or more overloaded members from the base class, then you specify 'Overloads'. The 'Overrides' usage is incorrect, Overloads in this case implies 'Overrides'.
        </li>
        <li>
           The IDE tries to correct you, but gives rather dumb suggestions.
        </li>
        <li>
           If the base forgets to declare its members with 'Overridable', derived classes still inherits these members, but can not override them.
        </li>
      </ol>
      <p>
        The 'Shadows' keyword might come in handy some time, but not often enough to justify being implied/default. The other keywords mentioned is just noise. Make 'Overrides' equal to 'Overloads' and make them default, and there is no difference except cleaner and clearer code.
      </p>
      <p>
        My preliminary conclusion is that VbDotNetIsaDisaster to program in. I have always been satisfied with VB6, been looking forward to the OO improved version, but the disappointment forces me towards C# in the first place, perhaps to Delphi or Java.
      </p>
      <p>
        For <a href="MicroSoft.html">MicroSoft</a>'s sake I hope it is just me -- <a href="ThomasEyde.html">ThomasEyde</a>
      </p>
      <hr/>
      <p>
        It seems to me that VB has always been targeted at inexperienced programmers who tend to write spaghetti no matter what you give them, and what makes them happy are features that save key strokes.  I think this might be in that category.  I think the general consensus has always been to use <a href="CsharpLanguage.html">CsharpLanguage</a> to do "real" <a href="DotNet.html">DotNet</a> development.
      </p>
      <p>
        <em>There is nothing wrong by itself with saving keystrokes. I personally feel that visual things are best done with a visual interface. However, not all things are that way and some things are not easy to maintain as a visual even if they are easy to start as a visual. It is a matter of </em><a href="PickTheRightToolForTheJob.html">PickTheRightToolForTheJob</a>.<em> -- </em><a href="AnonymousDonor.html">AnonymousDonor</a>
      </p>
      <p>
        <em>(new speaker) If that's the consensus I disagree with it.  The language differences between </em><a href="CsharpLanguage.html">CsharpLanguage</a> and <a href="VisualBasicDotNet.html">VisualBasicDotNet</a> are so minor that it's hardly possible to say one is much better than another.  The two are somewhat different syntaxes for what amounts to the same comprehensive <a href="DotNet.html">DotNet</a> language. -- <a href="MarkSchumann.html">MarkSchumann</a><em></em>
      </p>
      <hr/>
      <p>
        Shadows lets you "fix" it if the base class forgot to declare it Overridable. Your method will be called instead of the base class method when the derived type is used or when type object is used (a reference of type Object binds by name at run time). It will not be used when passing a reference of the base class type.
      </p>
      <p>
        Personally I find it of most use when I find it convenient to create a private member function of the same name of another private member
        function in the base class. Without Shadows, it thinks you are trying to override a non-overridable method. 
      </p>
      <p>
        <em>This is just silliness to fix other silliness. Remeniscent of </em><a href="AddingEpicycles.html">AddingEpicycles</a>.<em></em>
      </p>
      <code>
        Go read <a href="SomebodyElsesFramework.html">SomebodyElsesFramework</a><br/>
      </code>
      <hr/>
      <p>
        Perhaps allowing non-overridable methods are the problem to begin with. You never know what somebody will need in the future. Perhaps competing with Java was more important to MS than having a clean language. MS was paranoid of Java for several years. --top
      </p>
      <hr/>
      <hr/>
      <ul>
        <li>
           <strong>RE: Lack of C#(</strong><a href="CsharpLanguage.html">CsharpLanguage</a>)-style auto-properties.<strong></strong>
        </li>
      </ul>
      <p>
        When we decide not to take advantage of the <a href="PropertyFieldTransparency.html">PropertyFieldTransparency</a> property of the <a href="CsharpLanguage.html">CsharpLanguage</a>, the language designers thoughtfully provided us with the convenient syntactic shorthand notation enabled by "auto-properties."
      </p>
      <p>
        In the <a href="CsharpLanguage.html">CsharpLanguage</a>, this code
      </p>
      <code>
        public int PriceCode { get; set; }<br/>
      </code>
      <p>
        essentially generates this code for you at compile time
      </p>
      <code>
        private int _priceCode;<br/>
        public int PriceCode {<br/>
        get { return _priceCode; }<br/>
        set { _priceCode = value; }<br/>
        }<br/>
      </code>
      <p>
        <em>(which ends up producing results largely equivalent to writing this code)</em>
      </p>
      <code>
        public int PriceCode;<br/>
      </code>
      <p>
        <em>(See </em><a href="PropertyFieldTransparency.html">PropertyFieldTransparency</a> for details.)<em></em>
      </p>
      <p>
        But in <a href="VisualBasic.html">VisualBasic</a>, most pundits seem to think that <a href="VisualStudio.html">VisualStudio</a> Snippets and/or tools that generate all this duplicated code for you is the best solution.
        But <a href="CodeSnippetsEncourageDuplicatedCode.html">CodeSnippetsEncourageDuplicatedCode</a>!
        And other ways of generating boilerplate duplicated code do to.
      </p>
      <hr/>
      <p>
        <a href="CategoryVisualBasic.html">CategoryVisualBasic</a> <a href="CategoryDotNet.html">CategoryDotNet</a>
      </p>
    </div>
  </body>
</html>