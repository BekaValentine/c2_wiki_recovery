<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Its Not About Discipline
      </h1>
      <p>
        I have often heard programmers describe the discipline that is required to write robust software. My point of view is that if discipline is required, the framework in which you are working is wrong. Now, I'm not saying that there's anything wrong with being a disciplined person - far from it. What I am suggesting is, <em>discipline</em> implies <em>repetition</em> and repetition of any sort is a <a href="BadThing.html">BadThing</a>.
      </p>
      <p>
        This same argument applies to <a href="CopyAndPasteProgramming.html">CopyAndPasteProgramming</a>; it leads to <a href="CopyPasteThinking.html">CopyPasteThinking</a>. Humans don't like repetition. They get bored. They stop paying attention. They miss things. They fail to <em>think</em>.
      </p>
      <p>
        Far better is to arrange things so that no discipline is required. Humans can be relied upon to take the path of least resistance. Discipline is what forces us out of the path of least resistance. But if it's possible, why not just make the path of least resistance the correct one?
      </p>
      <p>
        This argument may sound trivial, but it runs pretty deep. When working with other people, one has to ensure that the costs of doing "the right thing" (from one's own point of view) are less than the costs of any other obvious approach. The same principle applies in poker. You have to make the other guy <em>want</em> to believe that he can beat you when he can't, or vice versa.
      </p>
      <p>
        Here is a concrete example. Suppose you were designing a logging system with multiple fixed-format log entries. One way of designing the logging API might be this:
      </p>
      <code>
        interface Logger {<br/>
        public int registerEntryType(string[] argNames); // returns a logTypeId<br/>
        public void log(int format, string[] args);      // takes a logTypeId<br/>
        }<br/>
      </code>
      <p>
        This design has the advantage of being very easy to do from the designer's point of view. But it's wide open to abuse. What if the user doesn't register the log type first? What if he passes the wrong number of arguments in args? It takes <em>discipline</em> from the end-user for this design to be used correctly. Consider this alternative design:
      </p>
      <code>
        interface LogType {<br/>
        }<br/>
      </code>
      <code>
        interface LogEntry {<br/>
        public void setArg(string name, string value);<br/>
        }<br/>
      </code>
      <code>
        interface Logger {<br/>
        public LogType registerEntryType(string[] argNames);<br/>
        public LogEntry createEntry(LogType type);<br/>
        }<br/>
      </code>
      <p>
        This is a lot harder to implement. However, there is very little scope for the end-user to go wrong in using it. Most importantly, the interface is self-documenting; there is only one obvious way of using it. A little bit of extra work up-front pays off handsomely in the long run.
      </p>
      <p>
        -- <a href="DavidKeithTurner.html">DavidKeithTurner</a>
      </p>
      <hr/>
      <p>
        Strong agreement here. One of my sideline tasks at work has been to develop coding standards, but we always get sidetracked on nit-picks by developers who are adamant about some obscure style point. So I have been trying to find/build a C++ code formatter that would allow specification of every format point, and then make it automatically run on module check in, so that all code in the system is in the "standard" format, and every developer, when they check a module out, can get it in their favorite format. That way, nobody can get out of standard, and nobody has to change their coding habits, but we get a One True Format for comparisons. -- <a href="PeteHardie.html">PeteHardie</a>
      </p>
      <p>
        <em>Kind of like indent(1) for </em><a href="CeePlusPlus.html">CeePlusPlus</a>... there are a bunch of people trying to do similar things. An example: <a href="http://www.uvm.edu/~ashawley/c/indent/''">http://www.uvm.edu/~ashawley/c/indent/''</a>
      </p>
      <hr/>
      <p>
        <strong>Discipline does not imply repetition, but repetition can be a </strong><a href="GoodThing.html">GoodThing</a><strong></strong>
      </p>
      <p>
        Experience implies repetition; "I have done this before, therefore I am experienced." Increased experience implies increased repetition; "I have done this many times before, therefore I am highly experienced." Experience is valued because it is hoped that efficiency will result.
      </p>
      <p>
        Discipline, however, does not imply repetition, it merely implies following a prescribed set of steps. Discipline can be used in lieu of experience if the prescribed set of steps are those that would be done by an experienced individual.
      </p>
      <p>
        Good approaches to follow can be found through experience and passed on through discipline.
      </p>
      <p>
        The alternative to repetition is to treat everything as unique. In this case, a developer with 25 years of experience is no more likely to be successful than a developer writing his first line of code.
      </p>
      <p>
        <em>My point is that if the steps have to be prescribed, you have reduced the role of the human being to that of the automaton. No one is denying that experience is valuable, and that idioms and patterns are also valuable. However, repetitive tasks should be avoided at all costs.</em> (See the first story on <a href="MyBestProgrammingMoment.html">MyBestProgrammingMoment</a>.) <em>There is a difference between the repetition of prescribed [complex] instructions and the repetition (or at least pattern recognition) of experience. Also, experience can get you into trouble when new idioms emerge: witness the number of C++ programmers who free() objects allocated with new.</em>
      </p>
      <p>
        <em>I disagree strongly with you on the point that treating everything as unique renders 25 years of experience useless. It doesn't. You'll still recognize patterns you've seen before, and possibly apply solutions you've used before. However, you shouldn't be doing it by rote. It should be a question of, "I have x, y and z in my toolbox. Which is most appropriate for the task at hand?".</em>
      </p>
      <p>
        The point of experience is to do things in a rote manner. This frees up time and effort for the truly unique things one needs to accomplish. If one has a problem that x, y, or z could solve, just pick one and go on to the next issue. Piddling around trying to determine whether x is slightly better than y or z if all have served adequately in the past is wasted effort. This is the benefit experience brings, the ability to recognize a pattern and provide an adequate solution with a minimal amount of time and effort.
      </p>
      <p>
        [Discipline may imply repeatedly applying a set of principles, but that is not the same thing as repeatedly creating the same code. Applying best practices, over and over again, is good. Writing the same code, over and over again, is not. In software engineering, discipline is important because our natural tendencies are often at odds with our best practices.]
      </p>
      <p>
        <em>That's exactly why it's a good idea to manipulate things so that "best practices" align with "natural tendencies". My natural tendency is to grab the stuff I want to use and use it, without reading the documentation too carefully. Therefore, it's a good idea to make the libraries work well with sort of use. In particular, they shouldn't ask me to do more than the bare minimum required to get what I want. That means that APIs which involve "close" or "release" or "dispose" functions fail this design criterion. I contend that it's always possible to design around requirements of this nature.</em>
      </p>
      <hr/>
      <p>
        Quoting King Crimson, "Discipline is never an end in itself, only a means to an end."
      </p>
      <hr/>
      <dl>
        <dt> </dt>
        <dd>"It is a profoundly erroneous truism, repeated by all copy books and by eminent people when they are making speeches, that we should cultivate the habit of thinking of what we are doing. The precise opposite is the case. Civilization advances by extending the number of important operations which we can perform without thinking about them."</dd>
      </dl>
      <dl>
        <dt>	 </dt>
        <dd>-- <a href="AlfredNorthWhitehead.html">AlfredNorthWhitehead</a></dd>
      </dl>
      <p>
        But Alfred North Whitehead was not saying that we advance by thinking less and less, ending in a state of complete thoughtlessness. <em>Through</em> our thought and <em>through</em> our discipline, we reduce the amount of thought and discipline required for certain operations, so that we can apply our thought and discipline to <em>new</em> problems, not so we can become slobs.
      </p>
      <ul>
        <li>
           Just so. When you practice until you <em>know</em> it, then <em>thinking</em> about it becomes unnecessary. <a href="WaxOnWaxOff.html">WaxOnWaxOff</a>.
        </li>
      </ul>
    </div>
  </body>
</html>