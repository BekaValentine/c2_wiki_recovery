<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Blocks Are Inside Out Methods
      </h1>
      <p>
        A block is an everted (inside-out) method.
      </p>
      <p>
        A normal function:
      </p>
      <code>
        def foo(x)<br/>
        x + 42<br/>
        end<br/>
      </code>
      <p>
        A similar block:
      </p>
      <code>
        y = 42<br/>
        block_user do |x|<br/>
        x + y<br/>
        end<br/>
      </code>
      <p>
        The call site for <em>foo</em> would just look like <em>foo(12)</em>. The name of <em>foo</em> is on 
        the outside, its calling parens are on the outside, and its behavior is 
        on the inside.
      </p>
      <p>
        The block turns this pattern inside out. The call site (<em>yield(12)</em> or 
        <em>block.call(12)</em>) is inside the <em>block_user</em>.
      </p>
      <p>
        The behavior is on the outside.
      </p>
      <p>
        So when <em>foo</em> takes its argument, it needs delimiters to name the argument 
        for the interpreter. <em>(x)</em>.
      </p>
      <p>
        When <em>block_user</em> passes <em>x</em>, the block needs delimiters to name its 
        argument, so its block body can use it. <em>|x|</em>.
      </p>
      <p>
        And because the behavior is on the outside, it can share variables from 
        its enclosing scope. <em>foo()</em>, by contrast, can only share variables from 
        its enclosing class.
      </p>
      <p>
        -- <a href="PhlIp.html">PhlIp</a>
      </p>
      <p>
        <em>"Inside Out Methods"?  You certainly have a unique perspective on blocks.  As I understand it, blocks are simply a name for an (often limited) form of </em><a href="HigherOrderFunctions.html">HigherOrderFunctions</a>.  Depending on the language, they can be lexically or dynamically scoped, and lexical scoping allows formation of <em>closures</em> (which are what make blocks really useful).  The above block would be equivalent to:<em></em>
      </p>
      <code>
        let y = 42 in \x -> (x + y)<br/>
        (or, for a variable 'y')<br/>
        let y = new cell<int>(42) in \x -> (x + dereference(y))  <br/>
      </code>
      <p>
        <em>Some languages languages make 'dereference(y)' implicit, of course.  And you'd want to let someone else see 'y' before embedding it in the function if the mutability of y is to be of any use to you.</em>
      </p>
      <p>
        <em>Anyhow, saying that 'foo(12)' necessarily has its behavior 'on the inside' seems a bit questionable even for 'lower order' methods, given access to global variables:</em>
      </p>
      <code>
        extern int y;<br/>
        int foo(int x) { return (x + y); }<br/>
      </code>
      <p>
        <em>As such, you may want to rethink your reasoning for your terminology a bit.</em>
      </p>
      <p>
        Won't happen. Not enough people know the word "everted" for it to work. (-:
      </p>
    </div>
  </body>
</html>