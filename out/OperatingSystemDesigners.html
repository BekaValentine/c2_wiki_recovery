<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Operating System Designers
      </h1>
      <p>
        An OS designer is someone who considers <a href="OperatingSystemsDesignPrinciples.html">OperatingSystemsDesignPrinciples</a>, <a href="UserStories.html">UserStories</a>, functional requirements, and other such things and <em>creates</em> the concepts to reconcile them all. So for example, <a href="LinusTorvalds.html">LinusTorvalds</a> is not an OS designer since Linux is a carbon copy of Unix.
      </p>
      <p>
        A <em>good</em> OS designer is someone who knows and is willing to use all existing <a href="OperatingSystemsResearch.html">OperatingSystemsResearch</a>, but never performs any such research themselves (at least, not <strong>as</strong> a designer). This might not be the case for all design fields, but given the enormous amount of operating systems research which has been underutilized, abandoned or just plain ignored, it is certainly the case with OS design. And since most UIs properly belong to the OS, it shouldn't surprise that the same goes for them too.
      </p>
      <p>
        An <em>architect</em> is someone who reuses existing designs and tailors them to the situation at hand. Or the reverse. It all depends on whether you want to say that <a href="FrankLloydWright.html">FrankLloydWright</a> was a bad designer or a bad architect for ignoring user needs. This page goes by the first convention; a designer creates, an architect reuses. So in selecting the features that constituted Minix' variation from Unix' architecture, to be able to implement it on a very primitive cpu, <a href="AndrewTanenbaum.html">AndrewTanenbaum</a> did architectural work.
      </p>
      <ul>
        <li>
           But <a href="FrankLloydWright.html">FrankLloydWright</a> was an excellent self-promoter, as was Edison (who's heard of Tesla?), and Marconi (who did not invent radio; credit probably should go to Tesla, although other claims have been made for Mahon Loomis, Alexander Popov, and in 1998 IEEE made a case for J.C. Bose). Self-promoters are almost always the ones who become famous, and then everyone (not just the public) assumes that they were great inventors/designers/architects/etc.
        </li>
        <li>
           <em>And people hate you for trampling their shining icons. Icons like </em><a href="LinusTorvalds.html">LinusTorvalds</a>, <a href="RichardStallman.html">RichardStallman</a>, <a href="DennisRitchie.html">DennisRitchie</a>, <a href="AlanKay.html">AlanKay</a>...<em></em>
          <ul>
            <li>
               Stallman is the exception to that; anyone who knows him personally, or even finds out much about him at a distance, completely understands that people would accuse him of, ummm....let's say, feet of clay. He's reminiscent of a slightly cleaned up, slightly more sane version of John Draper (CaptainCrunch).
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <p>
        see "Systems Software Research is Irrelevant",
        Rob Pike, August 5, 2000 (mirror) <a href="http://www.eng.uwaterloo.ca/~ejones/writing/systemsresearch.html">http://www.eng.uwaterloo.ca/~ejones/writing/systemsresearch.html</a>
      </p>
      <hr/>
      <p>
        Ongoing OS <em>designs</em>:
      </p>
      <ul>
        <li>
           JecelAssumpcaoJr; Merlin
        </li>
        <li>
           FrancoisReneRideau; Tunes (see <a href="TunesWiki.html">TunesWiki</a>)
        </li>
        <li>
           <a href="RichardKulisz.html">RichardKulisz</a>; <a href="BlueAbyss.html">BlueAbyss</a>
        </li>
        <li>
           <this is it folks, all of the major OS design projects on the entire planet>
        </li>
      </ul>
      <p>
        Good OS designers:
      </p>
      <ul>
        <li>
           <a href="AlanKay.html">AlanKay</a>: <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>
        </li>
        <li>
           <a href="DavidUngar.html">DavidUngar</a>: <a href="SelfLanguage.html">SelfLanguage</a>
        </li>
        <li>
           <a href="JohnMcCarthy.html">JohnMcCarthy</a>: <a href="LispLanguage.html">LispLanguage</a>
        </li>
        <li>
           <more>
        </li>
      </ul>
      <p>
        Bad OS designers:
      </p>
      <ul>
        <li>
           the E-rights group: <a href="ErosOs.html">ErosOs</a>
        </li>
        <li>
           HenryMassalin: <a href="SynthesisOs.html">SynthesisOs</a>
        </li>
        <li>
           <a href="DennisRitchie.html">DennisRitchie</a>, <a href="KenThompson.html">KenThompson</a>: <a href="PlanNine.html">PlanNine</a>
        </li>
        <li>
           <a href="RichardStallman.html">RichardStallman</a>: <a href="GnuHurd.html">GnuHurd</a>
        </li>
        <li>
           <many more>
        </li>
      </ul>
      <p>
        <em>In each of the following, it would be interesting to hear what they </em>'should<strong> have done, in addition to the critique of what they </strong>did<em>' do. E.g. in Plan9, which things should have been made more uniform?</em> Want more details?
      </p>
      <p>
        <strong>Why is </strong><a href="PlanNine.html">PlanNine</a> bad design?<strong> Because it's not uniform. Processes aren't files in Plan 9 but only represented by them. For Plan 9 to be perfectly uniform, it should be possible to write to a file to halt a process, copy a bunch of files to clone it, and write to a couple of files to restart them. IOW, fork() would've been a user-level script. And that's only judging Plan 9 by its own standards.</strong>
      </p>
      <p>
        At the time Plan 9 was made, it should really have been an object oriented OS (files are just crippled cases of objects) and the imperative notion of giving commands to fids should have been done away with by aggregating and nesting messages. Instead of "goDown(a); goDown(b); goDown(c); do(d)", it should've been passTo: #(a b c) message: d.
      </p>
      <p>
        And of course, Plan 9 lacks caps. This is important since getting rid of superuser and having a decent security scheme was one of the much vaunted features of Plan 9.
      </p>
      <p>
        Then there's other stuff like that Plan 9's namespace is globally inconsistent. This is a deficiency they recognized, but have never fixed. Well, you can't fix it if you stick to the concept of "binding" filesystems to a namespace with mounts, you have to use <em>bridging</em> with translators or portals instead.
      </p>
      <p>
        And of course, the crippling limitation that each directory can only have one parent directory. They came up with the "wonderful" sop of union directories instead.
      </p>
      <p>
        <strong>Why is HURD bad design?</strong> Because the only innovation in it are translators, and by "innovation" I mean something that's been discovered in the last 30 years. Translators occurred notably in <a href="GrassHopper.html">GrassHopper</a>. What's a translator? It's a replacement for a "mount". A translator isn't something that's attached to a namespace but rather lives <em>within</em> a filesystem to dynamically extend it.
      </p>
      <p>
        <strong>Why is EROS bad design?</strong> Because there is a kernel, it's neither OO nor functional, its capability scheme is 30 years old, the kernel holds all caps instead of their being distributed throughout the system. This is not state of the art!
      </p>
      <p>
        <strong>Why is </strong><a href="SynthesisOs.html">SynthesisOs</a> bad design?<strong> As I understand it, it does nothing that </strong><a href="SmalltalkLanguage.html">SmalltalkLanguage</a> doesn't do. It just compiles high-level source code into native code at runtime. Yawn.
      </p>
      <p>
        <em>This assessment is both unfair and incorrect. Synthesizing kernels do not simply compile existing code </em><a href="JustInTime.html">JustInTime</a>; rather, they generate <strong>new</strong> low-level driver code (off of an existing template, presumably) which is optimized specifically for each I/O service call. The premise is that the overhead of generating new code is offset by the greater efficiency of the optimized drivers. - <a href="JayOsako.html">JayOsako</a><em></em>
      </p>
      <p>
        Okay, fine. Then how is it different from a JIT + a dynamic optimizer that you call before you have any proven need for optimization? As opposed to Self's dynamic optimizer which only gets called <em>after</em> you have a proven need to optimize stuff ...
      </p>
      <p>
        When the only innovation in your OS is a different use for a compiler, it's really taking <a href="LanguagesAreOperatingSystems.html">LanguagesAreOperatingSystems</a> a little bit too far. -- rk
      </p>
      <hr/>
      <p>
        [section deleted -- provides no insight beyond that many, many OSes are simple knock-offs of each other]
      </p>
      <hr/>
      <p>
        <em>There are a large number of aspiring amateur </em><a href="OperatingSystemDesigners.html">OperatingSystemDesigners</a> on the web today, a handful of whom have actually produced working and sometimes even innovative systems. The remainder of this has been relocated to <a href="OperatingSystemsImplementation.html">OperatingSystemsImplementation</a>.<em></em>
      </p>
      <p>
        Writing's fine as long as it's never, ever confused with designing or indeed suggested that one has anything to do with the other. The difference is mentioned in <a href="LanguageDesignersOnWiki.html">LanguageDesignersOnWiki</a>, and here's a few points to help illustrate the distinction.
      </p>
      <p>
        You're <strong>not</strong> an OS designer if,
      </p>
      <ol>
        <li>
           you assume that a kernel exists in 2002
        </li>
        <li>
           you refer to <a href="LinusTorvalds.html">LinusTorvalds</a> in any way, shape or form, except as caveat and condemnation
        </li>
        <li>
           you refer to C/C++ as a high level language past 1980
        </li>
      </ol>
      <p>
        You don't even know the meaning of the term if,
      </p>
      <ol>
        <li>
           you think that a bootloader is part of an operating system
        </li>
        <li>
           you seriously advise people to clone an existing project and improve it
        </li>
        <li>
           you call yourself a coder
        </li>
      </ol>
      <hr/>
      <p>
        [I once wrote and shipped a special purpose OS, purely to save a deal that Sales made in a stupid way (they promised things that didn't exist and had never been discussed). In a sane world it wouldn't have been necessary. I wasn't trying to do a "good" design in some absolute sense, I was just trying to do something fast as damage control, and I succeeded, so I'm happy about it as a job well done. I would never try to defend any of its features as compared to some ideal, but its features were perfectly adapted to the microscopic problem it was solving. There's nothing for me to be ashamed of; on the contrary, I'm proud of it. Yet I don't see a non-derogatory category above in which to list this (if, hypothetically, I were to want to list it). Surely there's room in the world for special-purpose technology like that.]
      </p>
      <p>
        As Doug points out in <a href="LanguageDesignersOnWiki.html">LanguageDesignersOnWiki</a>, even coming up with a crippled, stripped down version of something can be a challenging design job requiring lots of creativity. Two things though. First, this page isn't limited to OS designers on this here wiki, so if we were to list everyone who ever did any sort of design on an OS, the list would be useless. Second, you'll have to provide more description for others to decide if you actually did any designing. Third, there's nothing wrong with being an OS writer if that's what you're paid to do.
      </p>
      <p>
        [The contract was going to be lost because a certain feature was ten-fold slower than it needed to be (causing lost data); since millions were at stake, every senior engineer had checked out the system, and they all agreed that the existing OS could not be sped up 10-fold in this area. So I designed and wrote a new OS that did that one thing as fast as the hardware allowed, yielding the 10-fold increase in performance necessary. I also invented and implemented a pure-declarative UI language to drive the user interface, which was integrated into that special purpose OS, and got a couple of guys to port a slew of device drivers over to it. Not bad for a 3 month project, which was all the time that was available to save the contract.]
      </p>
      <hr/>
      <p>
        See <a href="LanguagesAreOperatingSystems.html">LanguagesAreOperatingSystems</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryOperatingSystem.html">CategoryOperatingSystem</a> <a href="CategoryRant.html">CategoryRant</a>
      </p>
    </div>
  </body>
</html>