<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Multiple Inheritance
      </h1>
      <p>
        What you have when a class has more than one direct superclass.
        Some OO languages have <a href="MultipleInheritance.html">MultipleInheritance</a> (for instance:
        <a href="CeePlusPlus.html">CeePlusPlus</a>, <a href="CommonLisp.html">CommonLisp</a>, <a href="PythonLanguage.html">PythonLanguage</a>, <a href="PerlLanguage.html">PerlLanguage</a>); some don't (for
        instance: <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>, <a href="ModulaThree.html">ModulaThree</a>, <a href="JavaLanguage.html">JavaLanguage</a>).
        Java <em>does</em> have a sort of half-way house called "interfaces",
        providing multiple inheritance of interface but not of implementation. (<em>When I switched from C++ to Java I got blesses on my fingas.</em>)
      </p>
      <p>
        Some people like <a href="MultipleInheritance.html">MultipleInheritance</a>, some don't. See <a href="MultipleInheritanceIsNotEvil.html">MultipleInheritanceIsNotEvil</a>, and maybe also <a href="MultipleInheritanceInSmalltalk.html">MultipleInheritanceInSmalltalk</a>.
      </p>
      <p>
        Not to be confused with <a href="MultipleDispatch.html">MultipleDispatch</a>, which is what happens when
        method dispatch looks at the (dynamic) type of more than one object.
        (And which people disagree on just as much as they do about <a href="MultipleInheritance.html">MultipleInheritance</a>.)
      </p>
      <p>
        <em>Surely no one thinks </em><a href="MultipleDispatch.html">MultipleDispatch</a> is evil?<em></em>
      </p>
      <p>
        The classic first complaint about MI is inherited method clash. And just why can't people establish that inherited implementation clashes are illegal, and otherwise allow MI? That would have the side effect of preventing diamond-shaped hierarchies for all but the most abstract of classes. Essentially, it makes the practical issues disappear. This still leaves the damage you can cause with <a href="TaxoMania.html">TaxoMania</a>, but that is a <a href="BadProgrammer.html">BadProgrammer</a> problem, not a BadFeature problem. -- <a href="IanKjos.html">IanKjos</a>
      </p>
      <p>
        There <em>is</em> no method clash.  In <a href="CommonLisp.html">CommonLisp</a>, for example, each
        class has a <em>precedence list</em>, which is used to determine
        all applicable methods at time of dispatch.  This problem is
        a myth, and only exists in some (poorly, in my opinion) designed languages.
        --<a href="AlainPicard.html">AlainPicard</a>
      </p>
      <hr/>
      <p>
        Please don't forget <a href="EiffelLanguage.html">EiffelLanguage</a>.  It does <a href="MultipleInheritance.html">MultipleInheritance</a> right.
      </p>
      <hr/>
      <p>
        <a href="MultipleInheritance.html">MultipleInheritance</a> of implementation allows for <a href="MixIn.html">MixIn</a>s.
      </p>
      <hr/>
      <p>
        Some of us <a href="RelationalWeenie.html">RelationalWeenie</a>s see "sets" when we see multiple inheritance. Multiple inheritance is an oxymoron IMO because if you have multiple parents, then it is not really a true hierarchy any more. It is my belief that <a href="LimitsOfHierarchies.html">LimitsOfHierarchies</a> will eventually lead to sets as real-world complexity creeps into a project/system, which will lead to relational-like technology. Perhaps this is an <a href="AllRoadsLeadToRome.html">AllRoadsLeadToRome</a> sin, but that is how I see it. Hierarchies are easy to relate to (initially), but don't scale well over time (changes) or project size increases. -t
      </p>
      <p>
        <em>Yes, classes are sets of functions.  How is that comparable to relational where there are sets of data?</em>
      </p>
      <p>
        Classes are sets of objects, not sets of functions.  <a href="MultipleInheritance.html">MultipleInheritance</a> reflects the fact that sets may intersect, and is often an ugly kludge.
      </p>
      <hr/>
      <p>
        Why must it be a hierarchy?  Why not a simple directed graph?
      </p>
      <p>
        <em>It can be a graph. With multiple inheritance, it is a "multiarchy" instead of a hierarchy. The issue that must be resolved, however, is the order in which conflicts are resolved. If a given class inherits from both classA and classB, and both classA and classB define someMethod, then the order determines whether classA.someMethod or classB.someMethod is actually selected. Similarly, if either method includes a call to "super", or its equivalent, then the order determines which ancestor's method is selected. The "conflict" isn't a problem, per se. The multiple-inheritance mechanism simply needs to provide a mechanism for resolving the choice.</em>
      </p>
      <hr/>
      <p>
        See also: <a href="CallingaSpadeaSpade.html">CallingaSpadeaSpade</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryPolymorphism.html">CategoryPolymorphism</a> <a href="CategoryLanguageFeature.html">CategoryLanguageFeature</a>
      </p>
    </div>
  </body>
</html>