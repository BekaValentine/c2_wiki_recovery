<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Deterministic Message Passing
      </h1>
      <p>
        <em>Message-passing programs are difficult to test because of their non-deterministic behavior - </em> <a href="DoingStuff.html">DoingStuff</a>.<a href="DonaldNoyes.html">DonaldNoyes</a>.20141106
      </p>
      <p>
        One approach, called <a href="NonDeterministicTesting.html">NonDeterministicTesting</a>, involves executing a message-passing program with the same input many times in hope that faults will be exposed by one of these executions.
      </p>
      <p>
        <a href="NonDeterministicTesting.html">NonDeterministicTesting</a> has been widely used in practice, but unfortunately, in an ad-hoc manner. 
      </p>
      <ul>
        <li>
           I don't think <a href="MessagePassing.html">MessagePassing</a> has to be so difficult.  At some level of description, the program has to be deterministic.  Treat those individual modules as black-boxes that have a consistent, documented, input-output relationship.  As long as each of these (testable) modules performs as documented, then any program composed of these modules should be trustable as long as it is "well-formed" (i.e. logically-composed).  You might be interested in the discussion under <a href="ObjectOrientedRefactored.html">ObjectOrientedRefactored</a> which goes into a message-passing framework to take OOP to it`s ultimate.
        </li>
      </ul>
      <hr/>
      <p>
        A novel framework for non-deterministic testing of message-passing programs has been presented in an IEEE paper by Yu Lei and Eric Wong [1]
      </p>
      <p>
        The framework they propose uses a coverage criterion to guide the testing process. 
      </p>
      <ul>
        <li>
           During each test run, the sequence of send and receive events that are executed is recorded in an execution trace. 
        </li>
        <li>
           After each test run, the trace is analyzed to identify race conditions, which are used to derive coverage elements that have not been covered yet. 
        </li>
        <li>
           Random delays are inserted at a chosen set of program locations in order to increase the chance of covering the uncovered elements in the next test run. 
        </li>
      </ul>
      <p>
        This framework 
      </p>
      <ul>
        <li>
           provides a heuristic condition that can be used to decide when to stop testing. 
          <ul>
            <li>
               The condition is easy to compute and its satisfaction signals that the coverage criterion has likely been satisfied
            </li>
          </ul>
        </li>
        <li>
           can be automated at the source code level and allows one to obtain a measure of test coverage at the end of the testing process
        </li>
      </ul>
      <p>
        In the paper they describe a prototype tool and report some empirical results that demonstrate the effectiveness of the framework.
      </p>
      <hr/>
      <p>
        Citation:
      </p>
      <ul>
        <li>
           [1] - <em>Yu Lei, Eric Wong, "A Novel Framework for Non-Deterministic Testing of Message-Passing Programs", HASE, 2005, Ninth IEEE International Symposium on High-Assurance Systems Engineering (HASE'05), Ninth IEEE International Symposium on High-Assurance Systems Engineering (HASE'05) 2005, pp. 66-75, doi:10.1109/HASE.2005.2</em> 
        </li>
      </ul>
      <hr/>
      <p>
        <a href="CategoryParallelProcessing.html">CategoryParallelProcessing</a>
      </p>
    </div>
  </body>
</html>