<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Super Over Generalized
      </h1>
      <p>
        "Ya, well you can always say, I can do this thing to this thing." <a href="OverGeneralizing.html">OverGeneralizing</a> to the point where any two concepts/ideas could in some way be treated the same, usually resulting in sort of <a href="BruteForceSolutions.html">BruteForceSolutions</a>, which might not scale.
      </p>
      <p>
        Descriptive of Metametaland? (Not to be confused with Neverneverland.)
      </p>
      <p>
        <em>The problem with a </em><a href="SuperOverGeneralized.html">SuperOverGeneralized</a> solution is that as soon as your customer asks for something that doesn't conform to it's model, you're in trouble:  It may to an incredibly good job of doing every possible thing, that conforms to its model, but as soon as your customer throws a wrench in the works, by giving you an unexpected requirement, life gets tough.<em></em>
      </p>
      <p>
        Sometimes it's worth it, but sometimes it's not.
      </p>
      <hr/>
      <p>
        Recently I was writing a Reliable Transport Protocol simulation, in which a message had to be packetized or reassembled by a couple of threads. I got into trouble when I tried viewing the jobs for the send thread (SendJob) as the same kind of animal as jobs for the receive thread (ReceiveJob). After doing a lot of head-scratching, I came up with a better solution by using an list of Packets for the receive jobs. The send jobs were a different sort of animal because they involved an entire message, required feedback, etc. So I eliminated the ReceiveJob class and came up with a much cleaner solution. I forgot what the moral was... ah, well. --<a href="PatrickParker.html">PatrickParker</a>
      </p>
      <hr/>
      <p>
        In database design, when people start going over the edge, in terms of excessive generalization, I say, "I know!!!  Lets...
      </p>
      <ul>
        <li>
           Reduce the entire database design to a single table;
        </li>
        <li>
           Give it a system-assigned numeric key,
        </li>
        <li>
           and a large text field for the data.
        </li>
        <li>
           Then we can put any free-form data in the text field we want, and references to other objects/records can simply use the system assigned numeric id, as text."
        </li>
      </ul>
      <p>
        It truth, it would be possible to do this.
        Any system at all can be reduced to this kind of implementation.
        But you can't create any useful indexes for foreign key lookups, and processing the data can be somewhat problematic.  ;->
      </p>
      <p>
        After a while, you start to realize the value of StructuredData:
        Yes, it limits what you can do, but it makes it a lot easier to actually perform useful processing on the data.
        -- <a href="JeffGrigg.html">JeffGrigg</a>
      </p>
      <p>
        Yeah, you read the description above (of converting the entire database to one table) and you're rolling about the floor laughing.  Or not.  I've been in two quite different companies where the development team did exactly this.  It was painful to watch the first time, excruciating the second.  Both times the company was trying to model arrays of arbitrary C structs in the database.  These were 'configuration' databases.  My take is that the solution wasn't <a href="SuperOverGeneralized.html">SuperOverGeneralized</a> enough...  If they'd only had the courage to extend the database with the meta data features they needed, they could have stayed with multiple tables.  Instead they tried to squeeze a flexible structure (the ever changing configuration data structure) into a rigid one (the single table).  Bottom line, the basic unextended database features were not general enough to support what they were trying to do. -- <a href="JamesCrook.html">JamesCrook</a>
      </p>
      <hr/>
      <p>
        I'd vote that many many more applications are <a href="SlavishlyUnderGeneralized.html">SlavishlyUnderGeneralized</a> than <a href="SuperOverGeneralized.html">SuperOverGeneralized</a>. Applications that know more than they need about today's environment are typically much to resistant to change. I suspect the question is not is the system too generalized (whick like rich, slim, and successful is a contradiction) but is the system correctly generalized. --<a href="JimRussell.html">JimRussell</a>
      </p>
      <hr/>
      <p>
        See also <a href="PrematureGeneralization.html">PrematureGeneralization</a>, <a href="ThingsThatAreDifferentAreNotTheSame.html">ThingsThatAreDifferentAreNotTheSame</a>, <a href="ThereAreOnlyThreeNumbers.html">ThereAreOnlyThreeNumbers</a>
      </p>
    </div>
  </body>
</html>