<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Com Is Not
      </h1>
      <p>
        <a href="ComIsNot.html">ComIsNot</a>:
      </p>
      <ul>
        <li>
           OLE
        </li>
        <li>
           <a href="ComPlus.html">ComPlus</a>
        </li>
        <li>
           MTS
        </li>
        <li>
           Dead
        </li>
      </ul>
      <p>
        COM (<a href="ComponentObjectModel.html">ComponentObjectModel</a>) is an extremely flexible substrate for building distributed object systems or components. These components can be built in any language that supports the COM standard for layout of binary objects and callable from any language that either has this layout or supports the late binding interface IDispatch.
      </p>
      <p>
        COM is:
      </p>
      <ul>
        <li>
           A binary standard for layout of objects. This layout is simply a vtable which is generated by using C++ abstract base classes (equivalent to Java interfaces). They have to be laid out the same way as Microsoft's C++ compiler does them, but that's it.
        </li>
      </ul>
      <ul>
        <li>
           <a href="GloballyUniqueIdentifier.html">GloballyUniqueIdentifier</a>s (GUIDs) which uniquely identify COM interfaces, COM co-classes, COM objects, etc uniquely in time and space.
        </li>
      </ul>
      <ul>
        <li>
           <a href="InterfaceDefinitionLanguage.html">InterfaceDefinitionLanguage</a> (IDL) - A language independent way of uniquely identifying COM Interfaces, their GUIDs, their methods and how parameters are passed in, out or in/out and a way to generate proxy and stub DLLs for marshalling
        </li>
      </ul>
      <ul>
        <li>
           An interception Runtime that intercepts all calls and inserts a proxy/stub if necessary
        </li>
      </ul>
      <ul>
        <li>
           Location transparency. COM was ALWAYS designed for distributed calls in the beginning. NT4 was the first implementation. The key is that the way you call a COM method on an interface does not change.
        </li>
      </ul>
      <ul>
        <li>
           A COM Runtime, implemented in oleaut32.dll, that defines an API set, with CoX.... routines, such as <a href="CoCreateInstance.html">CoCreateInstance</a>(Ex) that locate the object either by looking in the Registry or in the case of COM+ configured components from the COM+ catalog
        </li>
      </ul>
      <ul>
        <li>
           Threading Models - STA, MTA, TNA to allow components of various threading types to live where they belong and talk to components of other threading requirements
        </li>
      </ul>
      <ul>
        <li>
           Optionally a Type Library generated from the IDL that allows COM to be used from brain-dead scripting languages
        </li>
      </ul>
      <p>
        COM clients *never* get a pointer to a COM object. They always get a pointer to an interface of that object. 
      </p>
      <p>
        COM does give you a defined interface: <em>IUnknown</em>, from which all other interfaces must be derived. IUnknown provides for reference counting (via <a href="AddRef.html">AddRef</a>/Release) and runtime interface discovery/navigation -- dynamic type casting (via <a href="QueryInterface.html">QueryInterface</a>).
      </p>
      <p>
        OLE defines several interfaces to do with object linking and embedding. These interfaces are on top of COM. DirectX defines interfaces for gaming. <a href="DirectShow.html">DirectShow</a> defines interfaces for media streaming. etc., etc. These are also on top of COM.
      </p>
      <p>
        MTS was a separate add-on product (NT Option Pack) which leverages this further to provide for other stuff like just-in-time activation (JITA), object pooling (lowers instantiation costs by reusing objects), transactions, etc.
      </p>
      <p>
        <a href="ComPlus.html">ComPlus</a> gets its name from COM + MTS + MSMQ + OTHER NEW FEATURES (like the new publish/subscribe event system). <a href="ComPlus.html">ComPlus</a> merges the COM and MTS object models into one object model and puts the runtime into the kernel. It adds a list of features detailed on the <a href="ComPlus.html">ComPlus</a> page. It doesn't necessary do anything different with DCOM (<a href="DistributedCom.html">DistributedCom</a>)... DCOM is really just COM over the wire, where location transparency means something more than just being outside an apartment or local process, adding the possibly of communicating with an instance of a component running on entirely different machine.
      </p>
      <hr/>
      <p>
        I'd prefer that this page not degenerate into a <a href="ThreadMode.html">ThreadMode</a> discussion. Ways that I think will avoid this are the following:
      </p>
      <ul>
        <li>
           Ask your questions below.
        </li>
        <li>
           If you answer a question, refactor the above explanation to include both, and delete the question.
        </li>
        <li>
           Please refrain from signing anything, unless you feel the need for <a href="DramaticIdentity.html">DramaticIdentity</a>.
        </li>
        <li>
           Keeping this page a PissingMatchFreeZone - slag COM off on <a href="ComIsHard.html">ComIsHard</a> if you feel the need.
        </li>
      </ul>
      <hr/>
      <hr/>
      <p>
        As one who has worked with COM since its beta in 1993 and taught it, I went and re-factored the above. -- <a href="SamGentile.html">SamGentile</a>
      </p>
      <hr/>
      <p>
        So, what's the story with Microsoft abandoning shared COM objects as code reuse? That is, storing multiple versions of the same COM object on the system, and then having each application maintain a manifest of the objects and versions they require? Actually, it's naturally because <a href="ComponentOrientedProgramming.html">ComponentOrientedProgramming</a> as code reuse doesn't work at the interface level because the interface isn't implementation. But how does this affect COM's usefulness? Why not just use DLLs (for INPROC COM objects)? I'm not trolling here either; I just don't get it anymore. I love COM, but it seems so useless now. -- <a href="SunirShah.html">SunirShah</a>
      </p>
      <p>
        I assume you are referring to <a href="DotNet.html">DotNet</a>'s model and COM being dead. First of all, COM is not dead and COM+ continues to evolve and get new features. <a href="DotNet.html">DotNet</a> has each Assembly (not application) maintain a manifest of the objects and versions they require. Why is this a win? Because this gets rid of the COM problem of having to register things in the Registry. This also allows a <a href="DotNet.html">DotNet</a> app to use xcopy deployment: you just simply copy all the assemblies and files to some directory and party on. No more registration. No more registry. Your other question I don't understand: COM DOES use DLLs for INPROC COM objects. Let me know if this is not clear. Thanks for your interest. -- <a href="SamGentile.html">SamGentile</a>
      </p>
      <p>
        Apparently, in the latest versions of Windows (don't know exactly; I'm a Palm developer now), applications will no longer be able to use registered COM objects, but have to use that manifest thing. I recognize the reason being version inconsistencies. This is because component-oriented programming does not create code reuse (nothing does). So, it would seem that it's cheaper for applications to just statically link everything, except for the problem bugfixes and patches. 
      </p>
      <p>
        <em>I don't believe that is true. I am using the latest Whistler and I can still register and use old-style COM objects.</em>
      </p>
      <p>
        In those cases, splitting the application into modules makes it easier to contain changes to small binaries. However, that doesn't explain what all the complication of COM is good for. A <em>plain vanilla</em> DLL seems like a better choice than a COM object. You lose the thread model, but that's really not much of an issue anyway. 
      </p>
      <p>
        <em>Why? DLLs can't be versioned. COM Interfaces can be. In Proc COM Objects are DLLs.</em>
      </p>
      <p>
        Out of process COM objects have advantages, especially if they are persistently loaded and shared. But in process COM objects are just complication and overhead that isn't really necessary. 
      </p>
      <p>
        <em>How so?</em>
      </p>
      <p>
        By the way, a nicer modularization scheme might be like Java's .class system, except that (just like everything in Java ;) it's broken. Perl has a good model too. Reports of C# indicate it's actually doing the right thing, which is super nice. But that doesn't leave much room for COM for normal applications.
      </p>
      <p>
        Then again, maybe the IDispatch interface is enough reason? Interlanguage operability? I'm not entirely sure about that. DLLs work for that too, in most cases. Maybe a better question is "What does an INPROC COM object do for you now?" -- <a href="SunirShah.html">SunirShah</a>
      </p>
      <p>
        <em>IDispatch is for dumb VB and scripting languages. DLLs and COM are not really a valid comparison unless you are comparing them for code reuse and then </em>InPROC COM solves is that the lack of a C++ binary standard limits what language features can be used across DLL boundaries. Simply exporting C++ member functions is not enough to create a vendor-independent component substrate. Also, because C++ requires the client knowledge of object layout, C++ introduces a tight binary coupling between the client and object executables. So versioning is impossible. COM solves these issues and more. It allows a client to select and load binary components dynamically that can evolve their implementation layout over time without requiring client recompilation. Also an INPROC COM component provides RTTI of interfaces across multiple vendor's compilers and languages. The last area is resource management. A INPROC COM object can go away when there are no outstanding references.<em></em>
      </p>
      <p>
        -- <a href="SamGentile.html">SamGentile</a>
      </p>
    </div>
  </body>
</html>