<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Duffs Device In Duffs Own Words
      </h1>
      <p>
        This is the text of a document by <a href="TomDuff.html">TomDuff</a> describing <a href="DuffsDevice.html">DuffsDevice</a>, which he sent to comp.lang.c in 1988 when <a href="DuffsDevice.html">DuffsDevice</a> came up. This version was taken from <a href="http://groups-beta.google.com/group/comp.lang.c/msg/bb78298175c42411,">http://groups-beta.google.com/group/comp.lang.c/msg/bb78298175c42411,</a> with the formatting intact, except where Wiki's <a href="TextFormattingRules.html">TextFormattingRules</a> interfered (<a href="WikiWord.html">WikiWord</a>s, italics, etc).
      </p>
      <p>
        The original netnews version (from 1984) Tom refers to and reconstructed can be found at <a href="http://groups.google.com/groups?selm=2748%40alice.UUCP,">http://groups.google.com/groups?selm=2748%40alice.UUCP,</a> and Tom presumably knows this.
      </p>
      <code>
        From: td@alice.UUCP (Tom Duff)<br/>
        Newsgroups: comp.lang.c<br/>
        Subject: Re: Explanation, please!<br/>
        Summary: Original citation<br/>
        Message-ID: <8144@alice.UUCP><br/>
        Date: 29 Aug 88 20:33:51 GMT<br/>
        References: <638@paris.ICS.UCI.EDU> <634@proxftl.UUCP> <660@proxftl.UUCP><br/>
        Organization: AT&T Bell Laboratories, Murray Hill NJ<br/>
        Lines: 151<br/>
      </code>
      <code>
        I normally do not read comp.lang.c, but Jim McKie told me<br/>
        that "Duff's device" had come up in comp.lang.c again.  I<br/>
        have lost the version that was sent to netnews in May 1984,<br/>
        but I have reproduced below the note in which I originally<br/>
        proposed the device.  (If anybody has a copy of the netnews<br/>
        version, I would gratefully receive a copy at research!td or<br/>
        td@research.att.com.)<br/>
      </code>
      <code>
        To clear up a few points:<br/>
      </code>
      <ol>
        <li>
          )      The point of the device is to express general
        </li>
      </ol>
      <code>
        loop unrolling directly in C.  People who have<br/>
        posted saying `just use memcpy' have missed the<br/>
        point, as have those who have criticized it using<br/>
        various machine-dependent memcpy implementations<br/>
        as support.  In fact, the example in the message is<br/>
        not implementable as memcpy, nor is any computer<br/>
        likely to have an memcpy-like idiom that implements<br/>
        it.<br/>
      </code>
      <ol>
        <li>
          )      Somebody claimed that while the device was named
        </li>
      </ol>
      <code>
        for me, I probably didn't invent it.  I almost<br/>
        certainly did invent it.  I had definitely not<br/>
        seen or heard of it when I came upon it, and nobody<br/>
        has ever even claimed prior knowledge, let alone<br/>
        provided dates and times.  Note the headers on the<br/>
        message below:  apparently I invented the device<br/>
        on November 9, 1983, and was proud (or disgusted)<br/>
        enough to send mail to dmr.  Please note that I<br/>
        do not claim to have invented loop unrolling, merely<br/>
        this particular expression of it in C.<br/>
      </code>
      <ol>
        <li>
          )      The device is legal dpANS C.  I cannot quote chapter
        </li>
      </ol>
      <code>
        and verse, but Larry Rosler, who was chairman of the<br/>
        language subcommittee (I think), has assured me that X3J11<br/>
        considered it carefully and decided that it was legal.<br/>
        Somewhere I have a note from dmr certifying that all<br/>
        the compilers that he believes in accept it.  Of course,<br/>
        the device is also legal C++, since Bjarne uses it in<br/>
        his book.<br/>
      </code>
      <ol>
        <li>
          )      Somebody invoked (or more properly, banished) the
        </li>
      </ol>
      <code>
        'false god of efficiency.'  Careful reading of my<br/>
        original note will put this slur to rest.  The<br/>
        alternative to genuflecting before the god of<br/>
        code-bumming is finding a better algorithm.  It<br/>
        should be clear that none such was available.  If<br/>
        your code is too slow, you must make it faster.  If no<br/>
        better algorithm is available, you must trim cycles.<br/>
      </code>
      <ol>
        <li>
          )      The same person claimed that the device wouldn't exhibit
        </li>
      </ol>
      <code>
        the desired speed-up.  The argument was flawed in two<br/>
        regards:  first, it didn't address the performance of<br/>
        the device, but rather the performance of one of its<br/>
        few uses (implementing memcpy) for which many machines<br/>
        have a high-performance idiom.  Second, the poster<br/>
        made his claims in the absence of timing data, which<br/>
        renders his assertion suspect.  A second poster tried<br/>
        the test, but botched the implementation, proving<br/>
        only that with diligence it is possible to make anything<br/>
        run slowly.<br/>
      </code>
      <ol>
        <li>
          )      Even Henry Spencer, who hit every other nail square on
        </li>
      </ol>
      <code>
        the end with the flat round thing stuck to it, made a<br/>
        mistake (albeit a trivial one).  Here is Henry replying<br/>
        to bill@proxftl.UUCP (T. William Wells):<br/>
        >>... Dollars to doughnuts this code<br/>
        >>was written on a RISC machine.<br/>
      </code>
      <code>
        >Nope.  Bell Labs Research uses VAXen and 68Ks, mostly.<br/>
      </code>
      <code>
        I was at Lucasfilm when I invented the device.<br/>
      </code>
      <ol>
        <li>
          )      Transformations like this can only be justified by measuring the
        </li>
      </ol>
      <code>
        resulting code.  Be careful when you use this thing that you don't<br/>
        unwind the loop so much that you overflow your machine's instruction<br/>
        cache.  Don't try to be smarter than an over-clever C compiler that<br/>
        recognizes loops that implement block move or block clear and compiles<br/>
        them into machine idioms.<br/>
      </code>
      <code>
        Here then, is the original document describing Duff's device:<br/>
      </code>
      <code>
        From research!ucbvax!dagobah!td  Sun Nov 13 07:35:46 1983<br/>
        Received: by ucbvax.ARPA (4.16/4.13)<br/>
        id AA18997; Sun, 13 Nov 83 07:35:46 pst<br/>
        Received: by dagobah.LFL (4.6/4.6b)<br/>
        id AA01034; Thu, 10 Nov 83 17:57:56 PST<br/>
        Date: Thu, 10 Nov 83 17:57:56 PST<br/>
        From: ucbvax!dagobah!td (Tom Duff)<br/>
        Message-Id: <8311110157.AA01034@dagobah.LFL><br/>
        To: ucbvax!decvax!hcr!rrg, ucbvax!ihnp4!hcr!rrg, ucbvax!research!dmr,<br/>
        ucbvax!research!rob<br/>
      </code>
      <code>
        Consider the following routine, abstracted from code which copies an<br/>
        array of shorts into the Programmed IO data register of an Evans &<br/>
        Sutherland Picture System II:<br/>
      </code>
      <code>
        send(to, from, count)<br/>
        register short *to, *from;<br/>
        register count;<br/>
        {<br/>
        do<br/>
      </code>
      <ul>
        <li>
          to = *from++;
        </li>
      </ul>
      <code>
        while(--count>0);<br/>
        }<br/>
      </code>
      <code>
        (Obviously, this fails if the count is zero.)<br/>
        The VAX C compiler compiles the loop into 2 instructions (a movw and<br/>
        a sobleq, I think.)  As it turns out, this loop was the bottleneck in<br/>
        a real-time animation playback program which ran too slowly by about 50%.<br/>
        The standard way to get more speed out of something like this is to unwind<br/>
        the loop a few times, decreasing the number of sobleqs.  When you do that,<br/>
        you wind up with a leftover partial loop.  I usually handle this in C with<br/>
        a switch that indexes a list of copies of the original loop body.  Of<br/>
        course, if I were writing assembly language code, I'd just jump into the<br/>
        middle of the unwound loop to deal with the leftovers.  Thinking about this<br/>
        yesterday, the following implementation occurred to me:<br/>
      </code>
      <code>
        send(to, from, count)<br/>
        register short *to, *from;<br/>
        register count;<br/>
        {<br/>
        register n=(count+7)/8;<br/>
        switch(count%8){<br/>
        case 0: do{     *to = *from++;<br/>
        case 7:         *to = *from++;<br/>
        case 6:         *to = *from++;<br/>
        case 5:         *to = *from++;<br/>
        case 4:         *to = *from++;<br/>
        case 3:         *to = *from++;<br/>
        case 2:         *to = *from++;<br/>
        case 1:         *to = *from++;<br/>
        }while(--n>0);<br/>
        }<br/>
        }<br/>
      </code>
      <code>
        Disgusting, no?  But it compiles and runs just fine.  I feel a combination<br/>
        of pride and revulsion at this discovery.  If no one's thought of it before,<br/>
        I think I'll name it after myself.<br/>
      </code>
      <code>
        It amazes me that after 10 years of writing C there are still little corners<br/>
        that I haven't explored fully.  (Actually, I have another revolting way to<br/>
        use switches to implement interrupt driven state machines but it's too<br/>
        horrid to go into.)<br/>
      </code>
      <code>
        Many people (even bwk?) have said that the worst feature of C is that<br/>
        switches don't break automatically before each case label.  This code forms<br/>
        some sort of argument in that debate, but I'm not sure whether it's for or<br/>
        against.<br/>
      </code>
      <code>
        yrs trly<br/>
        Tom<br/>
      </code>
    </div>
  </body>
</html>