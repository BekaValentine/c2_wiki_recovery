<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Theory Vs Empirical Stalemate
      </h1>
      <p>
        (Based on discussion at <a href="InsultJustificationDiscussion.html">InsultJustificationDiscussion</a>)
      </p>
      <p>
        Despite what <a href="TopMind.html">TopMind</a> believes, practitioners do not have any social license to blurt technical opinions then hide behind a shield of ignorance. Practitioners are welcome. They're also expected, if they come to a forum about <a href="PeopleProjectsAndPatterns.html">PeopleProjectsAndPatterns</a> in <a href="SoftwareDevelopment.html">SoftwareDevelopment</a>, to willingly educate themselves.
      </p>
      <p>
        <em>We have a </em>'stalemate<strong> where both sides </strong>won't do homework<strong> that the other expects. I expect you to turn your pet theories into demonstration code samples and scenarios (</strong><a href="RaceTheDamnedCar.html">RaceTheDamnedCar</a>), and you expect me to read and figure out your favorite academic books and papers. This stalemate is because I put much less value on theory than you and you place much less value on empirical demonstrations than I do. This is largely because I believe that software productivity is mostly about psychology (<a href="PsychologyMatters.html">PsychologyMatters</a>) and fitting people's personal mental models, while you feel it is more about finding the one true central universal "math" or model. --top<em></em>
      </p>
      <p>
        There is a serious problem with what you say, <a href="TopMind.html">TopMind</a>: you claim to favor demonstrated code examples, yet the 'technical opinions' you blurt tend to not contain such demonstrative code examples of a claim. Sure, sometimes you write up some code (e.g. in <a href="GuiMachineLanguage.html">GuiMachineLanguage</a>), but rarely does it <em>demonstrate</em> anything relevant to the argument (e.g. that you don't still need scripting, improved support for <a href="CrudScreen.html">CrudScreen</a> relative to HTML++, etc.), and it certainly doesn't <em>demonstrate</em> the wide variety of other claims you make (that it meets real-world needs, that fanboyism will destroy any app-lang specific solution, that there's a 'security' benefit). If you wish to use demonstrative code examples to prove your arguments, I can respect that method (in profession, if not attitude, I'm a practitioner too). But your execution of your favored approach to argument leaves much to be desired, and you regularly fill in the gap with distractions (<a href="RedHerring.html">RedHerring</a>), illogical leaps (<a href="NonSequitur.html">NonSequitur</a>), and unjustified or unjustifiable assertions (<a href="HandWaving.html">HandWaving</a>), sometimes all at once. Even if you don't believe your that bad, you should at least accept that many other people do believe you're that bad. The fact is, even if you don't put much value on theory, you must still rely upon it to bridge the gap between a code example and a claim that it achieves some useful property. But, because you are inept or uneducated in both theory and logic, you attempt to bridge that gap with sophistry (or fallacy, since you claim to be so 'innocent' and 'ignorant' despite being told off repeatedly). 
      </p>
      <ul>
        <li>
           The <a href="GuiMachineLanguage.html">GuiMachineLanguage</a> discussion is generally an exception because it requires predicting the future and human behavior with regard to acceptance of technology (AKA "marketing"). Both sides will be on fuzzy ground here. You too have no double-blind peer-reviewed certified study about the progress that HTML++ will make in the future. You also only can make educated guesses. This gets back my complaint that you slide between loose and tight evidence requirements to suit your particular argument instead of applying the standard even-handed. Why should I have to "prove" what will happen in the future while you don't? -t
        </li>
        <li>
           <a href="GuiMachineLanguage.html">GuiMachineLanguage</a> is not an exception. You slipped off the road into unjustified claims long before you got to 'marketing' issues, such as your claim that your GML 'four-column' structure is better for <a href="CrudScreen.html">CrudScreen</a> from a whole-system perspective. And, since you are apparently illiterate, my argument has never been that HTML++ "will" make it for the indefinite future. I have argued that it "can" make it for a few more decades, for which I provided reason (see <a href="LimitsOfHtmlStack.html">LimitsOfHtmlStack</a>).
        </li>
        <li>
           And your 'complaint' about 'sliding between loose and tight evidence requirements to suit a particular argument' still strikes me as irrational. Whatever it is you are <em>imagining</em> to be 'standard even-handed' is not standard. Standard is arguing from evidence and statistical principles (inductive and abductive logic) where necessary, and arguing from formal principles (deductive logic) where possible, and that is exactly what I do.
        </li>
        <li>
           <em>Tell me, what "statistical principles" do you use when you claim that HTML++ will likely eventually be CRUD-sufficient in our lifetime?</em>
        </li>
        <li>
           Define "CRUD-sufficient". If your definition is practical and technical rather than idealist, HTML++ is likely already there, short the tweaks for <a href="TopMind.html">TopMind</a>'s personal favorite keyboard bindings. And, though I won't bother to gain widespread statistics, my observations have been that software components tend to gain features and tweaks over their life-cycle rather than go the other direction.
        </li>
        <li>
           <em>"Personal favorites"? The down arrow behavior is very common in mature table and grid applications, including the very first microcomputer spreadsheet. If it was merely a personal preference, then it would not likely be so common (Excel, </em><a href="FoxPro.html">FoxPro</a>, Access, CFgrid, <a href="VisiCalc.html">VisiCalc</a>, dBASE, OOO-Calc, and probably others). I'm always guilty until proven innocent with you.<em> </em>
        </li>
        <li>
           Whether your favorite 'arrow behavior' is common or not isn't a technical issue. You can say that the arrow behavior isn't 'conventional', and even suggest it 'irritating', but I see no valid reason you could call it 'incorrect', unless you define "grid" in terms of a specific set of keyboard bindings.  
          <ul>
            <li>
               <em>If it violates enough conventions, then it's equivalent to "incorrect" either way. The down-arrow allows for column-downward data entry, which is a fairly common need.</em>
            </li>
          </ul>
        </li>
        <li>
           <em>As far as the criteria for CRUD-friendly, I'd say to be able to have nearly all the widgets and GUI behaviors described in </em><a href="WebBrowserMissingWidgetWorkArounds.html">WebBrowserMissingWidgetWorkArounds</a> in the same screen (if applicable, or else same app) in at least the 3 top web browsers, and still work on the next integer release in 2 out of 3 of the major browsers. -t<em></em>
        </li>
        <li>
           "Friendly" implies a much greater degree of support than "sufficient", does it not? And to me, 'CRUD-friendly' would need to be friendly on the development-side and server-side, too. Anyhow, I expect www.extjs.com widgets qualify for your 'sufficiency' spec. They are supported across three major versions of <a href="FireFox.html">FireFox</a> and three major versions of Internet Explorer and two major versions of Opera. Anyhow, we shouldn't digress much further on this subject.
        </li>
        <li>
           <em>It's speculative at this point whether extjs will work with all the widgets and form types together. I've had problems mixing other HTML++ widgets. And I agree about digressing. We should put these items in the proper slots eventually. -t</em>
        </li>
      </ul>
      <p>
        You claim <a href="PsychologyMatters.html">PsychologyMatters</a> on faith. You claim I want to 'find one true central universal "math" or model'. However, unlike you, I do not treat <a href="ComputerScience.html">ComputerScience</a> as a religion and I'm only marginally interested in <a href="SoftwareEngineering.html">SoftwareEngineering</a>. I make no claims about universe; I simply focus on obtaining sets of properties that I deem useful to use-cases that I believe have a demand, and I make no assertions about what is "universally better" or anything else (indeed, I find <em>your</em> idea of a universal 'better' to be illogical and irrational; <a href="InterCal.html">InterCal</a> is likely 'better' than C for frustrating readers of code, for example). The useful properties I tend to focus on are: security (secrecy, authority, liveness), composition, scalability, modularity, configurability (policy injection, dependency injection, configuration parameters), process accounting, concurrency, disruption tolerance, persistence, graceful degradation, resilience (self-healing), well-timing properties (real-time, deadlines, temporal windows), operations safety (termination, progress), type-safety, and performance. I always feel insulted when you take a look at a list like this, you only notice the last two items, wave performance away as though it isn't relevant, then start whining about me turning it into a typing debate... don't even start.
      </p>
      <p>
        <em>I don't know what you are referring to with regard to "waving away performance". If you are going to introduce specific instances of my alleged devious behavior, then either cite them properly or don't reference them at all. Half-ass citations are merely fodder for flame-wars. -t</em>
      </p>
      <p>
        <em>As far as your list, I agree we should try to optimize most of them also. I just disagree with you on how to go about it. -t</em>
      </p>
      <hr/>
      <p>
        And don't get me wrong, I am not a <a href="CowboyCoder.html">CowboyCoder</a> against abstractions in general. But what I have found by experience is that big grandiose abstractions tend to fail harder and uglier than small, local abstractions, and that one must plan for exceptions to the rule (deviations from abstraction) such that deviations don't bring down the whole thing (<a href="EightyTwentyRule.html">EightyTwentyRule</a>). Design machinery with tolerances for grit and bad replacement parts, because you won't always be around to police the machine. -t
      </p>
      <p>
        Sure. Big, grandiose abstractions - like the general idea of tables and procedures - fail harder and uglier than small, local abstractions. One must plan (<a href="BigDesignUpFront.html">BigDesignUpFront</a>) for the exceptions to the rule (deviations from abstraction) such that deviations don't bring down the whole thing (such as by having security, safety, scalability, composition, modularity, configurability, concurrency, well-timing, etc. issues). Languages should be designed to support modularity such that components can be fixed and replaced individually. I see nothing to disagree with here. I would say that <strong>you</strong> are the one who favors big, grandiose abstractions with your positions in <a href="TableOrientedProgramming.html">TableOrientedProgramming</a>, your anti-scripting stance on <a href="GuiMachineLanguage.html">GuiMachineLanguage</a>, your favoring 'entity' tables above 'narrow' tables, your attempt to generalize <a href="TypesAreSideFlags.html">TypesAreSideFlags</a>, etc. As noted above, I favor <em>properties</em>. 'Properties' (like scalability and concurrency and performance) are categorically different from 'abstractions' (like pure functions, procedures, actors, sets, lists, records, characters, numbers). I'm a fan of having many primitive abstractions, each with its own relatively narrow role to play. <a href="HorsesForCourses.html">HorsesForCourses</a>, <a href="PickTheRightToolForTheJob.html">PickTheRightToolForTheJob</a>. If abstractions aren't pulling double and triple-duties, optimizations for performance are easier to automate without sacrificing the various other useful properties, and composition can be made scalable via layered language (e.g. procedures can use functions, but not vice versa).
      </p>
      <p>
        <em>I will resist the urge to rekindle those subjects in this topics. If you wish to pull something out for specific analysis that illustrates issues in this topic, then please do. -t</em>
      </p>
      <p>
        The above list IS a set of specific examples for analysis. If you've forgotten, though, the <strong>point</strong> of those examples is that <a href="TopMind.html">TopMind</a> - not I - is the one who favors 'big' abstractions, such as 'use tables for everything', 'use callbacks to server for everything', etc. That's a meta-argument position, is it not? Individual arguments are specific points in an argument discussing habits across arguments. There is no rational or logical reason for you to rekindle those subjects. There is no rational or logical reason for me to pull something out for specific analysis, because your 'anti-scripting stance for GML' IS ALREADY something for specific analysis, as is your entire <em>concept</em> of <a href="TableOrientedProgramming.html">TableOrientedProgramming</a>.
      </p>
      <p>
        <em>I generally meant big domain abstractions, not big tool abstractions. -t</em>
      </p>
      <p>
        I program a computer, not a domain. I represent input and output. I represent many 'tool' abstractions for program components (actors, functions, procedures, message channels, sets, maps, lists, records, variants, numbers, subscriptions, mutexes, cancellation points, threads, stacks, queues, etc.). But, with two exceptions, I very rarely represent 'domain' abstractions at all - much less 'big' ones. Those exceptions: planners, and simulators, which must know something of a domain in order to plan for it or predict it. For planning and simulation, I favor <a href="LogicProgramming.html">LogicProgramming</a> idioms (and I'd favor a <a href="LogicProgramming.html">LogicProgramming</a> language, too, if it readily fits the rest of my toolset) - SQL supports a few such idioms.
      </p>
      <p>
        Anyhow, there is reason to believe you favor big 'tool' abstractions. I also like big tool abstractions, albeit specialized to the job.
      </p>
      <p>
        What would you consider to be a big 'domain' abstraction?
      </p>
      <hr/>
      <p>
        <a href="OctoberZeroNine.html">OctoberZeroNine</a>
      </p>
    </div>
  </body>
</html>