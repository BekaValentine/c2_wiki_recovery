<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Primary Noun
      </h1>
      <p>
        The <a href="PrimaryNoun.html">PrimaryNoun</a> requirement in many <a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a> languages emphasizes one noun at the expense of the others. This leads to a loss of symmetry, and forces the programmer to make arbitrary decisions about program structure. Not all <a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a> languages have the <a href="PrimaryNoun.html">PrimaryNoun</a> requirement (<a href="LispLanguage.html">LispLanguage</a> being the popular counter-example). --<a href="NonTopAnonymousDonor.html">NonTopAnonymousDonor</a>
      </p>
      <ul>
        <li>
           Some may argue that Lisp's approach is not OOP, or an extension of OOP.
        </li>
      </ul>
      <p>
        Here is an example of the lack of symmetry caused by the <a href="PrimaryNoun.html">PrimaryNoun</a> requirement, followed by several examples of how to re-write it to regain the symmetry.
      </p>
      <code>
        result=a.add(b,c,d)<br/>
      </code>
      <p>
        Procedural style.
      </p>
      <code>
        result=add(a,b,c,d)<br/>
      </code>
      <p>
        Function as the primary noun, also known as <a href="CommandPattern.html">CommandPattern</a>.
      </p>
      <code>
        result=add.invoke(a,b,c,d)<br/>
      </code>
      <p>
        Using operator overloading. Not all languages support this equally.
      </p>
      <code>
        result=a+b+c+d<br/>
      </code>
      <p>
        Procedural with binary operations.
      </p>
      <code>
        result=add(a,add(b,add(c,d)))<br/>
      </code>
      <p>
        Binary operations with objects.
      </p>
      <code>
        result=a.add(b.add(c.add(d)))<br/>
      </code>
      <p>
        Using tuples or lists. This may not be supported in any current languages.
      </p>
      <code>
        result=[a,b,c,d].add<br/>
      </code>
      <p>
        Accumulating the result with binary operations.
      </p>
      <code>
        int sum=0<br/>
        sum.add(a)<br/>
        sum.add(b)<br/>
        sum.add(c)<br/>
        sum.add(d)<br/>
      </code>
      <p>
        <strong>Different types of nouns</strong>
      </p>
      <p>
        The above example assumes that all of the nouns are of the same type. Similar problems appear when the nouns are of different types. Here is an example in which we need to keep track of employee office assignments. Note that this problem has more to do with the <em>ownership</em> of data than the above example.
      </p>
      <p>
        Typical procedural style.
      </p>
      <code>
        assign(employee,site)<br/>
      </code>
      <p>
        OOP style, with the employee as the <a href="PrimaryNoun.html">PrimaryNoun</a>.
      </p>
      <code>
        employee.assign(site)<br/>
      </code>
      <p>
        OOP style, with the site as the <a href="PrimaryNoun.html">PrimaryNoun</a>.
      </p>
      <code>
        site.assign(employee)<br/>
      </code>
      <p>
        The dilemma is which object <em>owns</em> the assignment data. There is usually some hint in the problem domain as to where the responsibility lies best. If not guided either way by the problem domain, a smart developer might introduce or find a third class to hold the responsibility - exactly to avoid an artificial choice of one or the other. This is the typical result with <a href="ResponsibilityDrivenDesign.html">ResponsibilityDrivenDesign</a>. For a counter-argument, see <a href="ResponsibilityDrivenDesignConflictsWithYagni.html">ResponsibilityDrivenDesignConflictsWithYagni</a>.
      </p>
      <code>
        assignments.create(employee,site)<br/>
      </code>
      <p>
        <em>A many-to-many class, eh?</em>
      </p>
      <hr/>
      <p>
        (Counter-point moved from <a href="ArgumentsAgainstOop.html">ArgumentsAgainstOop</a>)
      </p>
      <p>
        Re: 
      </p>
      <p>
        (quote)
      </p>
      <p>
        King Noun is Artificial - OO generally assumes there is one <a href="PrimaryNoun.html">PrimaryNoun</a> per action or operation. This assumption is often artificial. There is no such identifiable force of nature or human interaction. The nouns that participate in any given action are often numerous and changing. It is sometimes said that one should group code by the most stable factors. "Task" or "operation" is more stable than nouns or entities for the most part. One should be able to swap/change the noun(s) without changing the calling code. This is <a href="InformationHiding.html">InformationHiding</a>. In the real world, the relationship between nouns and actions is often many-to-many, and OO has generally been problematic with many-to-many relationships. <a href="ManyToManyChallenge.html">ManyToManyChallenge</a>.
      </p>
      <p>
        (end-quote) 
      </p>
      <p>
        This is commonly solved by use of a class-per-task pattern, as with <a href="FunctorObject.html">FunctorObject</a> and <a href="StrategyPattern.html">StrategyPattern</a>. <a href="MultipleDispatch.html">MultipleDispatch</a> is a language-level solution.
      </p>
      <p>
        <em>"Solved" by emulating non-OO is hardly "solved", and with the design overhead and complexity of the class/method system.</em>
      </p>
      <p>
        Reifying <em>tasks</em> is a fine example of OO. It isn't <em>emulating non-OO</em>. This particular case is closer to <em>if OO ain't working, you aren't using enough of it</em>. 
      </p>
      <p>
        <em>I'd like to study a realistic scenario. </em><a href="StrategyPattern.html">StrategyPattern</a> is not flexible to certain kinds of <a href="ChangePattern.html">ChangePattern</a>s.<em></em>
      </p>
      <hr/>
      <p>
        See:
      </p>
      <ul>
        <li>
           Use in Web Design
          <ul>
            <li>
               <em>Primary nouns are the “things” users can take action on or manipulate. Generally, one – three “things” will be used to complete a task. If primary nouns are clear, they help the user to conceptualize the interface or know what they can take action on. They also connect the tasks with the navigational model used on the web site.</em> 
              <ul>
                <li>
                   <a href="http://www.w-edge.com/navigation.htm">http://www.w-edge.com/navigation.htm</a>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           This almost reminds me of the newspaper reporting "5 W's" mantra of covering Who, What, When, Where, and Why.
        </li>
      </ul>
      <hr/>
      <p>
        <a href="EditHint.html">EditHint</a>: Refactor the <a href="ResponsibilityDrivenDesignConflictsWithYagni.html">ResponsibilityDrivenDesignConflictsWithYagni</a> <a href="ThreadMess.html">ThreadMess</a> and merge where appropriate.
      </p>
    </div>
  </body>
</html>