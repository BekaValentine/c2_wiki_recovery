<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        File Polling Concurrency
      </h1>
      <p>
        If a language does not support built-in concurrency, or if you are trying to tie two different languages together, one approach is "file polling". This is where files are used to communicate between each process/language. It is not meant for high-performance tasks, such as games, but can serve well for occasional needs.
      </p>
      <p>
        Some useful tips:
      </p>
      <ul>
        <li>
           Write to a temporary file (one not being sought), and then rename it to the target name when it is complete. This prevents the reading of half-complete files.
        </li>
      </ul>
      <ul>
        <li>
           Usually have the reader delete a "consumed" message file, not the writer.
        </li>
      </ul>
      <ul>
        <li>
           Use a "sleep" or "wait" function in the middle of any wait loop. Try to avoid "wait" functions that hog CPU. Some OS's have system functions that tell the OS you are giving it permission to execute pending stuff from other apps, which is what you want if you are waiting.
          <ul>
            <li>
               Or, if your system is slow enough, use cron on UNIX-like systems, and don't implement any loop.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           Don't wait forever. Have a max wait-loop threshold such that an error message or "retry" prompt appears. 
        </li>
      </ul>
      <ul>
        <li>
           After doing it a few times and you get a feel, you can start to create utility functions/methods to do it for you.
        </li>
      </ul>
      <p>
        -- top
      </p>
      <p>
        This must be one SynchronizationPattern which surely has been implemented thousands of times in the industry.
      </p>
      <p>
        Advantages:
      </p>
      <ul>
        <li>
           Simple to understand
        </li>
        <li>
           Simple to implement
        </li>
        <li>
           Simple maintain
        </li>
      </ul>
      <p>
        Disadvantages:
      </p>
      <ul>
        <li>
           Slow
        </li>
        <li>
           Works only well on large chunks of data
        </li>
        <li>
           May depend on file system semantics
        </li>
        <li>
           Very difficult to aggregate into larger processes
        </li>
      </ul>
      <hr/>
      <p>
        See also: <a href="TableOrientedSynchronization.html">TableOrientedSynchronization</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryConcurrency.html">CategoryConcurrency</a>
      </p>
    </div>
  </body>
</html>