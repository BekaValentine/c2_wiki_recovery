<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Wirth Languages
      </h1>
      <p>
        Languages developed by <a href="NiklausWirth.html">NiklausWirth</a>, an internationally famous specialist in programming-language design and implementation, most closely associated with ETH Zurich in Switzerland
        .
      </p>
      <hr/>
      <p>
        One commentator suggested, in a manner that suggested sarcasm, that the list be broadened: "Or: languages that look as if they were developed by <a href="NiklausWirth.html">NiklausWirth</a>". However, all of the languages listed were indeed developed by Wirth.
      </p>
      <hr/>
      <p>
        Wirth's language designs:
      </p>
      <ul>
        <li>
           Euler: Developed 1962-65 as part of his dissertation work. Intended as a generalization of the <a href="AlgolLanguage.html">AlgolLanguage</a> with the addition of dynamic lists and symbols (a la <a href="LispLanguage.html">LispLanguage</a>). Probably the first use of a PrecedenceGrammar.
        </li>
        <li>
           PL360: (1965) A programming language for the IBM System/360 (<a href="IbmSystemThreeSixty.html">IbmSystemThreeSixty</a>). PL360 really was a high-level assembler for the 360 architecture. Subroutine linkage and control structures were provided by the Algol-like parts of the language, while the instructions that actually did anything were in assembler format. It might be well argued that PL360 was the predecessor of IBM's PL/S (<a href="PlsLanguage.html">PlsLanguage</a>). See Niklaus Wirth: "PL360, a Programming Language for the 360 Computers". <em>JACM</em> 15(1): 37-74 (1968) [<a href="http://portal.acm.org/citation.cfm?id=321442&dl=ACM&coll=portal].">http://portal.acm.org/citation.cfm?id=321442&dl=ACM&coll=portal].</a> 
        </li>
        <li>
           Algol-W: Proposed as an alternative to Algol 68, a language designed as an successor to Algol-60, but resembled already Pascal. Joint work with <a href="CarHoare.html">CarHoare</a>. First language to support passing parameters by value-result. First language to support case ("switch") statement (invented by <a href="CarHoare.html">CarHoare</a>).
        </li>
        <li>
           Pascal (<a href="PascalLanguage.html">PascalLanguage</a>): (1968-) Among programming-language specialists, or computer-science students of the 1980s, "no introduction is needed", but it is worth noting that Pascal was intended for systems programming and not just for education.
          <ul>
            <li>
               And it was, somehow, used for systems programming here and there, but it is worth pointing out that, on platforms where C was also available, Pascal was <strong>not</strong> used for systems programming. Pascal forced a great deal more use of assembly language to get around language restrictions.
            </li>
          </ul>
        </li>
        <li>
           Modula (<a href="ModulaOne.html">ModulaOne</a>, <a href="ModulaTwo.html">ModulaTwo</a>, <a href="ModulaThree.html">ModulaThree</a>): Introduced language-level support for concurrency, multi-programming, modular programming. Modula-2 included encapsulation of machine primitive operations. <a href="ModulaThree.html">ModulaThree</a> was not designed by Wirth, though he did give it his approval. Technically it's not one of the <a href="WirthLanguages.html">WirthLanguages</a>.
        </li>
        <li>
           Oberon (<a href="OberonLanguage.html">OberonLanguage</a>): Oberon left off some parts of Modula-2 and introduced the concept of record type-extensions, used to implement objects.  Statically dispatched "methods" were invoked using normal procedure syntax (e.g., <strong>M.P(o, ...);</strong>).  Oberon-2 added type bound procedures, which are dynamically dispatched methods using a <a href="VeeTable.html">VeeTable</a> structure (e.g., <strong>o.P(...);</strong>).  Type-bound procedures <em>always</em> were dynamically dispatched; thus, one used normal M.P calling convention for statically resolved methods.  Oberon also introduced garbage collection to the world of statically-compiled, imperative programming languages, influencing languages and environments such as Java, .NET, and <a href="DeeLanguage.html">DeeLanguage</a>.
        </li>
      </ul>
      <hr/>
      <p>
        More information is available at <a href="http://www.inf.ethz.ch/~wirth/projects.html.">http://www.inf.ethz.ch/~wirth/projects.html.</a>
      </p>
      <hr/>
      <p>
        <em>Is PL360 different from PL/1?</em>
      </p>
      <p>
        A respondent answered the question of PL360 vs. PL/I with a simple "<em>Yes</em>". Actually, the question deserves an energetic "<strong>Hell, yes!</strong>" in reply. PL360 is a very simple and straightforward language, consistent with its very modest goals. PL/I is a notoriously complicated language, whose best rivals for complexity may be Ada, Algol 68, or C++.
      </p>
      <hr/>
      <p>
        Wirth also consulted during the development of the CedarLanguage at <a href="XeroxParc.html">XeroxParc</a> (which was the basis for the Oberon system), and <a href="ModulaTwo.html">ModulaTwo</a> + and <a href="ModulaThree.html">ModulaThree</a> at Digital.
        <em>And, I am told, on Apple's </em><a href="ObjectPascal.html">ObjectPascal</a>, first on the Lisa and later for the Mac.<em></em>
      </p>
      <hr/>
      <p>
        I was told by someone who attended Wirth classes in Switzerland that Wirth complained about modern languages like <a href="CeePlusPlus.html">CeePlusPlus</a> and <a href="JavaLanguage.html">JavaLanguage</a>, because those languages <strong>didn't get it</strong>. He said that <a href="NiklausWirth.html">NiklausWirth</a> made funny remarks about modern languages and that students laughed, but not at his jokes, but at him, because how could all those modern languages be all wrong? I think there is still something we didn't get about Wirth ideas an specially about <a href="PascalLanguage.html">PascalLanguage</a>. Only in <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> you get the same feeling that the program doesn't take too long to compile. In Java the time it takes is not so bad, but in Pascal it was even better. About C++, I can say that I agree wholeheartedly because it is not <a href="ObjectOriented.html">ObjectOriented</a>, and it is easier to produce buggy code than correct code. I have the feeling that in Pascal I never got so much buggy code as in C++. Even Smalltalk is much better at producing less buggy code. -- OneUnhappyCppLanguageProgrammer
      </p>
      <hr/>
      <p>
        Maybe <strong>your</strong> Pascal code was relatively bug free, but everyone else in the world sure cranked out buggy Pascal. Also I notice one strong similarity between Pascal and C++: in both cases, a lot of programming consists of fighting the language, rather than on focusing on the algorithm.
      </p>
      <hr/>
      <p>
        <em>C++ and Java don't get "what", exactly? Comparing Smalltalk with Pascal is interesting - if not humorous - given that the two languages are opposites of each other in so many ways. </em><a href="StaticTyping.html">StaticTyping</a> vs <a href="DynamicTyping.html">DynamicTyping</a>. <a href="BondageAndDiscipline.html">BondageAndDiscipline</a> vs limitless flexibility. Block-structured procedural with full <a href="LexicalScoping.html">LexicalScoping</a> vs OO without (other than SmalltalkBlocks). A traditional <a href="EditCompileLinkRun.html">EditCompileLinkRun</a> language vs an <a href="ImageBasedLanguage.html">ImageBasedLanguage</a>.<em></em>
      </p>
      <p>
        On the other hand, pascal and smalltalk both have small grammars that are easily implemented with recursive descent parsers. Both designs sought to capturing the essense of computation so that it could be more easily experienced by others. Interestingly, pascal allowed one to program in the context of a (possibly dynamic) structure using the "with" statement and thus anticipated object-oriented programming. -- <a href="WardCunningham.html">WardCunningham</a>
      </p>
      <hr/>
      <p>
        <em>C++ not </em><a href="ObjectOriented.html">ObjectOriented</a>? While it certainly isn't a pure OO language; it does support the OO paradigm. See <a href="DefinitionsForOo.html">DefinitionsForOo</a> and <a href="IsCeePlusPlusObjectOriented.html">IsCeePlusPlusObjectOriented</a> for this particular <a href="HolyWar.html">HolyWar</a>. -- <a href="ScottJohnson.html">ScottJohnson</a><em></em>
      </p>
      <hr/>
      <p>
        <a href="CategoryProgrammingLanguage.html">CategoryProgrammingLanguage</a> <a href="CategoryAlgol.html">CategoryAlgol</a> <a href="CategoryPascal.html">CategoryPascal</a>
      </p>
      <hr/>
      <p>
        Note that "<a href="BondageAndDiscipline.html">BondageAndDiscipline</a>" is an exonym by non Wirthian programmers (and many that lack even proper experience to judge it). The same with the remark about Pascal not being used as system language C systems.  At least in Europe Pascal had supplanted Algol as system language long before C escaped its Unix beginnings. Yes, C took over, but that is something else as never being used as such.
      </p>
      <hr/>
      <p>
        Contrast with "wirthless languages" ;-)
      </p>
    </div>
  </body>
</html>