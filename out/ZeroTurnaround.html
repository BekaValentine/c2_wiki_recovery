<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Zero Turnaround
      </h1>
      <p>
        You know you have <a href="ZeroTurnaround.html">ZeroTurnaround</a> when you are able to make any change to your application and, the nanosecond you save your changes, you can see their effect in your running application.
      </p>
      <hr/>
      <p>
        This is one of the reasons those PHP or Ruby developers say that they are much more productive than Java developers; anyone that has had to wait 30 seconds to see an extremely simple change in the code (like from if(var=="value") to if(var.equals("value)) be redeployed in <a href="JbossApplicationServer.html">JbossApplicationServer</a> knows that not having <a href="ZeroTurnaround.html">ZeroTurnaround</a> redeployment can be a big time-waster, specially during development, but also in production, specially if keeping downtime to the minimum is a priority.
      </p>
      <p>
        One company (with this name precisely) offers a product named <a href="JavaRebel.html">JavaRebel</a> that gives Java <a href="ZeroTurnaround.html">ZeroTurnaround</a> capabilities, another option is using <a href="OpenServicesGatewayInitiative.html">OpenServicesGatewayInitiative</a> Framework (<a href="OsGi.html">OsGi</a> Framework), what I find dissapointing is that Sun decided to embrace <a href="OsGi.html">OsGi</a> (now named <a href="DynamicComponentSupportForJava.html">DynamicComponentSupportForJava</a>) a complex technology that will require modification of the way .jars is packaged now, instead of plain just buying <a href="JavaRebel.html">JavaRebel</a> and making it <a href="OpenSource.html">OpenSource</a> (or creating its own version of <a href="JavaRebel.html">JavaRebel</a>, after all if Sun invented Java, why they didn't come up wit this idea themselves? Would it really be that hard for them to create something similar?).
        -- <a href="AnonymousDonor.html">AnonymousDonor</a>
      </p>
      <p>
        I think you have that backwards:
      </p>
      <ul>
        <li>
           Sun <strong>wants</strong> to split the Java runtime into separate modules (jars) so that partial and incremental deployment are possible, and JSR 277, The JavaModuleSystem enables them to do this.
          <ul>
            <li>
              <em>True</em>
            </li>
          </ul>
        </li>
        <li>
           The other big need for <a href="OsGi.html">OsGi</a> / JavaModuleSystem (JSR 277) functionality is to fix the <a href="ClasspathHell.html">ClasspathHell</a> problem:  My application uses libraries "B" and "C", both of which use library "D", but "B" and "C" require different versions of "D".  There's no version of "D" I can put on the CLASSPATH that will satisfy both "B" and "C".  Thus, I'm in "<a href="ClasspathHell.html">ClasspathHell</a>."
          <ul>
            <li>
              <em>True Too</em>
            </li>
          </ul>
        </li>
        <li>
           <em>But  you are forgetting the </em>'third goal<strong> , dynamically loading and unloading modules (a requirement for </strong><a href="ZeroTurnaround.html">ZeroTurnaround</a>) (as it is supported in the latest <a href="OsGi.html">OsGi</a> enabled application servers also such as <a href="JonAs.html">JonAs</a> or Sun owned <a href="GlassFish.html">GlassFish</a> ) Or as it is possible thanks to <a href="SpringFramework.html">SpringFramework</a> in their new <a href="SpringSourcedmServer.html">SpringSourcedmServer</a>, or as it is theoretically possible in Eclipse (although not as stable as it should because Eclipse was not built with <a href="OsGi.html">OsGi</a> support from the start (and even then we would need a <a href="MultitaskingVirtualMachine.html">MultitaskingVirtualMachine</a> to actually make it module crash proof) )<em></em>
        </li>
      </ul>
      <p>
        -- <a href="JeffGrigg.html">JeffGrigg</a> & <em></em><a href="AnonymousDonor.html">AnonymousDonor</a>Two<em>, intermixed</em>
      </p>
      <hr/>
      <p>
        I can see this leading to a "just hack it" mindset, since the time to see a change is so small, the developer starts to make changes instead of thinking about the correctness of said change.
        -- <a href="AnonymousDonor.html">AnonymousDonor</a>One
      </p>
      <p>
        <em>Yes, it does, but I think that developers should avoid the "just hack it" mindset because of some kind of objective proof that it is actually better that the "design it carefully first", and not because the platform leaves them with no choice at all (See </em><a href="BondageAndDisciplineLanguage.html">BondageAndDisciplineLanguage</a>) -- <a href="AnonymousDonor.html">AnonymousDonor</a>Two<em></em>
      </p>
      <p>
        Consider also unit testing and refactoring as well.
        -- <a href="AnonymousDonor.html">AnonymousDonor</a>Three
      </p>
      <p>
        <em>Please elaborate...</em>
        -- <a href="AnonymousDonor.html">AnonymousDonor</a>Two
      </p>
      <p>
        Well, according to XP methodology practices, you are free to "spike" out a solution to a problem -- this is equivalent to hacking/cobbling something together.
      </p>
      <p>
        Once things are working, however, you're now in a position to better understand the solution; either you can write your tests to back your hack (only do this if you know your finished solution matches the hacky solution, though), OR, you can rip your hack out, write your tests and follow proper TDD practices.  In either case, refactoring (if at all possible) is encouraged.
      </p>
      <p>
        You're using the hackability of the system to your advantage, instead of discarding it as a relic of bad behavior.
        -- <a href="AnonymousDonor.html">AnonymousDonor</a>Three
      </p>
      <p>
        <em>So... are we having some sort of  </em><a href="ViolentAgreement.html">ViolentAgreement</a>? (We both think <a href="ZeroTurnaround.html">ZeroTurnaround</a> is and advantage even if it can be abused by incompetent people)<em> -- </em><a href="AnonymousDonor.html">AnonymousDonor</a>Two
      </p>
      <p>
        I don't know; that depends on whether or not you are the same person as <a href="AnonymousDonor.html">AnonymousDonor</a>One, whose response I took in a decidedly <em>negative</em> context, not positive.  All I'm saying that you don't need to discard thinking in terms of correctness when you make so-called "quick hacks."  Hopefully I'm not being to violent in thinking this.  :)  -- <a href="AnonymousDonor.html">AnonymousDonor</a>Three
      </p>
      <p>
        <em>I am not the same person as </em><a href="AnonymousDonor.html">AnonymousDonor</a>One I am <a href="AnonymousDonor.html">AnonymousDonor</a>Two the one that loves <a href="ZeroTurnaround.html">ZeroTurnaround</a> and apparently PeacefulyAgreesWithYou ;-)<em></em>
      </p>
      <hr/>
      <p>
        I find that when doing <a href="TestDrivenDevelopment.html">TestDrivenDevelopment</a> (TDD) in <a href="ExtremeProgramming.html">ExtremeProgramming</a> (XP), quite independently of doing <a href="SpikeSolution.html">SpikeSolution</a> or not, quicker turnaround is always a good thing.
        The excessively long turnaround of JAR-ing and deploying code into a JEE application server, to be tested remotely makes <a href="TestDrivenDevelopment.html">TestDrivenDevelopment</a> <strong>much</strong> more difficult -- even to the point of discouraging the use of <a href="TestDrivenDevelopment.html">TestDrivenDevelopment</a>.
      </p>
      <p>
        The most common and successful approach I've seen is to decouple the application code from such heavy dependencies on the server framework, so that the application code can be tested "outside of the container."
        Then startup and class loading issues largely disappear.
      </p>
      <p>
        We should also remember that <a href="ExtremeProgramming.html">ExtremeProgramming</a>'s <a href="TestDrivenDevelopment.html">TestDrivenDevelopment</a> style was developed in the <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> development environment, which has always <strong>very</strong> dynamic:
        When a test calls a method that does not exist, the smalltalk debugger stops execution right there.
        Then you can add the missing method to the production code, pop the stack a few frames, and resume execution.
        So don't think that rapid turnaround necessarily implies hacking!
        -- <a href="JeffGrigg.html">JeffGrigg</a>
      </p>
      <hr/>
      <p>
        See <a href="XmlForZeroTurnaround.html">XmlForZeroTurnaround</a>
      </p>
      <hr/>
      <p>
        <a href="FebruaryZeroNine.html">FebruaryZeroNine</a>
      </p>
    </div>
  </body>
</html>