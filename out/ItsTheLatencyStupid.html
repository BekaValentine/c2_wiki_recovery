<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Its The Latency Stupid
      </h1>
      <p>
        "It's the Latency, Stupid" by StuartCheshire, May 1996. 
        <a href="http://www.stuartcheshire.org/rants/Latency.html.">http://www.stuartcheshire.org/rants/Latency.html.</a>
      </p>
      <p>
        A paper which argues that latency, rather than bandwidth, is the most important parameter for networking performance. (Of course, bandwidth is important too.)
      </p>
      <p>
        <em>The stated topic seemed irritatingly obvious, until I clicked through and saw this:</em>
      </p>
      <dl>
        <dt> </dt>
        <dd><em>Years ago David Cheriton at Stanford taught me something that seemed very obvious at the time...It's now many years later, and this obvious fact seems lost on the most companies making networking hardware and software for the home. I think it's time it was explained again in writing."</em></dd>
      </dl>
      <p>
        <em>Ah, that's different.</em>
      </p>
      <ul>
        <li>
           One interesting observation, hinted at in the paper but not stated explicitly (and perhaps a bit moot in these days of cheap broadband to the home):  Modem manufacturers, by virtue of the increasingly complex (and <a href="DigitalSignalProcessing.html">DigitalSignalProcessing</a>-intensive) modulation and compression schemes, have been actively trading away latency for bandwidth.  It doesn't take 100ms of latency to convert a bit into an audio tone; it does when you have a nest of adaptive filters trying to compensate for the characteristics of the phone line in order to get as much usable bandwidth as possible.
        </li>
      </ul>
      <hr/>
      <p>
        You know, reading Stuart's paper, I couldn't help noticing that there are parallels in software.  The most dramatic instance that comes to mind is database usage.
      </p>
      <p>
        I've written serious EnterpriseScale software using a database language & engine that has a lower theoretical <em>capacity</em> than <a href="BigIron.html">BigIron</a> engines, but achieved results that were more usable at the desktop -- because I was able to reduce the latency to nearly nothing (from the user's perspective).
      </p>
      <p>
        They don't want to "ClickAndWait" they want to see something right now.  The majority of the queries done from the desktop were single or double record requests, with spikes of a few dozen, but in general the user was not interested in browsing 10,000 records at once.  Yes, I still had to do magic to do summary reports in a timely fashion, but the majority of the people using the system had a "wow, that's fast" experience most of the time.
      </p>
      <p>
        -- <a href="GarryHamilton.html">GarryHamilton</a>
      </p>
      <p>
        Not to mention the parallels in pr0n. What good is it to wait a while to see if the first few frames of a video are of somebody hot enough to continue watching? Much better to see them asap. . .
      </p>
      <p>
        <em>120x120 pixel thumbnails.</em>
      </p>
      <hr/>
      <p>
        See also: <a href="RemoteGuiProtocols.html">RemoteGuiProtocols</a>, <a href="PromisePipelining.html">PromisePipelining</a>.
      </p>
      <hr/>
      <p>
        <a href="CategoryPaper.html">CategoryPaper</a>
      </p>
    </div>
  </body>
</html>