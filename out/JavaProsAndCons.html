<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Java Pros And Cons
      </h1>
      <p>
        Seems to overlap with <a href="JavaDiscussion.html">JavaDiscussion</a>.
      </p>
      <hr/>
      <p>
        <strong>Pros</strong>
      </p>
      <ul>
        <li>
           Does not slow your computer speed
          <ul>
            <li>
               <em>Huh?</em>
            </li>
          </ul>
        </li>
        <li>
           Free
        </li>
        <li>
           The syntax is familiar to the myriad programmers that know any other C based language.
        </li>
        <li>
           Java (the platform) has a very large and standard class library, some parts of which are very well written.
        </li>
        <li>
           Java provides a platform for behavioral transfer from one address space to another. This is particularly evident in the dynamic class loading mechanisms of RMI (Remote Method Invocation).
        </li>
        <li>
           Automatic Memory Management implemented by <a href="GarbageCollection.html">GarbageCollection</a> and <a href="NoExplicitPointers.html">NoExplicitPointers</a>
        </li>
        <li>
           <a href="NoExplicitPointers.html">NoExplicitPointers</a>
        </li>
        <li>
           Explicit Interfaces
        </li>
        <li>
           Improving performance (especially under <a href="HotSpot.html">HotSpot</a> and IbmJava)
        </li>
        <li>
           Good portability (certainly better than that of nearly any compiled alternative)
        </li>
        <li>
           Simplified syntax (compared to C++)
        </li>
        <li>
           Language design not committee driven
        </li>
        <li>
           Comprehensive documentation
        </li>
        <li>
           Lots of available code and third-party libraries
        </li>
        <li>
           Lots of different choices between <a href="JavaIde.html">JavaIde</a>s which don't tie you into a specific Java implementation.
        </li>
        <li>
           If you love OOP, the only way to write functions is to make them class methods.
        </li>
        <li>
           No <a href="FragileBinaryInterfaceProblem.html">FragileBinaryInterfaceProblem</a>.
        </li>
        <li>
           Many standard interfaces defined in the standard library, which would have been vendor/OS specifc otherwise, helps a lot in achieving portability and ease integration/selection of 3rd party libraries.  E.g. JDBC, JMS, JCE, JAI, serial I/O, JAXP, JNDI, etc.  Some have correspondance in other languages (e.g. ODBC) but not all.
        </li>
      </ul>
      <hr/>
      <p>
        <strong>Cons</strong>
      </p>
      <ul>
        <li>
           Much of the Java code as written by experienced coders turns out to be boilerplate. This has led to the charge that Java code is object-oriented Cobol.
        </li>
        <li>
           If you dislike OOP or used mixed paradigms, the only way to write functions is to make them class methods.
        </li>
        <li>
           Some people think the class libraries are poorly written.
        </li>
        <li>
           As with all languages, getting used to the syntax conventions takes a while for those who come from other backgrounds.
        </li>
        <li>
           Some people think that <a href="CheckedExceptionsAreOfDubiousValue.html">CheckedExceptionsAreOfDubiousValue</a>
        </li>
        <li>
           Some people wish for keyword or default arguments to functions
        </li>
        <li>
           Some people miss closures (see <a href="SmalltalkMinusMinus.html">SmalltalkMinusMinus</a>, although <a href="BlocksInJava.html">BlocksInJava</a> is a good (?) fallback)
        </li>
        <li>
           Some people want destructors that are guaranteed to be called. (See <a href="FinalizeInsteadOfProperDestructor.html">FinalizeInsteadOfProperDestructor</a>)
        </li>
        <li>
           Poor garbage collection in some implementations/applications.
        </li>
        <li>
           Lack of garbage collection on resources other than memory (see <a href="FinalizeInsteadOfProperDestructor.html">FinalizeInsteadOfProperDestructor</a>)
        </li>
        <li>
           Type system forces programmers to hard-code knowledge of types in multiple places throughout the code -- see Conrad Weisert's article on the topic in <a href="http://www.idinews.com/casts.html">http://www.idinews.com/casts.html</a>
        </li>
        <li>
           Large memory footprint
        </li>
        <li>
           Requires an interpreter. It is still difficult to deliver a self-contained application  [If you feel that this has changed, please give us convincing information on "<a href="StandaloneJavaApplications.html">StandaloneJavaApplications</a>" so we can delete this point.]
        </li>
        <li>
           If you aren't careful, you can write slow programs. Of course, you can do this in any language.
        </li>
        <li>
           Bugs in library implementations (especially Swing)
        </li>
        <li>
           Bugs in JVM implementations (all JVMs are not created equal). This isn't Java's fault, but it has been known to limit Java's usefulness.
        </li>
        <li>
           Proprietary language (i.e., not committee driven). There have only been a few events that could be construed as Sun [now Oracle] abusing this power, and the <a href="JavaCommunityProcess.html">JavaCommunityProcess</a> (<a href="http://jcp.org)">http://jcp.org)</a> helps a lot. The main reason why people dislike this is because of what it "could" lead to.
        </li>
        <li>
           Primitive types don't inherit from Object. This is a decision the language designers made on purpose, and never causes problems that can't be worked around. Still, it robs the less intelligent of us of that cosy feeling of consistency. <em>And it frequently necessitates special-case code. See java.util.Arrays for example.</em>
        </li>
        <li>
           No generic programming means no <a href="StronglyTypedCollection.html">StronglyTypedCollection</a>s unless you write 'em yourself one at a time.
        </li>
        <li>
           Immutable types are a damn poor substitute for restricted references.
        </li>
        <li>
           Difficult to blur distinction between class and object when desired, which increases the need/want for HOF's.
        </li>
      </ul>
      <hr/>
      <p>
        <em>Some of the above is moved from </em><a href="JavaIsDead.html">JavaIsDead</a><em></em>
      </p>
      <p>
        A couple points:
      </p>
      <ul>
        <li>
           IBM is putting a <em>lot</em> of work into Java. The IbmJava JVM implementations are impressive and improving steadily.
        </li>
        <li>
           Much of Java's performance problems can be traced to the unfortunate use of <a href="DoubleBufferedGraphicsInJava.html">DoubleBufferedGraphicsInJava</a>.
        </li>
      </ul>
      <hr/>
      <p>
        Please try to keep discussion of these bullets on pages centered on the bullet point, not on this page.
        Post flames in <a href="JavaIsaDeadEnd.html">JavaIsaDeadEnd</a> and <a href="JavaIsDead.html">JavaIsDead</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryJava.html">CategoryJava</a>
      </p>
    </div>
  </body>
</html>