<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Affine Transformation
      </h1>
      <p>
        Non-technically, Affine Transformations are translations, dilations/expansions/contractions, rotations, reflections, shears and combinations thereof. (Note that this list is hyper-complete - some of the items can be created by composing some of the others. For example, translations and rotations can always be obtained by a pair of reflections.)
      </p>
      <p>
        This works in any Euclidean space, but most people only work in <strong>2D</strong>, and a few in <strong>3D</strong>. There are people who actually do real work (for which read commercially applicable) in <strong>9D</strong> spaces.
      </p>
      <p>
        In <strong>2D</strong> all possible affine transformations are given by the simple equation
      </p>
      <code>
        xnew = a*x + c*y + e<br/>
        ynew = b*x + d*y + f<br/>
      </code>
      <hr/>
      <p>
        Slightly more specifically, the building blocks of <a href="AffineTransformation.html">AffineTransformation</a>s are:
      </p>
      <ul>
        <li>
           translation (sliding every point left, right, up, down, in out, <em>etc.,</em>' by the same amount)
        </li>
        <li>
           rotation (rotating every point around some given fixed point by the same angle)
        </li>
        <li>
           linear stretching (e.g., multiplying the <strong><em>x</em></strong> coordinate of every point by some constant <strong><em>k</em></strong> while leaving the <strong><em>y</em></strong> coordinate alone)
        </li>
        <li>
           shearing (e.g., leaving the <strong><em>y</em></strong> coordinate alone while adding to the <strong><em>x</em></strong> coordinate some constant <strong><em>s</em></strong> times the <strong><em>y</em></strong> coordinate)
        </li>
      </ul>
      <p>
        An affine transformation of an ellipse always produces an ellipse (allowing that a circle is, in geometry, a specific example of an ellipse)
      </p>
      <p>
        More technically, given <em>any</em> space <strong>S</strong> with concepts of colinearity and distance, an <a href="AffineTransformation.html">AffineTransformation</a> is a mapping from <strong>S</strong> to <strong>S</strong> preserving colinearity of points and ratios of distances. It can be shown that parallel lines are preserved, but angles and areas/volumes are not preserved.
      </p>
      <p>
        By comparison, a <a href="LinearTransformation.html">LinearTransformation</a> is an special kind of <a href="AffineTransformation.html">AffineTransformation</a>, one that leaves the origin fixed. Translations are therefore not Linear Transformations.
      </p>
      <p>
        As an observation, the fact that translations and rotations can each be obtained as a pair of reflections leads to the idea that a translation can be thought of as a special case of a rotation. This works if you do something technical (compact the space) and think of a translation as a rotation around a point at infinity. Basically, a very big circle locally looks like a line, and as the circle gets bigger so the approximation gets better. With care you can talk about a circle whose centre is at infinity, and that's the same as a line. The detail needs considerable attention to avoid paradoxes and inconsistencies.
      </p>
      <hr/>
      <p>
        As an example of why it's useful, interesting and potentially important ...
      </p>
      <p>
        The <a href="HolyGrail.html">HolyGrail</a> of ImageRecognition systems is "<a href="AffineTransformation.html">AffineTransformation</a>-independence", so a shape rates the same regardless of how you rotate it, or twist the camera's view of it.
      </p>
      <p>
        In particular, if you look straight down at some object on a table (with a camera), any number of steps of turning the object clockwise or counterclockwise and pushing the object elsewhere on the table can be represented by a single <a href="AffineTransformation.html">AffineTransformation</a> from the start position to the end position.
      </p>
      <p>
        If the current image from that camera is (sufficiently close to) an <a href="AffineTransformation.html">AffineTransformation</a> of the original training image of a screwdriver, we can be sure there is now a screwdriver on the table. If the current image is not anywhere close to an <a href="AffineTransformation.html">AffineTransformation</a> of a screwdriver, then whatever is on the table is not a screwdriver.
      </p>
      <p>
        In fact, changing the camera's view does not generally give an affine transformation because ratios of distances within a line get changed, but while that's literally true, within certain limits it's close enough.
      </p>
      <hr/>
      <p>
        An <a href="AffineTransformation.html">AffineTransformation</a> in <strong>2D</strong> transforms one <strong>2D</strong> picture into another <strong>2D</strong> picture. Any combination of any number of rotation, linear stretching, shearing, and translation steps results in a single <a href="AffineTransformation.html">AffineTransformation</a> that can be represented by 6 numbers. Some kinds of transformations are not <a href="AffineTransformation.html">AffineTransformation</a>s, and so cannot be generated no matter how many translations, rotations, shears, or linear stretches are combined.
      </p>
      <p>
        If you pick any 3 points in the original image (as long as they are not all on the same line) and specify 3 corresponding points in the final image, you can find the appropriate <a href="AffineTransformation.html">AffineTransformation</a> and therefore find out where any point in the original image falls onto the final image. (In other words, draw a rectangle around the original image, and pick the top-left, bottom-left, and bottom-right points. Find the corresponding 3 points in the final image. Extrapolate the position of the top-right point to make a parallelogram - often not a rectangle - and then you can draw a grid to interpolate every other point).
      </p>
      <hr/>
      <p>
        See also <a href="LinearAlgebra.html">LinearAlgebra</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryMath.html">CategoryMath</a>
      </p>
    </div>
  </body>
</html>