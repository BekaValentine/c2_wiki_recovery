<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Implicit Typing
      </h1>
      <p>
        <a href="ImplicitTyping.html">ImplicitTyping</a> is a term proposed on this Wiki for any language typing system which requires few or no type annotations (type declarations of variables, object members, function arguments, etc.) -- as opposed to <a href="ManifestTyping.html">ManifestTyping</a>, in which type information must be provided by the programmer.
      </p>
      <p>
        This comes in three flavours:
      </p>
      <ul>
        <li>
           <a href="DynamicTyping.html">DynamicTyping</a>.  There are no explicit type annotations.  Usually, typechecking occurs at runtime, causing an exception on type failures.  Examples of such languages include <a href="LispLanguage.html">LispLanguage</a>, <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>, <a href="PythonLanguage.html">PythonLanguage</a>, <a href="RubyLanguage.html">RubyLanguage</a>, and <a href="PhpLanguage.html">PhpLanguage</a>.
        </li>
      </ul>
      <ul>
        <li>
           Static <a href="TypeInference.html">TypeInference</a>.  Type annotations are optional.  Typechecking occurs at <a href="CompileTime.html">CompileTime</a>, and/or before the program is executed.  Type failures cannot occur at runtime.  Found in many functional languages, such as <a href="HaskellLanguage.html">HaskellLanguage</a>, <a href="MlLanguage.html">MlLanguage</a>, <a href="ObjectiveCaml.html">ObjectiveCaml</a>.
        </li>
      </ul>
      <ul>
        <li>
           <a href="SoftTyping.html">SoftTyping</a>.  Type annotations are optional.  Some types are inferred before the program is executed, but dynamic checks are inserted for any use of a value that cannot be statically inferred to be safe.  Feedback is given to the programmer about which code is statically safe and which is not.  Implemented in only a few languages: <a href="DrScheme.html">DrScheme</a>, <a href="EeLanguage.html">EeLanguage</a>.
        </li>
      </ul>
      <p>
        In addition, a language is <a href="StronglyTyped.html">StronglyTyped</a> if it is <em>either</em> impossible for a type failure to occur at <a href="RunTime.html">RunTime</a>, or all type failures cause a well-defined error or exception. (There may be some "loopholes" in the checking of some constructs, but see <a href="StronglyTypedWithoutLoopholes.html">StronglyTypedWithoutLoopholes</a>.) It is <a href="WeaklyTyped.html">WeaklyTyped</a> if type failures are possible and cause <a href="UndefinedBehavior.html">UndefinedBehavior</a>. This is in principle an orthogonal dimension to <a href="ManifestTyping.html">ManifestTyping</a> vs <a href="ImplicitTyping.html">ImplicitTyping</a>. However, in practice very few languages are both weakly and implicitly typed (perhaps <a href="BcplLanguage.html">BcplLanguage</a>?).
      </p>
      <p>
        <em>Note:  In the above, "typechecking" refers to more than operations such as "instanceof" or "dynamic_cast" or similar.  It refers to any query of an object to determine if it supports a given feature or property.  Thus, a message send in </em><a href="SmalltalkLanguage.html">SmalltalkLanguage</a> involves typechecking, even though the concept of "types" is rather loose in Smalltalk.  Likewise with a car/cdr operation in Lisp; both check to see that the operand is a <a href="ConsCell.html">ConsCell</a> and not an atom; even though there is no real concept of an "atom" type.  Think of typechecking as a "can I do this" operator.<em></em>
      </p>
      <p>
        Languages with <a href="ManifestTyping.html">ManifestTyping</a> include <a href="CeeLanguage.html">CeeLanguage</a>, <a href="CeePlusPlus.html">CeePlusPlus</a>, <a href="JavaLanguage.html">JavaLanguage</a>, and <a href="CsharpLanguage.html">CsharpLanguage</a>.
      </p>
      <p>
        <a href="DynamicTyping.html">DynamicTyping</a> is far easier to implement than <a href="TypeInference.html">TypeInference</a>, is a bit more flexible (there are many typing systems for which <a href="TypeInference.html">TypeInference</a> is undecidable), and is more robust against changes in one module in a program consisting of multiple modules (the worst that can happen is <a href="DoesNotUnderstand.html">DoesNotUnderstand</a>, or a similar exception, being raised).  However, it can be rather slow.
      </p>
      <p>
        <a href="TypeInference.html">TypeInference</a> has the advantage of lower runtime penalties (runtime typechecking costs machine cycles; many languages with <a href="TypeInference.html">TypeInference</a> can elide most if not all typechecking code), and better provability (the compiler can <em>prove</em> that typing errors will not occur).  However, in a large program with lots of different modules; assumptions built into the code can lead to <a href="UndefinedBehavior.html">UndefinedBehavior</a> if one such module is replaced and the rest are not.  (This is a problem with <a href="StaticTyping.html">StaticTyping</a> in general).
      </p>
      <hr/>
      <p>
        History retained for context:
      </p>
      <p>
        <em>Maybe </em><a href="AutomaticTyping.html">AutomaticTyping</a> is a better term for the union of <a href="TypeInference.html">TypeInference</a> and <a href="DynamicTyping.html">DynamicTyping</a>.  <a href="ManifestTyping.html">ManifestTyping</a> (the form of static typing found in languages like C/C++/Java, where type annotations have to be attached to every declaration) needs a good antonym; I prefer <a href="AutomaticTyping.html">AutomaticTyping</a> to the one currently suggested here on Wiki--<a href="LatentTyping.html">LatentTyping</a>.  The term <em>automatic</em> suggests right up front why it's desirable--one less bookkeeping detail for the programmer to deal with.<em></em>
      </p>
      <p>
        I agree that it would be nice to have an antonym to <a href="ManifestTyping.html">ManifestTyping</a>, and <a href="AutomaticTyping.html">AutomaticTyping</a> is probably better than anything else I've heard. It still doesn't feel quite right to me, though. "Automatic" makes it sound like Smalltalk is going to extra trouble behind the scenes to deal with types for you. It really isn't. It's just waiting until the type information is handy. There's a kind of simplicity there that the word "automatic" doesn't convey.
      </p>
      <p>
        But this is a silly nit to pick, and I don't have a better suggestion. :) So go for it.
      </p>
      <p>
        <em>How about LazyTyping</em>? 
      </p>
      <p>
        Or more seriously <a href="ImplicitTyping.html">ImplicitTyping</a>, which is expressive
      </p>
      <ul>
        <li>
           verbally as matching <a href="TypeInference.html">TypeInference</a> ("I infer what you imply"), and because something implicit can be made manifest
        </li>
        <li>
           functionally in that it suggests that the data for potential <a href="TypeInference.html">TypeInference</a> are present in unprocessed form. 
        </li>
      </ul>
      <hr/>
      <p>
        Even in strongly typed languages there is partial implicit typing in situations such as:
      </p>
      <code>
        <strong>const</strong> X = 5;<br/>
      </code>
      <p>
        In the above code,  we do not declare X as a byte or an integer. It is implicitly decided by the compiler (or interpreter).
      </p>
      <code>
        <strong>const</strong> S = 'hello';<br/>
      </code>
      <p>
        Above we do not declare S as a string or an array of chars. It is implicitly decided by the compiler (or interpreter).
      </p>
      <ul>
        <li>
           <em>Even in strongly typed languages...</em> - <a href="ImplicitTyping.html">ImplicitTyping</a>/<a href="ManifestTyping.html">ManifestTyping</a> is orthogonal to <a href="StrongTyping.html">StrongTyping</a>/<a href="WeakTyping.html">WeakTyping</a>.  In strongly typed languages with full <a href="ImplicitTyping.html">ImplicitTyping</a> (such as ML and Haskell), there is a great deal more than 'partial' <a href="ImplicitTyping.html">ImplicitTyping</a>.	However, since your point seems to be that some languages that primarily favor <a href="ManifestTyping.html">ManifestTyping</a> possess some simple <a href="ImplicitTyping.html">ImplicitTyping</a>, you're right on that point - and, across versions, more such languages are receiving 'auto' typed variables, not just constants (including C++0X).  
        </li>
      </ul>
      <code>
        <strong>auto</strong> v = some+hideous*expression;<br/>
      </code>
      <p>
        Imagine though, if we had "no constants" or "implicit constant/variables". At some point, the human has to intervene and write down in the code a contract as to what is what - explicitely. Imagine if your language required  you make assumptions about whether a variable is really a constant or not? Doesn't sound logical? Imagine a language without any constants - it was up to you to make sure a variable stayed constant or not - because it was implicit. A variable staying constant? Huh? Yes, this ridiculousness happens.  If I want a string to stay a string - it is not necesarily possible in dynamically typed languages if there is no explicit human written contract! One should be able to declare whether or not his type stays a "constant type of type" - just as one can declare whether his variable can remain constant or not (yes, I realize the irony - a variable that is a constant is not a variable - but see my point?). See also <a href="TypeSystemThroughComments.html">TypeSystemThroughComments</a> for more thoughts on sterility of code. 
      </p>
      <p>
        <em>There are many languages without constant identifiers, so they're easy to imagine - even languages where you can change the value of 'pi'.  But I do prefer languages support declaration and proof of invariants - i.e. they support it so I don't have to guarantee it by hand.  (In a one-man project of smaller size, invariants ain't a big deal... it's when you have teams of five or six or more people, and you're rotating interns, etc. that you want invariants to resist the </em><a href="WorseThanFailure.html">WorseThanFailure</a> approaches to programming.)<em></em>
      </p>
      <hr/>
      <p>
        I find some problems with this description/category. First, we should distinguish between "not required" and "not allowed". 
      </p>
      <p>
        Second, there are often implied ways to supply type info to the interpreter/compiler (I/C). For example, even if there are no formal type declarations, the existence of quotes around a constant (string) or decimals (float) could potentially be a kind of type declaration (if the I/C chooses to use such info). I've worked with languages like this. Rough example:
      </p>
      <code>
        a = 23;<br/>
        b = "23";<br/>
        c = 23.0;<br/>
        print(type(a)); // result: INTEGER<br/>
        print(type(b)); // result: STRING<br/>
        print(type(c)); // result: DOUBLE<br/>
      </code>
      <p>
        I'm not sure "implied" is the right word. If the "rules" are that "quotes mean string", then using quotes is no different than an explicit type indicator. The difference is a <strong>matter of syntax</strong>, not semantics. Quotes are no more or less "implied" than the prefix "String". These two may generate <em>identical</em> machine language (depending on language):
      </p>
      <code>
        double x = 0;<br/>
      </code>
      <code>
        var x = 0.0;	// period implies "double"<br/>
      </code>
      <p>
        Third, declarations may not mean much. For example, if you declare everything Variant in VB or Object in Java, you are still making a type declaration. But they are not usable declarations in a "type" sense. This is essentially emulating a type-free language (assuming a sufficient number of operators will process "variants"). --top
      </p>
      <hr/>
      <p>
        Does this set of categories cover old <a href="FortranLanguage.html">FortranLanguage</a>'s implicit typing? Would Fortran code <em>sans</em> explicitly typed variables be considered Static <a href="TypeInference.html">TypeInference</a>?
      </p>
      <hr/>
      <p>
        <a href="CategoryLanguageTyping.html">CategoryLanguageTyping</a>
      </p>
    </div>
  </body>
</html>