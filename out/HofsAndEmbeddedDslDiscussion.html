<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Hofs And Embedded Dsl Discussion
      </h1>
      <p>
        A discussion branch off of <a href="SummaryOfHofExamples.html">SummaryOfHofExamples</a>
      </p>
      <p>
        [Perhaps, <em>if</em> parallelism is all we need in the application. What happens when we find we can use an <a href="InternalIterator.html">InternalIterator</a> too? Maybe an <a href="EmbeddedDomainSpecificLanguage.html">EmbeddedDomainSpecificLanguage</a> or two? Event handlers? An algorithm we need to inject customisation into? What happens when we need all of those things, yet we only know about a "parallel" block construct? -DavidMcLean]
      </p>
      <p>
        What if Lisp-speaking aliens land all around us? I'd have to study specific scenarios on a case-by-case basis and weigh it against the alternatives. If I actually see <strong>common</strong> uses for such in my niche, I'll consider it. So far, not. (The issue of requirements frequency keeps popping up in these debates.) For example, a task- or department-specific API is often used rather than an <a href="EmbeddedDomainSpecificLanguage.html">EmbeddedDomainSpecificLanguage</a>. A full <a href="EmbeddedDomainSpecificLanguage.html">EmbeddedDomainSpecificLanguage</a> is generally only justified if it's to be heavily used, in which case a expert on <a href="EmbeddedDomainSpecificLanguage.html">EmbeddedDomainSpecificLanguage</a> is usually brought in.
      </p>
      <p>
        [I'm not sure you're clear on what an <a href="EmbeddedDomainSpecificLanguage.html">EmbeddedDomainSpecificLanguage</a> <em>is</em>, if you're drawing a distinction between one and a "task- or department-specific API". The average <a href="EmbeddedDomainSpecificLanguage.html">EmbeddedDomainSpecificLanguage</a> is <em>exactly</em> a task-specific API; it's just one that happens to gear the language's existing syntax to the domain. Take a look at RSpec, Rake, or Sinatra for illustrative and popular <a href="RubyLanguage.html">RubyLanguage</a> examples - or their JS equivalents, if you prefer (Mocha, Jake, and Express, respectively). You don't need a special <a href="EmbeddedDomainSpecificLanguage.html">EmbeddedDomainSpecificLanguage</a> expert any more than you need to bring in an expert for every other library and package your solution requires. As for the rest of your response, as I implied above your argument relies on the assumption that we only need parallelism, and even more specifically that we only need <em>one specific kind</em> of parallelism. It's exceedingly easy to run up against the limits of such a restricted construct; trivially, suppose we suddenly needed the ability to query in serial, such as to access a <a href="ControlTable.html">ControlTable</a> and dispatch on the result. In addition, again, you're spending complexity on one very specific use instead of a general tool that solves a wide range of problems - even if we only need that one kind of parallelism, what if we have events? Do we introduce a whole separate language construct for binding event handlers? Why encourage <a href="LanguageIdiomClutter.html">LanguageIdiomClutter</a> when we could just as easily use the same construct for both needs? -DavidMcLean]
      </p>
      <p>
        That's essentially <a href="SystemsSoftware.html">SystemsSoftware</a>, which I've already agreed can probably make better use of HOF's. And sometimes <a href="LanguageIdiomClutter.html">LanguageIdiomClutter</a> seems to work better in the field; I don't know why, it's just the way typical humans are. See <a href="GreatLispWar.html">GreatLispWar</a>.
      </p>
      <p>
        [<strong>What's</strong> essentially <a href="SystemsSoftware.html">SystemsSoftware</a>? I mentioned a bunch of things. Resolve your pronouns. -DavidMcLean]
      </p>
      <p>
        Writing new languages or API's intended for a wide audience or audience outside one organization is generally <a href="SystemsSoftware.html">SystemsSoftware</a>: tools used BY application developers. It's generally not worth it to make a custom language for a small audience; API's and "helper functions" are sufficient and don't require hiring language specialists. And if you wish to flesh out more examples, please do, but remember this is a summary page.
      </p>
      <p>
        [Seems perfectly reasonable, but I don't mean to claim you'd necessarily want to <em>write</em> an <a href="EmbeddedDomainSpecificLanguage.html">EmbeddedDomainSpecificLanguage</a>, nor any complete libraries, specifically for your application. All that I suggest, and all that the examples I provided demonstrate, is that you might want to <em>use</em> an <a href="EmbeddedDomainSpecificLanguage.html">EmbeddedDomainSpecificLanguage</a> as part of your application. Sinatra and Express are helpful for writing Web apps. RSpec and Mocha help you write unit tests. Rake and Jake help you write build tasks. All those things can be of use in an application. (Of course, if your application surpasses a certain level of complexity, it <em>might</em> become valuable to start building elaborate libraries and even the occasional <a href="EmbeddedDomainSpecificLanguage.html">EmbeddedDomainSpecificLanguage</a> to keep the code flexible and generally compact. But it also might not; it's far more likely that you'd need to <em>use</em> these things than <em>build</em> them.) -DavidMcLean]
      </p>
      <p>
        <a href="BusinessRulesMetabase.html">BusinessRulesMetabase</a> describes alternatives to a custom language. It caters to power-users who are not expected to be programmers, but can handle quasi-programming of business. Sometimes orgs have power-users who can program, but I've seen cases where when they move on or retire, their replacement cannot figure out their stuff. A <a href="BusinessRulesMetabase.html">BusinessRulesMetabase</a>, on the other hand, is a <strong>more transferable interface</strong>. Again, one typically has to target a typical staff member for a given position, not an advanced one.
      </p>
      <p>
        [A <a href="BusinessRulesMetabase.html">BusinessRulesMetabase</a> seems to be operating in a completely different field to the tools presented. Why would you want "power-users" defining your Web app's routing and request handling, or your unit tests, or build steps? Those things (with the maaaaaybe-an-exception of routing) all have no visible impact on users. -DavidMcLean]
      </p>
      <p>
        I thought we are talking about domain tools, not programmer tools. What do you mean by "routing and request handling" for web apps?
      </p>
      <p>
        [We're talking about <a href="EmbeddedDomainSpecificLanguage.html">EmbeddedDomainSpecificLanguage</a>s, but the examples I chose are for domains that do not typically concern end-users. Take a look at Sinatra or Express. They provide an <a href="EmbeddedDomainSpecificLanguage.html">EmbeddedDomainSpecificLanguage</a> for describing Web app routing, e.g., the code that dispatches a GET request for /some/particular/url/with/parameters/like/5 to the appropriate code for handling that request. -DavidMcLean]
      </p>
      <p>
        It sounds like a hybrid WCMS and programming framework. I probably couldn't evaluate such a product here and now effectively. I don't dispute that it "works", but the issue is how it compares to alternatives. Is there a particular feature of it you wish to illustrate? And are you saying HOF's make it easier on the DSL creators or users or both? -t
      </p>
      <p>
        [Nah, Express and Sinatra aren't CMSes, just Web frameworks; they're only meant to serve as examples of <a href="EmbeddedDomainSpecificLanguage.html">EmbeddedDomainSpecificLanguage</a>, so nothing specific to these frameworks alone is particularly relevant. And my claim is that the use of a DSL, built with anonymous and higher-order functions, makes the API friendlier and more flexible for its users. -DavidMcLean]
      </p>
    </div>
  </body>
</html>