<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Genera Os
      </h1>
      <p>
        This was the operating system that ran on the <a href="SymbolicsMachine.html">SymbolicsMachine</a>. It was reported to have a simply awe-inspiring development environment.  It is still in use in animation houses and as a development environment.
      </p>
      <p>
        It lives on as an environment (<a href="OpenGenera.html">OpenGenera</a>) running under Tru64 (the Alpha Unix from Compaq).
      </p>
      <hr/>
      <p>
        I program on a LispM daily now, so I thought I'd post a brief list of good things and bad. Keep in mind that Genera was doing this stuff in the early 90s :) <em>(Actually, the Symbolics system and Genera OS came out in 1983.)</em> <em>(To be technical, the OS *branded* as Genera came out ~1983 - with the 3600 series? I can't seem to remember. Anyway, they were still using the codebase developed for the regular Lisp Machines; I remember seeing in my research Stallman's account of the period, which mentioned that LMI and Symbolics shared the codebase for the OS until midway through the eighties when Symbolics closed off their servers and forked it (which supposedly prompted Stallman to begin duplicating their improvements and sharing them with LMI, which was a step towards GNU...- but I digress). So saying it came out in 83 is a bit misleading, as Symbolics released stuff before then, and of course they had on them that which would eventually become Genera.)</em>
      </p>
      <p>
        Good points for Genera:
      </p>
      <ol>
        <li>
           It's in Lisp :)
        </li>
        <li>
           The ability to find the callers of any method, and go through them just using the keyboard.
        </li>
        <li>
           The ability to edit any method by simply typing M-. and the method name. (Package prefix if it's in another package isn't a bad idea ;))
        </li>
        <li>
           The mouse can be used in an intelligent way. If you right mouse on the editor, a common list of things to do comes up, like Arglist, List Callers, List Definitions, etc.  Also it can be used to just click on a method name, and it'll "paste" it in as the input to commands.  Never mind that Alt Left Click will take you do the definition of the method you just clicked on etc etc.
        </li>
        <li>
           All of the above things make changing the signatures of methods, relatively non-traumatic, you can refactor things as you need to, to get the job done.
        </li>
      </ol>
      <p>
        Bad points for Genera:
      </p>
      <ol>
        <li>
           It's in Lisp ;)
        </li>
        <li>
           It's old, and runs only on LispMs, or Alphas emulating LispMs.  This means it can be a bit slow at times.
        </li>
        <li>
           It takes me 30+ min to reload a system.  Note, I work on a large Lisp system.
        </li>
        <li>
           It is JUST like emacs enough to fool you... until you go back to emacs :)
        </li>
        <li>
           LispMs can't run large Lisp systems; they are too slow. I don't know about <a href="OpenGenera.html">OpenGenera</a>.
        </li>
        <li>
           It's not SEXY(tm).  It just gets the job done.
        </li>
        <li>
           I'm still learning it ;).
        </li>
      </ol>
      <p>
        -- <a href="IraCooper.html">IraCooper</a>
      </p>
      <hr/>
      <p>
        The LispM can't run large Lisp systems? Haha. Bad joke. They were built for that. The Symbolics machines using the Ivory processor had a large address space of 36 bit. People were buying these machines to run extremely large software and in-core databases. The operating system and its applications add up from a few hundred thousand lines of Lisp code to more than million-lines-of-code applications. Is that large? I'd say so.
      </p>
      <p>
        It takes you 30 minutes to reload your system? Why are you reloading it? Save a 'world' and boot it. And then you patch it. If you are careful, you can have uptimes of months - even though you work within a fully dynamic environment.
      </p>
      <hr/>
      <p>
        Can it run our apps?  I recently demoed <a href="OpenGenera.html">OpenGenera</a>, and it could.  I don't think that my current UX1200 could at an acceptable speed, though I'm sure if I gave it enough swap it could.  I'm sure a 486 could run most modern apps with enough swap space, does this make it a good idea?
      </p>
      <p>
        My personal uptime is usually about a month or so, before I run into "out of memory" type issues that will force me to reboot.
      </p>
      <p>
        As far as loading from a base world.  I'm not convinced it would actually help that much because things change around here, quite a bit day to day, never mind month to month when I'd need to reload.
      </p>
      <p>
        -- <a href="IraCooper.html">IraCooper</a>
      </p>
      <hr/>
      <p>
        There were special memory boards for the XL1200 with tons of RAM - not just the 8MW.
      </p>
      <p>
        Wow, 8 Mega Watts of RAM, that's a lot!
      </p>
      <hr/>
      <p>
        <a href="CategoryOperatingSystem.html">CategoryOperatingSystem</a>
      </p>
    </div>
  </body>
</html>