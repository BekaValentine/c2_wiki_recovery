<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Sufficiently Large
      </h1>
      <p>
        <em>2 + 2 = 5, for sufficiently large values of 2</em>
      </p>
      <p>
        Mathematicians frequently use the phrase "for sufficiently large values of N". Often the audience is not quite aware just how large, 'sufficiently large' really is. It can be as large, or considerably larger than the number of fundamental particles (atoms, (baryons, leptons)) in the universe. Your guess at the exponent may be out by many orders of magnitude. 
      </p>
      <p>
        Sufficiently large can be <em>really big</em> in the way that space is not.
      </p>
      <p>
        This habit also sometimes extends to pure mathematicians, who step outside their field of expertise and try to apply mathematics to a world where sufficiently big is often not realized.
      </p>
      <p>
        This habit is also sometimes exemplified by non mathematicians who attempt to do something as simple as compute the Big O() of an algorithm and blithely assume that  O(kN^2 + cN + z) is best described as an O(N^2) algorithm because for <em>sufficiently large</em> N. . . . . Sometimes, however  cN + z >> kN^2 for all <em>practical</em> N. In truth, if c or z is <a href="SufficientlyLarge.html">SufficientlyLarge</a> and k is <a href="SufficientlySmall.html">SufficientlySmall</a>, and N typically a little number, say < 50,000, the algorithm may best be approximated as O(N) or O(z). 
      </p>
      <p>
        Read more about <a href="BigOh.html">BigOh</a>, and why it may not be the measure you need.
      </p>
      <p>
        <em>I think you're being unnecessarily harsh. </em><a href="BigOh.html">BigOh</a> has it's place, and it's an important one. For those with sufficient experience it serves as a marker to ask the question "How large are we talking about?"  For example, <a href="HeapSort.html">HeapSort</a> is faster than <a href="BubbleSort.html">BubbleSort</a> for sufficiently large N - how large, when does the change-over occur?<em></em>
      </p>
      <p>
        An concrete example: The InverseAckermannFunction (which occurs naturally in many GraphAlgorithms, e.g. UnionFind) grows <strong>very</strong> slowly. So slowly, that for all computationally relevant values (number of particles in the universe) you can assume it to be constant (i.e. <6).
      </p>
      <p>
        I think it was <a href="DonKnuth.html">DonKnuth</a> who said "log log log n <= 3". For comparison: exp(exp(exp(3))) > 10^229520860.
      </p>
      <p>
        <em>Of course, "sufficient experience" is a similarly moveable feast.</em>
      </p>
      <p>
        My favorite anecdote on this subject is sorting algorithms with multiple processors. With a number of processors on order of the number of things to be sorted, you can get sorting algorithms down to O(lg^2 n) time. 'Recently', a new algorithm was discovered which ran in O(lg n) time. However, the coefficients involved for real algorithms are like 1/2 and 40, meaning that while O(lg n) is better by asymptotic analysis, in the real world it's only better for sorting 2^80 particles or more, aka more particles than there are in the observable universe. However, custom dictates that when people publish papers on such sorting algorithms, they treat the O(lg n) as better. 
      </p>
      <hr/>
      <p>
        <a href="CategoryMath.html">CategoryMath</a>
      </p>
    </div>
  </body>
</html>