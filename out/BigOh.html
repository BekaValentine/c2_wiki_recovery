<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Big Oh
      </h1>
      <p>
        The Big-O notation (in mathematics named after Landau) describes the behaviour of a function for big inputs.
        It tries to capture the <em>core</em> of a function.
      </p>
      <p>
        Let's make a few examples.
      </p>
      <code>
        f(x) = x is in O(x)<br/>
        f(x) = x^2 is in O(x^2)<br/>
        f(x) = 100 x^2 + 13 x + 7 + sqrt(x) is in O(x^2)<br/>
      </code>
      <p>
        To be a bit more mathematical: O(x) is the set of all functions which grow at most as c*x for some constant c.
        Thus, we also have
      </p>
      <code>
        f(x) = x is in O(x^2) and O(x log x)<br/>
      </code>
      <p>
        In this sense, O(.) is like the greater or equal sign for functions.
      </p>
      <p>
        The notation is normally used when x is sufficiently large (approaches infinity), but can also be applied when x approaches some finite limiting value.
      </p>
      <p>
        Programmers use Big-O to get a rough estimate of "how many seconds" and "how much memory" various algorithms use for "large" inputs: "<a href="MergeSort.html">MergeSort</a> is O(n ln n) in time and O(n) in extra space. <a href="BubbleSort.html">BubbleSort</a> is O(n^2) in time and O(1) in extra space."
      </p>
      <p>
        If your algorithm is O(2^n) in time, and your input has a size of n=64 or more, that's a large input. Big O notation immediately tells you there's no point doing a detailed analysis or timing measurement, much less writing it in assembly language -- it's going to take over a hundred years, even if you could get the inner loop to run in 1 clock cycle.
      </p>
      <p>
        If your algorithm is O(2^n) in space, and your input has size of n=265 or more, that's a large input. Big O notation immediately tells you there's no point doing a detailed analysis or memory usage measurement -- if you could store 1 bit per electron, you would still need more electrons than exist in the universe.
      </p>
      <p>
        If your input is always small -- 1 or 2 or 3 -- then Big-O notation is irrelevant.
      </p>
      <p>
        For a humorous description of high-complexity algorithms, especially naive implementations, see <a href="OhMyGodComplexity.html">OhMyGodComplexity</a>.
      </p>
      <hr/>
      <hr/>
      <p>
        <em>(moved from </em><a href="BigOhNotation.html">BigOhNotation</a>)<em></em>
      </p>
      <p>
        Big-O notation is a ways of talking about the asymptotic performance ("speed") of an algorithm -- basically how it performs for extremely large input sizes. In this arena, a lot of real-world measurements are abstracted away.  If you have two algorithms for the same problem, one of which always takes twice as long as the other, they are considered equivalent from a Big-O point of view.
      </p>
      <p>
        Here is an example of Big-O notation.
      </p>
      <dl>
        <dt> </dt>
        <dd>The running time of bubble-sort on a set of size n is O(n^2).</dd>
      </dl>
      <p>
        This means that for "large enough" sets, bubble sort's worst-case performance will be roughly proportional to the square of the size of the set.
      </p>
      <p>
        The actual performance of bubble sort might be 2n^2 + 40n + 80 cycles, but the order notation conceals the coefficient of the highest-order term as well as all lower-order terms, and leaves only the (scaled) highest-order term.
      </p>
      <p>
        The technical definition is:
      </p>
      <dl>
        <dt> </dt>
        <dd>f(n) is O(g(n)) is equivalent to: There exist constants x and k such that for all n>k, x*f(n) < g(n)</dd>
      </dl>
      <p>
        Example: What x and k work for the above example 2n^2 + 40n + 80 is O(n^2)?  This means f(n) = 2n^2 + 40n + 80 and g(n) = n^2.
      </p>
      <p>
        One Possible Answer: x = 1/4, k = 25 . It doesn't have to be tight bounds in order to determine the order.
      </p>
      <p>
        Example: a + bn + cn^2 + ... + dn^s is O(what)?
      </p>
      <p>
        Answer: O(n^s)
      </p>
      <p>
        Also note that 2n^2 + 40n + 80 is O(n^3).  But it is obviously not O(n).
      </p>
      <p>
        Not all functions are comparable. For instance f(n)=n and g(n)=n^(1 + sin(x)). f(n) is not O(g(n)) and g(n) is not O(f(n)).  Also, order notation is only defined for functions that are "eventually nonnegative" -- that is, there exists some k that for all n>k, f(n) is nonnegative.
      </p>
      <p>
        We can think of O(g(n)) as a set consisting of all the functions that asymptotically grow at the same rate as, or slower than, g(n). But most people use "is" or the equal sign instead of set membership.
      </p>
      <p>
        O(g(n)) = { f(n) | f(n) is a function : There exist x,k such that for all n>k, x*f(n) < g(n) }
      </p>
      <p>
        If we have f(n) is O(g(n)) and g(n) is O(f(n)) then we say that f(n) is Theta(g(n)) and g(n) is Theta(f(n)). Theta is slightly preferred over O because it is a more exact and tight measure. But sometimes O is all that can be proved.
      </p>
      <p>
        When we say that an ALGORITHM is O(f(n)), we mean the running time of that algorithm.
      </p>
      <p>
        When we say that a PROBLEM is O(f(n)), we mean the running time of the best algorithm for that problem.  For instance, "Comparison-based sorting is O(n * log(n) )"
      </p>
      <p>
        (For more information, see the classic textbook <em></em><a href="IntroductionToAlgorithms.html">IntroductionToAlgorithms</a><em> by </em>ThomasCormen, CharlesLeiserson and RonRivest. ISBN 0-262-03293-7 )
      </p>
      <p>
        -- <a href="JonathanRynd.html">JonathanRynd</a>
      </p>
      <hr/>
      <hr/>
      <p>
        Big O notation expresses the asymptotic (for large N) behavior of an algorithm. Clearly this only approximates the actual behavior (time and space) of algorithms coded for real computers. Those who performance tune computer codes are advised to be aware of both asymptotic behavior and actual measures.
      </p>
      <ul>
        <li>
           <a href="http://www.nist.gov/dads/HTML/bigOnotation.html">http://www.nist.gov/dads/HTML/bigOnotation.html</a>
        </li>
      </ul>
      <p>
        Measurement on real computers may expose theoretical analysis to have counted the wrong thing. For example, sorting algorithms are often compared by counting <em>compare</em> operations while measurements could easily be dominated by caching or paging behavior. Here is another example.
      </p>
      <ul>
        <li>
           <a href="http://c2.com/doc/SerializationThroughput/index.html">http://c2.com/doc/SerializationThroughput/index.html</a>
        </li>
      </ul>
      <hr/>
      <p>
        Thus, though Big O is a powerful tool that a performance tuner must both acknowledge and understand, life is rarely so simple in practice. Its a bit like learning kinematics and then expecting all cows to be spherical point masses in a vacuum. If large test realistic data sets are unavailable during testing, awareness of how the program will theoretically scale under load is critical. If during testing actual test sets are available that represent both current and future sizes loads then theoretical predictions of Big O are always overruled by a correctly performed measurement. Be aware that providing realistic and worst case loads and datasets is probably at least as arcane a process as computing Big O.
      </p>
      <p>
        As was pointed out above, even for a simple (sort) algorithm, "which N?" becomes an issue. 
      </p>
      <p>
        In practice,I have needed to compute the Big O for an algorithm in which there were many user configurable free variables, N,M,P,Q,R,S. A basic Big O analysis showed big O was implicitly, obviously, and inescapably, O(c^Q), but Q was always one of (2,3,4, or 5). It was O(N) Linear in N where N = 1..1E6, It was polynomial in M, O(M^Q), It was weird things I could not work out in P,R,S,... Thus even if you held all else still while one variable in the sane range of values (say 1-10,000) some other currently fixed variable was an exponent in the constant part of the expression. Uggh. In the end I settled for the following analysis. "The last 10 times I used computation Algorithm A, on average, the computation Algorithm B would have been 1000 times faster. The process now appears likely to be IO bound."
      </p>
      <p>
        <em>That example does seem quite complicated. How often does the professional performance tuner encounter such awkward cases?</em>
      </p>
      <p>
        That is the most complicated example I (as a sample of one) ever met, but it does point out a class of complication invisible to many (would be) part-time performance tuners. Hence my claim for the validity of the statement "life is rarely so simple in practice".
      </p>
      <p>
        <em>Giving one extreme "counter-example" doesn't show that simplicity is rare. To do that, you would need to show that cases from the "invisible class" substantially predominate.</em>
      </p>
      <p>
        In my experience, the most common way in which life is rarely as simple as Big-O, is that often N is just not <a href="SufficientlyLarge.html">SufficientlyLarge</a>. Often, sufficient improvement is easily achievable by changing the k that is left out of BigO analysis. Often, BigO of 'comparison ops' is not relevant when BigO of 'cache misses' is. Optimizing the inner loop of a dot product speeds up many Machine Learning algorithms by a lot (sufficiently), but makes no change to BigO.
      </p>
      <ul>
        <li>
           <em>Your case seems to be primarily against misuse of </em>BigO, rather than against BigO per se. A dot product is not an obvious case for optimization - unless you have (specialized) knowledge of how to do it, and also know it's a principal component of the algorithm(s) used.<em></em>
        </li>
      </ul>
      <ul>
        <li>
           I would say that <a href="BigOh.html">BigOh</a> in terms of computer algorithms is generally "misused". Most <a href="BigOh.html">BigOh</a> analysis is done with the assumption of random access machines, but most non-embedded machines are decidedly not random access equivalent. They have many levels of caching, including hardware caching and virtual memory. For example, this makes two compare operations not equal, and thus your <a href="BigOh.html">BigOh</a> analysis is not (as) reliable. For example, B-trees exist because the important operation is disk access, not comparisons. In my current product, we changed a matrix from column major to row major to improve locality, thus cache hits, thus performance. The speed boost was huge. The moral is <a href="BigOh.html">BigOh</a> can be a useful tool, but only if you identify the correct function modeling its performance characterist, and this is sometimes nontrivial, so always measure with real data, including worst case and average case. 
        </li>
      </ul>
      <p>
        Also, consider "pruning" and the (MachineLearning) NN back-propagation algorithm; what is the change on the BigO created by "pruning"? What are we interested in measuring the change in? We could count the percentage of Neurones pruned and decide that this simply modified the k and not the BigO. The BigO after all is in terms of numbers of training cases. Even if we measured BigO in terms of Network architecture size, pruning still is only a kind of improvement that may be viewed as simplifying by a factor of k and not changing the BigO. It is, however, well-known that in practice pruning radically increases the performance of a back-propagation algorithm. This happens, I believe, because it increases the rate of convergence.
      </p>
      <p>
        <em>... and possibly </em>BigO can be applied to that rate of convergence. Whether that is the case or not, the example seems to be far from typical. BigO is not taught as a universal technique with no limitations.<em></em>
      </p>
      <p>
        In my limited experience, I expect that for many (most) applications programmers making business systems, the computation of BigO is no where near as difficult as my examples above, but I still have seen it got wrong way too often. On one business system, the case was made that our new GUI front end would bog down the servers. I pointed out that on the use cases we had, the new front end "A" hit the data base fewer times "B". The back end no longer had to run the 3270 terminals and respond to real time user inputs.
      </p>
      <p>
        <em>You say "the case was made..." - misusing </em>BigO? If so, why not explain the misuse as well as showing improvements in particular cases?<em></em>
      </p>
      <p>
        Note also: as has been subtly hinted at above, performance tuning is always evil; just don't do it. The first step in performance tuning is making a measure to prove that you just must do it. You must also then stop tuning as soon as it goes fast enough.
      </p>
      <p>
        <em>In many cases, near-optimal buffer sizes may be selected by default. When they're not, is it evil to specify near-optimal sizes? And why choose sizes known to be good enough, when other sizes are already known to be better?</em>
      </p>
      <p>
        <em>It seems odd to introduce </em>BigO, but then concentrate on its misapplication and hint that it's evil anyway, along with optimization in general. I would suggest a typical sequence is "notice (or anticipate) poor performance", then "identify the problem area", and then "alleviate the problem (using BigO if appropriate)".<em></em>
      </p>
      <hr/>
      <p>
        When I was taught <a href="BigOh.html">BigOh</a> at Columbia University CS in the mid-1980's, the emphasis was on "tight upper bounds" (see some examples above that aren't so tight), and on classifying a proposed computation in one of three categories: "possible", "feasible" or "efficient". "Possible" covers all that's theoretically computable, but where computation time or space grows exponentially with input size. "Feasible" includes polynomial complexities, while "Efficient" covers the gamut of logarithmic, linear and constant spaces or times. <a href="BigOh.html">BigOh</a> is "big picture", not intended for sub-optimizations. For guys whose only take on optimization is "write it in assembler", <a href="BigOh.html">BigOh</a> could be an insightful study. -- <a href="WaldenMathews.html">WaldenMathews</a>
      </p>
      <hr/>
      <p>
        <strong></strong><a href="DeletedUnlessDefended.html">DeletedUnlessDefended</a>:<strong></strong>
        I trimmed the sentence
        <em>Note that if f(x) is allowed negative values, the unsigned value must be in O(g(x)) for one to say f is in O(g(x)); g(x) has to be positive.</em>
        from the description.
        Since the time and space used by any algorithm is at minimum zero,
        it seems silly to deal with negative numbers.
        -- <a href="DavidCary.html">DavidCary</a>
      </p>
      <hr/>
      <p>
        <strong>It's about bounding of a function, not just time- and space-complexity</strong>
      </p>
      <p>
        Actually, <a href="BigOhNotation.html">BigOhNotation</a> isn't defined to be specifically about the time or space that an algorithm takes.  In <a href="NumericalAnalysis.html">NumericalAnalysis</a>, for example, the same notation describes the error bound of a function that approximates another function.  The error bound is itself a function of the size of the interval at which the function to be approximated is sample.  A high exponent in the <a href="BigOh.html">BigOh</a>, e.g. <em>O(h^5)</em>, is good because usually the interval width <em>h</em> is less than 1, and a number less than one raised to high power becomes very tiny indeed.
      </p>
      <hr/>
      <p>
        My definition, is that <a href="BigOh.html">BigOh</a> notation specifies (or gives) <em>abstract</em> run-time performance rather than <em>clock-time</em> performance.  "Abstract" here referencing a purely logical evaluation, akin to how number represents an abstract quantity, rather than 1 milliliter, for example.  For any particiluar implementation, then on a machine, the performance will be the <a href="BigOh.html">BigOh</a> operand multiplied by some constant factor peculiar to the specific machine (Intel 1.8GHz Pentium, for example).  -- <a href="MarkJanssen.html">MarkJanssen</a>
      </p>
      <p>
        <em>To an extent, yes.  In </em><a href="ComputerScience.html">ComputerScience</a>, Big O describes the relative time complexity of algorithms given some input n. O(1) means an algorithm whose time is constant relative to n, O(n) means the algorithm's time is related linearly to n, O(n**2) means its time is the square of n and so on.  However, given two algorithms -- one O(1) and one O(n!) -- and some n, it's entirely conceivable for the O(1) algorithm to take days to complete (though it will always take the same number of days, regardless of n) whilst the O(n!) algorithm completes in milliseconds.  Big O only gives relative performance proportional to n, not absolute performance.<em></em>
      </p>
      <hr/>
      <p>
        See also: <a href="OrderNotation.html">OrderNotation</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryPerformance.html">CategoryPerformance</a>
        <a href="CategoryOptimization.html">CategoryOptimization</a>
        <a href="ProfileBeforeOptimizing.html">ProfileBeforeOptimizing</a>
      </p>
    </div>
  </body>
</html>