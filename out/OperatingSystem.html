<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Operating System
      </h1>
      <p>
        The most low-level program that runs on any computer. It is started the moment the computer is switched on, and only ends the moment the computer is shut down. Its main task is to execute <a href="ApplicationProgram.html">ApplicationProgram</a>s, that perform the tasks that the user really wants to have done. 
      </p>
      <p>
        Note that not every computer runs an operating system. Many embedded systems have applications directly running over the hardware. Some desktop systems intentionally blur the distinction between operating system and application (e.g. the <a href="OberonLanguage.html">OberonLanguage</a>).
      </p>
      <p>
        <em></em>'The <a href="LanguageIsAnOs.html">LanguageIsAnOs</a><em></em>' -- for languages that were designed to run without benefit of an independent <a href="OperatingSystem.html">OperatingSystem</a>.
      </p>
      <p>
        See also <a href="PurelyFunctionalOperatingSystem.html">PurelyFunctionalOperatingSystem</a>, <a href="ObjectCapabilityOperatingSystem.html">ObjectCapabilityOperatingSystem</a>, <a href="KillerOperatingSystem.html">KillerOperatingSystem</a>.
      </p>
      <hr/>
      <p>
        An operating system is a program that provides an interface between the hardware and the business logic.
      </p>
      <hr/>
      <p>
        <em>I take issue with the "started the moment the computer is switched on" statement:</em>
      </p>
      <p>
        In the MS-DOS world, the ROM BIOS starts up when the computer is switched on, and it may invoke a bootstrap loader from the disk, which in turn loads the "full blown" <a href="OperatingSystem.html">OperatingSystem</a>. The ROM BIOS is <a href="OperatingSystem.html">OperatingSystem</a> independent - it could start many different OSes.
      </p>
      <hr/>
      <p>
        <em>I take issue with the "Its main task is to execute </em><a href="ApplicationProgram.html">ApplicationProgram</a>s"<em></em>
      </p>
      <p>
        The primary purpose of the operating system is to regulate access to hardware devices, including RAM, CPU, disk drives, etc. -- <a href="DavidCorbin.html">DavidCorbin</a>
      </p>
      <p>
        <em>Yes, but this only matters in so far as it lets application programs run!</em>
      </p>
      <p>
        Yes, like provide a protected memory space (NT uses a 4GB virtual address space with lower 2GB for users and upper 2 GB for the system, although this can be set to 3 GB for users with a special setting) with a Virtual Memory Manager, some abstract model of dealing with hardware (NT has Hardware Abstraction Layer - HAL), device driver model, kernel, services, etc.
      </p>
      <p>
        -- sg
      </p>
      <hr/>
      <p>
        There are <a href="OperatingSystem.html">OperatingSystem</a><strong>'s for embedded applications too...</strong>
      </p>
      <ul>
        <li>
           <a href="PalmOs.html">PalmOs</a> 
        </li>
        <li>
           Windows CE (See <a href="WinCe.html">WinCe</a>)
        </li>
        <li>
           <a href="SymbianOs.html">SymbianOs</a>
        </li>
        <li>
           <em>...others...</em>
        </li>
      </ul>
      <p>
        <a href="RealTimeOperatingSystem.html">RealTimeOperatingSystem</a>s have rather special scheduling and synchronizing facilities. These ensure that the highest priority task that is ready to run will always get to the processor within a finite and deterministic amount of time (typically in the single-digit microseconds on mid-level Pentium hardware). Popular real time operating systems include:
      </p>
      <ul>
        <li>
           <a href="RtLinux.html">RtLinux</a>, RtaiLinux, and the rest of the hacked-up Linux kernels
        </li>
        <li>
           QNX4 and <a href="QnxNeutrino.html">QnxNeutrino</a>
        </li>
        <li>
           WinCE (finite and deterministic does not necessarily mean quick, though)
        </li>
        <li>
           Custom solutions; writing real-time operating systems is a traditional entertainment for all embedded systems programmers
        </li>
      </ul>
      <hr/>
      <p>
        An operating system is <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a> for the things that application programmers found themselves doing over and over.
      </p>
      <hr/>
      <p>
        Is anyone doing real research on operating systems these days? We can all see the effects of what has evolved over the last twenty years - we have advanced so much that Linux is now quite popular, and Apple have developed a new OS "based on Unix", while <a href="MicroSoft.html">MicroSoft</a> continues to produce new operating systems which try to do better, but usually don't.
      </p>
      <p>
        <em></em><a href="EllFour.html">EllFour</a>? PlanB? Systems with OrthogonalPersistency...<em></em>
      </p>
      <p>
        Unix is perhaps the best thing we have, but that doesn't mean that it's really good. However, there's not much incentive for anyone to develop a new system is there?
      </p>
      <ul>
        <li>
           <em>Or the barrier to entry is too high: dealing with modern memory management, zillions of device drivers, schmancy graphics to attract users, etc. takes a lot of time and energy.</em>
        </li>
      </ul>
      <p>
        What do you think a new operating system should have - or even an older, but refurbished one? See <a href="NewOsFeatures.html">NewOsFeatures</a>.
      </p>
      <p>
        -- <a href="DavidMartland.html">DavidMartland</a>
      </p>
      <hr/>
      <p>
        <em>The most low-level program that runs on any computer</em>
      </p>
      <p>
        As long as you don't count the MonitorRom.  In many older designs, and (as I understand it), some newer designs, a Monitor ROM got/gets control at PowerOn.  This Monitor ROM could/can be used to examine memory, boot from specific devices, enter code by hand, and other stuff.  Some OS implementations were/are aware of the Monitor ROM and would/will allow escaping to it while preserving all other state.
      </p>
      <hr/>
      <p>
        MultiUser <a href="OperatingSystem.html">OperatingSystem</a>s support many concurrent users
      </p>
      <ul>
        <li>
           Pr1mos ran on a Pr1me computer with 3 MegaBytes of RAM, servicing 48 users at a time, all the time.
        </li>
        <li>
           OpenVMS runs DigitalEquipments (now owned by HP) VAXes, and 64bit Alpha Servers.
        </li>
        <li>
           Multics stood for Multiuser Computing System, I first saw it on some Honeywell hardware at MIT.
        </li>
        <li>
           <strong>Q</strong>: What OS did Xerox's Sigma series run?
        </li>
        <li>
           In the 1990's Unix became mainstream, with many vendors having their own flavors: DEC, HP, DG, Sun, SGI, IBM, and a whole litany of other acronyms.  At the same time, a variety of <a href="OpenSource.html">OpenSource</a> <a href="UnixClones.html">UnixClones</a> appeared:  <a href="NetBsd.html">NetBsd</a> <a href="FreeBsd.html">FreeBsd</a> <a href="OpenBsd.html">OpenBsd</a> and <a href="LinuxOs.html">LinuxOs</a>
        </li>
      </ul>
      <p>
        SingleUser <a href="OperatingSystem.html">OperatingSystem</a>s have grown over time
      </p>
      <ul>
        <li>
           CP/M booted on my Osborne from one 92kb floppy, with room to spare.
        </li>
        <li>
           Apple had a bunch of early OS, leading up to that on the Macintosh - which seemed to have remained nameless, but versioned.  They are now on version 10 (X) of the MacOS.
        </li>
        <li>
           MSDOS from Microsoft booted from floppies in the early days.
        </li>
        <li>
           Unix was named as a pun on the OS named Multics, a single users programming environment.
          <ul>
            <li>
              <em>[Unix never was a single-user OS. Its very first incarnation supported exactly two users.]</em>
            </li>
          </ul>
        </li>
        <li>
           <a href="MenuetosOperatingSystem.html">MenuetosOperatingSystem</a> is a modern single-floppy OS written in <a href="AssemblyLanguage.html">AssemblyLanguage</a>
        </li>
      </ul>
      <hr/>
      <p>
        See <a href="OperatingSystemsDesign.html">OperatingSystemsDesign</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryOperatingSystem.html">CategoryOperatingSystem</a> <a href="CategoryJargon.html">CategoryJargon</a>
      </p>
    </div>
  </body>
</html>