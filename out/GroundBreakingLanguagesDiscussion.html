<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Ground Breaking Languages Discussion
      </h1>
      <p>
        Here we discuss the list of <a href="GroundBreakingLanguages.html">GroundBreakingLanguages</a>, so that we don't clutter the List itself too much.
      </p>
      <p>
        <em>[NOTE: This page is in </em><a href="SeriousNeedOfAttention.html">SeriousNeedOfAttention</a>. I brought all the discussion over here to keep the list page uncluttered. Let's work out a consensus before changing that page, eh? -- <a href="MartySchrader.html">MartySchrader</a>]<em></em>
      </p>
      <hr/>
      <p>
        <em>Does anyone find it telling that almost half of these ground-breaking languages don't have a </em><a href="WikiPage.html">WikiPage</a> to describe them?<em></em>
      </p>
      <p>
        Ground-breaking languages often come from research labs or academia, and thus don't have the commercial clout to compete against popular languages of the time. They also embody novel ideas about programming, and it usually takes some time for those ideas to become mainstream. The novel ideas of a ground-breaking language are usually popularised by some other language that allows programmers to migrate their skill sets to that language. E.g. Object orientation hit the mainstream with C++; <a href="FunctionalProgramming.html">FunctionalProgramming</a> has languished on the sidelines for some time, but the ideas are being brought into the mainstream in the C++ standard library.
      </p>
      <hr/>
      <p>
        Note that I (<a href="CameronSmith.html">CameronSmith</a>) intended to restrict the list to "truly new" programming languages. Every one of the languages above spawned multiple descendants, many of which are clearly superior to the originals. But my point here is to recognize the people who had the spark of a genuinely new idea in programming, not the people who worked out all the kinks. (Not that that isn't important too.) Feel free to add to the list above, but please keep the "truly new" and "ground-breaking" standard in mind.
      </p>
      <p>
        <em>This list should be about languages, not people. Unless anyone disagrees I am going to switch the dd around so that the language comes first instead of the people.</em>
      </p>
      <hr/>
      <p>
        If you are interested in this topic, be sure not to miss the <a href="LanguageList.html">LanguageList</a>.
      </p>
      <hr/>
      <p>
        Historical note: According to the "Smalltalk" entry in the Language List, Smalltalk's creators consciously and deliberately "[t]ook the concepts of class and message from Simula 67 and made them all-pervasive", making Smalltalk "the quintessential object-oriented language". By the "truly new" standard, this would have forced me to delete Smalltalk, which someone else had added, from the list (which I am sure would have been a very unpopular thing to do). But the List also says this of Smalltalk: "Innovations included the bitmap display, windowing system and use of mouse." I would call those significant new ideas in how we interact with computers, and I think more specifically they have influenced how we think about <em>programming</em> computers, so I guess Smalltalk can stay. (<em>*grin*</em>) -- <a href="CameronSmith.html">CameronSmith</a>
      </p>
      <hr/>
      <p>
        Comment in a similar vein (or perhaps fodder for debate): Much as I love Perl, I feel that it should be <strong>excluded</strong> from this list. Although Perl brings together a ton of useful ideas under one roof (pattern-driven processing, regular expressions, first-class functions and closures as data, object-orientation, etc....), it didn't originate any of them. I would be happy to be convinced that it belongs, though. Maybe the thought of bringing together so many concepts in one language is itself a new language concept....? hmmmmm.... no, wait, there's PL/I. Darn. (Just because PL/I was horrible and Perl is wonderful isn't enough.) <em>Perhaps perl's contribution is the idea that the language should always try to do the right thing - whatever that might be in a given context.</em> [Perl is almost the antithesis of a <a href="RightThing.html">RightThing</a> language. It was invented to make systems hacks easier!  Glomming together a bunch of existing flawed tools does not get you the <a href="RightThing.html">RightThing</a>; it can get you something *useful* though.]
      </p>
      <p>
        <em>Even worse, some of the many concepts in PL/I actually originated in PL/I. That means that PL/I belongs to the list.</em>
      </p>
      <ul>
        <li>
           E.g. Explicit pointer data types/variables as a higher level language construct were first introduced in PL/I, by Harold "Bud" Lawson with input from <a href="DonKnuth.html">DonKnuth</a> and <a href="DougMcIlroy.html">DougMcIlroy</a>.
        </li>
      </ul>
      <p>
        Likewise, <a href="DonKnuth.html">DonKnuth</a>'s TeX is ineligible - it was preceded by troff and, I believe, by Scribe as a typesetting language, and by many many macro languages, including GPM and TRAC, as a programming language.
      </p>
      <p>
        [Not to mention troff. But Web, the language TeX was implemented in, introduced literate programming and so is eligable. And I suspect that <a href="MetaFont.html">MetaFont</a>, made to support TeX, is also an eligable language (depending how we define language)]
      </p>
      <hr/>
      <p>
        <strong>Request for help:</strong> Besides the question about the development of Simula 67 (above), I would also like to know this: what was the first programming language to include continuations as first-class data? I'm thinking CLU, but I could be wrong. Does anyone know? If so, please delete this request and add the language to the list. Thanks.
      </p>
      <p>
        <em>See </em><a href="SimulaLanguage.html">SimulaLanguage</a> re: your first question.<em></em>
      </p>
      <hr/>
      <p>
        I would expect that Fortran, Mumps, APT, and Simscript might qualify also? Or even Autocoder, C, and Bourne shell?
      </p>
      <p>
        <em>I thought of APT, but wasn't sure if it was influential enough to count. FORTRAN is already there (John Backus). C is definitely out - it has a long lineage, including B and BCPL and the "Algol-like" languages. Again, the point here is not to identify the most refined or best or most widely accepted language to embody an idea, but rather the first one to do so. In fact, "first" and "best" are likely to be at opposite ends of a particular line of development.</em> 
      </p>
      <hr/>
      <p>
        Prolog should be up there, as should the first language based on a ConstraintSolver.
      </p>
      <p>
        What about the first lazy functional language? Was it Hope or ML, or something else? <em>ML is strict. An early lazy language is SASL, but I suspect that the first true lazy language was some lazy Lisp dialect implemented in Lisp.</em>
      </p>
      <p>
        I did some coding in Hope for a denotational semantics course in grad school. I think of Hope as a "declarative" language rather than a functional programming language - but I'm not sure that's a sensible distinction.
      </p>
      <p>
        (Both functional programming languages and logic programming languages are <a href="DeclarativeLanguage.html">DeclarativeLanguage</a>s. JH) (That depends on the functional language. There are purely functional subsets of Lisp and Scheme, for example.)
      </p>
      <hr/>
      <p>
        I still think <a href="BasicCameFromFortran.html">BasicCameFromFortran</a>.
      </p>
      <hr/>
      <p>
        <em>Does John Ousterhout's Tcl (</em><a href="ToolCommandLanguage.html">ToolCommandLanguage</a>) fit?<em></em>
      </p>
      <p>
        Tcl was never touted as anything new. It amalgamated a number of existing ideas into one language:
      </p>
      <ul>
        <li>
           String based language (from SNOBOL)
        </li>
        <li>
           Commands and data use the same list syntax (from LISP)
        </li>
        <li>
           Variable substitution taken from UNIX shells, but implemented in a way that is easier to understand.
        </li>
        <li>
           Dynamic scoping (early LISP)
        </li>
        <li>
           Embeddable scripting language (in response to many applications at the time having incompatible embedded scripting languages)
        </li>
      </ul>
      <hr/>
      <p>
        XSLT, the XML tree-processing language, recycles pattern matching, functional programming w/ single assignments, and a few other familiar ideas. It is, however, ugly to a degree that may lack precedent. C's
      </p>
      <code>
        x = 1;<br/>
      </code>
      <p>
        can appear as
      </p>
      <code>
        <xsl:variable name="x"><xsl:value-of select="1"></xsl:variable><br/>
      </code>
      <p>
        <em>XSLT is based on DSSSL, which is based on Lisp. It is amazing what people will do to avoid Lisp.</em> <a href="BillDehora.html">BillDehora</a>
      </p>
      <p>
        BLISS seems long forgotten (thanks be), but had some notions I haven't seen elsewhere. For example, it had constructs like C's arrays, structs, and bitfields, but those were all built up by the programmer from more primitive constructs. Also, it was an un-typed language. It had a lack of data types so complete I can't begin to describe it. The statement
      </p>
      <code>
        x=x+1;<br/>
      </code>
      <p>
        for example, assigned 'x' the address of the memory location following the one at which 'x' was allocated. No one ever got call-by-reference right except by trial and error, especially when pointers were involved. Its macro processor made festive use of () vs. [] vs. <> delimiters.
      </p>
      <p>
        <em>Not quite. An operator was required for typical use of variables to indicate fetch/store (rvalue/lvalue). The logic is that a variable like "x" is bound to a memory address, so referencing "x" should just yield that address, not the value at that address. Which is all true, but a nuisance in everyday programming. So anyway, Bliss would do something similar to:</em>
      </p>
      <ul>
        <li>
          x = *x + 1
        </li>
      </ul>
      <p>
        <em>...to mean exactly the same thing that C would express via:</em>
      </p>
      <code>
        x = x + 1<br/>
      </code>
      <p>
        <em>It may actually have had a different operator for lvalue versus rvalue, I don't recall. For sure it did not use "*" for the symbol; maybe it was "@".</em>
      </p>
      <hr/>
      <p>
        I think there should be some reference to <a href="ConcurrentConstraintProgramming.html">ConcurrentConstraintProgramming</a> languages and more analytical stuff like <a href="PiCalculus.html">PiCalculus</a>. They are very different in programming style from the imperative languages that dominate this list. And they break a lot of new ground!
      </p>
      <p>
        For analytical languages, see <a href="ProcessCalculus.html">ProcessCalculus</a> and <a href="ProofOfCorrectness.html">ProofOfCorrectness</a>.
      </p>
      <p>
        Does anyone know of a concurrent constraint language that predates CSP (see <a href="CommunicatingSequentialProcesses.html">CommunicatingSequentialProcesses</a>)? CSP feels too polished to be a first cut at the concept, but it's the only language of it's type that I know of.
      </p>
      <p>
        I also feel that <a href="BourneShell.html">BourneShell</a> definitely belongs up there. The whole concept of a programming language as glue logic between small programs with pipes needs a representative.
      </p>
      <p>
        It would be nice to have a representative of the various regex languages around, awk?
      </p>
      <hr/>
      <p>
        While Simula <strong>introduced</strong> the (groundbreaking) concept of <a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a>, and <a href="SmallTalk.html">SmallTalk</a> <strong>purified</strong> took it further and made it more consistent, it was C++ that <strong>made it widely used</strong>. This is obviously not considered groundbreaking here. <a href="BjarneStroustrup.html">BjarneStroustrup</a>, having learned Simula early, did not go on to teach the world Simula. Instead he went to <a href="BellLabs.html">BellLabs</a> and incorporated the object-oriented concept into the world's dominating language, C, in such a way that transition would be feasible. Despite all the drawbacks of C and C++, Bjarne's effort is what brought OOP to the masses. I think this is non-trivial and worth mentioning. It requires a pragmatic view of what will make programmers chose a language. I don't think that the success of C and C++ can be written off as an historic coincidence. -- <a href="LarsAronsson.html">LarsAronsson</a>
      </p>
      <p>
        Just like the "success" of English, I think the success of C and C++ is <em>entirely</em> a historic coincidence, furthered
        by a healthy dose of <a href="WorseIsBetter.html">WorseIsBetter</a>. And C++ <em>still</em> isn't <a href="ObjectOriented.html">ObjectOriented</a>, so I can't see how it "brought OOP to the masses". -- <a href="AlainPicard.html">AlainPicard</a>
      </p>
      <p>
        <em>Alain; please go to </em><a href="IsCeePlusPlusObjectOriented.html">IsCeePlusPlusObjectOriented</a> and explain why you think that. Whether or not C++ is a <strong>good</strong> language is a fun topic to debate; however I see no reason to exclude it from the list of OO languages. -- <a href="ScottJohnson.html">ScottJohnson</a><em></em>
      </p>
      <hr/>
      <p>
        Perhaps Java should make the list purely because it served as the platform for the introduction of <a href="AspectOrientedProgramming.html">AspectOrientedProgramming</a> (AspectJ)?
      </p>
      <hr/>
      <p>
        Is Eiffel [<a href="EiffelLanguage.html">EiffelLanguage</a>] ground breaking? I like the whole <a href="DesignByContract.html">DesignByContract</a> deal, but I'll admit that this is nothing that couldn't be done by <a href="UseAssertions.html">UseAssertions</a>. -- <a href="AnonymousCoward.html">AnonymousCoward</a>
      </p>
      <p>
        While not as thought out as Eiffel, Alphard and Euclid both have the Design by Contract concepts. -- <a href="JoelRicker.html">JoelRicker</a>
      </p>
      <p>
        <a href="DesignByContract.html">DesignByContract</a> is a little more complex than assertions in object-oriented languages because the DBC implementation must take into account inheritance and whether a method is being called from outside an object (in which case, the object's invariant must be checked) or inside an object (in which case it shouldn't).
      </p>
      <hr/>
      <p>
        This should not be put into the the list of <a href="GroundBreakingLanguages.html">GroundBreakingLanguages</a>:
      </p>
      <dl>
        <dt><strong>C</strong> [<a href="CeeLanguage.html">CeeLanguage</a>]</dt>
        <dd>The first language built to fully exploit underlying hardware. The first language that did file IO right. The first language that did real dynamic memory management. The endpoint of "procedural" language development. Used to implement the most important operating systems. Used to implement countless other programming languages, including Perl and the Java VM. Shaping the way we think about programming. <em>[It probably wasn't C, but which was the first language to introduce the notion of a 'standard library', distinguished from the language core but nonetheless considered part of the language?]</em></dd>
      </dl>
      <p>
        This is THE language. "What English is to the world, C is to the world of computers." -- <a href="HelmutLeitner.html">HelmutLeitner</a>
      </p>
      <p>
        And what, exactly, <strong>is</strong> "English to the world"? Sure, it's the <em>lingua franca</em> (and note that English didn't have a word for that, so they stole it from another language). English's dominance is a historical accident, nothing
        more. Surely there's nothing intrinsically superior or elegant about
        it compared to, say french, arabic, mandarin, etc.
      </p>
      <p>
        Come to think of it, C's dominance is a historical accident as well...
        is that what the quote meant Helmut?
      </p>
      <p>
        I think you underestimate both, C and your mother tongue English. Simplicity, efficiency and flexibility may not seem "ground breaking" but they are. If we estimate e.g. PL/I complexity or a simple inference mechanism (PROLOG) higher, then I fear, our thinking is not "ground breaking". IMO the next ground breaking language would be a language usable to refactor UNIX making it OO *and* 30% smaller *and* 10% faster. -- hl
      </p>
      <p>
        But, Helmut, English is <strong>not</strong> my mother tongue! Nor do I consider C "flexible". -- <a href="AlainPicard.html">AlainPicard</a>
      </p>
      <p>
        C is a great language for all of the merits stated above. It is also a great milestone in the history of programming languages just because it synthesized many features of the idealized high-level procedural language. But, as much as we would like to see our favorite languages on every list of superlatives that are invented, C just doesn't qualify as "ground-breaking". -- RobertLehr
      </p>
      <p>
        C was not groundbreaking, it was a hack. Kind of the Algol that could be done there.
      </p>
      <p>
        C in only a language. English too. Ha siktir, you should also learn to think in Tibetan, turkish, or armenian to think in another manner than the way you think in English. Don't think using a language, but with the structures you are the father! Language is not so important. What is important is what you have to say, how many people will listen to you, and in our economic world the money you will be able to bring back. For scientific people, it will be the ideas and the symbolic computation you can make with it. For my own purpose I do my job with Asm, Pascal and Prolog (but not C). It depends on what is the best to do the automatic job fast without any crash. Peter. 
      </p>
      <hr/>
      <p>
        Why <strong>not</strong> C:
      </p>
      <p>
        <em>The first language built to fully exploit underlying hardware.</em>
      </p>
      <p>
        Have you ever tried to make bigints in C? Not being able to access the overflow flag (that exists in every processor so far) is a real pain. Surely it doesn't exploit hardware. In addition, you don't have instructions for accessing the cards on your computer (inp and outp are programmed in assembler).
      </p>
      <p>
        <em>The first language that did real dynamic memory management.</em>
      </p>
      <p>
        See <a href="LispLanguage.html">LispLanguage</a>. Modern <a href="GarbageCollection.html">GarbageCollection</a> is as fast as manual allocation or <a href="ReferenceCounting.html">ReferenceCounting</a> (sometimes faster).
      </p>
      <p>
        <em>The endpoint of "procedural" language development.</em>
      </p>
      <p>
        You don't even have lambda.
      </p>
      <p>
        <em>Used to implement the most important operating systems. Used to implement countless other programming languages, including Perl and the Java VM.</em>
      </p>
      <p>
        So?
      </p>
      <p>
        <em>Shaping the way we think about programming.</em>
      </p>
      <p>
        It isn't different that many earlier languages (BCPL, Algol, etc).
      </p>
      <hr/>
      <p>
        <a href="RubyLanguage.html">RubyLanguage</a>. If <a href="PythonLanguage.html">PythonLanguage</a> made it, and <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> made it, and <a href="PerlLanguage.html">PerlLanguage</a> almost made it, shouldn't <a href="RubyLanguage.html">RubyLanguage</a> also make it? Or maybe we should wait and see how far it gets first...
      </p>
      <p>
        <em>What does "how far it gets" have to do with how groundbreaking anything is?</em>
      </p>
      <p>
        How far in what?
      </p>
      <p>
        <em>I think they mean how well it does, probably in terms of popularity.</em>
      </p>
      <p>
        <a href="RubyLanguage.html">RubyLanguage</a> is usable, flexible, useful, powerful, and free. Not exactly ground breaking, as in having loads of new ideas, but a quite nice <a href="ReFactoring.html">ReFactoring</a> of many <a href="GoodIdea.html">GoodIdea</a>s. Strives for the <a href="PrincipleOfLeastSurprise.html">PrincipleOfLeastSurprise</a>, and the <a href="UniformAccessPrinciple.html">UniformAccessPrinciple</a>.
      </p>
      <hr/>
      <p>
        I do not want to police this page, but as far as I can see "combining many <a href="BigIdea.html">BigIdea</a>s in one new language" does not fulfill the "truly new" criteria. So far this list has somewhat managed to avoid the <a href="WikiGreatFoobarLists.html">WikiGreatFoobarLists</a> effect, especially because some people had the b*lls to occasionally move questionable entries to the "needs better motivation" part. So please, before putting Python back in the list, just sit back and consider the guidelines given on the top of the page. -- <a href="StephanHouben.html">StephanHouben</a>
      </p>
      <p>
        I'm not so sure. Sometimes all it really takes is to combine many old ideas and you get something actually new and groundbreaking. <a href="ExtremeProgramming.html">ExtremeProgramming</a> is a perfect example; nothing new, but you can tell by the initial backlash just how 'new' and different it really is. I admit however that just adding any old foo to any old bar doesn't qualify, but when the combination is distinctly new, then sure, it's groundbreaking.
      </p>
      <hr/>
      <p>
        The <a href="RebolLanguage.html">RebolLanguage</a> simply isn't groundbreaking. It's neat, but it mostly just has funky syntax.
      </p>
      <p>
        <em>Could you be a little more specific? Yes, it does draw some of its core features from other languages (Lisp, Forth, and Logo), but could you point me to other languages that support - 1) direct lexical forms for a large number of datatypes; 2) the concept of pseudo-types; 3) native near-BNF support (that recognizes native datatypes as tokens); 4) a syntax designed to be both human and computer friendly - maybe "transparent" is a better word - at the same time even when extended (subjective, yes , I know). I'm not trolling here. Yes, I'm a big fan of REBOL (hence I am biased :), but I've looked at lots of other languages and I'm truly interested in others that do these things, whether or not there's a semantic distinction between "truly new" and "it's a twist on xxx in lang-Z". -- Gregg Irwin</em>
      </p>
      <p>
        I don't know what's meant by 1) or 2) above. 4) is obviously very subjective. Have any of these four features influenced other languages or been widely discussed as desirable features for future languages? -- <a href="DanMuller.html">DanMuller</a>
      </p>
      <p>
        <em>Thanks for replying Dan. The two things that I see as deciding factors at the top of the </em><a href="GroundBreakingLanguages.html">GroundBreakingLanguages</a> page are "...they represented new ways of looking at how to interact with computers...unique insight that changed the way we thought about programming", so I won't try to address influence on other languages or whether a feature has been discussed as desirable. Something could be undesirable and still groundbreaking. :-) Let me see if I can clarify on the other points though.
      </p>
      <p>
        #4. Yes, I noted that it was subjective, but if you look at the syntax when compare to Lisp - as an example - you'll see that it's very easy to parse and load data, much like Lisp, but doesn't require all the parens that Lisp does, aiding raw usability. The big difference when compared with, say, Logo, is the large datatype space (i.e. number of native datatypes). Let's ignore it for now, since it's quite subjective though.
      </p>
      <p>
        #1. REBOL can understand something like: "Send $100.00 to zippy@pinhead.com at 10:30 and update <a href="http://www.rebol.com">http://www.rebol.com</a> from <a href="ftp://host.dom/update.html">ftp://host.dom/update.html</a> (from <body> to </body>) on 7-Nov-2003 then tell me it's done. Change the color of product #1001-100 version 1.2.3.4 to 25.90.175 -- that's all."
      </p>
      <p>
        Now, plain old REBOL won't be able to make much sense of that, but it won't choke trying to parse it either. It will recognize the following types of values in there: word money email time url paren tag date issue tuple. 
      </p>
      <p>
        There are other types it can recognize on sight as well (like strings of course). The key point is that you don't have to escape any of these datatypes with quotes and convert them to the appropriate type; REBOL recognizes them by their lexical form directly. SEND, TO, AT, AND, UPDATE, VERSION, and ALL are REBOL functions, but if I wanted to write my own dialect that understood the above, I could easily provide my own functions with those names to operate in that context; to REBOL they are just words until they are evaluated in some context.
      </p>
      <p>
        #2. Pseudo-types are a way to classify datatypes into groups that share common traits. They can be used much as you would use interfaces in objects. The big difference is that no inheritance or implementing of interfaces is done with the native datatypes. For example a file! value is always a file! value, but it can be used anywhere you can use a series! value or an any-string! value. If you write a function to take a series! or any-string! parameter, and pass a file! value, you still see it as a file! not as some abstract interface type.
      </p>
      <p>
        I hope that helps. My main concern is not getting REBOL back on the main list, but making sure it's excluded for valid reasons. When someone says "it mostly just has funky syntax", it tells me they haven't really looked at it.
      </p>
      <p>
        -- Gregg Irwin<em></em>
      </p>
      <p>
        I'm a big Rebol fan too, but I don't think it belongs in the list. Most of its great features came straight out of Lisp and Forth. In answer to your specific rebuttals:
      </p>
      <p>
        #1. I'm far from fluent in Forth, but I believe it won't choke on a statement like that either. Granted, you'd have to define an awful lot of words, and they could get pretty complicated (particularly if you don't want to have to write the statement backwards). But aren't the Rebol definitions needed to make sense of that fairly complicated too? There're a whole lot of prepositions in that statement that need to be defined and somehow carry meaning to eg. the "send" word. 
      </p>
      <p>
        #2. Isn't that the same thing as Haskell type-classes, or <a href="GenericProgramming.html">GenericProgramming</a> in C++? With type classes, you define the operations a class supports, and then a type that belongs to that class can be used anywhere the class is called from. With no inheritance. (Well, type classes can inherit from one another, but individual types are <em>instances</em> of type classes, they don't inherit from them). <a href="GenericProgramming.html">GenericProgramming</a> works the same way - as long as the type supports the operation the template requires, it can be used in that context.
      </p>
      <p>
        #4. COBOL is on the list because it's the first language with a syntax designed to be human-readable. Since then we've also had Basic and Python, and to some extent <a href="SmallTalk.html">SmallTalk</a>. Rebol may be the first language where a human-readable syntax didn't get in the way of writing useful programs (though many Pythonistas would disagree on that), but it's syntax is hardly ground-breaking.
      </p>
      <p>
        -- <a href="JonathanTang.html">JonathanTang</a>
      </p>
      <p>
        <em>Thanks for your comments Jonathan!</em>
      </p>
      <p>
        I'm not very good at explaining the "big ideas" of REBOL, based on the depth of <a href="DenotationalSemantics.html">DenotationalSemantics</a> work done by Carl for its design (e.g. dynamicity of parse trees, lack of known arity until evaluation, etc.), so I have to make do with my layman's explanations. :)
      </p>
      <p>
        #1. "...But aren't the Rebol definitions needed to make sense of that fairly complicated too? There're a whole lot of prepositions in that statement that need to be defined and somehow carry meaning to eg. the "send" word."
      </p>
      <p>
        The main point here is the datatypes that REBOL recognizes based purely on their lexical form. Yes, there is work to do to parse the above into pieces we can work on: 
      </p>
      <code>
        b: [<br/>
        Send $100.00 to zippy@pinhead.com at 10:30 and update <a href="http://www.rebol.com">http://www.rebol.com</a> <br/>
        from <a href="ftp://host.dom/update.html">ftp://host.dom/update.html</a> (from <body> to </body>) on 7-Nov-2003 then <br/>
        tell me it's done. Change the color of product #1001-100 version 1.2.3.4 to <br/>
      </code>
      <ol>
        <li>
          90.175 -- that's all.
        </li>
      </ol>
      <code>
        ]<br/>
      </code>
      <code>
        mail-rule: [<br/>
        'send set amt money! 'to set addr email! opt ['at set time time!]<br/>
        ]<br/>
        extract-text-rule: ['from set start-tag tag! 'to set end-tag tag!]<br/>
        custom-cmd: [<br/>
        ['tell 'me 'it's ['done. | 'done]] (cust-cmd: 'tell-when-done)<br/>
        ]<br/>
        update-rule: [<br/>
        'update set dest url! 'from set src url!<br/>
        opt [set sub-rule paren! (parse :sub-rule extract-text-rule)]<br/>
        'on set date date! <br/>
        opt ['then custom-cmd]<br/>
        ]<br/>
        change-rule: [<br/>
        'change opt 'the set attr word! 'of 'product set id issue!<br/>
        opt ['version set ver tuple!] <br/>
        'to set val any-type!<br/>
        opt ['-- any any-type!]<br/>
        ]<br/>
        rules: [<br/>
        some ['and | mail-rule | update-rule | change-rule] end<br/>
        ]<br/>
        parse b rules<br/>
      </code>
      <p>
        But the values that you and I recognize as humans are baked into the language itself, their lexical form based on how *we* recognize them, not a computerish syntax - except for strings, which I'm guessing may have been done partly to help you and I as programmers. :) 
      </p>
      <p>
        The big idea behind this the REBOL's main goal: the semantic exchange of information between people and machines. For marketing reasons, they've dropped the "messaging language" moniker, but that's what it really is, and that's why I think it's groundbreaking. What other languages out there preceded it in that regard? What other languages are there now?
      </p>
      <p>
        #2. "Isn't that the same thing as Haskell type-classes, or <a href="GenericProgramming.html">GenericProgramming</a> in C++?" 
      </p>
      <p>
        I don't think so because, again, it isn't a language feature that allows you to parameterize your own types, it represents a characteristic of the language's native data types (we can argue about what's native for purely OO languages; what constitues an interface versus a value - this is my view).
      </p>
      <p>
        #4. "...it's syntax is hardly ground-breaking."
      </p>
      <p>
        I disagree, I'm just not able to explain it well. :\ It's syntax isn't just about being human friendly, what's important is its *lack* of syntax; what it doesn't impose on us. What looks simple on the surface, and what I'm not able to explain well, is the effort that was required to make this happen, again stemming from Carl's research into denotational semantics. e.g. in REBOL, the reduction is free ranging; the syntax gives no clue to where the expression ends. It is determined by execution. 
      </p>
      <p>
        -- Gregg Irwin<em></em>
      </p>
      <hr/>
      <p>
        Was not Java the first language to introduce of compiling the language code to a cross-platform (virtual) machine language so that the compiled program (rather than the source code) code be cross-platform or was this idea borrowed from elsewhere? I appreciate the fact that the Java byte-code is, itself, just another language but there are benefits with statically checked languages to perform these checks during development time rather than as a runtime initialisation check.
      </p>
      <p>
        <em>No. </em><a href="EmacsLisp.html">EmacsLisp</a> has been doing that for many years, and I don't think it was the first either.<em></em>
      </p>
      <p>
        So then, what was the first language to
      </p>
      <ul>
        <li>
           designed to be cross-platform (by re-compiling) <em>(if I had to guess, I'd guess either COBOL or FORTRAN... but I wouldn't be surprised if it was some other language I've never heard of before)</em>
        </li>
        <li>
           designed to be cross-platform, even without re-compiling <em>(the </em><a href="PascalLanguage.html">PascalLanguage</a> p-code was pretty early... see below)<em></em>
        </li>
        <li>
           designed to be statically checked
        </li>
        <li>
           ?
        </li>
      </ul>
      <p>
        From <em>Introduction to Pascal for Scientists</em> (1981) Chapter 1:
      </p>
      <dl>
        <dt> </dt>
        <dd>The <a href="PascalLanguage.html">PascalLanguage</a> was developed in the late 1960s by <a href="NiklausWirth.html">NiklausWirth</a> at the ETH in Zurich; it was derived primarily from <a href="AlgolSixty.html">AlgolSixty</a>...</dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd>A compiler that translates the Pascal (or other language) statements into machine language directly is the most common type and is the least "portable" since it will not operate on any other make of computer. A useful compromise has been developed by Wirth and colleagues and refined by the <a href="UcsdPascal.html">UcsdPascal</a> project, where the compiler translates the statements not into the code for any specific machine but into instructions for a hypothetical computer or <em>p-machine.</em> This <em>p-code</em> can then be executed by simply writing a program to execute each of the insructions of the hypothetical machine's instruction set. This is a <em>p-code interpreter,</em> and such interpreters provide relatively fast execution of Pascal programs for a number of minicomputers and microprocessors. Such p-code programs also occupy a minimum of space. [emphasis in original]</dd>
      </dl>
      <p>
        What's not clear was when "Wirth and colleagues" developed the p-code and p-machine idea. Was it "in the late 1960s" when Pascal was first developed?
      </p>
      <hr/>
      <p>
        The idea of macros also seem to be a groundbreaking idea.
        Some of the comments hint that macros were first implemented in an early assembly language.
        Which was ... what?
      </p>
      <ul>
        <li>
           They've also been claimed to have been first introduced in COBOL 60, but I am dubious that they appeared in Cobol that early, and I share the impression that they appeared in early assembly - however there was clearly some kind of sharp evolution in the concept of macros that occurred in <a href="DougMcIlroy.html">DougMcIlroy</a>'s 1960 paper on the subject (which I haven't read, but was widely cited by other high profile research), so he seems to deserve some credit. I've been looking around for more clues but haven't gotten anything definitive yet.
        </li>
      </ul>
      <hr/>
      <p>
        Erlang:
      </p>
      <p>
        Erlang as not been classified as groundbreaking because only the concurrent aspects has been taken into account. However, error management and organisation of the code into a supervision tree is another fundamental concept of Erlang that is really groundbreaking. This is something that is properly explain in Joe Armstrong Thesis: 
        <a href="http://www.sics.se/~joe/thesis/armstrong_thesis_2003.pdf">http://www.sics.se/~joe/thesis/armstrong_thesis_2003.pdf</a>
      </p>
      <p>
        -- Mickaël Rémond
      </p>
      <hr/>
      <p>
        Isn't it wrong to call Java the first language with inner classes? AFAIK, Simula already had inner classes.
      </p>
      <p>
        <em>IIRC, C++ has </em><a href="InnerClass.html">InnerClass</a>s.<em> --</em><a href="AnonymousDonor.html">AnonymousDonor</a>.
      </p>
      <hr/>
      <p>
        Whenever I read the <a href="GroundBreakingLanguages.html">GroundBreakingLanguages</a> page, I have two conflicting thoughts:
      </p>
      <ul>
        <li>
           On a wiki, a page like this is going to end up with <em>every</em> language listed, because everyone thinks there is something ground breaking about their favorite.
        </li>
        <li>
           Every language <em>should</em> be on this list, because: Why was a whole new language invented if it didn't have something worthwhile to offer?
        </li>
      </ul>
      <p>
        -- <a href="RobertFisher.html">RobertFisher</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryProgrammingLanguage.html">CategoryProgrammingLanguage</a> <a href="CategoryDiscussion.html">CategoryDiscussion</a>
      </p>
    </div>
  </body>
</html>