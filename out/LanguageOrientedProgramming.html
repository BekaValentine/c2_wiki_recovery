<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Language Oriented Programming
      </h1>
      <p>
        Language Oriented Programming just got a face-lift (Nov, 2004). <a href="SergeyDmitriev.html">SergeyDmitriev</a> has published and article titled <em>Language Oriented Programming: The Next Programming Paradigm</em>. See <a href="http://www.onboard.jetbrains.com/articles/04/10/lop/.">http://www.onboard.jetbrains.com/articles/04/10/lop/.</a> His argument is that LOP will be the next programming paradigm after OOP <em>(oh boy, the </em><a href="NextBigThing.html">NextBigThing</a>)<em>.</em>
      </p>
      <p>
        It seems pretty compelling to me (but then again, I'm the editor of the article, and an employee of <a href="JetBrains.html">JetBrains</a>). We're looking for feedback, discussion, and especially criticism. I'm sure the wikizens have an opinion on this. What say ye?
      </p>
      <hr/>
      <p>
        I was going to respond on <a href="LambdaTheUltimate.html">LambdaTheUltimate</a>, where there's currently a forum discussion on this topic, but Wiki lets me link more easily...
      </p>
      <p>
        First off, there's a large amount of prior research in this direction, and not just in the Lisp world.  I think it's worth taking a look at:
      </p>
      <ul>
        <li>
           <a href="MlLanguage.html">MlLanguage</a> (ML initially stood for "<a href="MetaLanguage.html">MetaLanguage</a>", and was designed to make construction of compilers and DSLs easy).  There's a good presentation on how to write a DSL in Ocaml in a day at <a href="http://www.venge.net/graydon/talks/mkc/html/index.html.">http://www.venge.net/graydon/talks/mkc/html/index.html.</a>
        </li>
        <li>
           <a href="RebolLanguage.html">RebolLanguage</a>.  Rebol was initially supposed to be a universal data-exchange language.  <a href="EverythingIsa.html">EverythingIsa</a> dialect in Rebol, allowing you to adjust the language on the fly.  There's native BNF (<a href="BackusNaurForm.html">BackusNaurForm</a>) support, and execution can alter the parsing of subsequent tokens (this fact makes Rebol impossible to compile, but also makes it ideal for DSLs).  From the sample Rebol code I've seen, it looks a bit easier than the <a href="LanguageOrientedProgramming.html">LanguageOrientedProgramming</a> examples in the article.
        </li>
        <li>
           Preprocessors + combinator libraries in <a href="HaskellLanguage.html">HaskellLanguage</a>.  The two that come to mind are <a href="HaskellDb.html">HaskellDb</a> and WASH.  <a href="HaskellDb.html">HaskellDb</a> is a replacement for SQL that lets you write <a href="RelationalAlgebra.html">RelationalAlgebra</a> expressions directly in Haskell.  WASH is a webapp framework that's kind of like <a href="ActiveServerPages.html">ActiveServerPages</a> for Haskell, except it tends to integrate a bit better because Haskell code is already declarative.  There's also Fudgets, a GUI library in pure-functional style.
        </li>
        <li>
           D-expressions in <a href="DylanLanguage.html">DylanLanguage</a>.  There's a paper on this by JonathanBachrach, and it's the implementation strategy in FunctionalDeveloper.  This is a way to tap into the <a href="AbstractSyntaxTree.html">AbstractSyntaxTree</a> of parsed Dylan code fragments, except it actually works at a slightly higher level (the skeleton syntax tree).  It then provides a <a href="GenericFunction.html">GenericFunction</a> interface to manipulate code fragments.  Basically all of Dylan syntax is represented as D-expressions in FunctionalDeveloper, which is an elegant approach that unfortunately leads to impenetrable error messages when using that IDE.  DSLs like the Dylan User Interface Manager are done using Dylan macros.
        </li>
        <li>
           <a href="DavidMoon.html">DavidMoon</a>'s ideas on defsyntax (<a href="http://www.archub.org/arcsug.txt).">http://www.archub.org/arcsug.txt).</a>  I'm not sure I think this is a terribly great approach; BNF already provides a good mechanism for defining syntax, and providing an ad-hoc alternative just seems like a needless fragmentation.
        </li>
        <li>
           The internals of <a href="ParrotCode.html">ParrotCode</a>.  Parrot is written in <a href="CeeLanguage.html">CeeLanguage</a>, but it's C that's heavily preprocessed by various <a href="PerlLanguage.html">PerlLanguage</a> scripts.  As a result, there's a DSL to define PMCs, to define opcodes, to define JIT operations, and so on.  DanSugalski gave a presentation about the use of DSLs in Parrot at some recent convention.
        </li>
      </ul>
      <p>
        As for whether <a href="LanguageOrientedProgramming.html">LanguageOrientedProgramming</a> is a good idea, I see two big <a href="StumblingBlocksForDomainSpecificLanguages.html">StumblingBlocksForDomainSpecificLanguages</a> (content moved there, hope you don't mind.)
      </p>
      <hr/>
      <p>
        Previously, discussion of LOP on this wiki was based on <a href="HelmutLeitner.html">HelmutLeitner</a>'s interpretation of it. See <a href="http://www.wikiservice.at/thelop/wiki.cgi?LanguageOrientedProgramming">http://www.wikiservice.at/thelop/wiki.cgi?LanguageOrientedProgramming</a> for information about that. The 'new' LOP is technically derived from the same source, which was an article titled <em>Language Oriented Programming</em> by MartinWard (<a href="http://www.dur.ac.uk/martin.ward/martin/papers/middle-out-t.pdf).">http://www.dur.ac.uk/martin.ward/martin/papers/middle-out-t.pdf).</a> However, Helmut took a very different approach to it, so his LOP is not the same as <a href="SergeyDmitriev.html">SergeyDmitriev</a>'s LOP.
      </p>
      <hr/>
      <p>
        Xactium has some interesting technology that realizes this vision (their whole tool is defined using itself).  A book can be freely downloaded from their website (<a href="http://www.xactium.com/).">http://www.xactium.com/).</a> It seems that this technology has migrated over to this other website (<a href="http://www.ceteva.com/).">http://www.ceteva.com/).</a> There you can find everything formerly located at Xactium's site and much more.
      </p>
      <hr/>
      <p>
        The early access to Meta-Programming System is started in June 2005 at <a href="http://www.jetbrains.com/mps.">http://www.jetbrains.com/mps.</a>
      </p>
      <hr/>
      <p>
        Would the opposite be "attribute-based" programming, such as a <a href="BusinessRulesMetabase.html">BusinessRulesMetabase</a>?
      </p>
      <p>
        <em>Not necessarily.  The definition at the top of </em><a href="BusinessRulesMetabase.html">BusinessRulesMetabase</a> states, "[r]ather than coding <a href="BusinessRules.html">BusinessRules</a> in a generic language Java, C++ etc.[, p]ut them in a high level language/database explicitly for the purpose of storing and enforcing business rules."  I would interpret a high level language for storing (and representing) and enforcing business rules as being something that could conceivably employ <a href="LanguageOrientedProgramming.html">LanguageOrientedProgramming</a>.<em></em>
      </p>
      <p>
        <em>If it's a language, I wouldn't call it a "___base". I dissagree with that definition.</em>
      </p>
      <hr/>
      <p>
        Didn't this used to be called 'metalinguistic abstraction'? Why did it need a new name? -- <a href="BryanEdds.html">BryanEdds</a>
      </p>
      <p>
        Hi Bryan, I see 'metalinguistic abstraction' is an abstract concept that doesn't tell you how to construct the language. It also assumes, from what I read that an application specific language is the results. My concept is more concrete by providing a dictionary and rules, so you can see it as an specific implementation of the 'metalinguistic abstraction'. On the other hand, it has a more general forcus as a cross-application meta-language, with a special focus on reusable libraries and modules. -- <a href="HelmutLeitner.html">HelmutLeitner</a>
      </p>
      <hr/>
      <p>
        The article about language oriented programming is full of nonsense and tautology. First, programming has always been "language oriented" so the article title and concept is meaningless. That is how you program: you use a computer programming language. The title "language oriented programming" is redundant, since programming has always been oriented around programming languages. Second, in the article he says he never thinks of programs as a list of things to do (set of instructions). This is complete nonsense. What is the first thing that comes to mind when you want to build an input form on a website: first I want the user to input his data, then I want to collect the data, then I want to store it in a database. These are all very procedural ways of thinking, and this model works well.
      </p>
      <hr/>
      <p>
        <a href="CategoryMetaprogramming.html">CategoryMetaprogramming</a>
      </p>
    </div>
  </body>
</html>