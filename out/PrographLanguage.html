<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Prograph Language
      </h1>
      <p>
        Prograph is a <a href="GraphicalProgrammingLanguage.html">GraphicalProgrammingLanguage</a> developed somewhere in eastern Canada back in the wonder years of the early 90s, sold for some time by a company called Pictorius. See <a href="http://www.tritera.com/prograph.html">http://www.tritera.com/prograph.html</a>
      </p>
      <p>
        There is an effort, very low-energy apparently, called the "Open Prograph Initiative" to make Prograph into an <a href="OpenSource.html">OpenSource</a> project: <a href="http://www.ospgli.org/">http://www.ospgli.org/</a>
      </p>
      <p>
        <em>The "low-energy" evaluation still holds true, unfortunately. -- </em>RonCraig, OSPGLI<em></em>
      </p>
      <p>
        A commercial Macintosh software development environment exists that supports Prograph.  It is the Marten IDE by Andescotia.  See <a href="http://www.andescotia.com">http://www.andescotia.com</a>
      </p>
      <hr/>
      <p>
        Prograph is a language I wish had become more popular. The software itself was fantastic and produced VERY fast code. This was a programming environment way ahead of its time for the late '80s, but it suffered from poor marketing and poor documentation. 
      </p>
      <p>
        The first half of the tutorial tried to teach OOP to beginners using various farm animals as objects, AND teach you how to use the Prograph GUI all at the same time--may as well have used "pizza" or "fireman", the farm animals example stunk! The second half of the tutorial dropped all farm terminology but abruptly shifted to advanced OOP concepts, with only little information about the use of the compiler and its UI.
      </p>
      <p>
        A few years later the product was sold to another company. (Insert: Actually, it was just a reorganization of the first company, which had gone bankrupt; they tried and failed three times. See the article on Wikipedia for more info. -RonCraig) After that, there were too many bugs in the compiled code to use it reliably. It was never properly updated with the new Macintosh OS APIs and the code it compiled was becoming more bloated. The engineers were actually busy porting it to Windows, and like many other software companies they completely abandoned the Macintosh versions to jump on the MicrosoftBandwagon.
      </p>
      <p>
        The completely graphical editor was great in that it reduced the requirement of typing down to the bare minimum: object names, constants, mathematical expressions, and comments. I don't know of any modern environment that offers graphical programming capability to this extent--even the so-called "Visual" Basic is actually more BASIC code with a window & control editor than any real visual programming.
      </p>
      <p>
        A Prograph programmer knows very easily at a glance how efficient or inefficient the code really is:
      </p>
      <ul>
        <li>
           accessing a global variable means visually dragging an "elastic band" from the top of your program to where it's needed. If a function or method is buried deeply in the flowchart hierarchy, the line must enter the top of an object, then into the next object inside that one, recursively until it gets to where it is needed.
        </li>
      </ul>
      <p>
        <a href="MicroSoft.html">MicroSoft</a> stuff, but actually <em>composed of graphical primitives</em> -- dataflow <a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a> language. In other words, it's a <a href="GraphicalProgrammingLanguage.html">GraphicalProgrammingLanguage</a>.
      </p>
      <p>
        Programming in Prograph is an unusual challenge and a heady treat. Classes, methods, primitives, loops, and so forth are created by means of various mouse-clicks and drags, and the only typing you ever do is naming the little block you just created. Prograph code is in fact a web of dataflow connections between functions, and when it executes in interpreter mode you can debug the stuff by actually watching the values of objects flow between nodes in the hypergraph. And it compiles.
      </p>
      <ul>
        <li>
           When looking for places to optimize code, it's easy to spot an inefficient method with too many hand-me-down variables because a spiderweb of lines is extruding from its edges into all other directions.
        </li>
      </ul>
      <p>
        I gave up on Prograph around the same time the new company gave up on their Macintosh version, and haven't seen anything close to the elegance of this from anywhere. 
      </p>
      <p>
        -- <a href="CarstenKlapp.html">CarstenKlapp</a>
      </p>
      <hr/>
      <p>
        Perhaps <a href="LabView.html">LabView</a> [<a href="GeeLanguage.html">GeeLanguage</a>] is the spiritual descendant of this language? -- <a href="MikeSmith.html">MikeSmith</a>
      </p>
      <p>
        <em>Doubtless a relative. -- </em><a href="BillTozier.html">BillTozier</a><em></em>
      </p>
      <p>
        No. Neither invented the notion of graphical programming, and both were developed at very close to the same time by different people. Reference points:
      </p>
      <ul>
        <li>
           Prograph by Phil Cox and Tomasz Pietrzykowski, Acadia University, in Wolfville, Nova Scotia; paper published in 1985 ACM SIGSMALL. 
        </li>
        <li>
           G (<a href="LabView.html">LabView</a>) by Jeff Kodosky of National Instruments Corporation, first version released in 1986.
        </li>
      </ul>
      <p>
        Both are graphical languages, but that appears to be the sole connection (caveat, this is just based on web searching, not personal knowledge).
      </p>
      <hr/>
      <p>
        I've been a fan of <a href="GraphicalProgrammingLanguage.html">GraphicalProgrammingLanguage</a>s since the 1970s. On the other hand, none of them so far has been a <a href="SilverBullet.html">SilverBullet</a>. <a href="GeeLanguage.html">GeeLanguage</a>/<a href="LabView.html">LabView</a> is one of the most famous successful ones, but it is a <a href="DomainSpecificLanguage.html">DomainSpecificLanguage</a>.
      </p>
      <p>
        <em>Actually there's nothing about the G language itself that is domain-specific. The </em><a href="LabView.html">LabView</a> components are domain-specific (mainly data acquisition and control), of course, but the programming model isn't.<em> [Rest of discussion moved to </em><a href="GeeLanguage.html">GeeLanguage</a>.]
      </p>
      <hr/>
      <p>
        <a href="CategoryProgrammingLanguage.html">CategoryProgrammingLanguage</a>
      </p>
    </div>
  </body>
</html>