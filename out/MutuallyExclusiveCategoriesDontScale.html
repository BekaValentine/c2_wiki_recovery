<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Mutually Exclusive Categories Dont Scale
      </h1>
      <p>
        Somewhat related to <a href="LimitsOfHierarchies.html">LimitsOfHierarchies</a>, but not the quite the same, lists of mutually-exclusive (M.E.) categories or types are often a big source of scalability problems I have observed after working and contracting in a dozen+ companies of all sizes. The simplest example is a M.E. category system used to describe products, actions, stages, etc. When the system starts out small and simple, such may be satisfactory. However, as it grows in size or complexity, mutually-exclusive categories or sub-types start to fall apart. Often things fall into more than one category, for example, and to keep a system designed for M.E. you have to create a kind of <a href="CartesianJoin.html">CartesianJoin</a> of factors for new codes if you want to capture multiple classification slots. 
      </p>
      <p>
        As you might expect, I am going to say some kind of system generally based on or influenced by <a href="SetTheory.html">SetTheory</a> will scale better. However, it seems many existing tools are not really well-tuned to deal with sets. Set handling in tools is kind of an after-thought in many cases such that the work to prepare for them may be <a href="PrematureAbstraction.html">PrematureAbstraction</a> especially when <a href="FutureDiscounting.html">FutureDiscounting</a> is used. But if you are preparing up-front for expected uncertainty and change, then the bit of extra effort up front may well be worth it.
      </p>
      <p>
        Any list beyond about 15 will usually start showing signs of trouble. I challenge anybody to provide a list of M.E. classifications from the real world beyond 20 that are free of problems or partial duplication.
      </p>
      <p>
        --top
      </p>
      <p>
        <em>atoms -> elements</em>
      </p>
      <p>
        <em>molecules -> chemicals</em>
      </p>
      <p>
        Huh? 
      </p>
      <p>
        <em>There are hundreds of mutually exclusive (M.E.) classifications for elements: for example, there is one mutually exclusive category per element, based on the number of protons in the nucleus. There are also mutually exclusive categories based on the number of valence electrons for each atom in rest-state, and a mutually exclusive category for the noble gasses, and so on. Similarly, there are millions of organic and inorganic chemical compounds classified exclusively in terms of both their atomic structure and the physical bonds between them - millions of mutually exclusive distinctions. These two examples are, to a lucid and rational reader, very damning to your above assertion that </em><a href="MutuallyExclusiveCategoriesDontScale.html">MutuallyExclusiveCategoriesDontScale</a>, and are certainly higher on the <a href="EvidenceTotemPole.html">EvidenceTotemPole</a> than your <a href="ArgumentFromAuthority.html">ArgumentFromAuthority</a> ("I observed it in a dozen+ companies; the categories or sub-types start to fall apart; believe me!")<em></em>
      </p>
      <p>
        Plus, it's hard to test scaling unless God gets bored with the existing set.
      </p>
      <p>
        <em>Huh?</em>
      </p>
      <hr/>
      <p>
        How about a real example of your experiences, where things worked before and didn't when the list grows to about 15?
      </p>
      <p>
        <em>The list of "action codes" started out something like this:</em>
      </p>
      <code>
        IA - install product A<br/>
        UA - upgrade product A<br/>
        TA - test product A<br/>
        RA - remove product A<br/>
        IB - install product B<br/>
        UB - upgrade product B<br/>
        TB - test product B<br/>
        RB - remove product B<br/>
      </code>
      <p>
        Then when more bundled deals appeared, one could often do the same thing to both product lines. Thus, a new set of codes was introduced:
      </p>
      <code>
        I2 - install product A and B<br/>
        R2 - remove product A and B<br/>
      </code>
      <p>
        Upgrading and testing at the same time were relatively rare, so they were generally not tracked as being "both". However, third and fourth product lines appeared and the list indeed grew a <a href="CartesianJoin.html">CartesianJoin</a> feel to it. Now the codes are almost useless and are being supplanted with a more set-oriented architecture (independent of my involvement), but they still try to use the old codes because everybody has grown used to them.
      </p>
      <p>
        It is now clear that the most normalized approach is to not hard-wire the action to the product kind, and that there may be multiple actions per customer visit. However, I agree that doing this early on when there were fewer and simpler products may have been <a href="PrematureAbstraction.html">PrematureAbstraction</a>. 
      </p>
      <p>
        Another example is Email folders. Sometimes I want to search by sender, sometimes by project name, sometimes by project category(s), sometimes by project requester, sometimes by sent-date, sometimes by attachment type, etc. No single list of folders is sufficient to do this, and even with search options one has to select a particular folder to use the search options with our lame email software.
      </p>
      <hr/>
      <p>
        See also: <a href="LimitsOfHierarchies.html">LimitsOfHierarchies</a>, <a href="GranularityOfVariation.html">GranularityOfVariation</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryHierarchy.html">CategoryHierarchy</a>
      </p>
    </div>
  </body>
</html>