<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Homoiconicity Classification
      </h1>
      <p>
        [Note to those arriving here via Google: most of the following represents ideas and informal discussions between various wiki users, and is not represented to necessarily be authoritative in any particulars; it may or may not be. Caveat emptor.]
      </p>
      <p>
        [<em>Note to those arriving here from anywhere:  the caveat above should be assumed for every page in this wiki.</em>]
      </p>
      <p>
        [Certainly. I only added this note because the flavor of the below seemed to me to come across with a definitive kind of tone, and last year I noticed that a similar homoiconic page was very popular with google -- which I noticed only after seeing it <strong>cited</strong> elsewhere on the web, which worried me a bit. We're still arguing the topic, I don't want someone to immortalize in some textbook their mistaken understanding of our arguments! :-]
      </p>
      <hr/>
      <p>
        A subjective continuum from strong to weak.
      </p>
      <p>
        <strong>Strong</strong>
      </p>
      <ul>
        <li>
           Lisp
        </li>
        <li>
           TCL
        </li>
        <li>
           most machine languages (but the practice is frowned upon)
        </li>
        <li>
           dBASE & <a href="FoxPro.html">FoxPro</a>
        </li>
        <li>
           Smalltalk
        </li>
        <li>
           .Net languages (including C# and VB.Net)
        </li>
        <li>
           Assembly
        </li>
        <li>
           Java
        </li>
        <li>
           C, C++, COBOL, FORTRAN, Pascal, etc.
        </li>
      </ul>
      <p>
        <strong>Weak</strong>
      </p>
      <hr/>
      <p>
        <strong>Perhaps the following bit taken from </strong><a href="HomoiconicLanguages.html">HomoiconicLanguages</a> is worth factoring in:<strong></strong>
      </p>
      <ul>
        <li>
           <a href="LispFamily.html">LispFamily</a>:
          <ul>
            <li>
               data/code element type: atom (or defined atom?)
            </li>
            <li>
               block type: list/tree of atoms
            </li>
            <li>
               evaluator: eval (apply?)
            </li>
            <li>
               mutator: list operations
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <a href="TracLanguage.html">TracLanguage</a>
        </li>
      </ul>
      <ul>
        <li>
           <a href="GooLanguage.html">GooLanguage</a>:
          <ul>
            <li>
               data/code element type: Goo object
            </li>
            <li>
               block type: AST of Goo objects
            </li>
            <li>
               evaluator: REPL (form -> AST -> C -> gcc -> dynamic link)
            </li>
            <li>
               mutator: generic functions
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <a href="IoLanguage.html">IoLanguage</a>
        </li>
      </ul>
      <ul>
        <li>
           <a href="JayLanguage.html">JayLanguage</a>
          <ul>
            <li>
              data/code type:  formally,  the atomic representation '5!:0' (nested boxes of strings), but more commonly the linear representation '5!:5' (simple strings containing J code).  You can hack it down to the bit level using the internal representation '3!:1'.
            </li>
            <li>
               block type: an array of the data/code type.
            </li>
            <li>
               evaluator:  Many ways.  Most commonly, J code strings are executed with '".' (do).  Also used are: '~' (evoke) and '128!:2' (apply).  Atomic reps are usually "given life" with 5!:1, but can also be evoked wit  '@.' (agenda), '^:' (power), and ';.' (cut).  Hmm, almost anything involving gerunds.  In a sense, the copulae '=:' and '=.' too.  An interal rep can be changed back using 3!:2.
            </li>
            <li>
              mutators:  any normal data mutator in the language.  '{' (select), '}' (amend), etc probably most useful.  If manipulating as strings, using ';:' (word formation, the primitive that tokenizes J code (i.e. the builtin function that implements J's lexer)) along with the common 'subs' and 'rplc' verbs work well.
            </li>
            <li>
              extras:  For the masochistic, the 15!: family can be used to access J's memory space and do anything you like.  Of course, this has nothing to do with homoiconicity.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <a href="FactorLanguage.html">FactorLanguage</a>, <a href="JoyLanguage.html">JoyLanguage</a>:
          <ul>
            <li>
               data/code type: word
            </li>
            <li>
               block type: bracketed list of words
            </li>
            <li>
               evaluator: eval, higher order functions (IF, loops, linrec etc.)
            </li>
            <li>
               mutator: stack manipulators along with the block quote and unquote operators
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <a href="PostScript.html">PostScript</a>
          <ul>
            <li>
               data/code type: operator
            </li>
            <li>
               block type: executable array of operators
            </li>
            <li>
               evaluator: exec, higher order operators (conditionals, loops and more)
            </li>
            <li>
               mutator: array operations
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <a href="PrologLanguage.html">PrologLanguage</a>
          <ul>
            <li>
               (notes from a <a href="FunctionalProgramming.html">FunctionalProgramming</a> course on the web)
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <a href="RebolLanguage.html">RebolLanguage</a>:
          <ul>
            <li>
               data/code element type: value
            </li>
            <li>
               block type: block!
            </li>
            <li>
               evaluator: do
            </li>
            <li>
               mutator: series operations
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>
          <ul>
            <li>
               data/code type: string
            </li>
            <li>
               evaluator: evaluate: (readFrom: just does evaluate: plus type checking)
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <a href="SnobolLanguage.html">SnobolLanguage</a>
          <ul>
            <li>
               similar to TCL?
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <a href="TclLanguage.html">TclLanguage</a>: 
          <ul>
            <li>
               data/code element type: string token
            </li>
            <li>
               block type: string ("everything is a string")
            </li>
            <li>
               evaluator: eval
            </li>
            <li>
               mutator: string functions
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <a href="TexLanguage.html">TexLanguage</a>
          <ul>
            <li>
               A macro can be taken apart into its tokens and constructed from its tokens. Even the command name can be (de)composed.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <a href="XsltLanguage.html">XsltLanguage</a>
          <ul>
            <li>
               data/code element type: node (XML Infoset)
            </li>
            <li>
               block type: nested nodes and node-sets
            </li>
            <li>
               evaluator: none (?)
            </li>
            <li>
               mutator: templates
            </li>
          </ul>
        </li>
      </ul>
      <p>
        Here is the above Lisp example, in REBOL, as a console session:
      </p>
      <code>
        >> b: 3<br/>
        == 3<br/>
        >> b<br/>
        == 3<br/>
        >> a: [b: 15]<br/>
        == [b: 15]<br/>
        >> a<br/>
        == [b: 15]<br/>
        >> do a<br/>
        == 15<br/>
        >> b<br/>
        == 15<br/>
        >> last a<br/>
        == 15<br/>
        >> change back tail a 37<br/>
        == []<br/>
        >> a<br/>
        == [b: 37]<br/>
        >> do a<br/>
        == 37<br/>
        >> b<br/>
        == 37<br/>
      </code>
      <ul>
        <li>
           <a href="MachineLanguage.html">MachineLanguage</a>
          <ul>
            <li>
               Everything is numbers in the computer's memory. 
            </li>
            <li>
               Code can be modified, constructed and executed at runtime, using the same numeric representation for opcodes that is used to represent data. 
            </li>
            <li>
               Note that <a href="AssemblyLanguage.html">AssemblyLanguage</a> does not qualify, because it uses a symbolic representation of opcodes and operands that differs fundamentally from the representation of data. (Remember that it's not about what the language translates code <em>to</em> under the covers, but how the language is <em>represented</em>.)
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <strong>Disputed</strong>
      </p>
      <ul>
        <li>
           <a href="MalbolgeLanguage.html">MalbolgeLanguage</a>:
          <ul>
            <li>
               <em>Show me a Malbolge interpreter written in itself (or prove that it is possible) and I might believe you. :)</em> <strong>this comment doesn't mean that any language interpreter for language X that is also written in X shows that language X is homoiconic; read the rest of the page</strong> (the latter is directed to general readers of this page, not the original author of the "show me" comment)
            </li>
            <li>
               data/code type: trit (trinary digit)
            </li>
            <li>
               block type: tritword
            </li>
            <li>
               evaluator: interpreter
            </li>
            <li>
               mutator: every instruction modifies the code space
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <a href="ForthLanguage.html">ForthLanguage</a> (maybe):
          <ul>
            <li>
               <em>Nope. Try taking a Forth word, treating it as data, picking out e.g. the loop in the middle of it, delete the loop (leaving just the loop body, not the conditional), and then execute that changed word. Forth doesn't allow that.</em>
              <ul>
                <li>
                   Not the best counter-example: one can manipulate Lisp programs into being malformed as well. Given a Forth word equivalent to (setq b 45), another word could access its code field, find the XT for LITERAL, and change the following cell from 45 to something else, as in your Lisp example. <em>Portable</em> Forth doesn't allow that; the code field structure is unspecified (it could be machine code or ROM!), and many immediate words compile into XTs and inline data outside the scope of the spec (such as BRANCH, ?BRANCH, their target addresses, and literal numbers and strings).  One can manipulate token threaded code fields, but it would be a hack. Forth is fine with dynamic code <em>generation</em> but balks at code <em>mutation</em>.  Many Forth's also provide SEE for <em>introspection</em>, but the output is only for the user and SEE's implementation is not portable.
                  <ul>
                    <li>
                       I think you misunderstood the example. It's not about being well-formed. It's about the language naturally supporting manipulations of code because code and data have the same essential type. Forth lacks this trait. The example seems valid.
                      <ul>
                        <li>
                           The fundamental data type in Forth is the cell (or array of cells). The code field is an array of cells, each containing an XT or inline data, and as such can be manipulated just like any other cell array.  (Similar arguments apply to machine language.)  Note: I'm not arguing for Forth, I'm just feeling out the boundaries of the term "homoiconic".
                        </li>
                        <li>
                           <em>But as I said in the FAQ, none of this is supported </em>'by the language<em>' in either case; it is merely sometimes possible if you're clever, and will break in a different implementation. So it's not really an example of something about the language.</em>.
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <em>That's interesting, I didn't know about SEE. But I wasn't talking about malformed Forth, I just meant an example of "modify the program and then run it".</em>
        </li>
        <li>
           <em>Also note that there is discussion about self-modifying machine code in the above FAQ that would apply to some aspects of this.</em>
          <ul>
            <li>
               Inner interpreter (threaded):
            </li>
          </ul>
        </li>
        <li>
           data/code element type: execution token (XT)
        </li>
        <li>
           block type: dictionary entry (optional header + array of XT's)
        </li>
        <li>
           evaluator: EXECUTE
        </li>
        <li>
           constructor: defining words like ':' and IMMEDIATE words like IF <em>but no portable code mutator</em>
          <ul>
            <li>
               Outer interpreter (which may be stripped out of a turnkey Forth application):
            </li>
            <li>
               <em>How does the this differ from TCL?</em>
            </li>
          </ul>
        </li>
        <li>
           data/code element type: string token
        </li>
        <li>
           block type: string
        </li>
        <li>
           evaluator: EVALUATE
        </li>
        <li>
           mutator: string manipulation words
          <ul>
            <li>
               There is no fundamental data type in Forth; it's untyped. There are two fundamental containers: cells and characters. Forth code is stored in characters, in the form of source; Forth is fully homoiconic when it's used to manipulate its source. Forth's way of doing this is via IMMEDIATE words. You cannot manipulate an already-compiled word in portable Forth (but this is very rare in other homoiconic languages). Forth source maps directly onto the structure of Forth compiled code, because both are represented as linear strings of references to other words. Lisp code is manipulated as a tree; Forth code is manipulated as a string.
            </li>
            <li>
               <em>I sympathize with your argument, it is reasonable given a quick scan through this and related pages. However, your points have in fact been previously addressed, although it can be difficult to see that fact. If interested, I'd recommend re-reading this page again, carefully, and then the </em><a href="HomoiconicFaq.html">HomoiconicFaq</a> page, carefully, and especially <a href="FirstClass.html">FirstClass</a> and <a href="MetaCircularEvaluator.html">MetaCircularEvaluator</a> (since they are much shorter than these other pages, and although they shed only indirect light on the topic, it is potentially bright light).<em></em>
            </li>
            <li>
               <em>There are many points of view presented on these pages, but there certainly are some things to consider, for instance, any language is capable of manipulating its own source code as strings, if only by reading its source file and fiddling with that. Therefore, that ability shouldn't be called "homoiconicity", since essentially all languages can do that, yet the people who coined the term (see history, top of page) meant to distinguish some languages from others.</em>
            </li>
            <li>
               <em>It's also important to be cautious of nuances about source vs interpreted vs compiled. Everyone agrees Lisp is homoiconic. Traditionally, Lisp is compiled as an option, but defaults to interpreted. Its homoiconicity is clear when confined to interpreted S-Expressions, but is less clear for implementations which compile to machine code. Similar concerns apply to interpreted versus compiled Forth (and more so, for reasons concerning Forth previously discussed)</em>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <a href="ObjectsAreDictionaries.html">ObjectsAreDictionaries</a> and many dynamic OOP languages generally treat objects and maps as the same thing. "x.y.z" is simply a reference to a nested map. However, it tends to only apply to object/class structure and not so much to implementation syntax, although Smalltalkers may argue otherwise.
        </li>
      </ul>
      <ul>
        <li>
           <a href="PerlLanguage.html">PerlLanguage</a>
          <ul>
            <li>
               data/code type: scalar variable holding a string
            </li>
            <li>
               evaluator: eval STRING (also eval BLOCK, different thing)
            </li>
            <li>
               note: playing around with strings is just the kind of bussiness Perl enjoys :-) (plus: you can do the same at the AST and bytecode level)
            </li>
          </ul>
        </li>
      </ul>
      <p>
        See the note below about <em>primary language evaluator</em> being an implementation concept. The fact that multiple approaches (string or block, AST, bytecode) are cited makes me wonder, what is the "fundamental datatype" in Perl?
      </p>
    </div>
  </body>
</html>