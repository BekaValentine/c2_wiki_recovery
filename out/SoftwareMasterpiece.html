<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Software Masterpiece
      </h1>
      <p>
        A <a href="SoftwareMasterpiece.html">SoftwareMasterpiece</a> is just that. As in art, architecture, whatever, the main 
        criterion is to withstand the test of time.
        <em>In a field that is only a little more than half a century old (give or take a decade, and not counting Babbage), can we truly say that anything to date qualifies?</em>
      </p>
      <hr/>
      <p>
        There seems to be some disagreement over the definition of <a href="SoftwareMasterpiece.html">SoftwareMasterpiece</a>; 
        see <a href="SoftwareMasterpieceCriteriaDiscussion.html">SoftwareMasterpieceCriteriaDiscussion</a>.  I (Anonymous) propose factoring 
        this page into three separate pages as follows, in the hope of clearing up the 
        confusion. 
      </p>
      <ul>
        <li>
           <a href="CodeMasterpiece.html">CodeMasterpiece</a>
        </li>
        <li>
           <a href="SpecificationMasterpiece.html">SpecificationMasterpiece</a>
        </li>
        <li>
           <a href="UserExperienceMasterpiece.html">UserExperienceMasterpiece</a>
        </li>
      </ul>
      <hr/>
      <p>
        <a href="SoftwareMasterpiece.html">SoftwareMasterpiece</a>(s):
      </p>
      <ul>
        <li>
           <a href="EmacsEditor.html">EmacsEditor</a>
        </li>
        <li>
           <a href="TexTheProgram.html">TexTheProgram</a> <em>and </em><a href="MetaFont.html">MetaFont</a>?<em></em>
        </li>
        <li>
           <a href="SchemeLanguage.html">SchemeLanguage</a> (a thing of beauty) 
        </li>
        <li>
           Is it about the externals or internals?
        </li>
        <li>
           <a href="VmsOperatingSystem.html">VmsOperatingSystem</a>
        </li>
        <li>
           <a href="MumpsLanguage.html">MumpsLanguage</a> "Are you kidding? Please explain."
        </li>
        <li>
           <a href="ZorkGame.html">ZorkGame</a>
        </li>
        <li>
           <a href="LispLanguage.html">LispLanguage</a> (The original, <a href="HomoiconicLanguage.html">HomoiconicLanguage</a> with a <a href="MetaCircularEvaluator.html">MetaCircularEvaluator</a>)
        </li>
        <li>
           <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>
        </li>
        <li>
           <a href="PythonLanguage.html">PythonLanguage</a>
        </li>
        <li>
           cmForth and <a href="ColorForth.html">ColorForth</a>
        </li>
        <li>
           <a href="EclipseEditor.html">EclipseEditor</a> (In the surface it might not look it. But the way it uses OSGi and builds <a href="LateBinding.html">LateBinding</a> onto the JVM is magical)
        </li>
        <li>
           sed (Original from Lee <a href="McMahon.html">McMahon</a> Bell Labs)
        </li>
        <li>
           <a href="RubyLanguage.html">RubyLanguage</a>
        </li>
      </ul>
      <p>
        You can vote on these.  Add new ones only if you've dealt with their source.
      </p>
      <ul>
        <li>
           Huh? I've read the original source to <a href="ZorkGame.html">ZorkGame</a> on DEC 10s, I've read the source to both <a href="TecoEditor.html">TecoEditor</a> and C/elisp emacs, <a href="TexTheProgram.html">TexTheProgram</a>, <a href="MetaFont.html">MetaFont</a>, and lots of Scheme/Lisp interpreters, but whoever said that...vanishingly few have, so I doubt you have! So why the requirement? 
        </li>
      </ul>
      <p>
        See also <a href="ProgramsToRead.html">ProgramsToRead</a>
      </p>
      <p>
        I don't think we should talk about external properties of the programs, because 
        they exist independently of the programs.  I think we should talk about the 
        beauty, cleanness, design and buglessness of the source. 
        I refactored away everything that talks about ideas, not actual pieces of 
        software, because things that are not software are discussed in more detail 
        elsewhere and cannot be software masterpieces. 
      </p>
      <hr/>
      <p>
        Vote exclusion of <a href="SchemeLanguage.html">SchemeLanguage</a> (I added <a href="LispLanguage.html">LispLanguage</a> above). What makes 
        Scheme a masterpiece? Seeing as it's basically just another LISP... Some new 
        stuff, some changes, sure, but does that make a <a href="SoftwareMasterpiece.html">SoftwareMasterpiece</a> innovation 
        compared to the original (<a href="JohnMcCarthy.html">JohnMcCarthy</a>) LISP? Granted I haven't read any Scheme 
        source, but <em>would an improved version of a Picasso, no matter how much </em>
        "improved", ever count as a masterpiece?<em> I think not. -- </em><a href="SimonBrenner.html">SimonBrenner</a>
      </p>
      <hr/>
      <p>
        IMHO, <a href="UnixOs.html">UnixOs</a> ranks as a <a href="SoftwareMasterpiece.html">SoftwareMasterpiece</a>. It has inspired so many and it 
        refuses to die or even become obsolete. -- <a href="JavaSchrod.html">JavaSchrod</a> 
        <a href="TheUnixHatersHandbook.html">TheUnixHatersHandbook</a> tells you otherwise.  I'm a long time Unix user, but I 
        think their criticism hits the point.  -- <a href="PanuKalliokoski.html">PanuKalliokoski</a> 
        It's a funny book, with lots of on-target criticism, but they're all about 
        (highly annoying) side issues, not about Unix per se. The things that make Unix 
        a <a href="SoftwareMasterpiece.html">SoftwareMasterpiece</a> are unrelated to the complaints in that book. -- 
        <a href="DougMerritt.html">DougMerritt</a> ----
      </p>
      <p>
        <em></em><a href="TetrisGame.html">TetrisGame</a>. The game concept has been ported (to almost everything - including buildings! <a href="http://www.blinkenlights.de/arcade/games.en.html">http://www.blinkenlights.de/arcade/games.en.html</a> ) and cloned more times than you can count (look out for the cheap LCD copies in every toyshop), and has spawned innumerable variants, if not an entire genre of games. I'd say it's a <a href="SoftwareMasterpiece.html">SoftwareMasterpiece</a> if only for the fact that I've been playing it since 1991, and I still enjoy every single game. --EarleMartin<em></em>
      </p>
      <hr/>
      <p>
        If "time" was the test, then surely <a href="FortranLanguage.html">FortranLanguage</a> and <a href="CobolLanguage.html">CobolLanguage</a> belong on this list too. -- <a href="BillZimmerly.html">BillZimmerly</a> 
        <em>Which implementation?</em>
      </p>
      <ul>
        <li>
           Just wait a few more years and <a href="FortranLanguage.html">FortranLanguage</a> will make it to the list, it already almost qualifies.
        </li>
      </ul>
      <p>
        How about <a href="SmallTalk.html">SmallTalk</a>?
      </p>
      <p>
        Smalltalk-80 sure was one. As was Xerox's <a href="InterLisp.html">InterLisp</a>-D environment.
      </p>
      <p>
        Functionality, utility, and art are not particularly the same things. These 
        terms shouldn't be loosely thrown around. Just because software is long lived 
        and useful does not mean it is a <em>masterpiece</em>. 
      </p>
      <hr/>
      <p>
        There are two definitions that I use regularly in my own thoughts. A 
        masterpiece is either the best thing you have ever done, or (more importantly) 
        the specific piece of work that proves you are a master. Perhaps this would be 
        more of a "MasterWork" :), with the distinction being important only to me.
      </p>
      <p>
        Being a "master", to my mind, is when your peers consider you to be a master, 
        preferably when they judge you based on your work. -- <a href="JeffBay.html">JeffBay</a>
      </p>
      <hr/>
      <p>
        So, what qualifies <a href="EmacsEditor.html">EmacsEditor</a> as a masterpiece?
      </p>
      <p>
        It has withstood the test of time, and it has proven itself to be quite 
        extensible, to say the least. 
      </p>
      <hr/>
      <p>
        What do you think of the <a href="MathematicaPackage.html">MathematicaPackage</a>? Isn't it a masterpiece?
      </p>
      <p>
        Not if you use <a href="MaximaPackage.html">MaximaPackage</a>. --Anonymous
      </p>
      <p>
        Maxima isn't a masterpiece. Just look at its source code.
      </p>
      <p>
        <em>Mathematica isn't a masterpiece either, just look at the source code...  you </em>
        can't?  oh, never mind then.<em> </em>
        What about the <a href="MathematicaLanguage.html">MathematicaLanguage</a>?
      </p>
      <hr/>
      <p>
        One candidate is sendmail.  Ignore the horrible sendmail.cf syntax -- the 
        program handled and continues to handle a huge stream of email every day.  
        Possibly more than any other mail transfer agent.  One of the earliest 
        widely-used parts of ArpaNet (later the Internet), email may be said to be the 
        foundation upon which remote collaboration was built, and sendmail can be 
        credited for being the software that made it happen. It deserves recognition 
        for its longevity and power. --<a href="StevenNewton.html">StevenNewton</a> 
        Sorry, please not sendmail.  See chapter 4 of the <a href="TheUnixHatersHandbook.html">TheUnixHatersHandbook</a>, or at 
        least the small part of it that discusses the sendmail program itself and not 
        the major portions that discuss all sorts of other mail-related software 
        behaving badly, but not having anything to do with sendmail other than trying 
        to lay blame there because <em>sendmail is the ubiquitous MTA on the Internet</em> 
        and just about every mail message with a problem somewhere will have touched a 
        sendmail daemon. 
        <em>It may not be beautiful, but it enabled email to grow to the prominence it </em>
        has today, and it continues to handle massive volumes of messages (Sadly, most 
        of them are spam).  So what are the criteria? Can we call something a 
        masterpiece because of its place in the genre? Would the Model T be a 
        masterpiece? Why not?<em> </em>
        Because popularity doesn't equal masterpiece.  Being a masterpiece is about 
        aesthetics, it's about beauty, it's about elegance and simplicity.  If it isn't 
        beautiful, it isn't a masterpiece no matter what it accomplished.  A 
        masterpiece should inspire the viewer, it should make you want to do something 
        just like that, it should serve as a model of perfection or near perfection.  
        Windows dominates the computer OS market, no competitor is even close, but it 
        isn't a masterpiece of OS design.  Masterpiece's aren't always the winner, or 
        the most popular, <a href="WorseIsBetter.html">WorseIsBetter</a> for the masses.  But the masterpieces inspire 
        and influence future designs far more than reqular stuff.  As a language, Lisp 
        is a masterpiece, and you can see that by how many of it's features have made 
        it into other languages over the years.  Most languages are still in the 
        process of reinventing Lisp.  I'd say <a href="SmallTalk.html">SmallTalk</a> is a masterpiece for the same 
        reason. 
        No, not sendmail.  But the <a href="QmailSystem.html">QmailSystem</a> is a masterpiece.  sendmail works, but 
        qmail not only works better, it is beautiful.  -- <a href="RalphJohnson.html">RalphJohnson</a>
      </p>
      <p>
        IMNSHO, sendmail is the #1 example of a program that is very far from being 
        software masterpiece.  BIND is another high candidate.  Qmail might be a 
        software masterpiece in reliability (I don't know), but not usability - its 
        configuration and weird magical e-mail addresses (or were those from ezmlm?) 
        are a hairy ball. 
      </p>
      <p>
        sendmail is an anti-masterpiece in that it inspired me to write my own mail server because that would be easier (it proved to be *much* easier, in fact) than getting sendmail to work correctly for a very typical network. So, it inspired, but not in the way a masterpiece should.
      </p>
      <hr/>
      <p>
        Software Masterpiece: A program in the developer's mind before the first line 
        of code is written (It goes down hill from there). 
        <em>Just wanted to say that the above definition of a Software Masterpiece is a </em>
        masterpiece in itself. You really nailed it, in a very deep way. Sorry for the 
        interruption, back to your regular programming.<em> ----</em>
        Someone placed <a href="RubyLanguage.html">RubyLanguage</a> on the list. I'd disagree on the grounds that it's 
        too young and perhaps unproven to merit being considered a masterpiece. Perhaps 
        when they're on version 10? 
        Ruby was created on February 24, 1993, according to <a href="WikiPedia.html">WikiPedia</a>, making it over 
      </p>
      <ol>
        <li>
           years old now.  Is that too young? 
        </li>
      </ol>
      <p>
        <em>Compared to something like Emacs, yes.</em>
        Any language that breaks itself between updates and flip-flops between syntactic systems from <em>minor version to minor version</em> is absolutely not a candidate for inclusion in a list of software masterpieces. Inclusion of Ruby is laughable. I don't see Perl up there and its got a far more glorious and storied history than Ruby. I don't know that Python belongs, either, though perhaps its successful and consistent use of limited syntax is worthy of honorable mention (and perhaps some CPython implementation bits are themselves masterpieces, but this does not extend to the entire project).
      </p>
      <hr/>
      <p>
        Some possibilities in various genre:
      </p>
      <ul>
        <li>
           rsync (no way, the handling of lost connections was abysmal yet in 2002)
        </li>
        <li>
           Adobe Photoshop (no way, the last time I used photoshop is was very flaky - that was quite some time ago, but no way can this be a software masterpiece) 
          <ul>
            <li>
               you must try the present iteration of Photoshop - it is truly a masterpiece for <a href="PersonalUseComputing.html">PersonalUseComputing</a>. -- 2008
            </li>
            <li>
               <em>It's too cluttered and confusing.</em>
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <p>
        The deepest meaning of this page is that there is little agreement on which software are masterpieces, perhaps because as a field software 
        engineers/programmers pay little respect to learning from the past.
      </p>
      <ul>
        <li>
           It is more than that, it is what is and what continues to be used because <a href="ItWorks.html">ItWorks</a>, it is Useful, Useable and Used.
        </li>
      </ul>
      <p>
        <a href="LiterateProgramming.html">LiterateProgramming</a> would encourage us to read good programs like books.  But 
        which good programs are these?  As a profession we need clarify what our 
        'scriptures' are.	-- RobinChauhan 
      </p>
      <hr/>
      <p>
        I would say <a href="PostScript.html">PostScript</a> probably fits the bill.  I haven't really read the 
        source code of any implementations, but it works so well that you generally 
        don't see that it's there.  I'd say that's a good indication of mastery.
      </p>
      <hr/>
      <p>
        <a href="ColorForth.html">ColorForth</a> is a masterpiece.  It embodies <a href="ChuckMoore.html">ChuckMoore</a>'s decades of experience in 
        refining the <a href="ForthValues.html">ForthValues</a> of minimalist design. Reading it is like seeing an 
        Aikido master effortlessly deflect half a dozen attackers; what Chuck achieves 
        seems impossible in the tiny amount of code involved. 
      </p>
      <hr/>
      <p>
        I believe <a href="LuaLanguage.html">LuaLanguage</a> qualifies because it is a very compact implementation of a simple and elegant language, written in a very portable style of C. Not only is it production quality, shipping in many products, but it is an exemplar learning tool. It has a one pass parse that directly emits the IL, a unique implementation of closures using a technique called upvalues, and several other innovative features. The authors are also very open about explaining and documenting their work. It's a real contribution to the art.
      </p>
      <hr/>
      <ul>
        <li>
           X11 <a href="XwindowProtocol.html">XwindowProtocol</a>, whilst the implementation may be arguably inelegant, the design and extensibility definitely are elegant. 
        </li>
        <li>
           telnet, it is inconceivable that such ugly programming forms the basis of networking over 20 yrs. (I find that ugly coded programs can be regarded as a masterpiece; masterpieces have undeniable effects in the computing world and technical merit, rather than to depend on the taste for coding style of various Wikipedia contributors.)
        </li>
        <li>
           <a href="PostScript.html">PostScript</a> definitely.
        </li>
        <li>
           Google; no need to download! <em>Which of the various </em><a href="GoogleTechnology.html">GoogleTechnology</a> are you referring to?<em> </em>
        </li>
        <li>
           xv, once ubiquitous image viewer
        </li>
        <li>
           <a href="WordPerfect.html">WordPerfect</a> 5.1, best word processor ever.
        </li>
      </ul>
      <hr/>
      <p>
        GNU <a href="ScreenMultiplexor.html">ScreenMultiplexor</a> is definitely a masterpiece in usefulness. It is simple, 
        easy to learn and allows lots of activities otherwise impossible over an SSH 
        link (or in a console that gets interrupted when quitting and restarting X11). 
        I haven't had a look at the source though. 
      </p>
      <hr/>
      <p>
        I'd vote in DirMagic (the DOS utility that is still better/faster than windows 
        explorer) and several of the TSR's I used to use. What about the original 
        Norton DOS defrag? or <a href="PartitionMagic.html">PartitionMagic</a>? Those were so useful and powerful they 
        were revolutions. 
      </p>
      <hr/>
      <p>
        GREATEST SOFTWARE EVER:
      </p>
      <ul>
        <li>
          VI, versions 1.0-1.2 only, please.
        </li>
        <li>
          Ed.
        </li>
        <li>
          Mugwumps.
        </li>
        <li>
          Lynx.
        </li>
        <li>
          Top.
        </li>
        <li>
          Did I mention <a href="EdIsTheStandardTextEditor.html">EdIsTheStandardTextEditor</a>?
        </li>
        <li>
          The portion of EMACS that quotes Zippy the Pinhead.
        </li>
      </ul>
      <hr/>
      <p>
        SQLite. Most widely deployed sql database engine in the world. As powerful as other database engines ten times the size. Clean, nicely-commented sourcecode.
      </p>
      <ul>
        <li>
           <em>SQLite can't really be compared to most other database engines, because it's an embedded DBMS.  There is no free-running server, nor are there the networking, security and concurrency control mechanisms required in a free-running server, nor does it support stored procedures.  Foreign key constraints are recognised but ignored, though they can be awkwardly implemented with triggers.  As such, it can't really be compared to the Oracle DBMS, </em>MySQL, <a href="PostgreSql.html">PostgreSql</a>, and so on.  It would be more appropriate to compare it to other embedded database engines like the Berkeley DB, which are not ten times the size.  From SQLite's own Web site: "Think of SQLite not as a replacement for Oracle but as a replacement for fopen()."<em></em>
        </li>
      </ul>
      <p>
        Colorforth: I want to believe. But I couldn't find any help or documentation. When I tried it, it just gave me a place to type. Clueless, I tried typing random characters...and it crashed. Tried again, same. How do I grok the colorforth?  <em>First, become familiar with </em><a href="ForthLanguage.html">ForthLanguage</a> (e.g., via GForth) so you have some understanding of Forth to start off with.  <a href="ColorForth.html">ColorForth</a> assumes you grok Forth first.  Then, basically, read the source.  As indicated above, <a href="ColorForth.html">ColorForth</a> is a very, very minimalist system.  It is essentially an interactive assembly language for a hypothetical dual-stack virtual machine that maps very closely to real hardware; unlike GForth, <a href="ColorForth.html">ColorForth</a> imposes <em>no protections</em> for you (otherwise, it's not minimal!), so yes, you can crash the system trivially if you don't know what you're doing with it. --SamuelFalvo<em></em>
      </p>
      <p>
        XMMS - less bugs than anything I know, spectacularly clean code, useful comments, lightweight, and handy.  
      </p>
      <hr/>
      <p>
        If you've got VMS there, you should consider Plan 9 as well.	Very elegant design and a clean way to solve many problems.  9P is a fabulous idea which spawned FUSE.  The C source code is also well written and available for reading.  <a href="http://plan9.bell-labs.com/plan9/about.html">http://plan9.bell-labs.com/plan9/about.html</a>
      </p>
      <hr/>
      <p>
        I elect <a href="SmlLanguage.html">SmlLanguage</a>, as per The Definition of Standard ML.  Or would this be more of a <a href="SpecificationMasterpiece.html">SpecificationMasterpiece</a>?
      </p>
      <hr/>
      <p>
        I (<a href="NatPryce.html">NatPryce</a>) suggest the <a href="GitVersionControl.html">GitVersionControl</a>.  The command-line tools are clunky but the model underlying them is a beautiful example of elegant simplicity.
      </p>
    </div>
  </body>
</html>