<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Extreme Programming Challenge Seventeen
      </h1>
      <p>
        For years your product has been promoted by accepting any change or enhancement suggested by a new potential customer if it is theoretically possible and will win a sale.
      </p>
      <p>
        You have approx. 1,500,000 lines of C/C++, all heavily coupled, with much duplication: as many as six classes/structs representing similar or identical abstractions. 
      </p>
      <p>
        Many parts of the product use sophisticated numerical techniques: <a href="SimulatedAnnealing.html">SimulatedAnnealing</a>, ComputationalGeometry, some others.
      </p>
      <p>
        There is an extensive X-based GUI, but <a href="ModelViewController.html">ModelViewController</a>/<a href="DocumentView.html">DocumentView</a> etc. have <em>not</em> been applied. 
      </p>
      <p>
        All the tools data is held in ascii files with highly non-normalised formats: lots more duplication within and between files.
      </p>
      <p>
        There is high churn. One or two people remain in the company who understood how the product worked <em>a couple of versions ago</em>. 
      </p>
      <p>
        This practice of accepting any and all enhancements has ensured that the product is market leader, and has been for some time. Naturally, management wish to preserve this "responsiveness" for as many more years as it has already been.
      </p>
      <p>
        Known, serious, defects persist unremedied for years. Changes to the code-base are becoming more expensive exponentially. Startups are beggining to appear with more robust, cheaper competing products, stealing market share.
      </p>
      <p>
        Management are extremely reluctant to allow any diversion of effort from <em>production</em> (as they see it: adding features) to 
        <em>maintenance</em> (which they would consuder refactoring to be), the two activities are managed separately.
      </p>
      <p>
        How could XP help you <em>stay</em> "successful"? 
      </p>
      <p>
        <em>We are not successful at this point, since management won't even let us refactor. We're dead, IMO.  --rj</em>
      </p>
      <hr/>
      <p>
        Any of the XP techniques could be useful in this situation. The question is how they might be applied.
      </p>
      <p>
        In the history of the project on which this challenge is based, it is interesting to note that a "troubleshooter", with an excellent track record was brought in as development manager. He attempted to bring in some XP-like practices, and was very popular with the developers, and improved the situation somewhat. He was less popular with management and was eventually given a GoldenHandshake.
      </p>
      <hr/>
      <p>
        This is a contradictory situation.  A system like this is hard to change, and
        so it will not have every feature that sales would like.  
      </p>
      <p>
        <em>It will have something like every feature sales would like (even if they doesn't work too well), or a contractual obligation outstanding to add such in the near future. The statement is that enhancements are </em>'accepted<em>', not delivered.</em> 
      </p>
      <p>
        The situation <em>is</em> contradictory. Contradictory, but (more-or-less) real. Or, it was real some years ago. 
      </p>
      <p>
        It is also of only historical interest to the poster of the challenge.
      </p>
      <hr/>
      <p>
        <em>There are bad situations. Perhaps this was one. XP is mostly about not getting into them. However, if I had to be there (and I wouldn't have to) I'd try the things I listed above. It's important to remember that there are more programming jobs than there are [good] programmers.  --</em><a href="RonJeffries.html">RonJeffries</a><em></em>
      </p>
      <p>
        Most of the developers working on that product have since voted with their feet, the product is not long for this world.
      </p>
      <hr/>
      <p>
        Another approach, worth trying before walking, is to sell the primary XP values to management before looking at <em>the best way</em> you're going to achieve them. The <a href="ExtremeValues.html">ExtremeValues</a> are motherhood statements, almost impossible to argue against. Since they're non-technical, they can communicate to management. Communicate them.
      </p>
      <p>
        Then, and only then, push on the business process from XP. Try something like the "Requirements and Scheduling Guidelines" in the <a href="ExtremeUnifiedProcess.html">ExtremeUnifiedProcess</a>.  <a href="SoftlySoftlyCatcheeMonkey.html">SoftlySoftlyCatcheeMonkey</a>. <a href="OnlySayThingsThatCanBeHeard.html">OnlySayThingsThatCanBeHeard</a>. Only when you have business clamoring for the <a href="ExtremeValues.html">ExtremeValues</a> can you begin to effect an XP process.
      </p>
      <p>
        There will be holdouts on the business side. If you really want to make your development become successful, you need to find ways to employ them. Don't work directly, but subtly. Use <a href="WuWei.html">WuWei</a>. If you're rational, and you use your heads, you can make good use of people who are not and who don't. 
      </p>
      <p>
        <em>Or should this move to XPC16?</em> --<a href="PeterMerel.html">PeterMerel</a>
      </p>
      <p>
        There are a lot of issues here.  Some are about how to change your processes and  change the way you relate to management.  But there is also the issue of how you change your code.  If I had 500,000 lines of poorly written, but working, Smalltalk code, I'd refactor it.  I'd write tests first, of course.  I think I can refactor my way out of any Smalltalk program.  But Smalltalk is easier to refactor than C/C++, mostly because of the tools, but also because the language
        is simpler.  It is a lot easier to imagine C programs that are hopeless.  In those cases, it is easier to start over from scratch.
      </p>
      <p>
        Figure out how long it is taking to add features the way things are going.
        If you started over from scratch, how long would it take you to get to the
        place where you are now, and how long would it take to add features then?
        Note that the new system would probably take half the lines of code as the
        current system.  If the current system is as bad as you claim, the point where it is cheaper to redevelop shouldn't be too far in the future.  
      </p>
      <p>
        Sometimes you have to keep adding features to the current system.  Then you have two teams, one developing the new system, and one the old system.  -<a href="RalphJohnson.html">RalphJohnson</a>
      </p>
      <hr/>
      <p>
        See <a href="ExtremeProgrammingChallenge.html">ExtremeProgrammingChallenge</a>
      </p>
    </div>
  </body>
</html>