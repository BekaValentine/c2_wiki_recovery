<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Cee Plus Plus Sux
      </h1>
      <p>
        A common argument in favor of <a href="CeePlusPlus.html">CeePlusPlus</a> is its performance advantage over other languages. But are the language's disadvantages a worthwhile compromise for performance?
      </p>
      <p>
        <em></em><a href="DanGreen.html">DanGreen</a> comments on a Q&A with Brian Hook [<a href="http://www.voodooextreme.com/ask/askgrand.html]:''">http://www.voodooextreme.com/ask/askgrand.html]:''</a>
      </p>
      <dl>
        <dt> </dt>
        <dd>Like most language discussion, it comes down to the writer's perspective and personal weighting in the flexibility, performance, understandability triangle. Depending on your use for a language, understandability may be the most important aspect. In my work, UnderstandabilityRulesSupreme. Choosing the right algorithm, purchasing a bigger "PizzaBox" or scaling outwards (like a WebFarm) will settle nearly all performance issues. But when writing a game on today's hardware, understandability has to take a BackSeat to FramesPerSecond. However, I suspect <a href="MooresLaw.html">MooresLaw</a> may put an end to the argument within the next decade and understandability will be the only factor. Maybe the <a href="SoftwareCrisis.html">SoftwareCrisis</a> will intervene before then, anyway, and force everyone's hand. (See <a href="RichardGabriel.html">RichardGabriel</a>'s <a href="PatternsOfSoftware.html">PatternsOfSoftware</a> for an excellent discussion of understandability amongst other things.) -- <a href="DanGreen.html">DanGreen</a></dd>
      </dl>
      <p>
        <em></em><a href="BadCodeCanBeWrittenInAnyLanguage.html">BadCodeCanBeWrittenInAnyLanguage</a>, but big languages, or <a href="LittleLanguage.html">LittleLanguage</a>s with big libraries, make bad code much easier. If <a href="CeePlusPlusSux.html">CeePlusPlusSux</a>, so do <a href="JavaLanguage.html">JavaLanguage</a>, <a href="VisualBasic.html">VisualBasic</a>, and <a href="PerlLanguage.html">PerlLanguage</a>. All of these languages are bad for newbies, all are easier to write than to read unless you use discipline and standards, and all are indispensable within certain domains. The best way is to pick the appropriate language for the job: <a href="HorsesForCourses.html">HorsesForCourses</a>. Or pick more than one language to enhance "understandability", say, use the <a href="SimplifiedWrapperAndInterfaceGenerator.html">SimplifiedWrapperAndInterfaceGenerator</a> to bolt small, self-contained C++ primitives into a <a href="PythonLanguage.html">PythonLanguage</a> framework ... -- <a href="PeterMerel.html">PeterMerel</a><em></em>
      </p>
      <hr/>
      <p>
        <a href="MooresLaw.html">MooresLaw</a> is a <a href="RedHerring.html">RedHerring</a> if you are in competition. It is not enough for your solution on today's hardware to be as fast as the competitor's solution 3 years ago, even though 3 years ago everyone thought this level of performance was good enough. <a href="MooresLaw.html">MooresLaw</a> applies to the competition too. They will still be twice as fast as you.
      </p>
      <p>
        <em>...If processing power reaches a level that supports instantaneous usage for all applications bar those that contain </em><a href="NpComplete.html">NpComplete</a> algorithms, twice as fast is a non-event. And I guess that's the key. Will there be some point in the future when language-level optimizations aren't important? If so, then by definition the triangle of performance, flexibility, understandability is reduced to flexibility and understandability. (I'm not sure I even understand what I mean by flexibility... perhaps reusability would be a better term. <em>...actually, after re-reading </em><a href="PatternsOfSoftware.html">PatternsOfSoftware</a>, Gabriel's term Habitability covers it nicely.<em>) Anyway, algorithm choice may always be important, but what percentage of applications are algorithmically intensive? Will the applications of tomorrow be more algorithmically intensive than those of today? Are the bottlenecks of tomorrow going to be network bandwidth and video bandwidth anyway? Is squeezing the performance of the software going to be unnecessary because the time taken to go send the info down the pipe or display and relay the latest 3D, surround sound, feedback wizardry to the user will far exceed it? I don't have the answers to these questions but I have suspicions and that's why I used the word suspect above.</em> -- <a href="DanGreen.html">DanGreen</a>
      </p>
      <p>
        The real issue is whether we believe in the 80:20 rule of performance, and whether we are applying it right. -- <a href="DaveHarris.html">DaveHarris</a>
      </p>
      <p>
        What gets me about the above statement, "<a href="MooresLaw.html">MooresLaw</a> applies to the competition too. They will still be twice as fast as you" is that <a href="MooresLaw.html">MooresLaw</a> <strong>is</strong> the reason I wish more programmers could spend less of their time fixated on performance issues. But there seems to be a vicious cycle: programmers getting drawn into excessive optimization because of the importance given to benchmark testing as the determining factor whereby which application or operating system is "more viable in the e-commerce marketplace" (or whatever.) I've experienced aspects of this in console game development, and observed similar on the linux-kernel mailing list. But every time my operating system crashes (yes, it happens to be dual-boot NT/linux) what really affects me - emotionally, anyway - is the sheer dedication of programmer time on the linux-kernel list to making aspect X of the operating system Y cycles faster. And the fact they're obligated to pursue this path because of the benchmark-following 'drones' purchasing systems IN IGNORANCE of <a href="MooresLaw.html">MooresLaw</a>... is really irritating. I want a reliable system. I can buy faster hardware every three months. -- <a href="BillKelly.html">BillKelly</a>
      </p>
      <hr/>
      <p>
        I code faster in some languages than others, despite equivalent experience levels. -- <a href="PhlIp.html">PhlIp</a>
      </p>
      <hr/>
      <p>
        Competition is a <a href="RedHerring.html">RedHerring</a>. Most software is developed in-house, so there is no <em>competitor</em> as such.
      </p>
      <p>
        In the small minority of cases where there really is competition, and the software needs to be brought to market, who do you think will win, the company which finishes 6 months early, or the company whose software is twice as fast?
        Besides, decisions about buying large software products are almost <strong>never</strong> reduced to technical issues, always market and social ones.
      </p>
      <p>
        <em>And to what do we owe the blanket assumption that one language will let you finish 6 months early? could it be ... SATAN?? -- PCP</em>
      </p>
      <hr/>
      <p>
        Sure <a href="CeePlusPlus.html">CeePlusPlus</a> is hard to use. But somebody has got to do it to create all those <a href="ScriptingLanguage.html">ScriptingLanguage</a>s and <a href="UserInterface.html">UserInterface</a>s that allow the majority to avoid C++ programming. Heart surgery is tough as well, but you'd never say it sucked if you needed a triple-bypass done right and fast. You'd just find one of the practitioners who knew how, and gladly admit you weren't one of them.
      </p>
      <p>
        <em>Most scripting languages are written in </em><a href="CeeLanguage.html">CeeLanguage</a>, and often sizeable parts are written in themselves (i.e., just the <a href="ByteCode.html">ByteCode</a> interpreter in C). Tk, Gtk and Motif are examples of GUI toolkits written in C. <a href="SqueakSmalltalk.html">SqueakSmalltalk</a>'s <a href="MorphicInterface.html">MorphicInterface</a> is written in <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>, <a href="JavaSwing.html">JavaSwing</a> is written in <a href="JavaLanguage.html">JavaLanguage</a>. Garnet is written in <a href="CommonLisp.html">CommonLisp</a>.<em></em>
      </p>
      <p>
        Now ... WhyAreMostScriptingLanguagesWrittenInCee? 
      </p>
      <p>
        <em></em>'Because C is a PortableAssemblyLanguage.<em></em>'
      </p>
      <hr/>
      <p>
        That would be fine, but at least there aren't thousands of people who think they are skilled heart surgeons practicing heart surgery :)
      </p>
      <hr/>
      <p>
        <em></em><a href="MooresLaw.html">MooresLaw</a> <strong>is</strong> the reason I wish more programmers could spend less of their time fixated on performance issues<em></em>
      </p>
      <p>
        Keep in mind that not everyone writes software (or OSes) for the latest and greatest PC. Do you want to pay for a 1.5 GHz Pentium IV for your <a href="TiVo.html">TiVo</a> box (which I've been told runs Linux)? Do you think grocery stores would pay for them in their cash registers? Not every programmer sees the immediate benefits of <a href="MooresLaw.html">MooresLaw</a>. -- <a href="EddieDeyo.html">EddieDeyo</a>
      </p>
      <p>
        <em>It's a matter of marketability. If speed distinguishes your software from your competitors, performance is killer. If not, go program in </em><a href="PrologLanguage.html">PrologLanguage</a>.<em></em>
      </p>
      <hr/>
      <p>
        To me writing command line programs in <a href="CeePlusPlus.html">CeePlusPlus</a> is not bad, but <a href="MicrosoftFoundationClasses.html">MicrosoftFoundationClasses</a>, ATL, etc. are what is so bad. This is where Java has it all over <a href="VisualStudio.html">VisualStudio</a> 6 C++. However, <a href="DotNet.html">DotNet</a> and <a href="CeeSharp.html">CeeSharp</a> level the playing field now.
      </p>
      <hr/>
      <p>
        Competition is <em>not</em> a <a href="RedHerring.html">RedHerring</a>, it is the <em>reason</em> why C++ will be abandoned. That is because <a href="TimeToMarket.html">TimeToMarket</a> will overwhelm performance, given <a href="MooresLaw.html">MooresLaw</a>, making C++ a losing proposition.
      </p>
      <hr/>
      <p>
        I work with <a href="HandHeld.html">HandHeld</a>s. I use C++ and C (and <a href="PerlLanguage.html">PerlLanguage</a> to generate C++). Java programmers look at my code and freak out. They tell me that my perfectly compiling and working code is illegal just because I use <strong>struct</strong> instead of <strong>class</strong>. They create <strong>virtual</strong>s when an <strong>if</strong> statement would do, and don't use <strong>virtual</strong> when polymorphically overloading. They <strong>delete</strong> stack objects, but they don't <strong>delete[]</strong> when <strong>new[]</strong>ing. They construct temporaries on the heap and then leak them when they terminate scope. When you ask them why they didn't use the stack, they complain that there's no <strong>Stack</strong> class from the standard library. I want to hit them with their keyboards. <a href="JavaLanguage.html">JavaLanguage</a> is <a href="CobolLanguage.html">CobolLanguage</a>. Java programmers aren't. -- <a href="SunirShah.html">SunirShah</a>
      </p>
      <p>
        Do you have some observation to make other than that programmers who know only Java idioms aren't good at C++?
      </p>
      <p>
        We interview a lot of self-described C++ programmers. Even self-described "expert" C++ programmers. Damn few of them can spot a non-virtual destructor, or explain why such a thing might be problematic. 
      </p>
      <p>
        There are some <em>atrocious</em> C++ programmers making a perfectly good living, and there are some star programmers who choose to use Java. -- anon.
      </p>
      <p>
        Well, obviously. The assertion was that on average Java programmers aren't very good programmers compared to C++ programmers on average. But consider the environment in 1994 before Java was released. Now all the bad programmers have moved onto Java. Bad programmers will always exist, and always herd to whatever is the hot new do-it-all language of the day. <em>Mooooo.</em> -- <a href="SunirShah.html">SunirShah</a>
      </p>
      <hr/>
      <p>
        See: <a href="AllPanaceasBecomePoison.html">AllPanaceasBecomePoison</a>, <a href="ComplexityMatters.html">ComplexityMatters</a>, <a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a>, <a href="CppBashing.html">CppBashing</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryCpp.html">CategoryCpp</a> <a href="CategorySucks.html">CategorySucks</a>
      </p>
    </div>
  </body>
</html>