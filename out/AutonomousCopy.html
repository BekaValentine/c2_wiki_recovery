<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Autonomous Copy
      </h1>
      <p>
        ... <a href="LocalConceptPresence.html">LocalConceptPresence</a> has led to multiple
        object instances, each in its own computing
        context, that represent a single
        analysis concept.
        Each computing context has its own interface
        to this single "logical" object.
      </p>
      <hr/>
      <p>
        <strong>We want to avoid unnecessary coordination</strong>
        <strong>between multiple instances of one concept.</strong>
      </p>
      <p>
        Many method invocations will require coordination
        among the objects, either at the business rule
        level or at the level of object state coordination,
        or both.
        We want to be able to distinguish between
        methods that require coordination and those that
        don't.
      </p>
      <p>
        You could factor the shared state and behavior
        into a separate object (see <a href="RelationshipObject.html">RelationshipObject</a>).
        However, what is local and what is shared may
        change with business rules, and you want to
        minimize the code changes that must be made to
        reflect such changes in methods and data structures.
        Also, <a href="OccamsRazor.html">OccamsRazor</a> suggests against creating
        an object just for this purpose.
      </p>
      <p>
        <em>Therefore:</em>
      </p>
      <p>
        <strong>For methods that require no coordination</strong>
        <strong>between objects, just execute the method</strong>
        <strong>locally.</strong>
        In C++, you can declare such methods to be <em>const</em>
        member functions, documenting that they do not
        change the state of the object, so no state
        coordination between instances is necessary.
      </p>
      <p>
        Other methods can coordinate using <a href="SymmetricalReference.html">SymmetricalReference</a>.
      </p>
      <hr/>
      <p>
        This provides an efficient alternative to
        <a href="RemoteProxy.html">RemoteProxy</a> for objects where a significant
        fraction of method calls can execute
        locally.
      </p>
      <p>
        Factoring out this pattern separate from
        <a href="SymmetricalReference.html">SymmetricalReference</a> and <a href="LocalConceptPresence.html">LocalConceptPresence</a>
        makes it possible to combine the patterns in
        interesting ways that capture several other RPC
        approaches.
        The original <a href="HalfObjectPlusProtocol.html">HalfObjectPlusProtocol</a>
        is one archetypical combination of the
        patterns <a href="SymmetricalReference.html">SymmetricalReference</a>, <a href="LocalConceptPresence.html">LocalConceptPresence</a>
        and <a href="AutonomousCopy.html">AutonomousCopy</a>.
      </p>
    </div>
  </body>
</html>