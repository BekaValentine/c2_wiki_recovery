<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Static Methods Non Polymorphic
      </h1>
      <p>
        <em>[Voting on </em><a href="JavaDesignFlaws.html">JavaDesignFlaws</a> page.]<em></em>
      </p>
      <p>
        Java's static methods are non-polymorphic. This means that <em>sub-classes cannot override class methods.</em> This is unfortunately tied to Java's syntactic roots in <a href="CeePlusPlus.html">CeePlusPlus</a>. <a href="ObjectiveCee.html">ObjectiveCee</a> does this so much more cleanly: methods declared as class methods are truly class methods and are inherently polymorphic.
      </p>
      <p>
        <em>Does this complaint even make sense?  The flaw isn't static methods, it's lack of metaclasses that make class methods unworkable.  There's no real logical way static methods could be polymorphic as far as I can see, that would require subclassing what?</em>
      </p>
      <p>
        But Java has metaclasses (Class as a first order citizen); just that the implementation is flawed. 
      </p>
      <p>
        <em>I partially agree with that, but not really.  Class as a first order citizen isn't enough, you need to be able to subclass class and have your classes depened on your new metaclass, which can't be done, without that, you can't say java has metaclasses.  If you could do that, then you'd put methods into your new metaclass, and they would be polymorphic, and you wouldn't need the static method hack to simulate class methods.  You also wouldn't need factories, since the metaclass can now serve as the factory for that class of objects.</em>
      </p>
      <p>
        If <em>static</em> on a method means a <em>class</em> method, then a sub-class should theoretically be able to over ride the implementation.
      </p>
      <p>
        <em>A subclass of what?  A subclass of the metaclass sure, but not a subclass of the class itself, otherwise it'd be a regular virtual method.  If we have a class Car, and a subclass </em>FordCar, FordCar should not logically be able to override static methods of Car, that wouldn't make any sense.  First off, static on a method doesn't mean class method, since Java doesn't have metaclasses, static simply means shared method, and overriding a shared method would defeat the meaning of shared method, csharp has the same problem.<em></em>
      </p>
      <p>
        IMHO, first of all everything in a class's definition, either defines the class itself or defines the instance that can be created using the class, sharing as a concept didn't seem to me to have a meaning in this context. I think Car, FordCar example is a good one to show that sub-classes should be able to override their parent's. Basically a Car, a normal car would have two headlights but FordCar may well have 3, e.g. one in the middle of the other two. You can find many similar examples of static overrides in nature, just look at the variety of breeds of dogs, cats. <em>Serkan Kose</em>
      </p>
    </div>
  </body>
</html>