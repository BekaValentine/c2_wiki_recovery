<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Turing Equivalency For Data Structures
      </h1>
      <p>
        Lately there has been a lot of talk of <a href="DataStructures.html">DataStructures</a> that can represent equivalent information. Sometimes I refer to this as "<a href="TuringEquivalency.html">TuringEquivalency</a> of data structures", but I doubt that is technically accurate. Data structure equivalency might be analogous to <a href="TuringEquivalency.html">TuringEquivalency</a>, but not the same. Is there another term for this concept? -- top
      </p>
      <p>
        You need to think a little harder about your question, which then would pretty much answer itself. <strong></strong><a href="TuringEquivalent.html">TuringEquivalent</a><strong> refers to anything equivalent to a universal model of computation -- something that can compute anything computable. Literally speaking, of course data structures do not compute, so of course it's not appropriate to talk about "Turing equivalence of data structures".</strong>
      </p>
      <p>
        So what should we call data structures that are equivalent in terms of their ability to represent information? I think that the standard technical term for them would be "equivalent". ;-)
      </p>
      <p>
        <em>That might be confusing. The reader may not know what is equivalent about them.</em>
      </p>
      <p>
        If the reason that you dragged Turing into the matter was that you were pondering the question of universal data structures -- those that can represent anything representable -- there are a variety of possible answers to that. E.g. try the bit. Or the byte. Or the machine word. Naturally we can have sequences of bits/bytes/words, so low level strings are subsumed, not a separate case, so no wonder people are so fond of strings to represent data -- and why others hate them -- they're universal but low level, concrete rather than abstract, and nominally have no more error checking than do bit manipulations in assembly.
      </p>
      <p>
        If you want an abstract data structure rather than a low level concrete data structure, this gets into some twisty issues that begin with polymorphism and homoiconism and end up with the answer that you do in fact need a Turing machine (or equivalent) in order to represent anything representable, because algorithms are one of the things you may want to represent.
      </p>
      <p>
        Or perhaps you meant none of the above.
      </p>
      <hr/>
      <p>
        I guess, that UniversalDatastructures must include conditional parts and iterative parts. Iteration is usually possible with lists and/or recursion. The conditional part is trickier, because e.g. a Union will not do (the condition is not part of the data structure). I imagine something like:
      </p>
      <code>
        typedef { char head; if (head != 0) { CString tail } } CString; <br/>
      </code>
      <p>
        as a definition of C-sytle 0-terminated Strings.
      </p>
      <p>
        --<a href="GunnarZarncke.html">GunnarZarncke</a>
      </p>
      <hr/>
      <p>
        Isomorphic might be a good term; depending on the level of detail under consideration, it may well be possible to construct an IsoMorphism between two types of data structures, such as the isomorphism between binary trees and n-ary trees established by considering the left-child of a binary tree node to be the first child of that item and the right-child to be its right-sibling.
      </p>
      <p>
        Isomorphisms are structure-preserving mappings; how many, if any, exist between two objects depends on the structure considered.  -- <a href="AnonymousDonor.html">AnonymousDonor</a>
      </p>
      <p>
        Except that isomorphism has a precise mathematical meaning, and unless these data structures actually exhibit those properties, it's best not to mix terminology.  Someone might actually want to construct a <em>real</em> isomorphism between data structures (I'm guessing it's possible, though I don't know enough math or have enough time to do so), and then we'd be wholly confused.
      </p>
      <p>
        Personally, I'd just go with "equivalent".  It's what it means, after all.  If that's not specific enough, how about RepresentationallyEquivalent?  -- <a href="JonathanTang.html">JonathanTang</a>
      </p>
    </div>
  </body>
</html>