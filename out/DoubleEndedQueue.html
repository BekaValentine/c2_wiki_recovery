<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Double Ended Queue
      </h1>
      <p>
        A queue that allows items to be added or removed from either the front or the back of the queue. Often written as Deque and pronounced like "deck" to avoid confusing with DequeueOperation?. A <a href="DoubleEndedQueue.html">DoubleEndedQueue</a> is usually implemented using <a href="DoubleLinkedList.html">DoubleLinkedList</a>.
      </p>
      <p>
        <em>The C++ </em><a href="StandardTemplateLibrary.html">StandardTemplateLibrary</a> deque<T> isn't implemented in that way at all; it's implemented as a balanced array-of-arrays. Using rather clever allocation strategies; it has amortized O(1) performance for insertion/deletion at both front and rear, as well as for retrieval of an element. (However the "constant factors" for a deque are higher than for a vector<T>).<em></em>
      </p>
      <p>
        What are double ended queues used for?
      </p>
      <p>
        <em>And what's the 'clever' allocation strategy of the STL version?</em>
      </p>
      <p>
        Deques are useful (in C++ at least) when you need <strong>both</strong> O(1) random access, and ability to delete/insert at the ends. (You still cannot delete/insert in the middle in O(1) time; that requires O(n) time still).
      </p>
      <p>
        Deques work by maintaining a two-tier structure. The top tier is an array of pointers to fragments of equal size, except possibly at the ends; each fragment contains an array of elements contained. Random access is done by looking up the index in the toplevel array (since each fragment contains an equal number of elements, excluding the ends, this can be done in O(1) time), going to that fragment, and lookup up correct element (a modulo operation, also O(1)).
      </p>
      <p>
        I cannot recall exactly the details of how insertion/deletion work in a deque. Like vector, amortized O(1) performance at the tail is achieved with a) keeping additional buffer space so reallocation is rare, and b) doubling the size of the buffer each time a realloc is needed. Somebody more knowledgeable than I will have to fill in the rest of the details.
      </p>
      <p>
        For <em>most</em> applications, you're better off with vector<T> if you need fast random access, or list<T> if you need fast insertion/deletion. deque<T> is a compromise - I don't recall ever having to use it.
      </p>
      <p>
        -- <a href="ScottJohnson.html">ScottJohnson</a>
      </p>
      <p>
        <em>They're useful when a professor tells you to implement a solution using a Deque on a final exam. (I didn't want to insert the above answer until someone gave you a real one, thank you Scott.)</em>
      </p>
      <hr/>
      <p>
        <a href="CategoryDataStructure.html">CategoryDataStructure</a>
      </p>
    </div>
  </body>
</html>