<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Polymorphism And Inheritance
      </h1>
      <p>
        Loosely speaking, in order to have polymorphism we need to have some kind of inheritance.
      </p>
      <p>
        More exactly, polymorphism (<a href="InternalPolymorphism.html">InternalPolymorphism</a>) manifests when we invoke a function (dispatch a message) on a reference to an object.
      </p>
      <p>
        In order for the polymorphic invocation to work, the reference must point to an object whose actual <em>type</em> (or class) must inherit from a base class (<em>type</em>/<em>interface</em>) that the client code has knowledge of. Thus polymorphism is inherently related to inheritance (understood in the larger sense of a IS-A relation between objects and types ). 
      </p>
      <p>
        There is a little bit of inherent difficulty in addressing the subject generated by the fact that current OO programming languages don't treat the IS-A relation very loosely (class/interface/types) or don't support it quite well, at least IMO. -- <a href="CostinCozianu.html">CostinCozianu</a>
      </p>
      <p>
        <strong>Rebuttals:</strong> 
      </p>
      <p>
        In Smalltalk polymorphism is orthogonal to inheritance. 
      </p>
      <p>
        In Java we have <em>interfaces</em>, and implementing an interface is essentially different than extending a base class (which is the usual meaning of inheritance).
      </p>
      <p>
        Any language that supports <em>reflection</em> also does not require that polymorphism is related to inheritance.
      </p>
      <hr/>
      <p>
        See <a href="OnUnderstandingTypes.html">OnUnderstandingTypes</a>, <a href="ConfusionAboutInheritance.html">ConfusionAboutInheritance</a>, <a href="WhatIsDelegation.html">WhatIsDelegation</a>
      </p>
      <hr/>
      <p>
        Check out <a href="http://soronthar.blog-city.com/read/175488.htm">http://soronthar.blog-city.com/read/175488.htm</a>
      </p>
      <p>
        -- <a href="RafaelAlvarez.html">RafaelAlvarez</a>
      </p>
      <hr/>
      <p>
        What I mean by inheritance is actually subtyping, inheriting some <em>features</em>and/or <em>constraints</em> from a base type (class/interface/<a href="AbstractDataType.html">AbstractDataType</a>). More precisely, the object is involved in an IS-A relation with a specific base type that the client knows of.
      </p>
      <p>
        You polymorphically invoke a function through an object reference either directly using the OO language facility, or through reflection. Now we have to distinguish between statically-typed/dynamic languages (C++ versus Smalltalk), and invocation through reflection.
      </p>
      <p>
        Case A: Statically typed languages (C++, Java). Here the things are clear, you cannot make an invocation through an reference unless that reference has a specific type, and if the language is type consistent the reference cannot point to an arbitrary object, but only to an object that conforms to an base class definition (eventually an interface in Java). Anyway, the result is that the actual object is in a IS-A relation with the base class (either abstract or concrete) or interface in Java.
      </p>
      <p>
        Case B: Dynamic languages like Smalltalk. Here it is obvious that the actual class of an object need not inherit from a specific base class for the polymorphic invocation to happen. However, even if it's not something directly supported by the language we still witness a hidden (implicit) IS-A relation as is the case with invocation through reflection detailed below.
      </p>
      <p>
        Case C: Invocation through reflection. Again it is obvious that the target object's actual class need not <em>inherit</em> (as in specific OO language defined inheritance) from a base class, or implement a specific interface.
      </p>
      <p>
        Let's focus on an example that's well known: <a href="JavaBeans.html">JavaBeans</a>. The typical client of <a href="JavaBean.html">JavaBean</a> invocation through reflection is a Java IDE who gets the actual class of the object, inspect it to find the methods who match the getXXX()/setXXX()/isXXX() pattern (we skip the programatic interfaces defined in java.beans.*) and may invoke those methods dynamically (I don't know if polymorphically is the right word here) upon user triggered action in the property inspector. So apparently there is no IS-A relationships in this case.
      </p>
      <p>
        But what happens here is that there is a external contract (not enforced by the programming language compiler) between the client of a <a href="JavaBean.html">JavaBean</a> and the <a href="JavaBean.html">JavaBean</a> object, the contract defined in the <a href="JavaBeans.html">JavaBeans</a> specification, the only problem is that the specific language (Java in this case) is not flexible enough to be able to directly support/enforce this type of contract. Therefore the object IS-A <a href="JavaBean.html">JavaBean</a>, and since the notion of the type is generally understood as a set of values, we have that <a href="JavaBean.html">JavaBean</a> is really a type (although not supported by the language), and a well programmed <a href="JavaBean.html">JavaBean</a>, even has to conform to <a href="LiskovSubstitutionPrinciple.html">LiskovSubstitutionPrinciple</a>, that is it has to work as expected in any IDE/runtime that is programmed to be the client of the <a href="JavaBean.html">JavaBean</a> contract as defined in an external specification (not enforceable by the language). 
      </p>
      <p>
        The similar case can be made with a dynamic language: when the programmer invokes a method on a reference, he really expects that reference to conform to a more or less implicit contract . If you invoke a x.method_y() the object x is at least expected to be in an IS-A relation with a specific type. Even if that type is defined as loosely as <em>all objects whose class have a method named method_y and takes no parameter and returns void</em>.
      </p>
      <p>
        Sometimes the reflective invocation, can be made by a scripting engine who simply reads a string from the script and in interpreting it, generates the dynamic call. Here the contract moves one level above and is established between the object targeted and the script code that generates the method invocation, thus the contract is a little bit cross-language, but we still have an IS-A relation.
      </p>
      <hr/>
      <p>
        <Raw thread>
      </p>
      <p>
        <em>When we say that we want to store polymorphic relations (or collections, or better said </em>sets<em>) in the database, we always talk about a </em>base type<em> that all objects in the polymorphic relation should conform to</em> -- <a href="CostinCozianu.html">CostinCozianu</a>
      </p>
      <p>
        I don't believe this is always true. It certainly isn't necessarily for multiple inheritance languages like Eiffel or C++. It is <em>very</em> inconvenient for Java and Smalltalk. -- <a href="AnonymousDonor.html">AnonymousDonor</a>
      </p>
      <p>
        <em>And for most OO approaches inheritance is primarily related to code reuse - we want to reuse code from the base class, and usually implies that the class that inherits from the base class has more attributes but not less (of course the code from the base class still has to access its needed attributes). </em> 
      </p>
      <p>
        Inheritance is only one small part of reuse. In the alarm clock example, no inheritance is necessary to reuse the alarm clock for every object in the system. Polymorphism is the key in this example. 
      </p>
      <p>
        <em>And you can't have polymorphism without inheritance. Java interfaces a re just a disguised application of multiple inheritance, where the mess of dealing with inheritance of instance attributes is eliminated. However, Java </em>implements Interface<em> is structurally the same as inheriting from an abstract base class in C++. The fact that you are able to invoke a specific method on a reference is supported by the fact that that reference IS-A (conforms to) specific type. The generalization of inheritance with all its twists in the current programming languages is the IS-A relation.</em>-- Costin
      </p>
      <p>
        Untrue. Smalltalk's polymorphism is orthogonal to inheritance. In a sense, Java's is too since polymorphic behavior can be implemented through reflection and, often, very usefully is.
      </p>
      <p>
        <em>I don't think it's a good idea to link polymorphism and inheritance. I find polymorphism to be very valuable; inheritance, on the other hand, seems to introduce as many problems as it solves. With creative definitions of types, you can say that all polymorphism is linked to inheritance, but again, I don't think it's a good idea. I'd like to see more languages that implement polymorphism and not inheritance (and use some other technique to provide implementation reuse). -- </em><a href="JimLittle.html">JimLittle</a><em></em>
      </p>
      <p>
        </raw thread>
      </p>
      <p>
        As I am unqualified to speak on Smalltalk, I will accept that polymorphism can be done without inheritance (although I would be interested in hearing the details). I would suggest, however, the only purpose for using inheritance is to provide polymorphism. I would also say that using inheritance merely to reuse code is an incorrect use, leading to clutter and confusion. -- <a href="WayneMack.html">WayneMack</a>
      </p>
      <p>
        In Smalltalk (and Self and Ruby and Python and...), you can send any message to any object you want. The compiler doesn't check any types at compile time. At runtime, when an object receives a message, it checks to see if it has a method with the same name as the message. If it finds one, it executes the method; if it doesn't, it throws a "message not understood" exception.
      </p>
      <p>
        The point (for this page) is that it doesn't matter what class an object is, as long as it responds to the messages you send it. That's what Smalltalkers mean by "polymorphism" - you can substitute any object for any other object, as long as it responds sensibly to all the messages you're going to send it.
      </p>
      <p>
        (Lots of advantages and disadvantages to all this, of course. There are plenty of other pages on this wiki for that. But this is how languages like Smalltalk and Python do it. See <a href="TimLesher.html">TimLesher</a>'s example down there.)
      </p>
      <p>
        In these languages, inheritance really is just for code reuse. You don't need it for polymorphism - if you want A to respond to the same messages as B, but you don't want to reuse B's implementation, there's no reason to have A inherit from B.
      </p>
      <p>
        -- <a href="AdamSpitz.html">AdamSpitz</a>
      </p>
      <p>
        Why would you use inheritance for code reuse? I still don't see any rationale for inheritance if an alternative mechanism provides inheritance. Would some care to expand upon this for me? -- <a href="WayneMack.html">WayneMack</a>
      </p>
      <p>
        Suppose that I want to make an Integer class and a Float class. At first I make them both subclasses of Object. Later on, I notice that Integer and Float have a lot of code in common. For example, they both have an identical "squared" method:
      </p>
      <code>
        def squared<br/>
        return self * self<br/>
        end<br/>
      </code>
      <p>
        So I make a class called Number, make Integer and Float both be subclasses of Number, and put the "squared" method into the Number class. Now that code isn't duplicated anymore. Code reuse. (And polymorphism too.) You already understand this.
      </p>
      <p>
        Inheritance still gives you polymorphism. But you only need to use it in the cases where you want polymorphism <em>and</em> code reuse. Languages like Java force you to inherit from little "interfaces" even when you just want polymorphism. (See the SeekableAndWritable example below for an attempt to explain why this can cause problems.)
      </p>
      <p>
        -- <a href="AdamSpitz.html">AdamSpitz</a>
      </p>
      <hr/>
      <p>
        Another method to get polymorphism without inheritance is <a href="DuckTyping.html">DuckTyping</a>. <a href="DuckTyping.html">DuckTyping</a> can be used in (at least) C++ (via the STL) and Python. For example, say that (in Python) you have a File class:
      </p>
      <code>
        class File:<br/>
        def __init__(self):<br/>
        ...<br/>
        def read(self, numBytes):<br/>
        ...<br/>
        def write(self, data):<br/>
        ...<br/>
        def seek(self, offset):<br/>
        ...<br/>
      </code>
      <p>
        And you have a number of functions that can act on files:
      </p>
      <code>
        def WriteAOne(someFile):<br/>
        someFile.seek(0)<br/>
        someFile.write("1")<br/>
      </code>
      <p>
        You can use WriteAOne polymorphically with any object that implements the methods WriteAOne calls. -- <a href="TimLesher.html">TimLesher</a>
      </p>
      <p>
        <em>This is the same as Java's </em>'interface<em>' is it not?</em> -- <a href="PeteHardie.html">PeteHardie</a>
      </p>
      <p>
        In Java, you would need the creator of the File class to anticipate your needs and create an explicit SeekableAndWritable interface and mark File as implementing it. In Smalltalk or Python, you just create a new object that understands the "seek" and "write" methods and everything'll work. -- <a href="AdamSpitz.html">AdamSpitz</a>
      </p>
      <p>
        <em>Could someone show the above example in C++? I appraently missed the "aha" in the explanation.</em>
      </p>
      <p>
        In C++, the WriteAOne function would look something like this:
      </p>
      <code>
        void WriteAOne(File* someFile) {<br/>
        someFile->seek(0);<br/>
        someFile->write("1");<br/>
        }<br/>
      </code>
      <p>
        ... which is pretty much identical to the Python version, except that I had to write "File*" in the signature. That's probably a bad idea, because I want to be able to WriteAOne to any object that has "seek" and "write" methods, not just Files. So to get that amount of polymorphism, I need there to exist an "interface" like this:
      </p>
      <code>
        class SeekableAndWritable {<br/>
        public:<br/>
        virtual void seek(int i) = 0;<br/>
        virtual void write(char* s) = 0;<br/>
        };<br/>
      </code>
      <p>
        ... so that I can write the WriteAOne function like this:
      </p>
      <code>
        void WriteAOne(SeekableAndWritable* someFile) {<br/>
        someFile->seek(0);<br/>
        someFile->write("1");<br/>
        }<br/>
      </code>
      <p>
        The problem is, I need the File class to inherit from SeekableAndWritable. If I'm not the one who created the File class, then I'm stuck - I won't be able to use a File as a SeekableAndWritable.
      </p>
      <p>
        (Of course, C++ has templates and stuff, so I'd have alternatives. In Java I really <em>would</em> be stuck.)
      </p>
      <p>
        In a language with <a href="DynamicTyping.html">DynamicTyping</a> (like Smalltalk or Python or Ruby), these problems just disappear. You don't need to create explicit "interfaces". You don't need the creators of your library classes to anticipate all the little interfaces you'll need. You don't need the creator of the WriteAOne function to remember to declare the parameter as SeekableAndWritable instead of File. You just make sure that you pass in an object that understands all the messages that'll be sent to it, and everything works.
      </p>
      <p>
        -- <a href="AdamSpitz.html">AdamSpitz</a>
      </p>
      <hr/>
      <p>
        What about Parametric Polymorphism using only parameters to procedures and functions? See <a href="IncludeFileParametricPolymorphism.html">IncludeFileParametricPolymorphism</a>. This doesn't require inheritance. 
      </p>
      <p>
        <a href="ParametricPolymorphism.html">ParametricPolymorphism</a> (one piece of code statically dispatching to many possible locations based on parameter types) is not quite the same as OO 'virtual' method Polymorphism (one piece of code doing a runtime lookup for a method based upon a special runtime argument, that being the 'this' object pointer).  Both are less generic than GenericMethods which allow for true <a href="MultipleDispatch.html">MultipleDispatch</a> (another <a href="BlubParadox.html">BlubParadox</a> thing, and yet another case of Lisp getting it right thirty years earlier).  All forms of polymorphism suffer from issues of ambiguity in the case where some types can be viewed as or coerced into other types, and not all types match exactly.
      </p>
      <p>
        <em>In </em><a href="IncludeFileParametricPolymorphism.html">IncludeFileParametricPolymorphism</a>, the "not all types match exactly" problem is solved by using compile time IFDEF directives. It'd be better if it was implemented in the language directly, though.<em> </em>
      </p>
      <hr/>
      <p>
        See <a href="InternalPolymorphism.html">InternalPolymorphism</a>, <a href="CircleAndEllipseProblem.html">CircleAndEllipseProblem</a>, <a href="LiskovSubstitutionPrinciple.html">LiskovSubstitutionPrinciple</a>.
      </p>
      <hr/>
      <p>
        <a href="CategoryPolymorphism.html">CategoryPolymorphism</a> <a href="CategoryObjectOrientation.html">CategoryObjectOrientation</a>
      </p>
    </div>
  </body>
</html>