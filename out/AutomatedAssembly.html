<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Automated Assembly
      </h1>
      <p>
        [<a href="ComponentDesignPatterns.html">ComponentDesignPatterns</a> | <a href="CategoryPattern.html">CategoryPattern</a>]
      </p>
      <p>
        <strong>Context</strong>
      </p>
      <p>
        You are building a component-based framework based on <a href="AbstractInteractions.html">AbstractInteractions</a> and <a href="ThirdPartyBinding.html">ThirdPartyBinding</a>.
      </p>
      <p>
        <strong>Problem</strong>
      </p>
      <p>
        How do you ensure that users of the framework compose components correctly.
      </p>
      <p>
        <strong>Forces</strong>
      </p>
      <ul>
        <li>
           Components can be composed in many ways but not all possible compositions are valid.
        </li>
        <li>
           No customization, modification, or extension of components or the component framework can make it difficult for the application to be flexible to changing requirements.
        </li>
        <li>
           Instantiating and binding components is a complex and/or boring task. For example, it might involve a lot of boiler-plate code, which is a potential source of errors, or involve tricky concurrency issues such as race conditions which must be guarded against when composing components.
        </li>
        <li>
           Too much flexibility can place an unneeded burden upon the user who essentially needs to manually assemble the application before using it.  It would be like buying a car and getting it shipped to you in a box full of pieces.
        </li>
      </ul>
      <p>
        <strong>Solution</strong>
      </p>
      <p>
        As part of your framework, provide <a href="PrebuiltFunctionality.html">PrebuiltFunctionality</a> that can automatically instantiate and connect the correct components to perform common tasks.
      </p>
      <p>
        <strong>Resulting Context</strong>
      </p>
      <p>
        It is easier for framework users to make use of the framework for common tasks.
      </p>
      <p>
        It is no harder to use the framework for tasks that are not supported by <a href="AutomatedAssembly.html">AutomatedAssembly</a>.
      </p>
      <p>
        Components need to support <a href="InterfaceDiscovery.html">InterfaceDiscovery</a> so that <a href="AutomatedAssembly.html">AutomatedAssembly</a> functions can interrogate and connect their interfaces.
      </p>
      <p>
        Components that <a href="SplitDesignTimeAndRunTime.html">SplitDesignTimeAndRunTime</a> representations can only be assembled at design/build time, which makes it harder to adapt the system at run-time or without rebuilding the system.
      </p>
      <p>
        <strong>Known Uses</strong>
      </p>
      <p>
        The <a href="DirectShow.html">DirectShow</a> framework provides a graph builder object that can automatically instantiate and connect the correct filters to render a media file. It can also connect an output pin of a filter to an input pin of another and instantiate the correct filters to convert between the formats of two pins.
      </p>
      <p>
        The Regent distributed programming environment includes a "Stacker" class that that, given the name of a protocol, automatically instantiates protocol components and composes them into a compatible stack.
      </p>
      <p>
        Microsoft's ActiveX development tools include "wizards" that generate huge amounts of boilerplate code.  Personally, I distrust wizards because they allow lazy programmers to generate large amounts of code without actually understanding what they are doing, which causes problems as soon as they hit a bug.
      </p>
      <hr/>
      <p>
        This is quite similar to the approach David Canfield Smith and I took when we were building a component system with automatic assembly, back in 1991-92. We chose a system where components were connected in a dataflow style and were annotated with metadata describing their connectors. I think I like a more OO approach to the component interface descriptions. The results of our work are documented in:
      </p>
      <p>
        Smith, David C. and Joshua Susser. "A Component Architecture for Personal Computer Software," <em>Languages for Developing User Interfaces</em>, pp31-56, Brad Myers ed. Boston: Jones & Bartlett, 1992.
      </p>
    </div>
  </body>
</html>