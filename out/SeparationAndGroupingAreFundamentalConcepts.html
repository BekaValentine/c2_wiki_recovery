<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Separation And Grouping Are Fundamental Concepts
      </h1>
      <p>
        In a very long page, <a href="SeparationAndGroupingAreArchaicConceptsDiscussion.html">SeparationAndGroupingAreArchaicConceptsDiscussion</a>, an attempt is made as to spell out the Archaic nature of Separation and Grouping. I inspected the page and found the following words used, and I believe all of which can be said to contribute to separation and grouping:
      </p>
      <code>
        names variables<br/>
        hidden visible<br/>
        static dynamic<br/>
        namespaces scopes <br/>
        files sections paragraphs sentences words<br/>
        segments parts <br/>
        contraptions schemes methods threads<br/>
        local global <br/>
        searching sorting grouping summing reporting inspecting<br/>
        interpreting processing <br/>
        measures techniques priorities<br/>
        call-stacks databases sets<br/>
        tags <br/>
      </code>
      <p>
        If something is useful, usable and used, as all of the above are, I fail to see in what way the concepts behind them (that of Separation and Grouping) are anything else but fundamental and irreplaceable. If a concept is archaic, at least as I understand the meaning of the word archaic, it is in the process of deprecation and replacement. It seems to me a vital thing to be able to separate (as in wheat from chaff) and to group as to (put apples in a basket). How this is done may change, and the schemes, mechanisms and processes involved may be modernized to take advantage of new hardware and software, but the concepts in themselves are fundamental. --<a href="BlueHat.html">BlueHat</a>
      </p>
      <p>
        <em>I suspect what we have here is a vocabulary dispute, not so much a technical dispute. The concept I called "archaic" was "single dimensional" partitioning, which is the norm in the industry right now (but seems to be hitting walls). Multi-dimensional separation is usually NOT called "separation" in my experience, or at least is often not sufficient. But I will agree that perhaps English is not sufficient to describe modern cyberspace, so our 3D-world vocab is tripping us up.</em>
      </p>
      <p>
        I have been working on the concept "that perhaps English is not sufficient to describe modern cyberspace" in my quest to establish a scheme for separation and grouping based on what I once called HyperArtifacts. I am only beginning to get a handle on how this might be done, but fundamental to it is the use of single and multi-word combinations as atomic elements in a Hypertextual language. It will handle objects, processes, states and persistance and as many other things as might be required.
        --<a href="DonaldNoyes.html">DonaldNoyes</a>
      </p>
      <p>
        <em>Perhaps a different title should have been used, but until somebody finds a significantly better replacement, wiki tradition is that "good enough" titles stand if they have been there a while. It's not practical to keep flipping titles for incremental improvements. Further, titles should NOT be required to carry all potential scope limiters and disclaimers in my opinion. Other's have disagreed, although their arguments are weak and border on being childish in my opinion. That being said, you are welcome to propose new titles. Hopefully, we can reach a consensus before any change is made.</em>
      </p>
      <p>
        [You choose a big title and attack such a small aspect of it. You sow much confusion by doing so, and you create confrontations regarding the title that are not beneficial towards your purpose. Even responding to pages such as this one consumes your time, your energy, to no purpose other than once again explaining that your title is bigger than your claims. It would be wise to narrow the scope of the title to reflect the narrow scope of your claims (if you need help, terminology that describes what you so despise includes "DominantConcern" and "Tyranny of the Dominant Concern"). Since you don't like flipping titles, you would have been wise to apply greater thought when choosing the initial title. As far as "Multi-dimensional separation" being not called separation, you'll be disappointed to know that MDSOC (multi-dimensional <a href="SeparationOfConcerns.html">SeparationOfConcerns</a>) is a well known term among those who follow progress in <a href="ProgrammingLanguageTheory.html">ProgrammingLanguageTheory</a> and have read about <a href="HyperSpace.html">HyperSpace</a>s.]
      </p>
      <ul>
        <li>
           Some are okay with the "organic" nature of this wiki, while others are rather meticulous about titles. These two styles seem to be conflicting. Ward's original vision leaned toward the organic side. I agree with Ward more or less, but I promise I'll try to be more careful about titles in the future to avoid conflicts with the meticulous side. -top 
        </li>
        <li>
           [If successful, your efforts will be unnoticed... but only because absence of conflict isn't very noisy. I appreciate your promise.]
        </li>
        <li>
           I do believe those who I've angered by "attacking their holy cow" are biased against me in a vengeful kind of way such that they will scrutinize what I do more heavily. -t
        </li>
        <li>
           <em>I don't believe I've seen you successfully attack any "holy cows" here.  If you are scrutinized heavily, it is for (among other things) making bold assertions without sound defence -- especially those that demonstrate a clear lack of understanding of </em><a href="ComputerScience.html">ComputerScience</a> and <a href="SoftwareEngineering.html">SoftwareEngineering</a>.<em></em>
        </li>
        <li>
           People with vague or missing evidence often accuse the other of ignorance. It's their only escape. In other words, inarticulate cowards. People who truly know how to <em>apply</em> their superior knowledge to make things objectively better are not afraid of <a href="SelfStandingEvidence.html">SelfStandingEvidence</a>. They know where it makes things better, they know why it makes things better, and they know how to objectively measure it and show the measurements to disagreeing parties. If you rely on <em>substitutes</em> for science such as <a href="ArgumentByElegance.html">ArgumentByElegance</a>, then you cannot perform such steps and have to imply "trust me, I'm just smarter". -t
        </li>
        <li>
           <em>The majority of us happily discuss technology and theory but almost never promote it or engage in advocacy, or only do so in terms of addressing specific programming problems.  You are notable in </em>'generally<strong> promoting quite specific approaches -- </strong><a href="TableOrientedProgramming.html">TableOrientedProgramming</a> or <a href="HtmlStack.html">HtmlStack</a> replacements, for example -- or engaging in advocacy against use of higher-order programming techniques like HOFs.  Are you aware that this is classic <a href="ArgumentByElegance.html">ArgumentByElegance</a>, where "elegance" is your particular brand of table-oriented procedural programming?  I've never seen you offer any research citations or empirical evidence to support your approaches, or to provide evidence against those you deprecate.  As such, the only regular participant here who seems to imply "trust me, I'm just smarter" is...  You.<em></em>
        </li>
        <li>
           Unfortunately, <a href="SoftwareEngineering.html">SoftwareEngineering</a> depends largely on <a href="WetWare.html">WetWare</a>, and so most of my arguments are based on <a href="WetWare.html">WetWare</a> assumptions which I do try to state even if I cannot prove them in an absolute sense because the human mind is not yet subject to the kind of science we really need. In other words, I do my best to describe the <a href="WetWare.html">WetWare</a> models I use for my reasoning even though not every assumption or observation has been "certified". Your problem is that you refuse to see that <a href="ProgrammingIsInTheMind.html">ProgrammingIsInTheMind</a>, and instead invent fake or fuzzy metrics to make your case. There is no SoftwareScience so far. The field is fucked up. I'm just the messenger. Science served us well on the <em>hardware</em> side, but left town when software rolled in.
        </li>
        <li>
           <em>Could you show me where I "invent fake or fuzzy metrics to make [my] case?"</em>
        </li>
        <li>
           <em>If it's true that there is no science in </em><a href="SoftwareEngineering.html">SoftwareEngineering</a>, then could you stop promoting your table-oriented procedural hobby horses and stop deprecating programming techniques such as higher-order functions?  If "software [is] mostly about the human mind", then obviously no rational argument can be sustained in favour of table-oriented procedural programming or <a href="HtmlStack.html">HtmlStack</a> revisionism, or against higher-order functions.<em></em>
        </li>
        <li>
           The default is not that they are "good". Every tool and technique should be scrutinized and not accepted by default. If only <a href="OfficialCertifiedDoubleBlindPeerReviewedPublishedStudy.html">OfficialCertifiedDoubleBlindPeerReviewedPublishedStudy</a>s are allowed on this wiki, then we'd have to delete like 95% of the software stuff other than specific product info.
        </li>
        <li>
           <em>Your arguments appear to suggest that the default for table-oriented procedural programming is that it is "good", and that the </em><a href="HtmlStack.html">HtmlStack</a> and higher-order functions are not "good".<em></em>
        </li>
        <li>
           I advocate for my fav tools and you do the same. Nothing wrong with that. As far as the HOF debate, that's more about what the "industry" wants than it is about my favorite techniques. Like I've said before, even some of my own fav techniques are frowned upon in a typical workplace such that I have to cut down on them. Those topics are more about the sociology of the workplace.
        </li>
        <li>
           <em>Could you show me where I "advocate for my fav tools"?  I don't recall ever even mentioning my "fav tools".</em>
        </li>
        <li>
           I meant "tools or techniques". You do appear to promote certain techniques, but I don't want to get into a <a href="LaynesLaw.html">LaynesLaw</a> debate over "advocate".
        </li>
        <li>
           <em>What techniques do I promote?</em>
        </li>
        <li>
           Gratuitous use of HOF's.
        </li>
        <li>
           <em>Could you point to a use of HOFs that is gratuitous, and provide evidence that it is gratuitous (as opposed to being a reasonable and effective solution) by demonstrating a superior alternative?</em>
        </li>
        <li>
           Gee, a brilliant idea for a brand new debate! Why didn't we think of that debate before?
        </li>
      </ul>
      <p>
        <em>And I do indeed agree that *some* kind of "partitioning" is needed, and thus "some kind" of partitioning is "fundamental". It is absolute or single-dimensioned partition that is "archaic". The main point of the original topic was that </em>'we need relative partitioning and the current tools do not provide it<em>' well. If there's a better way to say it, that's good. {I added the blue-hat moniker. I hope you don't mind. Lack of handles can cause difficulties.} --top</em>
      </p>
      <p>
        <strong>Reference Pointers Versus Block Markers</strong>
      </p>
      <p>
        Strangely enough I am wearing a navy-blue hat right now from Juneau Alaska. I don't mind at all. I have long been an advocate for <a href="PositiveDialogue.html">PositiveDialogue</a>. It is far more productive and satisfying than confrontation and dispute. About partioning and dimensioning - What I see as needed is something that points rather than something that counts, and inserts in slots, positions or spaces. A sort of connection of concerns that is associative, so to speak. Thus when connecting something as complicated as a sentence or paragraph (made up of words and complex-words, the pointer(s) may be multiple from the same or several points in the sentence or paragraph. Not the simple single, dual or triple type found in linked lists and the like. --<a href="DonaldNoyes.html">DonaldNoyes</a>
      </p>
      <p>
        [Not archaic yet, at least not as most English speakers understand the term. Wait until WarAgainstDominantConcern is finished before you declare victory.]  {misplaced/drifted context?}
      </p>
      <p>
        That is an interesting open question: references versus "tagged chunks". It almost reminds me of closures-versus-start-stops in other debates. Or how to represent text formatting (nesting versus starters/stoppers). Chunks just seems cleaner for this use, partly because the scope of the category markers is cleaner and partly because functions, modules, and blocks already exist as possible pre-made frames of reference. If we have scope starters and enders, they may drift apart or get deleted out of sync. But it's likely a case of <a href="WaterbedTheory.html">WaterbedTheory</a> at play. Perhaps a tool could support both, at the price of added complexity. --top
      </p>
      <hr/>
      <p>
        Open Questions:
      </p>
      <ul>
        <li>
           Are references used, or "labeled blocks"? <a href="LabeledBlocks.html">LabeledBlocks</a> would simply attach markers to existing blocks, such as functions or curly-brace blocks.
          <ul>
            <li>
               If references are used, should they require a "closing" marker? (Or, perhaps required if indicated.)
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           Are the actual categories to be stored in the source code, or in a separate structure/database that links via a marker-ID? Similar questions apply to meta-data. A minimal-code approach would simply have an ID number, and then rest of the info kept in separate a database or system.
        </li>
      </ul>
      <ul>
        <li>
           Would markers be hand-keyed or machine-generated?
        </li>
      </ul>
      <ul>
        <li>
           Would the "live" code be stored in a database or files? (Files eventually have to be generated as existing most existing compilers/interpreters only support files. But, that is only during the "build" stage.)
        </li>
      </ul>
      <hr/>
      <p>
        <a href="AprilThirteen.html">AprilThirteen</a>
      </p>
    </div>
  </body>
</html>