<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Grain Of The Language
      </h1>
      <p>
        Languages are like wood. They have a natural way of working. Some languages have several. But if you try to do, say, OO in VB, or AI in Fortran, or parsing in COBOL <strong>(but see below)</strong>, or reflection in C++, you're going against the grain. The language will suddenly seem weak and full of knots and splinters. Use languages only in ways that they make easy - and if you want to do something else, pick a language that's better for that.
      </p>
      <hr/>
      <p>
        Sometimes you can't switch languages, especially if you've already invested a lot in that language. Say written most of the system in C++ before you realized you need a parser. C/C++ have horrid I/O/parser technologies.
      </p>
      <p>
        Solution: Know many languages and paradigms. Learn how to emulate them as you need them. Write a regular expression interpreter/parser in C++. Some languages are better than others at emulating different languages, like Scheme to make object-oriented programs. Bonus!
      </p>
      <p>
        The more languages you know, the more likely you will <a href="PickAnOkToolForTheJob.html">PickAnOkToolForTheJob</a>.
      </p>
      <hr/>
      <code>
        "How does it go .. real programmers program FORTRAN in any language !!" :)<br/>
      </code>
      <p>
        <em>It should be noted that the ability to emulate other languages in a given host language does not replace the need to understand the host language completely first. It is only through knowledge of the language that one knows when and how to extend it.</em>
      </p>
      <hr/>
      <p>
        <em>Some Java Zealots insist that there's no other way.</em>
      </p>
      <p>
        Or to all of the emacs zealouts, or VI zealouts, or Unix zealouts, or NT zealouts, or C++ zealouts, or ...
      </p>
      <code>
        (Is this a typo or are they really combinations of zealots and louts?<br/>
        Having met some, I like the combination idea.)<br/>
      </code>
      <p>
        Since <a href="LearningMeansMakingMistakes.html">LearningMeansMakingMistakes</a>, the way you find out the <a href="GrainOfTheLanguage.html">GrainOfTheLanguage</a>
        is by going against the grain.  If you are wise, you'll only make that particular mistake once.  But maybe you just didn't implement that inference
        engine properly, and if you used backward chaining instead then FORTRAN
        would be just fine for AI.  Life would be better if we documented what
        tools are NOT good for, as well as what they are good for.  What is Java
        bad at?
      </p>
      <ul>
        <li>
           Hard real-time
        </li>
        <li>
           bare metal programming (device drivers, etc.)
        </li>
      </ul>
      <hr/>
      <p>
        <strong>Nit pick</strong>
      </p>
      <p>
        'Parsing in COBOL'
      </p>
      <p>
        One of the better COBOL's I've used was written in COBOL, by a student, back in the 70's.  A straight forward top-down recursive-descent piece of code. However COBOL syntax isn't particularly recursive so the neither was the code! Readable:
      </p>
      <code>
        PERFORM COMPILE-IDENTIFICATION-DIVISION.<br/>
        PERFORM COMPILE-ENVIRONMENT-DIVISION.<br/>
        ....<br/>
      </code>
      <p>
        The lexer was the tough bit... and coded in assembler.
      </p>
      <p>
        --<a href="DickBotting.html">DickBotting</a>
      </p>
      <hr/>
      <p>
        What do you do when "the way" sucks. Case in point, perl doesn't do nested arrays. To have an array element be an array you have to do a lot of <a href="HocusPocus.html">HocusPocus</a> with "references." 
      </p>
      <p>
        <em>Like the initial statement on the page says, go with the flow.  Talk to someone else and see how he solved a similar problem within the restrictions of the language.  If perl doesn't do nested arrays, can you solve the problem without nested arrays?</em>
      </p>
    </div>
  </body>
</html>