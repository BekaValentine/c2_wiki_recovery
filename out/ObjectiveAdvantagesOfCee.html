<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Objective Advantages Of Cee
      </h1>
      <p>
        <a href="CeeLanguage.html">CeeLanguage</a> is often asserted to be better than most (or all) other languages, especially in its primary domain of systems programming. However, detractors often assert that its alleged advantages, such as compact code or faster run-time, are illusory or misleading, because it requires a greater programming effort to get a certain result than a more abstract language would, and that the resulting code is often more susceptible to serious bugs as well. This page is set up so that C partisans can assert any <em>objective</em> and preferably quantitative reasons why C is superior, either in a specific problem domain or in general, as well as for any counter-arguments by C detractors.
      </p>
      <ul>
        <li>
           <em>Execution speed?</em>  CeeAlso: <a href="AsFastAsCee.html">AsFastAsCee</a>, <a href="FasterThanCee.html">FasterThanCee</a>
        </li>
        <li>
           <em>Requires only the c library, which isn't a runtime (no overhead, no other processes running) and is present on all major operating systems.</em>
        </li>
        <li>
           <em>Possesses a very simple call-interface, which made it the standard </em>ApplicationBinaryInterface. (abi)<em></em>
        </li>
        <li>
           <em>Benefits from mature, high-performance compilers, by the virtue of being relatively simple to implement.</em>
        </li>
        <li>
           <em>Not offering </em><a href="StrongTyping.html">StrongTyping</a>, <a href="TypeInference.html">TypeInference</a> and other modern static typing, it stays flexible and extensible through its use of <a href="ManifestTyping.html">ManifestTyping</a> and <a href="WeakTyping.html">WeakTyping</a>.<em></em>
        </li>
        <li>
           <em>Benefits from having </em>'a<strong> compiler on new </strong><a href="EmbeddedSystem.html">EmbeddedSystem</a> platforms. In other words, <a href="CeeLanguage.html">CeeLanguage</a> is more CrossPlatform than any other language. (Well, after I fiddle with the <a href="MovingGoalPosts.html">MovingGoalPosts</a> so I can claim that <a href="AssemblyLanguage.html">AssemblyLanguage</a> and <a href="ForthLanguage.html">ForthLanguage</a> don't count).
          <ul>
            <li>
               Fiddling with goalposts is not needed to elminate <a href="AssemblyLanguage.html">AssemblyLanguage</a>; given that it isn't a single language, but a set of languages related only by the fact that they serve the same purpose--abstracting the instruction set of CPUs.  Code written for x86 assembly needs to be completely rewritten for <a href="PowerPc.html">PowerPc</a> or SPARC or ARM.  As far as <a href="ForthLanguage.html">ForthLanguage</a> goes, that one I don't know about--you might be correct given that many ultra-low-end CPUs may find it easier hosting Forth than C.  OTOH, excluding those sorts of platforms, C certainly has more mature implementations on 32-bit and better architectures than Forth does.  Plus, I like the compiler to keep track of stack frames for me, rather than having me do it manually....
            </li>
            <li>
               You can reasonably exclude Forth for the simple reason that some programmers (a majority? a strong plurality? I don't know) simply cannot deal with an exposed stack (two of them, actually) as their only execution model. I think it's very diagnostic to look at how many languages look like C and Algol and how very few look like Forth. (In fact, the only three Forth-like languages I know of that don't claim to be Forth dialects are <a href="PostScript.html">PostScript</a>, which few people write by hand, RPL, the programming language for <a href="HewlettPackard.html">HewlettPackard</a>'s calculators, and <a href="JoyLanguage.html">JoyLanguage</a>, a functional language that is based on the composition of functions.) (<a href="JavaVirtualMachine.html">JavaVirtualMachine</a> bytecode doesn't count: I don't think Sun officially offers JVM assemblers, and it isn't portable beyond the relatively few systems that have a working JVM implementation. An assembly language for a <a href="VirtualMachine.html">VirtualMachine</a> is still an assembly language.)
            </li>
          </ul>
        </li>
        <li>
           <em>Established knowledge base, and ease of finding information about it.  It is much easier to find a good book on C than a good book on Common Lisp or Objective Caml.</em>
        </li>
        <li>
           <em>Established resource base.  You want to use a GUI library?  They're written in C or C++.  You want to use a library for graphics, sound, mathematical transformations, database interface, networking, or just about anything else?  The first one you find is probably going to be written in C or C++.</em>
        </li>
      </ul>
      <hr/>
      <p>
        <a href="CategoryCee.html">CategoryCee</a>
      </p>
    </div>
  </body>
</html>