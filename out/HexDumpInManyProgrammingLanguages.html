<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Hex Dump In Many Programming Languages
      </h1>
      <p>
        See also: <a href="ArraySumInManyProgrammingLanguages.html">ArraySumInManyProgrammingLanguages</a>, <a href="CounterInManyProgrammingLanguages.html">CounterInManyProgrammingLanguages</a>, <a href="DotProductInManyProgrammingLanguages.html">DotProductInManyProgrammingLanguages</a>, <a href="WardNumberInManyProgrammingLanguages.html">WardNumberInManyProgrammingLanguages</a>, <a href="NinetyNineBottlesOfBeerOnTheWall.html">NinetyNineBottlesOfBeerOnTheWall</a>, <a href="ProgrammingChrestomathy.html">ProgrammingChrestomathy</a>
      </p>
      <p>
        <strong>Please use spaces rather than tabs in any code samples below (</strong><a href="ConvertSpacesToTabsNotForCode.html">ConvertSpacesToTabsNotForCode</a>).<strong></strong>
      </p>
      <p>
        A new <a href="ProgrammingChrestomathy.html">ProgrammingChrestomathy</a> challenge: hexdump a file, given a starting and ending offset in the file, and number of bytes to display per outline line. Newly recommended is to show the current offset at the start of each output line.
      </p>
      <p>
        Read the file <em>source</em> and print a <a href="HexDump.html">HexDump</a> of the bytes in the file from <em>start</em> to <em>end</em>, formatted to show <em>width</em> bytes separated by space, followed by a separator, then followed by the ASCII values of the displayed bytes (or a period for non-ASCII bytes), in the order they exist in the file. 
      </p>
      <hr/>
      <p>
        Has anyone tracked the most compact, yet viable, solutions? It seems to me that the Perl, Forth, and C examples solve the problem with the least fooling around.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="SchemeLanguage.html">SchemeLanguage</a><strong>: (alternative versions, or critiques of this one, would be welcome)</strong>
        [Note: I've removed many of the comments from my original version; ironically, it is now much clearer and easier to read.]
      </p>
      <code>
        ;; (hex-dump) => #t OR identifier<br/>
        ;; To use: <br/>
        ;;	start the Scheme interpreter<br/>
        ;;	(load 'hexdump)<br/>
        ;;	(hexdump)<br/>
        ;;<br/>
        ;;  Special Instructions:<br/>
        ;;	The filename must be enclosed in double quotes.	<br/>
        (define (hexdump)<br/>
        (let ((file	(begin (display "Filename: ") (read)))<br/>
        (start  (begin (display "Start: ")(read)))<br/>
        (finish (begin (display "End: ") (read)))<br/>
        (width  (begin (display "Bytes per Line: ") (read))))<br/>
        (dump-file file width start finish)))<br/>
      </code>
      <code>
        (define (dump-file filename line-length start finish)<br/>
        (cond ((not (string? filename))<br/>
        'err-no-filename)<br/>
        ((> 0 start)	  <br/>
        'err-negative-start)<br/>
        ((>= start finish)<br/>
        'err-startpoint-after-endpoint)<br/>
        (else (let ((src (open-input-file filename)) <br/>
        (width (if (> line-length 0) ; default line width to 16<br/>
        line-length<br/>
      </code>
      <ol>
        <li>
          )) 
        </li>
      </ol>
      <code>
        (size (- finish start)))	; total size of dump in bytes<br/>
        (if (not (port? src))  ; check for valid port<br/>
        'err-no-file<br/>
        (if (seek src start)	<br/>
        (display-dump src width size)<br/>
        'err-file-length-exceeded)))))) ; file ends before reaching start <br/>
      </code>
      <code>
        (define (seek src entrypoint)<br/>
        (let find ((count entrypoint))<br/>
        (cond ((>= 0 count) #t)<br/>
        ((eof-object? (read-char src))  ; if file ends before reaching entrypoint,<br/>
        (close-input-port src)	 ; close the file and return false<br/>
        #f)<br/>
        (else  (find (- count 1))))))	<br/>
      </code>
      <code>
        ;; (display-dump port integer integer) => #t OR identifier<br/>
        ;; Print out a hexdump <br/>
        ;;<br/>
        ;; The function accumulate-lines is used to collect<br/>
        ;; a group of lines up to blocksize in length to be printed<br/>
        ;; together as a single string. The purpose for this is to minimize<br/>
        ;; the number of calls to (display), a very high-overhead function.<br/>
        (define (display-dump src width size)<br/>
        (let ((blocksize 64)		<br/>
        (height (/ size width)))<br/>
        (do ((blockcount height (- blockcount blocksize)) ; decrement by blocksize each pass<br/>
        (dumpsize size (- dumpsize (* blocksize width))))	 <br/>
        ((or (<= blockcount 0)		<br/>
        (eof-object? (peek-char src))) <br/>
        (close-input-port src)<br/>
        #t)<br/>
        (display (accumulate-lines src width blocksize dumpsize))))) <br/>
      </code>
      <code>
        (define (accumulate-lines src width blocksize dumpsize)<br/>
        (let accumulate ((count blocksize)<br/>
        (tailing dumpsize)) <br/>
        (if (or (< count 0)	 ; if we've reached the end of the block,<br/>
        (< tailing 0))	; or the end of the dump region,<br/>
        ""			; return an empty string<br/>
        ; else, read a new line of data; if it is at the end of the region,<br/>
        ; only get the remaining part of the line, otherwise get a full line<br/>
        (let ((line (read-dump-line src (min tailing width)))) <br/>
        (if (null? line) ; if we've reached the end of the file,<br/>
        ""		; return an empty string<br/>
        ; otherwise, continue accumulating lines<br/>
        (string-append (format-line line width) <br/>
        (accumulate (- count 1) (- tailing width)))))))) <br/>
      </code>
      <code>
        (define (read-dump-line src width)<br/>
        (let read-data ((count width))<br/>
        (if (>= 0 count)<br/>
        '()<br/>
        (let ((next (read-char src)))<br/>
        (if (eof-object? next)<br/>
        '()<br/>
        (cons next (read-data (- count 1)))))))) <br/>
      </code>
      <code>
        (define (format-line dump width)<br/>
        (string-append (format-dump-line dump)<br/>
        (pad-string 3 (- width (length dump)))<br/>
        ": " <br/>
        (format-values-line dump) <br/>
        line-marker))<br/>
      </code>
      <code>
        (define line-marker (make-string 1 #\newline))<br/>
      </code>
      <code>
        (define (pad-string pad-size padding)<br/>
        (if (< 0 padding)<br/>
        (make-string (* pad-size padding) #\space)<br/>
        ""))<br/>
      </code>
      <code>
        (define (format-values-line dump)<br/>
        (list->string (map char-value dump))) <br/>
      </code>
      <code>
        (define (format-dump-line dump)<br/>
        (string-list-concat (map char->hex-string dump)	" ")) <br/>
      </code>
      <code>
        (define (string-list-concat string-list separator)<br/>
        (let cat ((stringlist string-list))<br/>
        (cond ((null? stringlist) "")<br/>
        ((list? stringlist) (string-append (car stringlist)<br/>
        separator<br/>
        (cat (cdr stringlist))))<br/>
        (else stringlist))))<br/>
      </code>
      <code>
        (define (char->hex-string c)<br/>
        (let* ((charval (char->integer c))<br/>
        (hexval (number->string charval 16)))<br/>
        (if (> 16 charval)<br/>
        (string-append "0" hexval)<br/>
        hexval)))<br/>
      </code>
      <code>
        (define (char-value c)<br/>
        (if (char-printable? c) <br/>
        c<br/>
        #\.)) <br/>
      </code>
      <code>
        (define (char-printable? c)<br/>
        (and (char<? #\space c)<br/>
        (char<? c #\~)))<br/>
      </code>
      <p>
        A sample printout, using it's own source file:
      </p>
      <code>
        > (hexdump)<br/>
        <strong>Filename: "hexdump.scm"</strong><br/>
        <strong>Start: 128</strong><br/>
        <strong>End: 256</strong><br/>
        <strong>Bytes per Line: 16</strong><br/>
      </code>
      <ol>
        <li>
           53 70 65 63 69 61 6c 20 49 6e 73 74 72 75 63 : .Special.Instruc
        </li>
        <li>
           69 6f 6e 73 3a 0d 0a 3b 3b 20 20 20 20 54 68 : tions:..;;....Th
        </li>
        <li>
           20 66 69 6c 65 6e 61 6d 65 20 6d 75 73 74 20 : e.filename.must.
        </li>
        <li>
           65 20 65 6e 63 6c 6f 73 65 64 20 69 6e 20 64 : be.enclosed.in.d
        </li>
        <li>
          f 75 62 6c 65 20 71 75 6f 74 65 73 2e 20 20 20 : ouble.quotes....
        </li>
        <li>
           0d 0a 0d 0a 28 64 65 66 69 6e 65 20 28 68 65 : .....(define.(he
        </li>
        <li>
           64 75 6d 70 29 0d 0a 20 20 28 6c 65 74 20 28 : xdump)....(let.(
        </li>
        <li>
           66 69 6c 65 20 20 20 28 62 65 67 69 6e 20 28 : (file...(begin.(
        </li>
      </ol>
      <code>
        #t<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="HaskellLanguage.html">HaskellLanguage</a><strong>:</strong>
      </p>
      <code>
        import System<br/>
        import IO<br/>
        import Data.Char<br/>
      </code>
      <code>
        hexdump start end width = unlines . map hexify . addLineNumber . splitGroups . takeRange<br/>
        where takeRange = take (end - start) . drop start<br/>
        splitGroups [] = []<br/>
        splitGroups xs = ys : splitGroups zs<br/>
        where (ys,zs) = splitAt width xs in<br/>
        addLineNumber = zip $ map (pad . show) $ iterate (+ width) start <br/>
        where pad str = replicate (6 - length str) '0' ++ str<br/>
        hexify (num, char) = num ++ ": " ++ (unwords $ map toHexDigit char) <br/>
        ++ ": " ++ map literal char<br/>
        toHexDigit = stringify . (`divMod` 16) . ord <br/>
        where stringify (x,y) = [intToDigit x, intToDigit y]<br/>
        literal c = if isPrint c then c else '.'<br/>
      </code>
      <code>
        withFile file func = readFile file >>= putStrLn . func<br/>
        main = do args <- getArgs<br/>
        let intArg = read . (args !!) in <br/>
        withFile (args !! 0) $ hexdump (intArg 1) (intArg 2) (intArg 3)<br/>
      </code>
      <p>
        Output:
      </p>
      <code>
        debian:/home/jdtang/vm/spike# ./hexdump hexdump.hs 0 150 15<br/>
      </code>
      <ol>
        <li>
          : 69 6d 70 6f 72 74 20 53 79 73 74 65 6d 0a 69: import System.i
        </li>
        <li>
          : 6d 70 6f 72 74 20 49 4f 0a 69 6d 70 6f 72 74: mport IO.import
        </li>
        <li>
          : 20 44 61 74 61 2e 43 68 61 72 0a 0a 68 65 78:  Data.Char..hex
        </li>
        <li>
          : 64 75 6d 70 20 73 74 61 72 74 20 65 6e 64 20: dump start end
        </li>
        <li>
          : 77 69 64 74 68 20 3d 20 75 6e 6c 69 6e 65 73: width = unlines
        </li>
        <li>
          : 20 2e 20 6d 61 70 20 68 65 78 69 66 79 20 2e:  . map hexify .
        </li>
        <li>
          : 20 61 64 64 4c 69 6e 65 4e 75 6d 62 65 72 20:  addLineNumber
        </li>
        <li>
          : 2e 20 73 70 6c 69 74 47 72 6f 75 70 73 20 2e: . splitGroups .
        </li>
        <li>
          : 20 74 61 6b 65 52 61 6e 67 65 0a 20 20 20 20:  takeRange.
        </li>
        <li>
          : 77 68 65 72 65 20 74 61 6b 65 52 61 6e 67 65: where takeRange
        </li>
      </ol>
      <p>
        -- <a href="JonathanTang.html">JonathanTang</a>
      </p>
      <hr/>
      <p>
        <a href="VisualBasicNine.html">VisualBasicNine</a>
      </p>
      <p>
        The following direct/imperative-style program does the trick
      </p>
      <code>
        Imports System<br/>
        Imports System.IO<br/>
      </code>
      <code>
        Module InManyLanguages<br/>
        Public Sub HexDump(ByVal filename As String, _<br/>
        ByVal startOffset As Integer, _<br/>
        ByVal endOffset As Integer, _<br/>
        ByVal width As Integer)<br/>
        Using fs = New FileStream(filename, FileMode.Open, FileAccess.Read)<br/>
        Console.WriteLine("Filename: {0}", filename)<br/>
        Console.WriteLine("Start: {0}", startOffset)<br/>
        Console.WriteLine("End: {0}", endOffset)<br/>
        Console.WriteLine("Bytes per line: {0}", width)<br/>
        If (fs.Length > startOffset) Then<br/>
        fs.Position = startOffset<br/>
        Dim buffer(width - 1) As Byte<br/>
        Dim bytesRead = 0<br/>
        Dim maxBytes = endOffset - startOffset<br/>
        Dim done = False<br/>
        While Not done<br/>
        Dim bytesToRead = IIf(maxBytes - bytesRead < width, maxBytes - bytesRead, width)<br/>
        Dim cb = fs.Read(buffer, 0, bytesToRead)<br/>
        bytesRead += cb<br/>
        done = cb < width Or bytesRead = maxBytes<br/>
      </code>
      <code>
        For index As Integer = 0 To cb - 1<br/>
        Console.Write("{0:X2} ", buffer(index))<br/>
        Next<br/>
        For index As Integer = cb To width - 1<br/>
        Console.Write("   ")<br/>
        Next<br/>
        Console.Write(": ")<br/>
        For index As Integer = 0 To cb - 1<br/>
        Dim b = buffer(index)<br/>
        Console.Write(IIf(b > 32 And b < 126, ChrW(b), "."))<br/>
        Next<br/>
        Console.WriteLine()<br/>
        End While<br/>
        End If<br/>
        End Using<br/>
        End Sub<br/>
        End Module<br/>
      </code>
      <p>
        Which prints out the following:
      </p>
      <code>
        Filename: InManyLanguages.vb<br/>
        Start: 128<br/>
        End: 256<br/>
        Bytes per line: 16<br/>
      </code>
      <ol>
        <li>
           73 20 49 6E 74 65 67 65 72 2C 20 42 79 56 61 : As.Integer,.ByVa
        </li>
        <li>
          C 20 65 6E 64 4F 66 66 73 65 74 20 41 73 20 49 : l.endOffset.As.I
        </li>
        <li>
          E 74 65 67 65 72 2C 20 42 79 56 61 6C 20 77 69 : nteger,.ByVal.wi
        </li>
        <li>
           74 68 20 41 73 20 49 6E 74 65 67 65 72 29 0D : dth.As.Integer).
        </li>
        <li>
          A 20 20 20 20 20 20 20 20 55 73 69 6E 67 20 66 : .........Using.f
        </li>
        <li>
           20 3D 20 4E 65 77 20 46 69 6C 65 53 74 72 65 : s.=.New.FileStre
        </li>
        <li>
           6D 28 66 69 6C 65 6E 61 6D 65 2C 20 46 69 6C : am(filename,.Fil
        </li>
        <li>
           4D 6F 64 65 2E 4F 70 65 6E 2C 20 46 69 6C 65 : eMode.Open,.File
        </li>
      </ol>
      <p>
        The imperative printing code within the loop could be replaced by this functional LINQ expression:
      </p>
      <code>
        Dim s = String.Join(" ", (From index In Enumerable.Range(0, cb) _<br/>
        Select buffer(index).ToString("X2")).Concat( _<br/>
        Enumerable.Repeat("  ", width - cb)).ToArray()) _<br/>
        & " : " & _<br/>
        New String((From index In Enumerable.Range(0, cb) _<br/>
        Let b = buffer(index) _<br/>
        Select CType(IIf(b > 32 And b < 126, ChrW(b), "."c), Char)).ToArray())<br/>
        Console.WriteLine(s)<br/>
      </code>
      <p>
        This isn't necessarily more maintainable or readable, but it proves the point.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="PythonLanguage.html">PythonLanguage</a><strong>:</strong>
      </p>
      <code>
        import sys<br/>
      </code>
      <code>
        def hexdump( chars, sep, width ):<br/>
        while chars:<br/>
        line = chars[:width]<br/>
        chars = chars[width:]<br/>
        line = line.ljust( width, '\000' )<br/>
        print "%s%s%s" % ( sep.join( "%02x" % ord(c) for c in line ),<br/>
        sep, quotechars( line ))<br/>
      </code>
      <code>
        def quotechars( chars ):<br/>
        return <em>.join( ['.', c][c.isalnum()] for c in chars )</em><br/>
      </code>
      <code>
        def file_section( name, start, end ):<br/>
        contents = open( name, "rb" ).read()<br/>
        return contents[start:end]<br/>
      </code>
      <code>
        if __name__ == '__main__':<br/>
        hexdump( file_section( sys.argv[1], int( sys.argv[2] ), int( sys.argv[3] )),<br/>
        ' ', int( sys.argv[4] ))<br/>
      </code>
      <p>
        Run output:
      </p>
      <code>
        $ python hexdump.py hexdump.py 0 60 16<br/>
      </code>
      <ol>
        <li>
          a 69 6d 70 6f 72 74 20 73 79 73 0a 0a 64 65 66 .import.sys..def
        </li>
        <li>
           68 65 78 64 75 6d 70 28 20 63 68 61 72 73 2c .hexdump..chars.
        </li>
        <li>
           73 65 70 2c 20 77 69 64 74 68 20 29 3a 0a 20 .sep..width.....
        </li>
        <li>
           20 77 68 69 6c 65 20 63 68 61 72 00 00 00 00 ..while.char....
        </li>
      </ol>
      <p>
        <em>Should this one lose points for reading the whole file into memory?</em>
      </p>
      <p>
        I don't think so. After all, memory-mapped files are a very powerful paradigm. There have been operating systems that only offered that option, and their proponents were very disdainful of the other approach.
      </p>
      <p>
        Long ago on systems with tiny RAM, this might have been crippling, since one couldn't view large files, but these days with big RAM and huge swap areas, it seems unlikely to be a pragmatic issue.
      </p>
      <p>
        There <strong>is</strong> something to be said for stream-based solutions as part of a <a href="DataFlowProgramming.html">DataFlowProgramming</a> system, but that doesn't seem a big deal on this particular page.
      </p>
      <p>
        The above version is buggy - it doesn't print brackets, etc, properly. Here's an idiomatic version that handles large files. It's less terse than it could be (but that's because it's more readable than it could be ;-)
      </p>
      <code>
        import sys<br/>
      </code>
      <code>
        def hexdump(fname, start, end, width):<br/>
        for line in get_lines(fname, int(start), int(end), int(width)):<br/>
        nums = ["%02x" % ord(c) for c in line]<br/>
        txt = [fixchar(c) for c in line]<br/>
        print " ".join(nums), "".join(txt)<br/>
      </code>
      <code>
        def fixchar(char):    <br/>
        from string import printable<br/>
        if char not in printable[:-5]:<br/>
        return "."<br/>
        return char<br/>
      </code>
      <code>
        def get_lines(fname, start, end, width):<br/>
        f = open(fname, "rb")<br/>
        f.seek(start)<br/>
        chunk = f.read(end-start)<br/>
        gap = width - (len(chunk) % width)<br/>
        chunk += gap * '\000'<br/>
        while chunk:<br/>
        yield chunk[:width]<br/>
        chunk = chunk[width:]<br/>
      </code>
      <code>
        if __name__ == '__main__':<br/>
        try:<br/>
        hexdump(*sys.argv[1:5])<br/>
        except TypeError:<br/>
        hexdump("hexdump.py", 0, 100, 16)<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="RubyLanguage.html">RubyLanguage</a><strong>:</strong>
      </p>
      <code>
        def hexdump(filename, start = 0, finish = nil, width = 16)<br/>
        ascii = <em></em><br/>
        counter = 0<br/>
        print '%06x  ' % start<br/>
        File.open(filename).each_byte do |c|<br/>
        if counter >= start<br/>
        print '%02x ' % c<br/>
        ascii << (c.between?(32, 126) ? c : ?.)<br/>
        if ascii.length >= width<br/>
        puts ascii <br/>
        ascii = <em></em><br/>
        print '%06x  ' % (counter + 1)<br/>
        end<br/>
        end<br/>
        throw :done if finish && finish <= counter<br/>
        counter += 1<br/>
        end rescue :done<br/>
        puts '   ' * (width - ascii.length) + ascii<br/>
        end<br/>
      </code>
      <code>
        if $0 == __FILE__<br/>
        if ARGV.empty?<br/>
        hexdump $0<br/>
        else<br/>
        filename = ARGV.shift<br/>
        hexdump filename, *(ARGV.map {|arg| arg.to_i })<br/>
        end<br/>
        end<br/>
      </code>
      <code>
        % hexdump.rb hexdump.rb 0 58 16<br/>
      </code>
      <ol>
        <li>
            64 65 66 20 68 65 78 64 75 6d 70 28 66 69 6c 65 def hexdump(file
        </li>
        <li>
            6e 61 6d 65 2c 20 73 74 61 72 74 20 3d 20 30 2c name, start = 0,
        </li>
        <li>
            20 66 69 6e 69 73 68 20 3d 20 6e 69 6c 2c 20 77  finish = nil, w
        </li>
        <li>
            69 64 74 68 20 3d 20 31 36 29 0a                idth = 16).
        </li>
      </ol>
      <hr/>
      <p>
        <strong></strong><a href="CeeLanguage.html">CeeLanguage</a><strong> or maybe </strong><a href="CeePlusPlus.html">CeePlusPlus</a><strong> - Not actually </strong><a href="CeeLanguage.html">CeeLanguage</a> - There are <a href="CeePlusPlus.html">CeePlusPlus</a> specifics used(like declaring variables in the middle of a function for readability). Why do people think <a href="CeePlusPlus.html">CeePlusPlus</a> means one must use class. Sigh. I guess the <a href="CeeLanguage.html">CeeLanguage</a>/<a href="CeePlusPlus.html">CeePlusPlus</a> are popular enough that people must post follow ups with their own visions. <em>An OO solution is probably overkill, but it wouldn't be unreasonable to ask that something purporting to be a </em><a href="CeePlusPlus.html">CeePlusPlus</a> example use things like the <a href="CeePlusPlus.html">CeePlusPlus</a> standard library, rather than the <a href="CeeLanguage.html">CeeLanguage</a> standard library... (or if you're going to use the <a href="CeeLanguage.html">CeeLanguage</a> library, at least use the standard <a href="CeePlusPlus.html">CeePlusPlus</a> headers for it [that's #include <cstdio> and #include <cstdlib>, rather than <stdio.h> and <stdlib.h>])...<em> - Fair enough, we'll call it a draw - if just to avoid a </em>LanguageHolyWar.
      </p>
      <p>
        <em>I posted one of the straight C language solutions below, which should tell you that I'm not a rabid foaming-at-the-mouth OO bigot, however I was the one that said it was C, not C++, and I stand by that. Aside from utterly trivial issues, it could compile with a C compiler. And yes, I would in fact want to see use of classes or templates, although as someone said above, at least using native C++ facilities for IO would put you in a more defensible position.</em>
      </p>
      <p>
        <em>Re: "follow up with their own visions" - there's room for multiple solutions in each language. I like to go for very terse solutions because I think that's a virtue in itself. Others obviously have somewhat different philosophies that they like to illustrate. -- dm</em>
      </p>
      <p>
        Not that I'm disagreeing with you - I do have strong <a href="CeeLanguage.html">CeeLanguage</a> influences, but just to explain where I was coming from - Can you imagine the <a href="ThreadMess.html">ThreadMess</a> if someone really did post a "true" <a href="CeePlusPlus.html">CeePlusPlus</a> example?
      </p>
      <p>
        You could guarantee a <a href="HolyWar.html">HolyWar</a> over:
      </p>
      <ul>
        <li>
           Whether writing to a generic stream is better than writing to cout.
        </li>
        <li>
           Whether it was encapsulated enough or had had too many "Get/Put" methods.
        </li>
        <li>
           What design patterns it followed incorrectly or *gasp*didn't use at all.
        </li>
        <li>
           The missing or excessive use of interfaces/templates/overloading. 
        </li>
      </ul>
      <p>
        I don't think this little exercises risk major HolyWars. Anyway, 
      </p>
      <ul>
        <li>
           generic streams make it more reusable, so that is more desirable. <em>I'd agree, but I would also consider the decision subjective</em>
          <ul>
            <li>
               On this page, yes, but in a real project, inevitably you want to direct something to cerr, not just cout, so I wouldn't call it subjective in general.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           Get/Put has of course been discussed, and I don't think there's any question: it's a Smell, but not necessarily wrong.
        </li>
        <li>
           Failing to use a known <a href="DesignPattern.html">DesignPattern</a> - now you're being silly. If you can cite any instances of that on the entire web by an apparently sane person, I'd be interested in seeing it. <em>True. . . and I do love being silly</em>
        </li>
        <li>
           Operator overloading ideally should be used only on numeric operators to implement new numeric types, except that Stroustrup brain damage means that it also should be used to extend standard operators like << and >>.
        </li>
        <li>
           Redefining other operators like ()[] etc usually should be done if and only if one is redefining essentially <strong>all</strong> operators transparently in order to play tricks like reference-counted garbage collection, and otherwise it's a major smell.
        </li>
        <li>
           Templates should be used any time there is a need to parameterize an algorithm by type. They should not be used to play other kinds of tricks -- except that by now there are a lot of C++ specific patterns on using them in bizarre ways in order to work around limitations of the language, so there are some peculiar cases where you've got a point.
        </li>
        <li>
           What do you mean by missing/overuse of interfaces?
          <ul>
            <li>
               <em>I meant whether the objects should have abstract interfaces, be wrapped in COM layers, etc - but I guess that goes back to the design patterns.</em>
            </li>
            <li>
               Ah.
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <em>Even in straight C, getting to the elegant minimum is fiercely debated. Perhaps the posts of "true" </em><a href="CeePlusPlus.html">CeePlusPlus</a> examples are so large that they could be the cause of the denied access problems we've been having. ;)<em></em>
      </p>
      <ul>
        <li>
           Perhaps. I've been thinking about doing one, and have refrained so far because of the mental image. ;-)
        </li>
      </ul>
      <code>
        /*<br/>
        This entry contains certain functionality the others may not.<br/>
      </code>
      <ul>
        <li>
           The stop-start span does not need to be equal to width
        </li>
        <li>
           The command-line is checked for missing arguments
        </li>
        <li>
          /
        </li>
      </ul>
      <code>
        #include <stdio.h><br/>
        #include <stdlib.h><br/>
      </code>
      <code>
        void hexdump(unsigned char *buffer, unsigned long index, unsigned long width)<br/>
        {<br/>
        unsigned long i;<br/>
        for (i=0;i<index;i++)<br/>
        {<br/>
        printf("%02x ",buffer[i]);<br/>
        }<br/>
        for (unsigned long spacer=index;spacer<width;spacer++)<br/>
        printf("	");<br/>
        printf(": ");<br/>
        for (i=0;i<index;i++)<br/>
        {<br/>
        if (buffer[i] < 32) printf(".");<br/>
        else printf("%c",buffer[i]);<br/>
        }<br/>
        printf("\n");<br/>
        }<br/>
      </code>
      <code>
        int hexdump_file(FILE *infile,unsigned long start, unsigned long stop, unsigned long width)<br/>
        {<br/>
        char ch;<br/>
        unsigned long f_index=0;<br/>
        unsigned long bb_index=0;<br/>
        unsigned char *byte_buffer = malloc(width);<br/>
        if (byte_buffer == NULL)<br/>
        {<br/>
        printf("Could not allocate memory for byte_buffer\n");<br/>
        return -1;<br/>
        }<br/>
        while (!feof(infile))<br/>
        {<br/>
        ch = getc(infile);	<br/>
        if ((f_index >= start)&&(f_index <= stop))<br/>
        {<br/>
        byte_buffer[bb_index] = ch;<br/>
        bb_index++;<br/>
        }<br/>
        if (bb_index >= width)<br/>
        {<br/>
        hexdump(byte_buffer,bb_index,width);<br/>
        bb_index=0;<br/>
        }	<br/>
        f_index++;	<br/>
        }<br/>
        if (bb_index)<br/>
        hexdump(byte_buffer,bb_index,width);<br/>
        fclose(infile);<br/>
        free(byte_buffer);<br/>
        return 0;<br/>
        }<br/>
      </code>
      <code>
        int main(int argc, char *argv[])<br/>
        {<br/>
        if (argc != 5)<br/>
        {<br/>
        printf("Usage: hexdump <infile> <start> <end> <width>\n");<br/>
        return 0;<br/>
        }<br/>
        FILE *infile=fopen(argv[1],"rb");<br/>
        if (infile==(FILE *)NULL)<br/>
        {<br/>
        printf("Error opening input file %s\n",argv[1]);<br/>
        return 0;<br/>
        }<br/>
        printf("Filename: \"%s\"\n",	argv[1]);<br/>
        printf("Start : %lu\n",	atoi(argv[2]));<br/>
        printf("End	: %lu\n",	atoi(argv[3]));<br/>
        printf("Bytes per Line: %lu\n",atoi(argv[4]));  <br/>
        int result = hexdump_file(infile,atoi(argv[2]),atoi(argv[3]),atoi(argv[4]));<br/>
        return 0;<br/>
        }<br/>
      </code>
      <p>
        Run output:
      </p>
      <code>
        $ hexdump hexdump.c 0 100 16<br/>
        Filename: "hexdump.c"<br/>
        Start : 0<br/>
        End	: 100<br/>
        Bytes per Line: 16<br/>
      </code>
      <ol>
        <li>
          f 2a 0d 0a 20 20 54 68 69 73 20 65 6e 74 72 79 : /*..  This entry
        </li>
        <li>
           63 6f 6e 74 61 69 6e 73 20 63 65 72 74 61 69 :  contains certai
        </li>
        <li>
          e 20 66 75 6e 63 74 69 6f 6e 61 6c 69 74 79 20 : n functionality
        </li>
        <li>
           68 65 20 6f 74 68 65 72 73 20 6d 61 79 20 6e : the others may n
        </li>
        <li>
          f 74 2e 0d 0a 20 20 20 20 2a 20 54 68 65 20 73 : ot...	* The s
        </li>
        <li>
           6f 70 2d 73 74 61 72 74 20 73 70 61 6e 20 64 : top-start span d
        </li>
        <li>
          f 65 73 20 6e				  : oes n
        </li>
      </ol>
      <p>
        -- <a href="LayneThomas.html">LayneThomas</a>
      </p>
      <hr/>
      <p>
        <strong></strong><a href="ForthLanguage.html">ForthLanguage</a><strong></strong>
      </p>
      <p>
        DUMP is in the ANS Tools word set, e.g. GNU Forth:
      </p>
      <code>
        HERE 32 DUMP<br/>
      </code>
      <ol>
        <li>
          : 80 C0 0C CC  C3 33 0C 30 - CC 33 0C C3  30 C3 0C CC  .....3.0.3..0...
        </li>
        <li>
          A0: CC CC CC CC  CC CC CC CC - C3 0C CC CC  CC CC CC CC  ................
        </li>
      </ol>
      <p>
        Here's an implementation that meets the new spec. (Usage:  "start end width HEXDUMP filename")
      </p>
      <ol>
        <li>
           value fileid
        </li>
      </ol>
      <code>
        : .pos ( ud -- )<br/>
        <# # # # #S #> type ." : " ;<br/>
        : .hex ( addr len -- )<br/>
        over + swap do I c@ S>D <# # # #> type space loop ;<br/>
        : .spacer ( width read -- )<br/>
        - 3 * spaces ." : " ;<br/>
        : .chars ( addr len -- )<br/>
        over + swap do I c@ dup 127 bl within if drop [char] . then emit loop ;<br/>
        : (hd) ( start end width "filename" -- )<br/>
        R/O OPEN-FILE throw  to fileid<br/>
        >R over - R> rot ( count width start )<br/>
        S>D fileid REPOSITION-FILE throw ( count width )<br/>
        begin  cr fileid FILE-POSITION throw .pos<br/>
      </code>
      <ol>
        <li>
          dup min pad swap fileid READ-FILE throw ?dup
        </li>
      </ol>
      <code>
        while  pad over .hex	2dup .spacer  pad over .chars<br/>
        over =          \ end of file?<br/>
        while  tuck - tuck 0>  \ end of range?<br/>
        while repeat then then 2drop<br/>
        fileid CLOSE-FILE throw cr ;<br/>
        : hexdump ( start end width "filename" -- )<br/>
        bl parse  base @ >R hex  ['] (hd) catch  R> base !  throw ;<br/>
      </code>
      <p>
        Sample output, testing EOF handling and partial last line :
      </p>
      <ol>
        <li>
           950 8 hexdump hexdump.f 
        </li>
        <li>
          A2: 61 73 65 20 21 20 20 74 : ase !  t
        </li>
        <li>
          AA: 68 72 6F 77 20 3B 0A    : hrow ;.
        </li>
      </ol>
      <p>
        <em>I believe that <# #> is underrated even in the Forth world, and certainly outside it. People seem to think it's pretty much equivalent to formatting in C or Lisp, but I think it is instead an example of an entire paradigm of programming that is mostly unexplored, although alluded to by </em><a href="ChuckMoore.html">ChuckMoore</a>.<em></em>
      </p>
      <p>
        Could you expand on this? Forth pictured numerics are simple, but not exactly the friendliest of constructs (you are specifying digits in reverse order, for example). Here is GNU Forth's simple implementation (though I added <em>digit>char</em> for clarity).
      </p>
      <code>
        variable holdptr<br/>
        variable holdend<br/>
        create holdbuf 64 allot<br/>
        here constant holdbuf-end<br/>
        : <# ( ud -- ud ) holdbuf-end dup holdptr ! holdend ! ;<br/>
        : hold ( c -- ) -1 holdptr +! holdptr @  dup holdbuf u< -17 and throw  c! ;<br/>
        : digit>char ( 0-35 -- [0-9A-Z] ) 9 over < IF 7 + THEN [char] 0 + ;<br/>
        : # ( ud -- ud/base ) base @ ud/mod rot digit>char hold ;<br/>
        : #s ( ud -- 0d ) BEGIN # 2dup or 0= UNTIL ;<br/>
        : #> ( ud -- addr len ) 2drop holdptr @ holdend @ over - ;<br/>
      </code>
      <p>
        <em>Yeah, and many in the Forth community actually regard them as obsolete. But I'm not talking about their literal use for formatting, I'm talking about them as an example of a different way of approaching doing programming. Recall anything that </em><a href="ChuckMoore.html">ChuckMoore</a> has said about how he approaches problem solving in Forth?<em></em>
      </p>
      <p>
        Here's one example of what Moore said:
      </p>
      <p>
        "The whole point of Forth was that you didn't write programs in Forth you wrote vocabularies in Forth. When you devised an application you wrote a hundred words or so that discussed the application and you used those hundred words to write a one line definition to solve the application. It is not easy to find those hundred words, but they exist, they always exist."
      </p>
      <p>
        "I wish I knew what to tell you that would lead you to write good Forth. I can demonstrate. I have demonstrated in the past, ad nauseam, applications where I can reduce the amount of code by 90% percent and in some cases 99%. It can be done, but in a case by case basis. The general principle still eludes me."
        <a href="http://www.ultratechnology.com/1xforth.htm">http://www.ultratechnology.com/1xforth.htm</a>
      </p>
      <p>
        He doesn't know how to explain how he goes about finding just the right set of words. I think <# #> serves as an illustration, not of the ultimate way to format, but of the paradigm he exercises unconsciously. -- dm
      </p>
      <hr/>
      <p>
        <strong></strong><a href="ColorForth.html">ColorForth</a><strong></strong>
      </p>
      <p>
        The wiki doesn't do color, so these are the mappings:
      </p>
      <ul>
        <li>
           red words are <strong>definitions</strong>
        </li>
        <li>
           green words and numbers are normal
        </li>
        <li>
           white words are (commentary)
        </li>
        <li>
           yellow words are executed [immediately]
        </li>
        <li>
           purple words are in-source variables (var x). The numbers shown after them are their actual contents.
        </li>
        <li>
           dark green hex constants are normal here
        </li>
        <li>
           color implementation and semantics are described on <a href="http://www.colorforth.com/parsed.html">http://www.colorforth.com/parsed.html</a>
          <ul>
            <li>
               <strong>I see your new links on </strong><a href="ColorForth.html">ColorForth</a>, but I still don't see a pointer to a list of <a href="ColorForth.html">ColorForth</a> words. Previously I would have assumed that I could have guessed some of them, like "dup", since it seems vaguely similar to constructs in other versions of Forth. :-) But since you assure me <a href="ColorForth.html">ColorForth</a> is so very different (and since Moore has such disdain for ANS Forth), I'd better not take that on faith. Maybe "dup" stands for "DuPont".<strong></strong>
              <ul>
                <li>
                   Many are the same (dup, drop, swap, @, !, +, etc.), but many others are different from their Forth counterparts (or, if, -, ;), some words are renamed (push, pop, minus), and many more are unique to the system (show, screen, keyboard). It is dangerous to assume too much when reading <a href="ColorForth.html">ColorForth</a> source.
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           Huh? I don't <strong>want</strong> to assume anything; I keep asking if you know where there is a list of <a href="ColorForth.html">ColorForth</a> word definitions. If the answer is "no, you have to infer it from reading their implementation in x86 assembly or in terms of the 27 forth chip primitives", ok, then that's the way it is, and if I ever truly need to figure it out, I'll do that. But it seems more likely to me that there is in fact a word list in English somewhere, and it's merely in an obscure location. Also, if the answer is "I don't know offhand, and I don't have time to search it out for you", of course that's fine too. :-) I just thought it was potentially interesting, and oddly hard to find. Then again, the Forth world is strangely allergic to anything resembling standards, it seems, ANS Forth notwithstanding, since so many seem to despise it, not just Moore.
        </li>
      </ul>
      <p>
        Other Strange Things:
      </p>
      <ul>
        <li>
           (I didn't find the definition for <em>h.</em>, so it's probably in the assembly kernel.)
          <ul>
            <li>
               At first I thought perhaps h. was doing a 4 bit to hex conversion per call, but every two calls are followed by cr, so I must be misunderstanding the context.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <em>or drop if</em>: unlike Forth, <em>if</em> uses the processor zero flag, not the top stack item. <em>or</em> sets the flag for <em>if</em>, <em>drop</em> clears the unneeded numeric result. Since <em>or</em> is an exclusive-or (don't ask), the clause is equivalent to <em><> if</em> in standard Forth.
        </li>
        <li>
           <em>dump</em> falls through into <em>r</em> and <em>u</em> falls through into <em>+xy</em> to avoid a function call (a common <a href="AssemblyLanguage.html">AssemblyLanguage</a> idiom)
        </li>
        <li>
           <em>dump</em>, <em>r</em>, and <em>cmp</em> set the background task (straight dump or diff of two regions). The displayed dump is <em>active</em> and displays changes to memory in real time.
        </li>
        <li>
           <em>dump</em>, <em>byte</em>, <em>u</em>, <em>d</em>, and <em>+xy</em> update the address to show.
        </li>
        <li>
           The dumps don't show ASCII because <a href="ColorForth.html">ColorForth</a> uses a Huffman encoding for text. The format per line for <em>dump</em> is "<hex word> <hex address>" and for <em>cmp</em> it is "<hex x> <hex y> <[red] offset>" with the x and y base addresses listed at the top. The offset is printed red if the contents differ.
        </li>
      </ul>
      <p>
        {block 32} 
      </p>
      <code>
        (dump) var x (200000) var y (201200)<br/>
        <strong>one</strong> dup @ h. space dup h. cr ;<br/>
        <strong>lines</strong> for one -1 + next drop ;<br/>
        <strong>dump</strong> x !<br/>
        <strong>r</strong> show black screen x @ 15 + 16 text lines keyboard ;<br/>
        <strong>it</strong> @ + @ dup h. space ;<br/>
        <strong>lines</strong> for white i [x] it i [y] it or drop if red then i . cr -next ;<br/>
        <strong>cmp</strong> show blue screen text 19 lines red [x] @ h. space [y] @ h. keyboard ;<br/>
        <strong>u</strong> 16<br/>
        <strong>+xy</strong> dup [x] +! [y] +! ;<br/>
        <strong>d</strong> -16 +xy ;<br/>
        <strong>ati</strong> F4100000 (ff7fc000) or<br/>
        <strong>byte</strong> 4 / dump ;<br/>
        <strong>fix</strong> for 0 over ! 1 + next ; [dump]<br/>
      </code>
      <p>
        {block 33} <em>this is the shadow block, commentary on the previous block. An editor command flips between a block and its shadow.</em>
      </p>
      <code>
        (does not say empty, compiles on top of application)<br/>
        <strong>x</strong> -a (current address)<br/>
        <strong>one</strong> a-a (line of display)<br/>
        <strong>lines</strong> an<br/>
        <strong>dump</strong> a (background task continually displays memory)<br/>
        <strong>u</strong> (increment address)<br/>
        <strong>d</strong> (decrement)<br/>
        <strong>ati</strong> (address of AGP graphic registers)<br/>
        <strong>byte</strong> (a byte address dump)<br/>
        <strong>fix</strong> an-a (test word)<br/>
      </code>
      <p>
        <em>I just looked (for way too long) and couldn't find a list of the standard (well - common) colorforth words anywhere at all (Moore has an annoying page purporting to help programmers that basically says "try it! I'll add documentation some year. Maybe"). Where can I find one?</em>
      </p>
      <p>
        <a href="ColorForth.html">ColorForth</a> is primarily <a href="ChuckMoore.html">ChuckMoore</a>'s personal programming system. As a working engineer, he hasn't had much time or inclination to document his evolving experiment. He admits communication is one of his weaknesses. Others have written better documented variants that keep the flavor of <a href="ColorForth.html">ColorForth</a>; I'll try to add more references to the <a href="ColorForth.html">ColorForth</a> page. This particular snippet came from some webified source on <a href="http://www.merlintec.com/download/color.html">http://www.merlintec.com/download/color.html</a>
      </p>
      <p>
        <em>You've already largely translated it out of colorforth; may as well continue until it's 100% one of the regular forths. After all, there seem to be, what, 20 regular colorforth users, and 1 colorforth expert, in the world? :-)</em>
      </p>
      <p>
        Actually, I haven't changed it a whit; it's a direct mapping from color to markup. <a href="ColorForth.html">ColorForth</a> has very different semantics from standard Forth. They're even further apart than <a href="SchemeLanguage.html">SchemeLanguage</a> is from <a href="CommonLisp.html">CommonLisp</a>.
      </p>
      <p>
        <em>Magenta variables are interesting, since they're basically a bizarre way of doing persistence.</em>
      </p>
      <hr/>
      <p>
        <strong></strong><a href="JavaLanguage.html">JavaLanguage</a><strong>:</strong>
      </p>
      <code>
        import java.io.File;<br/>
        import java.io.FileInputStream;<br/>
        import java.io.FileNotFoundException;<br/>
        import java.io.IOException;<br/>
        import java.io.UnsupportedEncodingException;<br/>
      </code>
      <code>
        public class HexDump {<br/>
      </code>
      <code>
        public static void main(String[] args) throws IOException {<br/>
        String inputFileName = args[0];<br/>
        int start = Integer.parseInt(args[1]);<br/>
        int end = Integer.parseInt(args[2]);<br/>
        int width = Integer.parseInt(args[3]);<br/>
        byte[] bytes = read(inputFileName, start, end);<br/>
        for (int index = 0; index < bytes.length; index += width) {<br/>
        printHex(bytes, index, width);<br/>
        printAscii(bytes, index, width);<br/>
        }<br/>
        }<br/>
      </code>
      <code>
        private static byte[] read(String inputFileName, int start, int end)<br/>
        throws FileNotFoundException, IOException {<br/>
        File theFile = new File(inputFileName);<br/>
        FileInputStream input = new FileInputStream(theFile);<br/>
        int skipped = 0;<br/>
        while (skipped < start) {<br/>
        skipped += input.skip(start - skipped);<br/>
        }<br/>
        int length = (int) (Math.min(end, theFile.length()) - start);<br/>
        byte[] bytes = new byte[length];<br/>
        int bytesRead = 0;<br/>
        while (bytesRead < bytes.length) {<br/>
        bytesRead = input.read(bytes, bytesRead, bytes.length - bytesRead);<br/>
        if (bytesRead == -1) {<br/>
        break;<br/>
        }<br/>
        }<br/>
        return bytes;<br/>
        }<br/>
      </code>
      <code>
        private static void printHex(byte[] bytes, int offset, int width) {<br/>
        for (int index = 0; index < width; index++) {<br/>
        if (index + offset < bytes.length) {<br/>
        System.out.printf("%02x ", bytes[index + offset]);<br/>
        } else {<br/>
        System.out.print("	");<br/>
        }<br/>
        }<br/>
        }<br/>
      </code>
      <code>
        private static void printAscii(byte[] bytes, int index, int width)<br/>
        throws UnsupportedEncodingException {<br/>
        if (index < bytes.length) {<br/>
        width = Math.min(width, bytes.length - index);<br/>
        System.out.println(<br/>
        ":"<br/>
        + new String(bytes, index, width, "UTF-8").replaceAll("\r\n", " ").replaceAll(<br/>
        "\n",<br/>
        " "));<br/>
        } else {<br/>
        System.out.println();<br/>
        }<br/>
        }<br/>
      </code>
      <p>
        }
      </p>
      <code>
        Arguments: HexDump.java 0 100 16<br/>
      </code>
      <ol>
        <li>
           6d 70 6f 72 74 20 6a 61 76 61 2e 69 6f 2e 46 :import java.io.F
        </li>
        <li>
           6c 65 3b 0d 0a 69 6d 70 6f 72 74 20 6a 61 76 :ile; import jav
        </li>
        <li>
           2e 69 6f 2e 46 69 6c 65 49 6e 70 75 74 53 74 :a.io.FileInputSt
        </li>
        <li>
           65 61 6d 3b 0d 0a 69 6d 70 6f 72 74 20 6a 61 :ream; import ja
        </li>
        <li>
           61 2e 69 6f 2e 46 69 6c 65 4e 6f 74 46 6f 75 :va.io.FileNotFou
        </li>
        <li>
          e 64 45 78 63 65 70 74 69 6f 6e 3b 0d 0a 69 6d :ndException; im
        </li>
        <li>
           6f 72 74					:port
        </li>
      </ol>
      <hr/>
      <p>
        And another <a href="JavaLanguage.html">JavaLanguage</a> example factored differently:
      </p>
      <code>
        package main;<br/>
        import java.io.*;<br/>
        import java.util.*;<br/>
      </code>
      <code>
        public class Dump {<br/>
      </code>
      <code>
        public static void main(String[] args) {<br/>
        byte[] bytes = new ContentFile(args[0]).content().getBytes();<br/>
        int start = integer(args[1]);<br/>
        bytes = slice(bytes, start, integer(args[2]));<br/>
        int perLine = integer(args[3]);<br/>
        List<Line> chunks = chunks(start, bytes ,perLine);<br/>
        for(Line x : chunks)<br/>
        x.writeLn(perLine);<br/>
        }<br/>
      </code>
      <code>
        private static String leftPadded(String s, int num) {while (s.length() < num) s = " " + s; return s; }<br/>
        private static int integer(String s) {  return Integer.parseInt(s);  }<br/>
      </code>
      <code>
        private static List<Line> chunks(int start, byte[] bytes, int perLine) {<br/>
        List<Line> result = new <a href="ArrayList.html">ArrayList</a><Line>();<br/>
        while (bytes.length > 0) {<br/>
        result.add(new Line(start, slice(bytes, 0, perLine)));<br/>
        bytes = slice(bytes, perLine, bytes.length);<br/>
        start += perLine;<br/>
        }<br/>
        return result;<br/>
        }<br/>
      </code>
      <code>
        private static byte[] slice(byte[] bytes, int start, int end) {<br/>
        if (end > bytes.length) end = bytes.length;<br/>
        if (end - start <= 0) return new byte[0];<br/>
        byte[] result = new byte[end - start];<br/>
        System.arraycopy(bytes, start, result, 0, end - start);<br/>
        return result;<br/>
        }<br/>
      </code>
      <code>
        static class ContentFile {<br/>
        File file_;<br/>
        public ContentFile(String name) {<br/>
        file_ = new File(name);<br/>
        }<br/>
        public String content() {<br/>
        try {<br/>
        <a href="StringBuffer.html">StringBuffer</a> buf = new <a href="StringBuffer.html">StringBuffer</a>();<br/>
        BufferedReader in = new BufferedReader(new FileReader(file_));<br/>
        for(String s = in.readLine(); s != null; s = in.readLine())<br/>
        buf.append(s);<br/>
        return buf.toString();<br/>
        } catch (Exception e) {<br/>
        throw new <a href="RuntimeException.html">RuntimeException</a>("couldn't get content", e);<br/>
        } <br/>
        }<br/>
        }<br/>
      </code>
      <code>
        static class Line {<br/>
        final int start;<br/>
        final byte[] bytes;<br/>
        public Line(int start, byte[] bytes) {<br/>
        this.bytes = bytes;<br/>
        this.start = start;<br/>
        }<br/>
        public void writeLn(int perLine) {<br/>
        System.out.println("O: " + leftPadded("" + start, 4) + " " + bytesText(perLine) + ":" + text());<br/>
        }<br/>
        private String text() {<br/>
        String result = "";<br/>
        for(int i = 0; i < bytes.length; i++) {<br/>
        char c = (char) bytes[i];<br/>
        result += Character.isLetterOrDigit(c) || Character.isSpace(c) ? c : '.';<br/>
        }<br/>
        return result;<br/>
        }<br/>
        private String bytesText(int perLine) {<br/>
        String result = "";<br/>
        for(int i = 0; i < bytes.length; i++) {<br/>
        result += String.format("%02x ", bytes[i]);<br/>
        }<br/>
        while (perLine-- > bytes.length) result += "   ";<br/>
        return result;<br/>
        }<br/>
        }<br/>
        }<br/>
      </code>
      <code>
        C:\eclipserc3\eclipse\workspace\hex\bin>java -cp . main.Dump ..\src\main\Dump.java 0 100 16<br/>
        O:   00 70 61 63 6b 61 67 65 20 6d 61 69 6e 3b 69 6d 70 :package main.imp<br/>
        O:   16 6f 72 74 20 6a 61 76 61 2e 69 6f 2e 2a 3b 69 6d :ort java.io...im<br/>
        O:   32 70 6f 72 74 20 6a 61 76 61 2e 75 74 69 6c 2e 2a :port java.util..<br/>
        O:   48 3b 70 75 62 6c 69 63 20 63 6c 61 73 73 20 44 75 :.public class Du<br/>
        O:   64 6d 70 20 7b 20 20 20 20 70 75 62 6c 69 63 20 73 :mp .    public s<br/>
        O:   80 74 61 74 69 63 20 76 6f 69 64 20 6d 61 69 6e 28 :tatic void main.<br/>
        O:   96 53 74 72 69                                     :Stri<br/>
      </code>
      <p>
        C:\eclipserc3\eclipse\workspace\hex\bin>
      </p>
      <p>
        I wanted to factor the chunks method into the Line class by creating a line with the entire source byte array, and then calling a method subdivide, which would call a method line() and a method rest(). Think that would pretty up a bit more, but hey - real work calls.
      </p>
      <p>
        -- <a href="JeffBay.html">JeffBay</a>
      </p>
      <hr/>
      <p>
        <strong></strong><a href="BourneShell.html">BourneShell</a><strong>:</strong>
      </p>
      <code>
        #!/bin/sh<br/>
      </code>
      <code>
        if [ $# -ne 4 ]<br/>
        then<br/>
        echo "Usage: $0 <source> <start> <end> <width>" 1>&2<br/>
        exit 2<br/>
        fi<br/>
      </code>
      <code>
        SOURCE="$1"<br/>
        START="$2"<br/>
        END="$3"<br/>
        WIDTH="$4"<br/>
        LENGTH=`expr $END - $START`<br/>
      </code>
      <code>
        hexdump -s $START -n $LENGTH -e $WIDTH'/1 "%02X "' -e '" : "' -e '"%_p"' -e '"\n"' $SOURCE<br/>
      </code>
      <p>
        ...<a href="HaHaOnlySerious.html">HaHaOnlySerious</a>!
      </p>
      <hr/>
      <p>
        <strong></strong><a href="PerlLanguage.html">PerlLanguage</a><strong>:</strong>
      </p>
      <code>
        #!/usr/bin/perl -w<br/>
        use Fcntl qw(:seek);<br/>
        use List::Util qw(min);<br/>
        use strict;<br/>
        if(@ARGV != 4) {<br/>
        print STDERR "Usage: $0 <source> <start> <end> <width>\n";<br/>
        exit(2);<br/>
        }<br/>
        my ($source, $start, $end, $width) = @ARGV;<br/>
        open(SOURCE, "<", $source) or die("Can't open $source");<br/>
        seek(SOURCE, $start, SEEK_SET) or die("Can't seek to $start");<br/>
        my $block;<br/>
        for(my $left = $end - $start; $left > 0 && read(SOURCE, $block, min($width, $left)); $left -= length($block)) {<br/>
        my $hex = join(" ", (map { sprintf("%02X", ord($_)) } split(//, $block)));<br/>
        $hex .= '	' x ($width - length($block));<br/>
        my $plain = join("", (map { printable($_) ? $_ : "." } split(//, $block)));<br/>
        print "$hex: $plain\n";<br/>
        }<br/>
        sub printable { my $o = ord($_[0]); return $o >= 33 && $o <= 126; }<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="CeeLanguage.html">CeeLanguage</a><strong>:</strong>
      </p>
      <code>
        #include <stdio.h><br/>
        #include <stdlib.h><br/>
        #include <ctype.h><br/>
        int min(int a, int b) { return a < b ? a : b; }<br/>
        int main(int argc, char *argv[]) {<br/>
        FILE *fp;<br/>
        int i, start, end, width, left, count;<br/>
        unsigned char *buf;<br/>
        if(argc != 5) {<br/>
        fprintf(stderr, "Usage: %s <source> <start> <end> <width>\n", argv[0]);<br/>
        exit(2);<br/>
        }<br/>
        if((fp = fopen(argv[1], "r")) == NULL) { perror("fopen"); exit(2); }<br/>
        start = atoi(argv[2]);<br/>
        end	= atoi(argv[3]);<br/>
        width = atoi(argv[4]);<br/>
        left = end - start;<br/>
        if((buf = malloc(width)) == NULL) {<br/>
        fprintf(stderr, "No memory?!?\n");<br/>
        exit(2);<br/>
        }<br/>
        if(fseek(fp, start, SEEK_SET)) { perror("fseek"); exit(2); }<br/>
        while(left > 0 && (count = fread(buf, 1, min(left, width), fp))) {<br/>
        for(i = 0; i < count; i++)	 printf("%02X ", buf[i]);<br/>
        for(i = 0; i < width - count; i++) printf("	");<br/>
        printf(": ");<br/>
        for(i = 0; i < count; i++) printf("%c", isgraph(buf[i]) ? buf[i] : '.');<br/>
        printf("\n");<br/>
        left -= count;<br/>
        }<br/>
        free(buf);<br/>
        return 0;<br/>
        }<br/>
      </code>
      <p>
        Hmm, this doesn't appear to be totally debugged:
      </p>
      <code>
        ./a.out a.out 0 50 16<br/>
      </code>
      <ol>
        <li>
          F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00 : .ELF............
        </li>
        <li>
           00 03 00 01 00 00 00 FFFFFFB0 FFFFFF84 04 08 34 00 00 00 : ............4...
        </li>
      </ol>
      <code>
        FFFFFFC0 23 00 00 00 00 00 00 34 00 20 00 06 00 28 00 : .#......4.....(.<br/>
      </code>
      <ol>
        <li>
           00						: #.
        </li>
      </ol>
      <p>
        You need to add a mask: printf("%02X ", buf[i] & 0xff);
      </p>
      <p>
        Minor detail.
      </p>
      <p>
        <em>Ah. Signed chars are sign extended into signed ints... Fixed by making the chars unsigned.</em>
      </p>
      <p>
        You beat me to the edit, and with a shorter solution, it looks like.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="CeeLanguage.html">CeeLanguage</a><strong>:</strong>
      </p>
      <p>
        After great struggle, I transformed the natural but verbose approach of C closures, reflection, and metaclasses into something a little more terse:
      </p>
      <code>
        #include	<assert.h><br/>
        #include	<stdio.h><br/>
        #include	<ctype.h><br/>
        void displayHexRecord(char *data, int count, int record_length) {<br/>
        int	i;<br/>
        for (i=0; i < count; i++) printf("%02x ", data[i] & 0xff);<br/>
        for (; i < record_length; i++) printf("	");<br/>
        printf(": ");<br/>
        for (i=0; i < count; i++) {<br/>
        if (isgraph(data[i])) putchar(data[i]);<br/>
        else		  putchar('.');<br/>
        }<br/>
        putchar('\n');<br/>
        }<br/>
        void hexDump(FILE *f, long cur_addr, long end, int bytes_per_line) {<br/>
        int	record_length, read_count;<br/>
        char	*data;<br/>
        assert(data = (char*) calloc(sizeof(data[0]), bytes_per_line));<br/>
        if (-1 == fseek(f, cur_addr, SEEK_SET)) perror("fseek");<br/>
        while (1) {<br/>
        printf("%05x  ", cur_addr);<br/>
        read_count = end - cur_addr;<br/>
        if (read_count > bytes_per_line) read_count = bytes_per_line;<br/>
        record_length = fread(data, sizeof(char), read_count, f);<br/>
        displayHexRecord(data, record_length, bytes_per_line);<br/>
        if (record_length < bytes_per_line) break;<br/>
        if (end <= (cur_addr += record_length)) break;<br/>
        }<br/>
        free(data);<br/>
        }<br/>
      </code>
      <p>
        Output for hexDump(f, 0, 55, 16) of its own executable:
      </p>
      <ol>
        <li>
            7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 : .ELF............
        </li>
        <li>
            02 00 03 00 01 00 00 00 f0 83 04 08 34 00 00 00 : ............4...
        </li>
        <li>
            44 35 00 00 00 00 00 00 34 00 20 00 06 00 28 00 : D5......4.....(.
        </li>
        <li>
            23 00 20 00 06 00 00				: #......
        </li>
      </ol>
      <p>
        There's something strange about powerful languages having longer examples than powerless languages...
      </p>
      <p>
        <em>where's the main() and why no checking of command line arguments - it wouldn't produce a full executable without some other harness, so. . . where is it?</em>
      </p>
      <p>
        It's a library function. Requiring a full program violates the spirit of these <a href="ProgrammingChrestomathy.html">ProgrammingChrestomathy</a> pages; someone has already commented on searching and hex <strong>editing</strong>, and why exactly are we leaving out the GUI? :-P That's all foolishness, so I created a library routine. I also left out e.g. printing the filename, because that violates principles outlined in <a href="TheArtOfUnixProgramming.html">TheArtOfUnixProgramming</a>; that, too, is an inappropriate requirement, although obviously it only adds one line of code to a program in any language.
      </p>
      <p>
        <em>Printing the filename wasn't a requirement. The Scheme program prompts the user for the filename, etc., from the console because command-line arguments aren't part of the standard language. Apparently, the person who wrote the C++ example (which, as someone else pointed it, is actually plain C) mistook the Scheme program prompting the user for input as printing the arguments out.</em>
      </p>
      <ul>
        <li>
           Ah, I think I see. Incidentally, I was the one who pointed out the C++ was actually C, so it wasn't "someone else", it was just "someone". :-)
        </li>
      </ul>
      <p>
        Anyone who fails to grok these points should immediately go download and examine the (huge) GNU hello world distribution, and ponder how it is that hello world got to be so big.
      </p>
      <p>
        (It got to be that big because it's an example of how to release packages The GNU Way and they wanted to give an example of every bell, whistle, and gong you can accomplish with standard GNU packaging tools. In other words, it got that big because it's demonstrating a nontrivial solution set to a <em>highly</em> nontrivial problem.)
      </p>
      <p>
        But if you just want to try it, a trivial main will do it:
      </p>
      <code>
        #include <stdio.h><br/>
      </code>
      <code>
        int main(void) {<br/>
        FILE *f = fopen("a.out", "r");<br/>
        if (f == NULL) {<br/>
        perror("a.out");<br/>
        exit(1);<br/>
        }<br/>
        hexDump(f, 0, 55, 16);<br/>
        return 0;<br/>
        }<br/>
      </code>
      <p>
        Parse command line args? What's that got to do with hex dump Chrestomathy? How about a test harness? I never saw a Marketing Requirements doc, either. Where's our sysadmin plan? Budget? HR-required ergonomic classes? Shall I go on? :-)
      </p>
      <p>
        It's not really terse if it's missing a main, and puts printfs on the same line as the for loop. How many corners can you cut and claim "but it's terse!"? :->
      </p>
      <p>
        (Bug fixed, thanks.)
      </p>
      <p>
        <em>How many corners can you cut and claim "but it's terse"? That's a good question. But you know, textbooks and magazine columns that illustrate algorithms almost always leave out error checks, because they get in the way of seeing the algorithm that is the true point.</em>
      </p>
      <p>
        <em>The question of whether to sometimes put trivial bodies on the same line as the control construct, or whether to always put them on separate lines, is purely stylistic, and obviously </em><a href="HolyWar.html">HolyWar</a>s have been fought about that. Some people claim that it makes a huge difference in readability, but I personally don't think it matters too much either way in most cases.<em></em>
      </p>
      <p>
        <em>The other </em><a href="CeeLanguage.html">CeeLanguage</a> author did similar things - while finding an even more terse algorithm kernel as well.<em></em>
      </p>
      <p>
        Well, every programmer thinks their coding style is the "pragmatic optimum", so I won't argue that. The whole Chrestomathy idea should apply to samples
        within the same language too. I guess the "real-world" origins of this page have changed, but now it's kind of a loose problem. How does the file get read? What does it link with? Does it require a host environment? Unfortunately "hex dumping" isn't really an algorithmic problem. . . so . . I guess I have no point than to say I'm not sure what the criteria for a good example is anymore.
      </p>
      <p>
        <em>It's not a huge algorithmic problem; none of these chrestomathy pages are. But it's an interesting </em>'small<em>' algorithmic problem. I still need to finish examining why it is that the other author got a smaller kernel than I did, so as to keep in mind any points I observe for future use. Look for general principles whenever possible, I say.</em>
      </p>
      <p>
        <em>P.S. I thought I already addressed the issue of the missing main(), but to be somewhat more explicit: it would be all but trivially the same for all of these chrestomathy pages. It's not interesting, it's not illustrative, it doesn't vary, but it certainly adds clutter. And also, come now, I added one after someone implied they didn't want to be bothered writing one to test my code...but I still don't see that it is part of the chrestomathy proper. A proper Hello World illustrates half of how to do it in C, and an example of any use of getopts illustrates the other half.</em>
      </p>
      <hr/>
      <p>
        <strong></strong><a href="JavaScript.html">JavaScript</a><strong>: (JScript running under WSH - Windows Script Host - uses </strong><a href="ActiveXscripting.html">ActiveXscripting</a> for its file API)
      </p>
      <p>
        note about <a href="ActiveXscripting.html">ActiveXscripting</a>:
        one way or another you don't have direct access to file I/O (Input Output) inside an ECMAscript implementation (meaning the core language definition), the file I/O depends on the environment where the language is implemented.
        Here in WSH, Microsoft has provided external COM objects for file I/O access, in another environment like FESI ( <a href="http://www.lugrin.ch/fesi/fioext.html">http://www.lugrin.ch/fesi/fioext.html</a> ) you could use another way to access file I/O with the File constructor, anyway the code provided can be easyly ported to different ECMAscript environment just edit the readFile method in HexDump.
      </p>
      <p>
        usage:
        cscript hexdump.js <filename> <start> <end> <width>
      </p>
      <p>
        limitation: this work only for ASCII files
      </p>
      <p>
        <strong>if you want to edit the code edit it correctly, or make a fork with your own version,</strong>
        if I have formated or given a particular structure to this script there are good reasons for that:<strong></strong>
      </p>
      <ul>
        <li>
           code readability
        </li>
        <li>
           code reuse
        </li>
      </ul>
      <p>
        if you're not happy with it make your own entry and dont't garbage my own.
      </p>
      <p>
        /* Function: trace */
      </p>
      <code>
        function trace( /*String*/ txt )<br/>
        {<br/>
        WScript.Echo( txt.toString() );<br/>
        }<br/>
      </code>
      <p>
        /* Singleton: Application */
        Application = {};
        Application.arguments = [];
      </p>
      <p>
        Application.getArguments = function()
      </p>
      <code>
        {<br/>
        var args, i;<br/>
        args = WScript.Arguments;<br/>
      </code>
      <code>
        for( i=0; i<args.length; i++ )<br/>
        {<br/>
        this.arguments.push( args(i) );<br/>
        }<br/>
      </code>
      <code>
        return this.arguments;<br/>
        }<br/>
      </code>
      <p>
        /* Class: HexDump */
      </p>
      <code>
        HexDump = function( /*String*/ source, /*Int*/ start, /*Int*/ end, /*Int*/ width )<br/>
        {<br/>
        this.source = source;<br/>
        this.start  = start;<br/>
        this.end    = end;<br/>
        this.width  = width;<br/>
      </code>
      <code>
        this.file   = "";<br/>
        this.hex    = [];<br/>
        this.dump   = [];<br/>
      </code>
      <code>
        this.parse();<br/>
        }<br/>
      </code>
      <code>
        HexDump.prototype.toString = function()<br/>
        {<br/>
        var data, CRLF;<br/>
        data = "";<br/>
        CRLF = "\r\n";<br/>
      </code>
      <code>
        data += "<a href="HexDump.html">HexDump</a>: \""+this.source+"\" ["+this.start+"-"+this.end+"] ("+this.width+")" + CRLF;<br/>
        data += this.dump.join( CRLF );<br/>
        return data;<br/>
        }<br/>
      </code>
      <code>
        HexDump.prototype.readFile = function( /*String*/ filepath )<br/>
        {<br/>
        var FSO, file, data;<br/>
        FSO   = new ActiveXObject( "Scripting.FileSystemObject" );<br/>
        file  = FSO.OpenTextFile( filepath, /*FileIOmode.reading*/ 1, false, /*FileFormat.ascii*/ false );<br/>
        data  = file.ReadAll();<br/>
        file.Close();<br/>
      </code>
      <code>
        return data;<br/>
        }<br/>
      </code>
      <code>
        HexDump.prototype.formatText = function( /*String*/ txt )<br/>
        {<br/>
        txt = txt.split( " " ).join( "." );<br/>
        txt = txt.split( "\n" ).join( " " );<br/>
        txt = txt.split( "\r" ).join( " " );<br/>
        return txt;<br/>
        }<br/>
      </code>
      <code>
        HexDump.prototype.charToHex = function( /*Char*/ c )<br/>
        {<br/>
        var hex;<br/>
        hex = c.charCodeAt( 0 ).toString( 16 );<br/>
        return( (hex.length==2)? hex: "0"+hex );<br/>
        }<br/>
      </code>
      <code>
        HexDump.prototype.parse = function()<br/>
        {<br/>
        var i, j, char, hexLine, fileLine;<br/>
      </code>
      <code>
        this.file = this.readFile( this.source );<br/>
        this.file = this.file.substring( this.start, this.end );<br/>
      </code>
      <code>
        for( i=0; i<this.file.length; i++ )<br/>
        {<br/>
        char = this.file.charAt( i );<br/>
        this.hex.push( this.charToHex( char ) );<br/>
        }<br/>
      </code>
      <code>
        j        = 0;<br/>
        hexLine  = "";<br/>
        fileLine = "";<br/>
        while( j < this.file.length )<br/>
        {<br/>
        hexLine  = this.hex.slice( j, j+this.width+1 );<br/>
        while( hexLine.length <= this.width )<br/>
        {<br/>
        hexLine.push( "  " );<br/>
        }<br/>
        hexLine  = hexLine.join( " " );<br/>
      </code>
      <code>
        fileLine = this.file.slice( j, j+this.width+1 );<br/>
        fileLine = this.formatText( fileLine );<br/>
      </code>
      <code>
        this.dump.push( hexLine + " : " + fileLine );<br/>
      </code>
      <code>
        j += this.width;<br/>
        }<br/>
      </code>
      <code>
        }<br/>
      </code>
      <p>
        /* MAIN ENTRY POINT */
      </p>
      <code>
        Application.main = function()<br/>
        {<br/>
        var args, dump;<br/>
      </code>
      <code>
        args = this.getArguments();<br/>
      </code>
      <code>
        if( args[3] == null )<br/>
        {<br/>
        args[3] = 16; //default value<br/>
        }<br/>
      </code>
      <code>
        if( args[2] == null )<br/>
        {<br/>
        args[2] = 100; //default value<br/>
        }<br/>
      </code>
      <code>
        if( args[1] == null )<br/>
        {<br/>
        args[1] = 0; //default value<br/>
        }<br/>
      </code>
      <code>
        if( args[0] == null )<br/>
        {<br/>
        trace( "usage:\r\ncscript hexdump.js <filename> <start> <end> <width>" );<br/>
        return;<br/>
        }<br/>
      </code>
      <code>
        dump = new <a href="HexDump.html">HexDump</a>( args[0], parseInt(args[1]), parseInt(args[2]), parseInt(args[3]) );<br/>
      </code>
      <code>
        trace( dump );<br/>
        }<br/>
      </code>
      <code>
        Application.main();<br/>
      </code>
      <p>
        output for cscript hexdump.js hexdump.js 0 100 16
      </p>
      <code>
        HexDump: "hexdump.js" [0-100] (16)<br/>
      </code>
      <ol>
        <li>
          f 2a 20 46 75 6e 63 74 69 6f 6e 3a 20 74 72 61 63 : /*.Function:.trac
        </li>
        <li>
           65 0d 0a 2a 2f 0d 0a 74 72 61 63 65 20 3d 20 66 : ce  */  trace.=.f
        </li>
        <li>
           75 6e 63 74 69 6f 6e 28 20 2f 2a 53 74 72 69 6e : function(./*Strin
        </li>
        <li>
          e 67 2a 2f 20 74 78 74 20 20 29 0d 0a 20 20 20 20 : ng*/.txt..)  ....
        </li>
        <li>
           7b 0d 0a 20 20 20 20 57 53 63 72 69 70 74 2e 45 : .{  ....WScript.E
        </li>
        <li>
           63 68 6f 28 20 74 78 74 2e 74 6f 53 74 72 69 6e : Echo(.txt.toStrin
        </li>
        <li>
          e 67 28 29					: ng()
        </li>
      </ol>
      <p>
        (My 1st participation in this great wiki ;) -- <a href="ZwetanKjukov.html">ZwetanKjukov</a>
        [sideNote: I can provide also a oneliner totally obscured and unreadable but I don't really see any usefulness to that.]
      </p>
      <p>
        Neither does anyone else. Layne did that to be sarcastic because I wrote something like:
      </p>
      <code>
        if (x) y();<br/>
      </code>
      <p>
        where he thought style required always writing
      </p>
      <code>
        if (x) {<br/>
        y();<br/>
        }<br/>
      </code>
      <p>
        That's the only reason that he posted his unreadable oneliners; they were an editorial comment.
      </p>
      <hr/>
      <p>
        Here's a <strong></strong><a href="CommonLisp.html">CommonLisp</a><strong> version without pretense of efficiency or command-line parsing:</strong>
      </p>
      <code>
        (defun dump-line (in start width count)<br/>
        (let ((bytes (loop for i below count<br/>
        for byte = (read-byte in nil nil)<br/>
        while byte collect byte)))<br/>
        (format t "~&~8,'0X ~{~2,'0X ~}~A | ~{~C~}"<br/>
        start<br/>
        bytes<br/>
        (make-string (* 3 (- width (length bytes))) <br/>
        :initial-element #\Space)<br/>
        (loop for byte in bytes<br/>
        for char = (code-char byte)<br/>
        when (graphic-char-p char) collect char<br/>
        else collect #\.))))<br/>
      </code>
      <code>
        (defun dump (file start end width)<br/>
        (with-open-file (in file <br/>
        :direction :input<br/>
        :element-type '(unsigned-byte 8))<br/>
        (when (file-position in start)<br/>
        (loop with true-end = (min end (file-length in))<br/>
        for i from start below true-end by width <br/>
        do (dump-line in i width (min width (- true-end i))))))<br/>
        (format t "~%"))<br/>
      </code>
      <p>
        Sample output, generated by evaluating <strong>(dump "dump.lisp" 3 37 16)</strong>:
      </p>
      <ol>
        <li>
           66 75 6E 20 64 75 6D 70 2D 6C 69 6E 65 20 28 69  | fun dump-line (i
        </li>
        <li>
           6E 20 73 74 61 72 74 20 63 6F 75 6E 74 20 77 69  | n start count wi
        </li>
        <li>
           64 74                                            | dt
        </li>
      </ol>
      <p>
        -- <a href="DanMuller.html">DanMuller</a>
      </p>
      <p>
        Standard <a href="CommonLisp.html">CommonLisp</a> doesn't provide a way to get command-line arguments. Guess I'll have to add interactive argument acquisition.
      </p>
      <hr/>
      <p>
        [<strong>Historical note:</strong> The original version of this page stated that other chrestomathy pages "do not demonstrate the use of the languages in a way that is applicable to real-world programming", with implication that this one <strong>would</strong>. It also placed several requirements on the program which were out of place in this sort of demonstration (that it had to be a stand-alone program, that read user input from the either the command line or the console, etc.). This naturally enough garnered several scornful remarks. When the problem definition was refactored, the origianl version and the subsequent discussion were moved here for reference sake.]
      </p>
      <p>
        While there are several <a href="ProgrammingChrestomathy.html">ProgrammingChrestomathy</a> pages already, most of them deal with a task that is either trivial (printimg "Hello, World!" or the lyrics to "99 Bottles of Beer", encrypting a cleartext in RotThirteen), or of primarily theoretical or abstract importance (the 8-Queens Problem, calculating dot-products). While these are all valuable in their own way, one could argue that they do not demonstrate the use of the languages in a way that is applicable to real-world programming. 
      </p>
      <p>
        To this end, I am hereby proposing a new chrestomathy challenge: a program in the format
      </p>
      <p>
        hexdump <em>source</em> <em>start</em> <em>end</em> <em>width</em>
      </p>
      <p>
        which reads the file <em>source</em> and prints a <a href="HexDump.html">HexDump</a> of the bytes in the file from <em>start</em> to <em>end</em>, formatted to show <em>width</em> bytes separated by space, followed by a separator, then followed by the ASCII values of the displayed bytes, in the order they exist in the file. The program include the code to read these arguments, either from the command line, or from user input. Either console or GUI programs are acceptable, though portable code is preferred where possible. The code should be testable by independent third parties. Any instructions needed for testing the code (target environment, special requirements) should be listed in the program comments.
      </p>
      <p>
        <em>I wouldn't say that this problem is any more or less trivial than the other chrestomathy (great word!) pages. Depends what your real world is, I guess.</em>
      </p>
      <p>
        There are a host of "real world" factors ignored here too:
      </p>
      <ul>
        <li>
           Reusability - There is no incentive here to make the code reusable.
        </li>
        <li>
           Error handling - Missing arguments, bad read on file, etc are very vague
        </li>
        <li>
           Hex searching - Nothing is more annoying than a hex editor you can't search in
        </li>
        <li>
           Agility - How agile is the code? Would it respond well to requests for new features?
        </li>
        <li>
           Installability - A standalone EXE would be easier than having to install interpreters, etc.
        </li>
        <li>
           Cross-platform issues - Does it need recompilation? Does an interpreter exist for system <X>?
        </li>
        <li>
           Code readability - Which was a hazy problem to begin with.
        </li>
        <li>
           Graphics - Color highlighting of the "selected hex" surrounded by "unselected hex"
        </li>
      </ul>
      <p>
        I just don't think it's possible to take all the complexities of "real software" and reduce it to a single problem - because the solutions will be optomized to fit the rules of the game, and not the realities of customer satisfaction.
      </p>
      <p>
        <em>Late note: although it wasn't originally mentioned, in real life it is fairly essential to show the current address at the start of each line, so I recommend adding that to the existing examples below.</em>
      </p>
      <p>
        Very well, the point is conceded. It was a mistake for me to use the phrase 'real-world' for something as artificial and isolated as this. I might replace it with 'practical', but that has nearly as many problems, now doesn't it? My intention was simply that it would show some of the aspects of languages which normally are ignored in such demonstration programs, not to make a commercial-quality project of it. Perhaps even that was poorly considered - after all, it is still a very small task, and such details only serve to confuse. While I still think it is a good example project, my presentation was regrettable (though perhaps not as regrettable as the Scheme example I wrote). -- <a href="JayOsako.html">JayOsako</a>
      </p>
      <p>
        <em>The 8 queens chrestomathy page had people talking about "extra points" for things like N-queens rather than just 8; not everyone bothered. I would think that approach would be appropriate for all such things: the challenge itself should be quite minimal, but with recognition of extras that make sense. I sure would give someone brownie points if they added a gui, searching, editing, color high lighting, etc etc, all in a small enough amount of code to not be absurd to put on this page (not sure how feasible that would be).</em>
      </p>
      <p>
        Perhaps I should refactor the page to that model, then. I don't want to step on too many toes, however; I'm fairly new to Wiki (modulo a few things I wrote years ago, and have largely regretted), and I'm still not comfortable with the editing ettiquette. -- <a href="JayOsako.html">JayOsako</a>
      </p>
      <p>
        <em>The cautious approach would be to just rewrite what you yourself wrote, noting in broad outline any changes you made that might surprise someone who already contributed code to the page. We're only hoping to improve things, not to make people feel like we're unfairly changing the rules on them or something, thus the note about what changed.</em>
      </p>
      <p>
        <em>I presume there is no current motivation to rewrite everyone's code, so it's not really about refactoring the whole page.</em>
      </p>
      <p>
        You are correct, of course; there's no need to refactor anything except the requirements (and my awful Scheme code). I'm not sure what will be done with the comments that were made about it; for now, I'll leave them as the are, though I'll put a separator and a note as to what they refer to). 
      </p>
      <hr/>
      <p>
        <strong></strong><a href="FoxPro.html">FoxPro</a><strong></strong>
      </p>
      <p>
        Someone already posted a Perl solution and a C/C++ solution, and portability seems to be important, so I won't post an <a href="AssemblyLanguage.html">AssemblyLanguage</a> solution, but I do have another portable language (this will also run as-is in XBase++ and probably in both <a href="FlagShip.html">FlagShip</a> and Clipper).
      </p>
      <ul>
        <li>
          	fhdump.prg
        </li>
      </ul>
      <code>
        parameters	filename, start, stop, dwidth<br/>
        private	talking, hex_ascii, d_len, di, str16, d_str, hex_str<br/>
      </code>
      <code>
        if set("talk") = "ON"<br/>
        set talk OFF<br/>
        talking = .T.<br/>
        else<br/>
        talking = .F.<br/>
        endif<br/>
        crlf = chr(13) + chr(10)			&& for convenience<br/>
        hex_ascii = ""				&& buffer for output line<br/>
        dwidth = min(dwidth, 200)			&& largest reasonable display width<br/>
        dwidth = max(dwidth, 1)			&& smallest reasonable display width<br/>
        fh = fopen(filename)				&& open file at low level<br/>
        if fh > 0					&& proceed only if valid handle<br/>
        ?					&& begin new line<br/>
        xi = fseek(fh, start)			&& skip to desired offset in file<br/>
        do while !feof(fh) AND xi <= stop	&& stop at end of file<br/>
        raw = fread(fh, dwidth)	&& read a block of desired size<br/>
        hex_str = padr(hex(raw, " "), dwidth * 3)	&& pad short line<br/>
        hex_ascii = str(xi, 5) +": "+ hex_str +"| "+ strip(raw) + crlf<br/>
        ?? hex_ascii			&& offset: hex digits | stripped ASCII<br/>
        xi = xi + dwidth		&& bump the offset<br/>
        enddo<br/>
        endif<br/>
        fh = fclose(fh)				&& housekeeping<br/>
      </code>
      <code>
        if talking<br/>
        set talk ON<br/>
        endif<br/>
      </code>
      <code>
        return<br/>
      </code>
      <ul>
        <li>
          	-----------------
        </li>
      </ul>
      <ul>
        <li>
           most output devices don't deal well with control characters, so  ...
        </li>
      </ul>
      <code>
        function strip				&& replace control chars in string with '.'<br/>
        parameters	rawstring<br/>
        private	outstring, sx, byte<br/>
        outstring = ""<br/>
        for sx = 1 to len(rawstring)		&& examine each byte in string<br/>
        byte = substr(rawstring, sx, 1)	&& get single byte<br/>
        outstring = outstring + iif(asc(byte) > 31, byte, ".")<br/>
        endfor				&& keep printables, convert controls<br/>
        return outstring<br/>
      </code>
      <ul>
        <li>
           convert a string of bytes to hex, padded with 'padchar'
        </li>
      </ul>
      <code>
        function hex<br/>
        parameters	string, padchr		&& bytes and separator<br/>
        private	nbytes, hex_str, ix, bc<br/>
        padchr = iif(type("padchr") = "C", padchr, "")	&& optional separator<br/>
        hex_str = ""				&& result buffer<br/>
        nbytes = len(string)			&& count the bytes<br/>
        for ix = 1 to nbytes			&& and one by one ...<br/>
        bc = substr(string, ix, 1)	&& extract a byte<br/>
        hex_str = hex_str + hdigits(bc) + iif(ix = nbytes, "", padchr)<br/>
        endfor				&& and build result hex digit string<br/>
        return hex_str<br/>
      </code>
      <ul>
        <li>
           render a byte as a pair of hex digits
        </li>
      </ul>
      <code>
        function hdigits<br/>
        parameters	char<br/>
        private	ch_hi, ch_lo, av, nib<br/>
        av = asc(char)			&& ASCII value of byte<br/>
        nib = int(av / 16)			&& high order nibble<br/>
        ch_hi = chr(nib + iif(nib > 9, 55, 48))	&& hex nibble<br/>
        nib = mod(av, 16)			&& low order nibble<br/>
        ch_lo = chr(nib + iif(nib > 9, 55, 48))	&& hex nibble<br/>
        return ch_hi + ch_lo				&& two nibbles to a byte<br/>
      </code>
      <ul>
        <li>
          	eof
        </li>
      </ul>
      <code>
        - - - - - - - - - -<br/>
        output of <strong>do fhdump with fhdump.prg", 0, 128, 16</strong><br/>
      </code>
      <ol>
        <li>
          : 2A 09 66 68 64 75 6D 70 2E 70 72 67 0D 0A 0D 0A | *.fhdump.prg....
          <ol>
            <li>
              : 70 61 72 61 6D 65 74 65 72 09 66 69 6C 65 6E 61 | parameter.filena
            </li>
            <li>
              : 6D 65 2C 20 73 74 61 72 74 2C 20 73 74 6F 70 2C | me, start, stop,
            </li>
            <li>
              : 20 64 77 69 64 74 68 0D 0A 70 72 69 76 61 74 65 |  dwidth..private
            </li>
            <li>
              : 09 09 74 61 6C 6B 69 6E 67 2C 20 68 65 78 5F 61 | ..talking, hex_a
            </li>
            <li>
              : 73 63 69 69 2C 20 64 5F 6C 65 6E 2C 20 64 69 2C | scii, d_len, di,
            </li>
            <li>
              : 20 73 74 72 31 36 2C 20 64 5F 73 74 72 2C 20 68 |  str16, d_str, h
              <ol>
                <li>
                  : 65 78 5F 73 74 72 0D 0A 0D 0A 69 66 20 73 65 74 | ex_str....if set
                </li>
                <li>
                  : 28 22 74 61 6C 6B 22 29 20 3D 20 22 4F 4E 22 0D | ("talk") = "ON".
                </li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
      <code>
        - - - - - - - - - -<br/>
        output of <strong>do fhdump with "fhdump.prg", 0, 64, 8</strong><br/>
      </code>
      <ol>
        <li>
          : 2A 09 66 68 64 75 6D 70 | *.fhdump
        </li>
        <li>
          : 2E 70 72 67 0D 0A 0D 0A | .prg....
          <ol>
            <li>
              : 70 61 72 61 6D 65 74 65 | paramete
            </li>
            <li>
              : 72 09 66 69 6C 65 6E 61 | r.filena
            </li>
            <li>
              : 6D 65 2C 20 73 74 61 72 | me, star
            </li>
            <li>
              : 74 2C 20 73 74 6F 70 2C | t, stop,
            </li>
            <li>
              : 20 64 77 69 64 74 68 0D |  dwidth.
            </li>
            <li>
              : 0A 70 72 69 76 61 74 65 | .private
            </li>
            <li>
              : 09 09 74 61 6C 6B 69 6E | ..talkin
            </li>
          </ol>
        </li>
      </ol>
      <hr/>
      <p>
        <strong>Minimally Excessive </strong><a href="CeeLanguage.html">CeeLanguage</a><strong> example:</strong>
      </p>
      <p>
        There was debate about my other C example, so here's what happens when C gets a little too terse. . . -- <a href="LayneThomas.html">LayneThomas</a>
      </p>
      <code>
        #include <stdio.h><br/>
        hexer(FILE *f,int b,int e,int w){<br/>
        unsigned char cb[2048];int z[3]={0,0,0};<br/>
        while(!feof(f)){<br/>
        fscanf(f,"%c",&cb[z[2]]);<br/>
        if ((z[1]>=b)&&(z[1]<e)){<br/>
        if (z[2]==0) printf("%4u : ",z[1]);printf("%02X ",cb[z[2]],z[2]++);<br/>
        if ((((z[1]-b)%w)==(w-1)||((z[1]==e-1)?z[0]=1:z[0]=0))){<br/>
        if (z[0]) for (z[0]=0;z[0]<(w-z[2]);z[0]++){printf("__ ");}printf(" : ");<br/>
        for (z[0]=0;z[0]<w;z[0]++)(cb[z[0]]<32)?printf("."):printf("%c",cb[z[0]],z[2]=0);	  printf("\n");<br/>
        }}z[1]++;}<br/>
        return 0;<br/>
        }<br/>
        int main(void){FILE *inf=fopen("main.cpp","rt"); hexer(inf,10,243,16);fclose(inf);return 0;}<br/>
      </code>
      <code>
        output of "hasaproblem", 10 100, 16<br/>
      </code>
      <ol>
        <li>
           : 73 74 64 69 6F 2E 68 3E 0A 68 65 78 65 72 28 46  : stdio.h>.hexer(F
        </li>
        <li>
           : 49 4C 45 20 2A 66 2C 69 6E 74 20 62 2C 69 6E 74  : ILE *f,int b,int
        </li>
        <li>
           : 20 65 2C 69 6E 74 20 77 29 7B 0A 20 20 75 6E 73  :  e,int w){.  uns
        </li>
        <li>
           : 69 67 6E 65 64 20 63 68 61 72 20 63 62 5B 32 30  : igned char cb[20
        </li>
        <li>
           : 34 38 5D 3B 69 6E 74 20 7A 5B 33 5D 3D 7B 30 2C  : 48];int z[3]={0,
        </li>
        <li>
           : 30 2C 30 7D 3B 0A 20 20 77 68 69 6C 65 28 21 66  : 0,0};.  while(!f
          <ol>
            <li>
               : 65 6F 66 28 66 29 29 7B 0A 20 20 66 73 63 61 6E  : eof(f)){.  fscan
            </li>
            <li>
               : 66 28 66 2C 22 25 63 22 2C 26 63 62 5B 7A 5B 32  : f(f,"%c",&cb[z[2
            </li>
            <li>
               : 5D 5D 29 3B 0A 20 20 69 66 20 28 28 7A 5B 31 5D  : ]]);.  if ((z[1]
            </li>
            <li>
               : 3E 3D 62 29 26 26 28 7A 5B 31 5D 3C 65 29 29 7B  : >=b)&&(z[1]<e)){
            </li>
            <li>
               : 0A 20 20 69 66 20 28 7A 5B 32 5D 3D 3D 30 29 20  : .  if (z[2]==0)
            </li>
            <li>
               : 70 72 69 6E 74 66 28 22 25 34 75 20 3A 20 22 2C  : printf("%4u : ",
            </li>
            <li>
               : 7A 5B 31 5D 29 3B 70 72 69 6E 74 66 28 22 25 30  : z[1]);printf("%0
            </li>
            <li>
               : 32 58 20 22 2C 63 62 5B 7A 5B 32 5D 5D 2C 7A 5B  : 2X ",cb[z[2]],z[
            </li>
            <li>
               : 32 5D 2B 2B 29 3B 0A 20 20 __ __ __ __ __ __ __  : 2]++);.  [2]],z[
            </li>
          </ol>
        </li>
      </ol>
      <p>
        Allow me to don the <a href="CeeLanguage.html">CeeLanguage</a> evil advocate's hat for a moment:
      </p>
      <ul>
        <li>
           It is readable, I didn't PGP it. Heck, I didn't even Rot13 it.
        </li>
        <li>
           Some people say it won't compile for ANSI C. I submit that a real <a href="CeeLanguage.html">CeeLanguage</a> programmer would make it.
        </li>
        <li>
           Some would say that the final line of output has a bug at the end. I would say that any good programmer would see the blank lines and know to ignore the equivalent text, therefore there is no problem.
        </li>
        <li>
           It is very memory efficient for its hard-coded 2048 limit. . . but that's twice as good as other examples! Including ones that don't handle the line
        </li>
        <li>
           It has all three parts - address, hex and character display.
        </li>
        <li>
           It is a fully compiling executable
        </li>
        <li>
           It only uses stdio.h
        </li>
        <li>
           It even closes the file at the end. . . uhm. . . cause. . . it's awesome. . .
        </li>
        <li>
           The variables are reasonably named - except for "z" - which is terser to save space
        </li>
        <li>
           Is this better?
        </li>
      </ul>
      <p>
        <strong>Super Two-Line Excessively Minimal </strong><a href="CeeLanguage.html">CeeLanguage</a> example<strong>:</strong>
      </p>
      <code>
        #include <stdio.h><br/>
        hexer(FILE *f,int b,int e,int w){unsigned char cb[2048];int z[3]={0,0,0};while(!feof(f)){fscanf(f,"%c",&cb[z[2]]);if ((z[1]>=b)&&(z[1]<e)){if (z[2]==0)	printf("%4u : ",z[1]);printf("%02X ",cb[z[2]],z[2]++);if ((((z[1]-b)%w)==(w-1)||((z[1]==e-1)?z[0]=1:z[0]=0))){if (z[0]) for (z[0]=0;z[0]<(w-z[2]);z[0]++){printf("__ ");}printf(" : ");for (z[0]=0;z[0]<w;z[0]++)(cb[z[0]]<32)?printf("."):printf("%c",cb[z[0]],z[2]=0);printf("\n");}}z[1]++;}return 0;}int main(void){ FILE	*inf=fopen("main.cpp","rt"); hexer(inf,10,243,16); fclose(inf);return 0;}<br/>
      </code>
      <p>
        I am of course joking about all this.
      </p>
      <p>
        <em>Sarcastic, you mean. Since you have all this boundless energy, where's that C++ version?</em>
      </p>
      <p>
        I'm currently uploading it. . . Even at 700k/s, it will still take until tomorrow morning.
      </p>
      <p>
        <em>Smaller than I expected; congratulations.</em>
      </p>
      <hr/>
      <p>
        Here is an attempt at a reasonable-length <a href="CeePlusPlus.html">CeePlusPlus</a> version:
      </p>
      <code>
        #include <iostream><br/>
        #include <algorithm><br/>
        #include <sstream><br/>
        #include <iomanip><br/>
        using namespace std;<br/>
      </code>
      <code>
        struct hexwriter<br/>
        {<br/>
        stringstream _numbers,_letters;<br/>
        int _start,_width,_position;<br/>
      </code>
      <code>
        hexwriter(int start,int width) : <br/>
        _start(start), _width(width), _position(0)<br/>
        {<br/>
        }<br/>
      </code>
      <code>
        void operator()(char value)<br/>
        {<br/>
        _numbers << setw(2) << setfill('0') << hex;<br/>
        _numbers << static_cast<int>(static_cast<unsigned char>(value)) << ' ';<br/>
        _letters << (iscntrl(value)?'.':value);<br/>
        if(++_position%_width==0)<br/>
        flush();<br/>
        }<br/>
      </code>
      <code>
        void flush()<br/>
        {<br/>
        if(0!=_position)<br/>
        {<br/>
        cout << right << setw(8) << hex << _start << " : ";<br/>
        cout << left << setw(3*_width) << _numbers.str() << ": " << _letters.str() << endl;<br/>
        _position=0;<br/>
        _start+=_width;<br/>
        }<br/>
        _numbers.str("");<br/>
        _letters.str("");<br/>
        }<br/>
        };<br/>
      </code>
      <code>
        int main(int argc,char** argv)<br/>
        {<br/>
        int first=(argc>1)?atoi(argv[1]):0;<br/>
        int last=(argc>2)?atoi(argv[2]):string::npos;<br/>
        int width=(argc>3)?atoi(argv[3]):16;<br/>
      </code>
      <code>
        typedef istreambuf_iterator<char> cinit;<br/>
        string buffer(cinit(cin.rdbuf()),cinit());<br/>
        buffer=buffer.substr(first,last);<br/>
      </code>
      <code>
        hexwriter writer(first,width);<br/>
        for_each<string::iterator,hexwriter&>(buffer.begin(),buffer.end(),writer);<br/>
        writer.flush();<br/>
        }<br/>
      </code>
      <code>
        $ hexdump 10 110 24 < hexdump.cpp<br/>
        a : 69 6f 73 74 72 65 61 6d 3e 0a 23 69 6e 63 6c 75 64 65 20 3c 61 6c 67 6f : iostream>.#include <algo<br/>
      </code>
      <ol>
        <li>
           : 72 69 74 68 6d 3e 0a 23 69 6e 63 6c 75 64 65 20 3c 73 73 74 72 65 61 6d : rithm>.#include <sstream
        </li>
        <li>
          a : 3e 0a 23 69 6e 63 6c 75 64 65 20 3c 69 6f 6d 61 6e 69 70 3e 0a 75 73 69 : >.#include <iomanip>.usi
        </li>
        <li>
           : 6e 67 20 6e 61 6d 65 73 70 61 63 65 20 73 74 64 3b 0a 0a 73 74 72 75 63 : ng namespace std;..struc
        </li>
        <li>
          a : 74 20 68 65 78 77 72 69 74 65 72 0a 7b 0a                               : t hexwriter.{.
        </li>
      </ol>
      <p>
        -- <a href="MichaelSparks.html">MichaelSparks</a>
      </p>
      <hr/>
      <p>
        <a href="OcamlLanguage.html">OcamlLanguage</a>:
      </p>
      <code>
        open Printf<br/>
      </code>
      <code>
        let hexadecimal str =<br/>
        let buffer = Buffer.create ((String.length str) * 3) in begin<br/>
        String.iter (fun char -><br/>
        Buffer.add_string buffer (sprintf " %02x" (int_of_char char))) str;<br/>
        Buffer.contents buffer<br/>
        end<br/>
        and ascii str =<br/>
        let buffer = Buffer.create (String.length str) in begin<br/>
        String.iter (fun char -><br/>
        Buffer.add_char buffer<br/>
        (match char with<br/>
        ' ' .. '~' -> char<br/>
        | _ -> '.')) str;<br/>
        Buffer.contents buffer<br/>
        end<br/>
      </code>
      <code>
        let front width pos str =<br/>
        printf "%08x:%*s | %*s\n"<br/>
        pos (3*width) (hexadecimal str) width (ascii str)<br/>
        and back width pos str =<br/>
        printf "%08x:%-*s | %-*s\n"<br/>
        pos (3*width) (hexadecimal str) width (ascii str)<br/>
      </code>
      <code>
        let dump filename ?s:(s = 0) ?e:e ?width:(width = 16) () =<br/>
        let chan = open_in_bin filename in<br/>
        let display f length =<br/>
        let buf = (String.make length '\000') in<br/>
        let real_length = input chan buf 0 length in<br/>
        let _ = if real_length > 0 then<br/>
        (f (String.sub buf 0 real_length)) else () in<br/>
        if real_length < length then raise End_of_file else ()<br/>
        in<br/>
        let front_off = (width - (s mod width)) in<br/>
        let (final, remaining) =<br/>
        match e with<br/>
        Some e -> ((fun pos -> (e - pos) <= width),<br/>
        (fun pos -> (e - pos)))<br/>
        | None -> ((fun pos -> false),<br/>
        (fun pos -> 0))<br/>
        in<br/>
        try begin<br/>
        seek_in chan s;<br/>
        display (front width s) front_off;<br/>
        let rec continue pos =<br/>
        if (final pos) then begin<br/>
        display (back width pos) (remaining pos);<br/>
        raise End_of_file<br/>
        end else begin<br/>
        display (back width pos) width;<br/>
        continue (pos+width)<br/>
        end<br/>
        in continue (s + front_off)<br/>
        end with End_of_file -> begin<br/>
        close_in chan;<br/>
        ()<br/>
        end<br/>
        ;;<br/>
      </code>
      <code>
        let usage () =<br/>
        eprintf "Usage: %s file [start [end [width]]]\n" Sys.argv.(0) in<br/>
        let main () =<br/>
        match Sys.argv with<br/>
        [|_|] -> usage ()<br/>
        | [|_; file|] -> dump file ()<br/>
        | [|_; file; s|] -> dump file ~s:(int_of_string s) ()<br/>
        | [|_; file; s; e|] -><br/>
        dump file ~s:(int_of_string s) ~e:(int_of_string e) ()<br/>
        | [|_; file; s; e; width|] -><br/>
        dump file ~s:(int_of_string s) ~e:(int_of_string e)<br/>
        ~width:(int_of_string width) ()<br/>
        | _ -> usage ()<br/>
        in main ()<br/>
      </code>
      <hr/>
      <p>
        <a href="JayLanguage.html">JayLanguage</a>:
      </p>
      <code>
        nhex =: 3 : 0  NB. res;val<br/>
        ' ',~"1(((>0{y.)$16) #: >1{y.){ '0123456789ABCDEF'<br/>
        )<br/>
      </code>
      <code>
        hex =: 3 : ',.nhex 2;a.i.y.'<br/>
      </code>
      <code>
        prt =: 3 : 0<br/>
        pa =. (32+i.96){a.<br/>
        mk =. '.'<br/>
        (pa i.y.){pa,mk<br/>
        )<br/>
        hexdump =: 3 : 0	NB. 'file';start;end;width<br/>
        fn =. >0{y.<br/>
        st=. >1{y.<br/>
        sz=. >:((1!:4 <fn)<.>2{y.)-st<br/>
        w=. >3{y.<br/>
        r=. >.sz%w<br/>
        adrs=. nhex 4;st+w*i.r<br/>
        text=. (r,w)$(1!:11 fn;st,sz),(-sz-r*w)${.a.<br/>
        adrs,. (hex text),. ':',.' ',. prt text<br/>
        )<br/>
      </code>
      <p>
        Put to use:
      </p>
      <code>
        hexdump 'c:\prj\j\hexdump.ijs';20;73;10<br/>
      </code>
      <ol>
        <li>
           65 78 20 3D 3A 20 33 20 3A 20 : ex =: 3 : 
        </li>
        <li>
          E 30 20 20 4E 42 2E 20 72 65 73 : 0  NB. res
        </li>
        <li>
           3B 76 61 6C 0D 0A 09 27 20 27 : ;val...' '
        </li>
        <li>
           2C 7E 22 31 28 28 28 3E 30 7B : ,~"1(((>0{
        </li>
        <li>
          C 79 2E 29 24 31 36 29 20 23 3A : y.)$16) #:
        </li>
        <li>
           20 3E 31 7B 00 00 00 00 00 00 :  >1{......
        </li>
      </ol>
      <p>
        -- <a href="MarcThibault.html">MarcThibault</a>
      </p>
      <hr/>
      <p>
        Here is an attempt at a reasonable-length Java version:
      </p>
      <p>
        import java.io.FileInputStream;
      </p>
      <p>
        public class HexDump {
      </p>
      <code>
        public static void main(final String[] args) throws Exception {<br/>
        final int width = 3 * Integer.parseInt(args[3]);<br/>
        final FileInputStream inS = new FileInputStream(args[0]);<br/>
        inS.skip(Integer.parseInt(args[1]));<br/>
        final <a href="StringBuilder.html">StringBuilder</a> hex = new <a href="StringBuilder.html">StringBuilder</a>();<br/>
        final <a href="StringBuilder.html">StringBuilder</a> chr = new <a href="StringBuilder.html">StringBuilder</a>();<br/>
      </code>
      <code>
        for (int pos = Integer.parseInt(args[2]); pos > 0 && inS.available() > 0; pos--) {<br/>
        chr.append((char) inS.read());<br/>
        hex.append(String.format("%1$02x ", (byte) chr.charAt(chr.length() - 1)));<br/>
        if (hex.length() >= width || pos <= 1) {<br/>
        System.out.println(String.format("%1$-" + (width) + "s", hex) + ":" <br/>
        + chr.toString().replaceAll("[^!-~]", " "));<br/>
        hex.setLength(0);<br/>
        chr.setLength(0);<br/>
        }<br/>
        }<br/>
        }<br/>
      </code>
      <p>
        }
      </p>
      <p>
        Arguments: HexDump.java 0 100 16
      </p>
      <ol>
        <li>
           6d 70 6f 72 74 20 6a 61 76 61 2e 69 6f 2e 46 :import java.io.F
        </li>
        <li>
           6c 65 49 6e 70 75 74 53 74 72 65 61 6d 3b 0d :ileInputStream; 
        </li>
        <li>
          a 0d 0a 70 75 62 6c 69 63 20 63 6c 61 73 73 20 :   public class 
        </li>
        <li>
           65 78 44 75 6d 70 20 7b 0d 0a 09 70 75 62 6c :HexDump {   publ
        </li>
        <li>
           63 20 73 74 61 74 69 63 20 76 6f 69 64 20 6d :ic static void m
        </li>
        <li>
           69 6e 28 66 69 6e 61 6c 20 53 74 72 69 6e 67 :ain(final String
        </li>
        <li>
          b 5d 20 61                                     :[] a
        </li>
      </ol>
      <hr/>
      <p>
        A shorter <a href="CeePlusPlus.html">CeePlusPlus</a> version, with error checking:
      </p>
      <code>
        #include <algorithm><br/>
        #include <cctype><br/>
        #include <fstream><br/>
        #include <iomanip><br/>
        #include <iostream><br/>
        #include <stdexcept><br/>
        #include <string><br/>
        #include <vector><br/>
      </code>
      <code>
        using namespace std;<br/>
      </code>
      <code>
        void show_char(char c) { cout << (isprint(c) ? c : '.'); }<br/>
        void show_hex(char c) { cout << setw(2) << (c & 0xff) << ' '; }<br/>
      </code>
      <code>
        int main(int argc, char** argv) {<br/>
        try {<br/>
        if (argc != 5)<br/>
        throw invalid_argument("Usage: hexdump <file> <start> <end> <width>");<br/>
        ifstream in(argv[1], ios::binary);<br/>
        if (! in)<br/>
        throw invalid_argument("File not found");<br/>
        size_t pos(strtoul(argv[2], 0, 0)), end(strtoul(argv[3], 0, 0)), width(strtoul(argv[4], 0, 0));<br/>
        if (end < pos || width < 1)<br/>
        throw invalid_argument("Invalid arguments");<br/>
        in.seekg(pos);<br/>
        if (! in)<br/>
        throw invalid_argument("Start position is past end of file");<br/>
        vector<char> buf(width);<br/>
        cout << hex << setfill('0');<br/>
        for (; in && pos < end; pos += width) {<br/>
        in.read(&buf[0], min(end - pos, width));<br/>
        size_t bytes(in.gcount());<br/>
        if (bytes) {<br/>
        cout << setw(8) << pos << " : ";<br/>
        for_each(&buf[0], &buf[bytes], show_hex);<br/>
        cout << string(3 * (width - bytes), ' ') << ": ";<br/>
        for_each(&buf[0], &buf[bytes], show_char);<br/>
        cout << '\n';<br/>
        }<br/>
        }<br/>
        return 0;<br/>
        }<br/>
        catch (const exception& ex) {<br/>
        cerr << "*** " << ex.what() << '\n';<br/>
        return 1;<br/>
        }<br/>
        }<br/>
      </code>
      <code>
        ./hexdump hexdump.cpp 100 200 16<br/>
      </code>
      <ol>
        <li>
           : 63 6c 75 64 65 20 3c 73 74 64 65 78 63 65 70 74 : clude <stdexcept
        </li>
        <li>
           : 3e 0a 23 69 6e 63 6c 75 64 65 20 3c 73 74 72 69 : >.#include <stri
        </li>
        <li>
           : 6e 67 3e 0a 23 69 6e 63 6c 75 64 65 20 3c 76 65 : ng>.#include <ve
        </li>
        <li>
           : 63 74 6f 72 3e 0a 0a 75 73 69 6e 67 20 6e 61 6d : ctor>..using nam
        </li>
        <li>
          a4 : 65 73 70 61 63 65 20 73 74 64 3b 0a 0a 76 6f 69 : espace std;..voi
        </li>
        <li>
          b4 : 64 20 73 68 6f 77 5f 63 68 61 72 28 63 68 61 72 : d show_char(char
        </li>
        <li>
          c4 : 20 63 29 20                                     :  c) 
        </li>
      </ol>
      <p>
        -- RossSmith
      </p>
      <hr/>
      <p>
        A <a href="EuphoriaLanguage.html">EuphoriaLanguage</a> version.  I'd forgotten how verbose Euphoria is, although this could be shortened...
      </p>
      <code>
        include get.e<br/>
        include file.e<br/>
      </code>
      <code>
        constant STDOUT = 1, STDERR = 2<br/>
      </code>
      <code>
        sequence Filename<br/>
        integer Start, End, Width, FileHandle, Lines<br/>
      </code>
      <code>
        procedure Error(sequence msg)<br/>
        puts(STDERR, msg)<br/>
        abort(2)<br/>
        end procedure<br/>
      </code>
      <code>
        procedure Usage()<br/>
        Error("Usage: ex hexdump.ex <filename> <start> <end> <width>\n")<br/>
        end procedure<br/>
      </code>
      <code>
        -- Convert string to integer, erroring with invalid parameter if not valid<br/>
        function IntParam(sequence string)<br/>
        sequence tmp<br/>
        tmp = value(string)<br/>
        if tmp[1] = GET_SUCCESS and integer(tmp[2]) then<br/>
        return tmp[2]<br/>
        end if<br/>
        Usage()<br/>
        end function<br/>
      </code>
      <code>
        -- Check command line parameters<br/>
        procedure GetParams()<br/>
        sequence cmd<br/>
        cmd = command_line()<br/>
        cmd = cmd[3..length(cmd)]<br/>
        if length(cmd) != 4 then<br/>
        Usage()<br/>
        end if<br/>
        Filename = cmd[1]<br/>
        Start = IntParam(cmd[2])<br/>
        End = IntParam(cmd[3])<br/>
        Width = IntParam(cmd[4])<br/>
        Lines = floor((End - Start + 1) / Width)<br/>
        if remainder((End - Start + 1), Width) != 0 then<br/>
        Lines = Lines + 1<br/>
        end if<br/>
        end procedure<br/>
      </code>
      <code>
        -- Main Program start!<br/>
        GetParams()<br/>
        FileHandle = open(Filename, "rb")<br/>
        if FileHandle = -1 then<br/>
        Error("Unable to read file '" & Filename & "'\n")<br/>
        end if<br/>
      </code>
      <code>
        sequence Bytes<br/>
        sequence Output<br/>
        integer Void, RemainingBytes, BytesToRead, Offset, Padding<br/>
      </code>
      <code>
        Void = seek(FileHandle, Start)<br/>
        RemainingBytes = End - Start + 1<br/>
        Offset = Start<br/>
      </code>
      <code>
        for lindex = 1 to Lines do<br/>
        Output = sprintf("%04x : ", Offset)<br/>
      </code>
      <code>
        if Width < RemainingBytes then<br/>
        BytesToRead = Width<br/>
        else<br/>
        BytesToRead = RemainingBytes<br/>
        end if<br/>
        RemainingBytes -= BytesToRead<br/>
        Offset += BytesToRead<br/>
      </code>
      <code>
        Bytes = get_bytes(FileHandle, BytesToRead)<br/>
        for bindex = 1 to length(Bytes) do<br/>
        Output &= sprintf("%02x ", Bytes[bindex])<br/>
        end for<br/>
      </code>
      <code>
        Padding = 3 * Width + 7<br/>
        if length(Output) < Padding then<br/>
        Output &= repeat(' ', Padding - length(Output))<br/>
        end if<br/>
      </code>
      <code>
        Output &= ": "<br/>
        for bindex = 1 to length(Bytes) do<br/>
        if Bytes[bindex] >= 32 and Bytes[bindex] <= 127 then<br/>
        Output &= Bytes[bindex] -- printable<br/>
        else<br/>
        Output &= ' ' -- not printable, show space instead<br/>
        end if<br/>
        end for<br/>
      </code>
      <code>
        Output &= "\n"<br/>
        puts(STDOUT, Output)<br/>
        end for<br/>
      </code>
      <p>
        Outputs:
      </p>
      <ol>
        <li>
           : 69 6E 63 6C 75 64 65 20 67 65 74 2E 65 0D 0A 69 : include get.e  i
        </li>
        <li>
           : 6E 63 6C 75 64 65 20 66 69 6C 65 2E 65 0D 0A 0D : nclude file.e   
        </li>
        <li>
           : 0A 63 6F 6E 73 74 61 6E 74 20 53 54 44 4F 55 54 :  constant STDOUT
        </li>
        <li>
           : 20 3D 20 31 2C 20 53 54 44 45 52 52 20 3D 20 32 :  = 1, STDERR = 2
        </li>
        <li>
           : 0D 0A 0D 0A 73 65 71 75 65 6E 63 65 20 46 69 6C :     sequence Fil
        </li>
        <li>
           : 65 6E 61 6D 65 0D 0A 69 6E 74 65 67 65 72 20 53 : ename  integer S
        </li>
        <li>
           : 74 61 72 74                                     : tart
        </li>
      </ol>
      <hr/>
      <p>
        In <a href="PhpLanguage.html">PhpLanguage</a>:
      </p>
      <code>
        <?php<br/>
        array_shift($argv);<br/>
        if (count($argv) !== 4) {<br/>
        die("Usage: php hexdump.php <filename> <start> <end> <width>\n");<br/>
        }<br/>
        list($filename, $start, $end, $width) = $argv;<br/>
        $fn = @fopen($filename, 'rb');<br/>
        if ($fn === FALSE) {<br/>
        die("Unable to open file '$filename'\n");<br/>
        }<br/>
        fseek($fn, $start);<br/>
        $offset = $start;<br/>
        while ($offset < $end && !feof($fn)) {<br/>
        $readto = min(array($offset + $width - 1, $end));<br/>
        $bytes = fread($fn, $readto - $offset + 1);<br/>
        $bytes = str_split($bytes);<br/>
        $line = sprintf('%04x : ', $offset);<br/>
        foreach ($bytes as $byte) {<br/>
        $line .= sprintf('%02x ', ord($byte));<br/>
        }<br/>
        if (strlen($line) < ($width * 3 + 7)) {<br/>
        $line .= str_repeat(' ', $width * 3 + 7 - strlen($line));<br/>
        }<br/>
        $line .= ': ';<br/>
        foreach ($bytes as $byte) {<br/>
        $line .= (ord($byte) >= 32 && ord($byte) <= 127) ? $byte : ' ';<br/>
        }<br/>
        print $line ."\n";<br/>
        $offset += $width;<br/>
        }<br/>
        fclose($fn);<br/>
      </code>
      <p>
        Outputs:
      </p>
      <code>
        C:\programming-exercises\hexdump>php hexdump.php hexdump.php 0 99 16<br/>
      </code>
      <ol>
        <li>
           : 3c 3f 70 68 70 0a 61 72 72 61 79 5f 73 68 69 66 : <?php array_shif
        </li>
        <li>
           : 74 28 24 61 72 67 76 29 3b 0a 69 66 20 28 63 6f : t($argv); if (co
        </li>
        <li>
           : 75 6e 74 28 24 61 72 67 76 29 20 21 3d 3d 20 34 : unt($argv) !== 4
        </li>
        <li>
           : 29 20 7b 0a 20 20 64 69 65 28 22 55 73 61 67 65 : ) {   die("Usage
        </li>
        <li>
           : 3a 20 70 68 70 20 68 65 78 64 75 6d 70 2e 70 68 : : php hexdump.ph
        </li>
        <li>
           : 70 20 3c 66 69 6c 65 6e 61 6d 65 3e 20 3c 73 74 : p <filename> <st
        </li>
        <li>
           : 61 72 74 3e                                     : art>
        </li>
      </ol>
      <hr/>
      <p>
        <strong>TCL</strong>
      </p>
      <code>
        package require binary<br/>
      </code>
      <code>
        proc hexdump {str} {<br/>
        set s ""<br/>
        set addr 0<br/>
      </code>
      <code>
        append s "[format "%07x" $addr]: "<br/>
        set t ""<br/>
        for {set i 0} {$i < [string length $str]} {incr i} {<br/>
        if {$i > 0 && [expr $i % 16] == 0} {<br/>
        append s "  $t\n"<br/>
        append s "[format "%07x" $addr]: "<br/>
        incr addr 16<br/>
        set t ""<br/>
        } elseif {$i > 0 && [expr $i % 2] == 0} {<br/>
        append s " "<br/>
        }<br/>
      </code>
      <code>
        set char [string index $str $i]<br/>
        binary scan $char H2 cc<br/>
        append s $cc<br/>
        if {[string is print $char]} {<br/>
        append t $char<br/>
        } else {<br/>
        append t "."<br/>
        }<br/>
        }<br/>
        puts $s<br/>
        }<br/>
      </code>
      <hr/>
      <p>
        <a href="CategoryInManyProgrammingLanguages.html">CategoryInManyProgrammingLanguages</a>
      </p>
    </div>
  </body>
</html>