<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Xp Schedule Faq
      </h1>
      <p>
        From <a href="XpFaq.html">XpFaq</a>
      </p>
      <p>
        <em>How much faster will a UML Phase make us?</em>
      </p>
      <p>
        pandith@my-deja.com wrote:
      </p>
      <code>
        > I have the requirements for a project and have to design the system.<br/>
        ><br/>
        > Once we got the requirements, we did the use cases and use case<br/>
        > diagrams. What is the logical and easiest way to arrive at the low<br/>
        > level design?<br/>
        ><br/>
        > Should we do activity diagram or Component diagram and Sequence diagram<br/>
        > to end up with the Class Diagram?<br/>
      </code>
      <p>
        Easy. Take the most important feature, and type in a snip of code that will
        test the feature exists. (<a href="TestDrivenDesign.html">TestDrivenDesign</a>.)
      </p>
      <p>
        Then type in the feature. Forget, at this point, any concept of Design, or
        of drawing pictures of your design. Forget every feature you know the
        program eventually must support except the one single feature you are typing
        in. Sounds easy, huh? (<a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a>.)
      </p>
      <p>
        When you go to the next feature, add a test for it, then add the feature.
        Repeat. (<a href="ContinuousIntegration.html">ContinuousIntegration</a>.)
      </p>
      <p>
        As you do this, the code will get ... ugly. Detect ugliness by looking for
        places where the code violates the "<a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a>" rule. This means you
        don't have the right kinds of abstractions. At this point, change the code
        so it fixes the OAOO problem. As you do this you'l probably put in some
        structure (<a href="AdapterPattern.html">AdapterPattern</a>, etc.).
      </p>
      <p>
        Chart your program's structure, as it emerges from the feature list, using
        the UML you are learning. This means your UML is now proofed and known to
        work. Easy, huh? (Reversed <a href="WaterFall.html">WaterFall</a>.)
      </p>
      <p>
        As you refactor code, the test you wrote (before _each_ feature) will
        protect that feature. Without this simple safety net, you will eventually
        generate code that can't be changed at all, and your project will die. (<a href="KentBeck.html">KentBeck</a>.)
      </p>
      <p>
        If you "train" your team, code and <a href="UnifiedModelingLanguage.html">UnifiedModelingLanguage</a> diagrams to always incrementally make the code better over time, it can live for ever. Easy.
      </p>
      <p>
        > BTW the project has a tight schedule.
      </p>
      <p>
        The system I listed preserves each feature as you add it. Therefore you know
        the general rate at which the team adds features. This lets you know when
        the project will end. (<a href="PlanningGame.html">PlanningGame</a>.)
      </p>
      <p>
        You are trying to do all the UML up front, in a batch. _Nobody_ does it like
        that, but the UML books often overlook this point. Big batches like this
        will damage your schedule by obscuring the actual rate at which real
        features can be added. Lots of <a href="UnitTest.html">UnitTest</a>s to lock down functionality are
        more important, and easier. They will eventually support good design, which
        then deserves to be drawn up in UML diagrams.
      </p>
      <p>
        --<a href="PhlIp.html">PhlIp</a>
      </p>
    </div>
  </body>
</html>