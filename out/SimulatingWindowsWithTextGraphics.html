<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Simulating Windows With Text Graphics
      </h1>
      <p>
        <em>[from </em><a href="IsSmalltalkWithoutGraphicsAnyGood.html">IsSmalltalkWithoutGraphicsAnyGood</a>?]<em></em>
      </p>
      <hr/>
      <p>
        Describe <a href="SimulatingWindowsWithTextGraphics.html">SimulatingWindowsWithTextGraphics</a> here.
      </p>
      <p>
        In the '80s, 80x25 color monitors were irritatingly fuzzy, but monochrome monitors were crisp and clear up to at least 132x50 characters.
        "Hercules" compatible graphics cards were common and good, but manipulating 720x348 black and white bits was still a bit much for a 4.77 MHz 8-bit CPU (...pretending to be a 16-bit processor).
      </p>
      <code>
        Q: How to simulate multiple windows?<br/>
        A: With graphic caracters.  Something like the following.<br/>
        (But one can do a lot better with IBM-PC character graphic characters.)<br/>
      </code>
      <code>
        +-----------------------+<br/>
        |                       |<br/>
        |              +------------------+<br/>
        |              |                  |<br/>
        +--------------|                  |<br/>
        +------------------+<br/>
      </code>
      <code>
        Q: What about mice?<br/>
        A: Mice were quite usable in several character-based MS-DOS environments at the time:<br/>
        The mouse moves a character box cursor.  And you could select and highlight<br/>
        character ranges, just as you can do today in an "MS-DOS Window" in most versions<br/>
        of Microsoft Windows.<br/>
      </code>
      <code>
        Q: How many characters wide should a menu be?<br/>
        A: That one's easy:  Just a few characters wider than the longest entry.  Unless you<br/>
        want to limit the width.  But that's an issue with bit mapped GUIs too.  It's<br/>
        actually an <strong>easier</strong> problem to solve with a fixed-width character based user<br/>
        interface:  Worst case, you might have to dynamically scroll text, as some of<br/>
        today's cell phone browsers do.<br/>
      </code>
      <p>
        <em>Screen shot of </em><a href="TurboVision.html">TurboVision</a> demo:<em></em>
      </p>
      <p>
        <img src="http://tvision.sourceforge.net/tv2-QNX-tvscreen.jpg" />
      </p>
      <p>
        Wow.  Shadows even.  Now that's "hi-tech."  ;->
      </p>
      <ul>
        <li>
           I always hated such shadows in the DOS days. They looked pretty, but made it hard to read the text underneath. An option to turn them off is always nice. Another case of marketing interfering with productivity.
        </li>
      </ul>
      <p>
        I could do a decent Smalltalk class browser with an "text" based interface like this.
        And it could have very good performance -- even on an 8-bit 4.77 MHz CPU.
        -- <a href="JeffGrigg.html">JeffGrigg</a>
      </p>
      <p>
        <em>The best-laid plans of mice and men ...</em>
      </p>
    </div>
  </body>
</html>