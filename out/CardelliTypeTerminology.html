<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Cardelli Type Terminology
      </h1>
      <p>
        <a href="LucaCardelli.html">LucaCardelli</a>'s influential 1997 paper "Type Systems" (<a href="http://citeseer.ist.psu.edu/cardelli97type.html)">http://citeseer.ist.psu.edu/cardelli97type.html)</a> gives definitions for a number of terms related to types, excerpted here. See also <a href="TypesOfTyping.html">TypesOfTyping</a>.
      </p>
      <p>
        His approach and definitions are very reasonable for some purposes, but incomplete for others. Notably, he considers only typed variables, not typed cells, and hence calls <a href="LispLanguage.html">LispLanguage</a> an "untyped" language. This is not so much wrong, as it is unhelpful, for the Lisp side of the world; there are other approaches that are more helpful there.
      </p>
      <p>
        Cardelli's approach on the other hand is very handy for discussing things like <a href="HaskellLanguage.html">HaskellLanguage</a>.
      </p>
      <ul>
        <li>
           <strong>Abstract type:</strong> A data type whose nature is kept hidden, in such a way that only a predetermined collection of operations can operate on it.
        </li>
        <li>
           <strong>Contravariant:</strong> A type that varies in the inverse direction from one of its parts with respect to subtyping. The main example is the contravariance of function types in their domain. For example, assume (A <: B) and vary X from A to B in (X -> C); we obtain (A -> C) :> (B -> C).  Thus (X -> C) varies in the inverse direction of X.
        </li>
        <li>
           <strong>Covariant:</strong> A type that varies in the same direction as one of its parts with respect to subtyping. For example, assume (A <: B) and vary X from A to B in (D -> X); we obtain ((D -> A) <: (D -> B)). Thus (D -> X) varies in the same direction as X.
        </li>
        <li>
           <strong>Derivation:</strong> A tree of judgments obtained by applying the rules of a type system.
        </li>
        <li>
           <strong>Dynamic checking:</strong> A collection of run time tests aimed at detecting and preventing forbidden errors.
        </li>
        <li>
           <strong>Dynamically checked language:</strong> A language where good behavior is enforced during execution.
        </li>
        <li>
           <strong>Explicitly typed language:</strong> A typed language where types are part of the syntax.  (aka <a href="ManifestTyping.html">ManifestTyping</a>)
        </li>
        <li>
           <strong>First-order type system:</strong> One that does not include quantification over type variables.
        </li>
        <li>
           <strong>Forbidden error:</strong> The occurrence of one of a predetermined class of execution errors; typically the improper application of an operation to a value, such as logical-not applied to 3.
        </li>
        <li>
           <strong>Good behavior:</strong> Same as being well behaved.
        </li>
        <li>
           <strong>Ill typed:</strong> A program fragment that does not comply with the rules of a given type system.
        </li>
        <li>
           <strong>Implicitly typed language:</strong> A typed language where types are not part of the syntax (or are an optional part). (See <a href="ImplicitTyping.html">ImplicitTyping</a>)
        </li>
        <li>
           <strong>Judgment:</strong> A formal assertion relating entities such as terms, types, and environments.  Type systems prescribe how to produce valid judgments from other valid judgements.
        </li>
        <li>
           <strong>Polymorphism:</strong> The ability of a program fragment to have multiple types (opposite of monomorphism).  (Note: Not the same as interface polymorphism, where a program fragment has a single type but many implementations.)
        </li>
        <li>
           <strong>Safe language:</strong> A language where no untrapped errors can occur.
        </li>
        <li>
           <strong>Second-order type system:</strong> One that includes quantification over type variables, either universal or existential.
        </li>
        <li>
           <strong>Static checking:</strong> A collection of compile time tests, mostly consisting of typechecking.  (Orthogonal to explicit/implicit typing.)
        </li>
        <li>
           <strong>Statically checked language:</strong> A language where good behavior is determined before execution.
        </li>
        <li>
           <strong>Strongly checked language:</strong> A language where no forbidden errors can occur at runtime (depending on the definition of forbidden error).  Generally achieved in statically checked languages by compile-time typing error.  Generally achieved in dynamically checked languages by graceful abortion of the operation (e.g. throwing an exception).
        </li>
        <li>
           <strong>Subsumption:</strong> A fundamental rule of subtyping, asserting that if a term has a type A, and (A <: B) (the subtype relationship), then the term can be passed to functions that take parameters of type B.
        </li>
        <li>
           <strong>Subtyping:</strong> A reflexive and transitive binary relation over types that satisfies subsumption; it asserts the inclusion of collections of values.  The subtype relationship is traditionally indicated with the operator '<:'.
        </li>
        <li>
           <strong>Trapped error:</strong> An execution error that immediately results in a fault.
        </li>
        <li>
           <strong>Type:</strong> A collection of values. An estimate of the collection of values that a program fragment can assume during program execution.
        </li>
        <li>
           <strong>Type inference:</strong> The process of finding a type for a program within a given type system.  
        </li>
        <li>
           <strong>Type reconstruction:</strong> The process of finding a type for a program where type information has been omitted, within a given type system.
        </li>
        <li>
           <strong>Type rule:</strong> A component of a type system. A rule stating the conditions under which a particular program construct will not cause forbidden errors.
        </li>
        <li>
           <strong>Type safety:</strong> The property stating that programs do not cause untrapped errors.
        </li>
        <li>
           <strong>Type soundness:</strong> The property stating that programs do not cause forbidden errors.
        </li>
        <li>
           <strong>Type system:</strong> A collection of type rules for a typed programming language. Same as static type system.
        </li>
        <li>
           <strong>Typechecker:</strong> The part of a compiler or interpreter that performs typechecking.
        </li>
        <li>
           <strong>Typechecking:</strong> The process of checking a program before execution to establish its compliance with a given type system and therefore to prevent the occurrence of forbidden errors. (Dynamic typechecking will be performed upon program fragments immediately prior to their execution.)
        </li>
        <li>
           <strong>Untyped language:</strong> A language that does not have a (static) type system, or whose type system has a single type that contains all values.
        </li>
        <li>
           <strong>Typed language:</strong> A language with an associated (static) type system possessing at least two types, whether or not types are part of the syntax, and whether or not those types are statically checked.
        </li>
        <li>
           <strong>Typing error:</strong> An error reported by a typechecker to warn against possible execution errors.
        </li>
        <li>
           <strong>Untrapped error:</strong> An execution error that does not immediately result in a fault.
        </li>
        <li>
           <strong>Valid judgment:</strong> A judgment obtained from a derivation in a given type system.
        </li>
        <li>
           <strong>Weakly checked language:</strong> A language that is statically checked but provides no clear guarantee of absence of execution errors.
        </li>
        <li>
           <strong>Well behaved:</strong> A program fragment that will not produce forbidden errors at run time.
        </li>
        <li>
           <strong>Well formed:</strong> Properly constructed according to formal rules.
        </li>
        <li>
           <strong>Well-typed program:</strong> A program (fragment) that complies with the rules of a given type system.
        </li>
      </ul>
      <hr/>
      <p>
        See also <a href="ContraVsCoVariance.html">ContraVsCoVariance</a>, et al.
      </p>
      <hr/>
      <p>
        <a href="CategoryTypeTheory.html">CategoryTypeTheory</a> or <a href="CategoryLanguageTyping.html">CategoryLanguageTyping</a>?
      </p>
    </div>
  </body>
</html>