<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Odd Word Problem Solutions
      </h1>
      <p>
        Provide here your solution(s) to the <a href="OddWordProblem.html">OddWordProblem</a>. Failure to do so will color how seriously comments are taken concerning how trivial the problem is.
      </p>
      <hr/>
      <p>
        In <a href="CeeLanguage.html">CeeLanguage</a>:
      </p>
      <code>
        #include <stdio.h><br/>
        #include <ctype.h><br/>
      </code>
      <code>
        int  peek()   { int c = getchar(); ungetc(c, stdin); return c; }<br/>
        int  pop()    { return getchar(); }<br/>
        int  alpha()  { return isalpha(peek()); }<br/>
        int  space()  { return isspace(peek()); }<br/>
        void chkend() { if(peek() == '.') { printf(".\n"); exit(0); } }<br/>
      </code>
      <code>
        void spaces(int f) { while(space()) pop(); chkend(); if(f) putchar(' '); }<br/>
        void even()        { while(alpha()) putchar(pop()); }<br/>
        void odd()         { if(alpha()) { int c = pop(); odd(); putchar(c); } }<br/>
      </code>
      <code>
        int main() { spaces(0); for(;;) { even(); spaces(1); odd(); spaces(1); } }<br/>
      </code>
      <p>
        Beware when testing this that your buffering does not interfere with very long input.
      </p>
      <p>
        <em>Beautiful.</em>
      </p>
      <hr/>
      <p>
        Another in <a href="CeeLanguage.html">CeeLanguage</a>:
      </p>
      <p>
        The function f(char *cur) takes a pointer to the input text and prints output text to
        stdin as specified by the problem.  It returns a non-zero value upon failure (which
        only happens if the string does not have the terminating point or if printf fails).
      </p>
      <p>
        int f(char *cur)
        {
      </p>
      <code>
        char buffer[20], *out;<br/>
        int STATE, i;<br/>
      </code>
      <code>
        while(isspace(*cur)) cur++;<br/>
      </code>
      <code>
        for(STATE = 1, i = 0; *cur; i = 0, putchar(' '))<br/>
        {		<br/>
        while(isalpha(*cur)) buffer[++i] = *cur++;<br/>
        out = buffer + (STATE == 1 ? 0 : i + 1);<br/>
        while(i--) putchar(*(out += STATE));<br/>
        STATE *= -1;<br/>
        while(isspace(*cur)) cur++;<br/>
        if(*cur == '.') return !printf(".\n");		<br/>
        }<br/>
        return 1;<br/>
      </code>
      <p>
        }
      </p>
      <hr/>
      <p>
        In <a href="SchemeLanguage.html">SchemeLanguage</a>:
      </p>
      <code>
        (define (spaces starting continuation)<br/>
        (case (peek-char)<br/>
        ((#\.)     (display #\.) (newline))<br/>
        ((#\space) (read-char) (spaces starting continuation))<br/>
        (else      (if (not starting) (display #\space)) (continuation))))<br/>
      </code>
      <code>
        (define (even)<br/>
        (case (peek-char)<br/>
        ((#\. #\space) (spaces #f odd))<br/>
        (else          (display (read-char)) (even))))<br/>
      </code>
      <code>
        (define (odd)<br/>
        (define (magic) (case (peek-char)<br/>
        ((#\. #\space) #f) <br/>
        (else (let ((c (read-char))) (magic) (display c)))))<br/>
        (magic)<br/>
        (spaces #f even))<br/>
      </code>
      <code>
        (spaces #t even)<br/>
      </code>
      <hr/>
      <p>
        Another in <a href="SchemeLanguage.html">SchemeLanguage</a>:
      </p>
      <code>
        (define spacemap '((startspaces . startspaces) (evenword . oddspaces) <br/>
        (oddspaces   . oddspaces)   (oddword  . evenspaces)<br/>
        (evenspaces  . evenspaces)))<br/>
        (define (oddmagic)<br/>
        (case (peek-char)<br/>
        ((#\space #\.) #f)<br/>
        (else (let ((c (read-char))) (oddmagic) (display c)))))<br/>
      </code>
      <code>
        (define (oddwords)<br/>
        (let loop ((state 'startspaces))<br/>
        (case (peek-char)<br/>
        ((#\space) (read-char) (loop (cdr (assv state spacemap))))<br/>
        ((#\.)     (display (read-char)) (newline))<br/>
        (else (case state<br/>
        ((startspaces)                       (loop 'evenword))<br/>
        ((evenword)    (display (read-char)) (loop 'evenword))<br/>
        ((oddspaces)   (display #\space)     (loop 'oddword))<br/>
        ((oddword)     (oddmagic)            (loop 'evenspaces))<br/>
        ((evenspaces)  (display #\space)     (loop 'evenword)))))))<br/>
      </code>
      <hr/>
      <p>
        In <a href="PerlLanguage.html">PerlLanguage</a> (ignoring the character-at-a-time requirement and doing it with strings and regular expressions):
      </p>
      <code>
        do { $line .= getc(); } until($line =~ /\.$/);<br/>
        $line =~ s/^ *//;<br/>
        $line =~ s/ *\././;<br/>
        $line =~ s/ +/ /g;<br/>
        $line =~ s/([^ .]+) ([^ .]+)/ "$1 " . reverse($2) /eg;<br/>
        print "$line\n";<br/>
      </code>
      <p>
        <em>Oh, please. If you're going to ignore one of the specifications for the problem, you could at least give a good answer. That's the sort of thing that makes Perl look bad. There's a </em>reverse<em> function for a reason, you know. Here, try this.</em>
      </p>
      <code>
        my @words = split " ", "whats the matter with kansas.";<br/>
        my $odd;<br/>
      </code>
      <code>
        for (0..$#words)<br/>
        {<br/>
        if ($odd) {<br/>
        $words[$_] = join "", reverse split "", $words[$_];<br/>
        undef $odd;<br/>
        next;<br/>
        }<br/>
        $odd = 1;  <br/>
        }<br/>
      </code>
      <code>
        print join " ", @words;<br/>
      </code>
      <hr/>
      <p>
        This does look pretty straightforward, with a couple of bookkeeping details in the spec. Here is a <a href="CommonLisp.html">CommonLisp</a> version. I haven't tried this, and only had a couple of minutes for it, but I think it is correct w.r.t the given spec. It uses as 20 character buffer, there are probably much more elegant ways to do this. -- ska
      </p>
      <code>
        (defun oddword (input-stream output-stream)<br/>
        (let ((word-count 0)<br/>
        (buffer (make-array 20 :element-type 'base-char :fill-pointer 0 :adjustable t)))<br/>
        (flet ((eat-spaces ()<br/>
        (loop for s = (read-char input-stream nil input-stream)<br/>
        until (or (eq s input-stream) (not (eq s #\space)))<br/>
        finally (unread-char s input-stream)))<br/>
        (print-word ()<br/>
        (if (oddp word-count)<br/>
        (loop for n from (1- (length buffer)) downto 0<br/>
        do (write-char (aref buffer n) output-stream))<br/>
        (loop for n below (length buffer)<br/>
        do (write-char (aref buffer n) output-stream)))<br/>
        (incf word-count)<br/>
        (setf (fill-pointer buffer) 0)))<br/>
        (loop for s = (read-char input-stream nil input-stream)<br/>
        until (eq s input-stream)<br/>
        do (case s<br/>
        (#\space<br/>
        (eat-spaces)<br/>
        (print-word)<br/>
        (unless (eq #\. (peek-char t input-stream))<br/>
        (write-char #\space output-stream)))<br/>
        (#\.		<br/>
        (print-word)<br/>
        (write-char #\. output-stream))<br/>
        (t (vector-push-extend s buffer)))))))<br/>
      </code>
      <hr/>
      <p>
        I took the above CL solution and improved (my opinion :-) it:
      </p>
      <ul>
        <li>
           Characters should be compared with eql or char=. eq does not necessarily work.
        </li>
        <li>
           By using handler-case and calling print-word in the end-of-file clause, the last word is printed even when the input doesn't end in a space or point. Also EOF is handled at exactly one location in the program.
        </li>
        <li>
           I found that using a list instead of a vector with fill-pointer as buffer often results in more elegant code.
        </li>
      </ul>
      <code>
        (defun oddword (&key (input *query-io*) (output *query-io*))<br/>
        (let ((word-count 0)<br/>
        (buffer nil))<br/>
        (flet ((eat-spaces ()<br/>
        (loop for c = (read-char input)<br/>
        while (eql c #\Space)<br/>
        finally (unread-char c input)))<br/>
        (print-word ()<br/>
        (mapc 'write-char (if (oddp word-count) buffer (reverse buffer)))<br/>
        (incf word-count)<br/>
        (setf buffer nil)))<br/>
        (handler-case (loop for c = (read-char input)<br/>
        do (case c<br/>
        (#\Space<br/>
        (print-word)<br/>
        (eat-spaces)<br/>
        (unless (eql #\. (peek-char t input))<br/>
        (write-char #\Space output)))<br/>
        (#\.<br/>
        (print-word)<br/>
        (write-char #\. output))<br/>
        (t (push c buffer))))<br/>
        (end-of-file () (print-word))))))<br/>
      </code>
      <hr/>
      <p>
        A Modula-2 implementation of a similar specification (word length 70, handle '\r') is at <a href="http://www.modulaware.com/mdlt53.htm.">http://www.modulaware.com/mdlt53.htm.</a> It uses <a href="CoRoutine.html">CoRoutine</a>s.
      </p>
      <hr/>
      <p>
        A <a href="JavaLanguage.html">JavaLanguage</a> solution:
      </p>
      <code>
        package com.ebh;<br/>
      </code>
      <code>
        import java.io.BufferedReader;<br/>
        import java.io.BufferedWriter;<br/>
        import java.io.FileReader;<br/>
        import java.io.FileWriter;<br/>
        import java.io.IOException;<br/>
        import java.util.ArrayList;<br/>
        import java.util.Collections;<br/>
        import java.util.Iterator;<br/>
      </code>
      <code>
        /**<br/>
      </code>
      <ul>
        <li>
           Consider a character set consisting of letters, a space, 
        </li>
        <li>
           and a point. Words consist of one or more, but at most 
        </li>
        <li>
           20 letters. An input text consists of one or more words 
        </li>
        <li>
           separated from each other by one or more spaces and 
        </li>
        <li>
           terminated by 0 or more spaces followed by a point. 
        </li>
        <li>
           Input should be read from, and including, the first 
        </li>
        <li>
           letter of the first word, up to and including the 
        </li>
        <li>
           terminating point. The output text is to be produced 
        </li>
        <li>
           such that successive words are separated by a single 
        </li>
        <li>
           space with the last word being terminated by a single 
        </li>
        <li>
           point. Odd words are copied in reverse order while even 
        </li>
        <li>
           words are merely echoed. For example, the input string 
        </li>
        <li>
           		whats the matter with kansas.
        </li>
        <li>
           becomes
        </li>
        <li>
           		whats eht matter htiw kansas.
        </li>
        <li>
           The problem is further restricted in that the characters 
        </li>
        <li>
           must be read and printed one at a time. 
        </li>
        <li>
          /
        </li>
      </ul>
      <code>
        public class <a href="OddWordProblem.html">OddWordProblem</a> {<br/>
        static ArrayList<Character> word = new ArrayList<Character>();<br/>
        static Character separator;<br/>
        static boolean forward=true;<br/>
        static boolean wordEnded = false;<br/>
        static final char SPACE = ' ';<br/>
        static final char PERIOD = '.';<br/>
      </code>
      <code>
        public static void main(String[] args) throws IOException {<br/>
        BufferedReader input = new BufferedReader(new FileReader(args[0]));<br/>
        BufferedWriter output = new BufferedWriter(new FileWriter(args[1]));<br/>
        solve(input, output);<br/>
        output.flush();<br/>
        }<br/>
      </code>
      <code>
        private static void solve(BufferedReader input, BufferedWriter output)<br/>
        throws IOException {<br/>
        int nextCharAsInt;<br/>
        while ((nextCharAsInt = input.read())!=-1) {<br/>
        char nextChar = (char)nextCharAsInt;<br/>
        if (nextChar == SPACE || nextChar == PERIOD) {<br/>
        endOfWord(output, nextChar);<br/>
        } else {<br/>
        middleOfWord(output, nextChar);<br/>
        }<br/>
        }<br/>
        if (separator!=null) {<br/>
        output.write(separator.charValue());<br/>
        }<br/>
        }<br/>
      </code>
      <code>
        private static void middleOfWord(BufferedWriter output, char nextChar) throws IOException {<br/>
        if (wordEnded) {<br/>
        wordEnded = false;<br/>
        forward = !forward;<br/>
        output.write(separator.charValue());<br/>
        }<br/>
        word.add(nextChar);<br/>
        }<br/>
      </code>
      <code>
        private static void endOfWord(BufferedWriter output, char nextChar)<br/>
        throws IOException {<br/>
        if (!forward) {<br/>
        Collections.reverse(word);<br/>
        }<br/>
        writeCurrentWord(output);<br/>
        separator = nextChar;<br/>
        word.clear();<br/>
        wordEnded = true;<br/>
        }<br/>
      </code>
      <code>
        private static void writeCurrentWord(BufferedWriter output)<br/>
        throws IOException {<br/>
        for (char c : word) {<br/>
        output.write(c);<br/>
        }<br/>
        }<br/>
        }<br/>
      </code>
      <p>
        What's so hard about that? -- <a href="EricHodges.html">EricHodges</a>
      </p>
      <p>
        See <a href="OddWordProblemSolutionArgument.html">OddWordProblemSolutionArgument</a>
      </p>
      <hr/>
      <p>
        A <a href="ForthLanguage.html">ForthLanguage</a> solution (should work in any ANS Forth):
      </p>
      <code>
        variable wordLen<br/>
        create word 20 chars allot<br/>
      </code>
      <code>
        : addLetter ( [a-z] -- )<br/>
        wordLen @ 20 < 0= abort" word too long!"<br/>
        word wordLen @ chars + c!  1 wordLen +! ;<br/>
      </code>
      <code>
        : emitWord<br/>
        word wordLen @ chars + word do I c@ emit loop ;<br/>
      </code>
      <code>
        : droWtime<br/>
        word 1 chars - dup wordLen @ chars + do I c@ emit -1 chars +loop ;<br/>
      </code>
      <code>
        : eatSpaces ( bl -- [a-z.] )<br/>
        begin drop key  dup bl <> until ;<br/>
      </code>
      <code>
        : getWord ( [a-z] -- [a-z.] )<br/>
        begin addLetter key<br/>
        dup [char] . = if exit then<br/>
        dup bl =<br/>
        until eatSpaces ;<br/>
      </code>
      <code>
        variable parity<br/>
      </code>
      <code>
        : wordOut<br/>
        wordlen @ 0= abort" word parsing broken"<br/>
        parity @ if droWtime false else emitWord true then<br/>
        parity !  0 wordLen ! ;<br/>
      </code>
      <code>
        : main<br/>
        false parity !  0 wordLen !<br/>
        bl eatSpaces ( c )<br/>
        dup [char] . = if emit exit then<br/>
        begin  getWord wordOut<br/>
        dup [char] . <><br/>
        while  space<br/>
        repeat emit ;<br/>
      </code>
      <p>
        This problem is also a good test for coming up with good test cases for the spec. For instance, I had to redo the design once when I realized "word  ." needed to output "word."  And then I had to handle the minimal input of "." and "  ." differently. -- <a href="IanOsgood.html">IanOsgood</a>
      </p>
      <p>
        <em>That's actually above and beyond the call of duty. Here is the initial spec, which disallows the minimal input you list:</em>
      </p>
      <dl>
        <dt> </dt>
        <dd>Consider a character set consisting of letters, a space, and a point. Words consist of one or more, but at most 20 letters. <strong>An input text consists of one or more words</strong> separated from each other by one or more spaces and terminated by 0 or more spaces followed by a point.</dd>
      </dl>
      <hr/>
      <p>
        Another <a href="ForthLanguage.html">ForthLanguage</a> solution, in the style of the elegant <a href="CeeLanguage.html">CeeLanguage</a> entry.  The 'ungetc' character is kept on top of the stack.
      </p>
      <code>
        : word?  dup [char] . <> over bl <> and ;<br/>
        : ?quit  dup [char] . = if emit quit then ;<br/>
        : eatbl  begin dup bl = while drop key repeat ?quit ;<br/>
        : even   begin word? while emit key repeat ;<br/>
        : odd    word? if key recurse swap emit then ;<br/>
        : main   cr key eatbl begin even eatbl space odd eatbl space again ;<br/>
      </code>
      <hr/>
      <p>
        The same in <a href="FalseLanguage.html">FalseLanguage</a>:
      </p>
      <code>
        [[$' =][%^]#]b:<br/>
        [$$'.=\' =|~]w:<br/>
        [$'.=~[' ,]?]s:<br/>
        [w;![^o;!\,]?]o:<br/>
        ^b;![$'.=~][w;[,^]#b;!s;!o;!b;!s;!]#,<br/>
      </code>
      <hr/>
      <p>
        <a href="CeePlusPlus.html">CeePlusPlus</a>
      </p>
      <code>
        #include <iostream><br/>
        #include <fstream><br/>
        #include <algorithm><br/>
      </code>
      <code>
        using namespace std;<br/>
      </code>
      <code>
        const char WORD_SEPARATOR = ' ';<br/>
        const char END_OF_STREAM = '.';<br/>
        const unsigned MAX_WORD_LENGTH = 20;<br/>
      </code>
      <code>
        //-----------------------------------------------------------------------------<br/>
        template <typename TYPE><br/>
        class auto_close<br/>
        {<br/>
        public:<br/>
      </code>
      <code>
        TYPE& resource;<br/>
        auto_close(TYPE& r) : resource(r) { };<br/>
        ~auto_close() { if (resource.is_open()) resource.close(); };<br/>
        };<br/>
      </code>
      <code>
        //-----------------------------------------------------------------------------<br/>
        void extractWord(istream& in, string& word)<br/>
        {<br/>
        while (in.good() && in.peek() != END_OF_STREAM && in.peek() == WORD_SEPARATOR)<br/>
        in.ignore();<br/>
      </code>
      <code>
        word.clear();<br/>
      </code>
      <code>
        while (in.good() && in.peek() != END_OF_STREAM && in.peek() != WORD_SEPARATOR) <br/>
        {<br/>
        word += in.get();<br/>
      </code>
      <code>
        if (word.length() > MAX_WORD_LENGTH)<br/>
        throw length_error("Invalid input. Character/Word length exceeded.");<br/>
        }<br/>
        }<br/>
      </code>
      <code>
        //*****************************************************************************<br/>
        int main(int argc, char* argv[])<br/>
        {<br/>
        try<br/>
        {<br/>
        if (argc != 3) throw invalid_argument("Invalid arguments.");<br/>
      </code>
      <code>
        ifstream infile(argv[1]);<br/>
        ofstream outfile(argv[2]);<br/>
        auto_close<ifstream> infile_close(infile);<br/>
        auto_close<ofstream> outfile_close(outfile);<br/>
        string word;<br/>
        unsigned long wordCount = 0;<br/>
      </code>
      <code>
        while (infile.good() && infile.peek() != END_OF_STREAM)<br/>
        {<br/>
        extractWord(infile, word);<br/>
      </code>
      <code>
        if (wordCount++ & 1)<br/>
        reverse(word.begin(), word.end());<br/>
      </code>
      <code>
        for (string::const_iterator p = word.begin(); p != word.end(); ++p)<br/>
        outfile << *p;<br/>
      </code>
      <code>
        outfile << WORD_SEPARATOR;<br/>
        }<br/>
      </code>
      <code>
        outfile.seekp(outfile.tellp() - fpos<int>(wordCount ? 1 : 0));<br/>
        outfile << END_OF_STREAM;<br/>
        }<br/>
        catch (exception& e) {<br/>
        cerr << "Error: " << e.what() << endl;<br/>
        return -1;<br/>
        }<br/>
      </code>
      <code>
        return 0;<br/>
        }<br/>
      </code>
      <p>
        -- <a href="KyleWakefield.html">KyleWakefield</a>
      </p>
      <hr/>
      <p>
        Erics solution translated to <a href="CeeSharp.html">CeeSharp</a> and refactored a bit
      </p>
      <code>
        using System;<br/>
        using System.IO;<br/>
        using System.Collections;<br/>
      </code>
      <code>
        public class OddWordProblem {<br/>
        [STAThread]<br/>
        static void Main(string[] args) {<br/>
        StreamWriter output = new StreamWriter(args[1]);<br/>
        new OddWordProblem().Solve(new StreamReader(args[0]), output);<br/>
        output.Flush();<br/>
        }<br/>
      </code>
      <code>
        ArrayList currentWord = new ArrayList();<br/>
        char aSeparator;<br/>
        bool isForward=true;<br/>
        bool isWordEnded=false;<br/>
      </code>
      <code>
        void Solve(StreamReader theInput, StreamWriter theOutput) {<br/>
        int nextChar;<br/>
        while ((nextChar = theInput.Read())!=-1) {<br/>
        char aChar = (char)nextChar;<br/>
        if(aChar==' '||aChar=='.')EndOfWord(theOutput, aChar);<br/>
        else MiddleOfWord(theOutput, aChar);<br/>
        }<br/>
        theOutput.Write(aSeparator);<br/>
        }<br/>
        void MiddleOfWord(StreamWriter theOutput, char aChar) {<br/>
        if(isWordEnded) {<br/>
        isWordEnded = false;<br/>
        isForward = !isForward;<br/>
        theOutput.Write(aSeparator);<br/>
        }<br/>
        currentWord.Add(aChar);<br/>
        }<br/>
        void EndOfWord(StreamWriter output, char nextChar) {<br/>
        if(!isForward)currentWord.Reverse();<br/>
        foreach(char aChar in currentWord)<br/>
        output.Write(aChar);<br/>
        aSeparator = nextChar;<br/>
        currentWord = new ArrayList();<br/>
        isWordEnded = true;<br/>
        }<br/>
        }<br/>
      </code>
      <hr/>
      <p>
        A modest proposal. To make OddWordProblemSolution in <a href="JavaLanguage.html">JavaLanguage</a> a worthwhile challenge, I spoke to myself: "Self! let's do it in a single procedure, with fixed size memory, like we used to do it <a href="PascalLanguage.html">PascalLanguage</a> and other worthwhile languages". Java syntax kind of stayed in my way, but then I figure out that _ can be an identifier, and is kind of unobtrusive to read. Therefore the fake _. operator will give access to your friendly VAR section of the outer procedure. Wile the fake ._() becomes an acceptable way to call a procedure. It's kind of prematurely optimized, but people who lived to program for Kbytes of memory have nothing to be ashamed of. 
      </p>
      <code>
        /**<br/>
      </code>
      <ul>
        <li>
           You can write PASCAL in JAVA
        </li>
        <li>
           With thanks to Dr. Wirth for showing the way
        </li>
        <li>
           and also to Dr. Gries for this invaluable piece of wisdom
        </li>
        <li>
           DO NOT PROGRAM IN A LANGUAGE PROGRAM <strong>INTO</strong> A LANGUAGE
        </li>
        <li>
          /
        </li>
      </ul>
      <code>
        public class OddWordsProgram { <br/>
      </code>
      <code>
        interface Procedure { public void _() throws Exception; }<br/>
        static final int MAX_SIZE=20;<br/>
      </code>
      <code>
        public static void main(String args[]) {<br/>
        // Like I told you, this is your friendly VAR section<br/>
        // mayeb we can lobby James Gosling to consider it for Java 1.6<br/>
        class VAR {<br/>
        int c; <br/>
        boolean readEvenFlag= true;<br/>
        boolean firstTimeSkipSpace=true;<br/>
        // for lack of real forward declarations some inner procedure<br/>
        // are declared as variables in the local scope<br/>
        } 	final VAR _ = new VAR(); <br/>
      </code>
      <code>
        class ReadNextChar {public void _() throws Exception {_.c= System.in.read(); }} <br/>
        final ReadNextChar readNextChar= new ReadNextChar();<br/>
      </code>
      <code>
        class EatSpace implements Procedure { public final void _() throws Exception {<br/>
        do {<br/>
        readNextChar._();<br/>
        } while (_.c != -1 && _.c== ' ' ); <br/>
        }} <br/>
        EatSpace eatSpace= new EatSpace(); <br/>
      </code>
      <code>
        class ReadEvenWord implements Procedure { public final void _() throws Exception {<br/>
        if (! _.firstTimeSkipSpace) {<br/>
        System.out.write(' '); } <br/>
        else _.firstTimeSkipSpace=false;<br/>
      </code>
      <code>
        do {<br/>
        System.out.write(_.c);<br/>
        readNextChar._();<br/>
        } while (_.c != -1 && _.c!=' ' && _.c!= '.');<br/>
      </code>
      <code>
        _.readEvenFlag= false;<br/>
        }} <br/>
        ReadEvenWord readEvenWord= new ReadEvenWord();<br/>
      </code>
      <code>
        final byte [] buffer= new byte[MAX_SIZE];<br/>
        class ReadOddWord implements Procedure { public final void _() throws Exception {<br/>
        int index=MAX_SIZE;<br/>
        System.out.write(' ');<br/>
        do {<br/>
        buffer[--index] = (byte) _.c;<br/>
        readNextChar._();<br/>
        } while (_.c != -1 && _.c!= ' ' && _.c!= '.' );<br/>
      </code>
      <code>
        System.out.write(buffer,index, MAX_SIZE - index); <br/>
        _.readEvenFlag= true;<br/>
        }} <br/>
        ReadOddWord readOddWord= new ReadOddWord();<br/>
      </code>
      <code>
        try {<br/>
        readNextChar._();<br/>
        while (true){<br/>
        if (_.c==' ')<br/>
        eatSpace._();<br/>
        else if (_.c== -1) {<br/>
        System.err.println("Error: unexpected end of file, waiting for '.' ");<br/>
        System.exit(-1);}<br/>
        else if (_.c == '.') {<br/>
        System.out.write('.');<br/>
        break;}<br/>
        else {<br/>
        if (_.readEvenFlag ) readEvenWord._();<br/>
        else readOddWord._();<br/>
        }}<br/>
        System.out.flush();<br/>
        }<br/>
        catch (ArrayIndexOutOfBoundsException ex) {<br/>
        System.err.println("I caught an odd input word longer than MAX_SIZE="+MAX_SIZE);<br/>
        System.exit(-1); }<br/>
        catch(Exception ex) {<br/>
        System.err.println(ex);<br/>
        ex.printStackTrace(System.err);<br/>
        System.exit(-1); }<br/>
        }}<br/>
      </code>
      <hr/>
      <p>
        As an example of how trivial this problem is without the restriction that characters be "READ AND WRITTEN" (oppose "READ and WRITTEN") one at a time, here is the <a href="HaskellLanguage.html">HaskellLanguage</a> solution:
      </p>
      <code>
        import Char<br/>
      </code>
      <code>
        main = (printOneAtATime . oddword) "whats the matter with kansas."<br/>
      </code>
      <code>
        printOneAtATime [] = putChar '\n'<br/>
        printOneAtATime (c:cs) = putChar c >> printOneAtATime cs<br/>
      </code>
      <code>
        oddword [] = []<br/>
        oddword ('.':cs) = ['.']<br/>
        oddword (c:cs)<br/>
        | isSpace c && test cs  = [c] ++ (oddword' (dropWhile isSpace cs) [])<br/>
        | isSpace c		= [c] ++ "."<br/>
        | otherwise		= [c] ++ (oddword cs)<br/>
      </code>
      <code>
        oddword' [] acc = acc<br/>
        oddword' ('.':cs) acc = acc ++ "."<br/>
        oddword' (c:cs) acc<br/>
        | isSpace c && test cs  = acc ++ [c] ++ (oddword (dropWhile isSpace cs))<br/>
        | isSpace c		= acc ++ "."<br/>
        | otherwise		= oddword' cs (c:acc)<br/>
      </code>
      <code>
        test cs = (head (dropWhile isSpace cs))  /= '.'<br/>
      </code>
      <p>
        Since the length of the words are bounded in the problem, "acc" will never grow beyond 20 characters. This is why you should challenge yourself with the Turing-tape style formulation of the problem. As an aside, this demonstrates how industry-standard languages can certainly be the wrong tool for the job.
      </p>
      <p>
        Note -- Reimplementing Haskell's output function is busywork. Modern systems use buffered I/O, so technically this solution might not satisfy "written one at a time" out of the box, but the spirit of the problem is maintained, assuming you allow for a "word" buffer at all. The standard Haskell function dropWhile reads one element at time by definition, as do my functions.
      </p>
      <p>
        <em>Note also the Lisp version above is pretty clean, even following the original spec (supporting your comment about industry-standard languages).</em>
      </p>
      <hr/>
      <p>
        I read the question and daydreamed at work about writing a C++ version based on a general finite state machine and polymorphism, but when I sat down to work on it at home I found myself more and more attracted to terser <a href="CeeLanguage.html">CeeLanguage</a> version, and so I wrote this:  
      </p>
      <code>
        #include <stdio.h><br/>
      </code>
      <code>
        char copy_word(char** in, char** out, int direction)<br/>
        {// copies word in direction specified, leaves dots and spaces.<br/>
        char c = **in;<br/>
        if (c != ' ' && c != '.') {		// dont touch specail chars<br/>
        ++*in;				<br/>
        if (direction == 1) {<br/>
      </code>
      <ul>
        <li>
          (*out)++ = c;			// do the copy
        </li>
      </ul>
      <code>
        copy_word(in, out, direction);	// recurse<br/>
        } else {<br/>
        copy_word(in, out, direction);	// recurse<br/>
      </code>
      <ul>
        <li>
          (*out)++ = c;			// do the copy
        </li>
      </ul>
      <code>
        }<br/>
        }<br/>
        return c;<br/>
        }<br/>
      </code>
      <code>
        char oddword(char* in, char* out)	<br/>
        {<br/>
        int dir = 1;			// first word backwards<br/>
        while (1) {			  <br/>
        if( *in == '.') break;		// dot means end<br/>
        while( *in == ' ') in++;	// eat space <br/>
      </code>
      <code>
        if( *in == '.') break;		// dot means end<br/>
        copy_word(&in, &out, dir*=-1);	// negating alternates direction<br/>
      </code>
      <code>
        if( *in == '.') break;		// dot means end<br/>
      </code>
      <ul>
        <li>
          out++ = *in++;			// space between words
        </li>
      </ul>
      <code>
        }<br/>
        return *out++ = *in++;		// end with a dot<br/>
        }<br/>
      </code>
      <code>
        char oddword0(char* in, char* out)<br/>
        {					// test main<br/>
        while(*out++ = *in++);<br/>
        }<br/>
      </code>
      <code>
        int main(int argc, char* argv[])<br/>
        {<br/>
        char buf[1024],*ptr = buf;		// this is just me revising pointers<br/>
        while (--argc || (ptr[-1] = 0)) <br/>
        for (char* wrd = *++argv; (*ptr++ = *wrd++) || !(ptr[-1] = ' '););<br/>
      </code>
      <dl>
        <dt>printf("Before</dt>
        <dd>%s\n",buf);</dd>
      </dl>
      <code>
        oddword(buf, buf);<br/>
      </code>
      <dl>
        <dt>printf("After </dt>
        <dd>%s\n",buf);	 // may be junk after dot</dd>
      </dl>
      <code>
        }<br/>
      </code>
      <p>
        Please forgive the main() function that I wrote first, not so much in the spirit of true XP but in order to practice pointer arithmetic!
      </p>
      <p>
        <strong>main()</strong> throws space-separated command line arguments into a fixed size array. You can test multiple spaces by quoting them in the command line. This array size limit is not a constraint of my solution, merely of the test code. Similarly the fact that you may see junk after the dot if you reuse the test buffer, as I do here. I think it is good to reuse the testbuffer for in and out despite the junk because it helps test that the algorithm is reading and writing one character at a time.
      </p>
      <p>
        The algorithm calls a recursive function to copy each word letter by letter but it does tail recursion to copy normally, and recurse, then copy to copy reversed. -- <a href="BillWeston.html">BillWeston</a>
      </p>
      <p>
        <em>hang on though, I just realised it doesn't fulfil the conditions... to do that I must always have a ++ when I have a *.  I will try again -- </em><a href="BillWeston.html">BillWeston</a><em></em>
      </p>
      <hr/>
      <p>
        What?  No <a href="RubyLanguage.html">RubyLanguage</a> solutions?  We'll have to fix that:
      </p>
      <code>
        class OddWord<br/>
      </code>
      <code>
        def initialize(input)<br/>
        @input = input<br/>
        end<br/>
      </code>
      <code>
        def go<br/>
        c = read_word(reverse = false)<br/>
        c = read_word(reverse = !reverse, find_word) until c == '.'<br/>
        puts c<br/>
        end<br/>
      </code>
      <code>
        private<br/>
      </code>
      <code>
        def read<br/>
        return [@input.getc].pack('c')<br/>
        end<br/>
      </code>
      <code>
        def read_word(reverse, c = read)<br/>
        return c if [' ', '.'].include?(c)<br/>
        print c unless reverse<br/>
        v = read_word(reverse)<br/>
        print c if reverse<br/>
        return v<br/>
        end<br/>
      </code>
      <code>
        def find_word(c = read)<br/>
        return find_word if c == ' '<br/>
        print ' ' unless c == '.'<br/>
        return c<br/>
        end<br/>
      </code>
      <code>
        end<br/>
      </code>
      <p>
        -- <a href="JasonArhart.html">JasonArhart</a>
      </p>
      <hr/>
      <p>
        <a href="PythonLanguage.html">PythonLanguage</a>:
      </p>
      <code>
        def oddwords(put,get):<br/>
        def output(stack, goForward=True):<br/>
        if goForward:<br/>
        for storedChar in stack:<br/>
        put(storedChar)<br/>
        else:<br/>
        while len(stack)>0:<br/>
        put(stack.pop())<br/>
        goForward=True<br/>
        stack=[]<br/>
        while 1:<br/>
        c=get()<br/>
        if c in " .":<br/>
        output(stack,goForward)<br/>
        goForward ^= True<br/>
        while c==" ":<br/>
        c=get()<br/>
        if c!=".":<br/>
        put(" ")<br/>
        stack=[]<br/>
        if c==".":<br/>
        put(".")<br/>
        break<br/>
        stack.append(c)<br/>
      </code>
      <p>
        Solutions to this puzzle should probably be divided into several categories.  In one category, the main restriction would be character-at-a-time I/O <em>without</em> the ability to push-back onto the input stream or pull-back from the output stream.  In other words, a solution would be a function which took arbitrary "char get(void)" and "void put(char)" functions, and reproduced the correct behavior.  In another category, I/O pushback (in the style of a Turing tape) would be permitted, but the program would not be permitted to store data "off the tape" in stacks or recursive function calls  -- solutions would presumably be submitted in <a href="BrainfuckLanguage.html">BrainfuckLanguage</a> or a similar Turing-tape emulator.
      </p>
      <hr/>
      <p>
        Ya shouldn'ta mentioned <a href="BrainfuckLanguage.html">BrainfuckLanguage</a>, 'cause I had to make a solution on the <a href="SnuspLanguage.html">SnuspLanguage</a> page.  Amazingly, it is not longer than other solutions on this page.
      </p>
      <hr/>
      <p>
        <em>Alternate </em><a href="PythonLanguage.html">PythonLanguage</a> solution:<em></em>
      </p>
      <code>
        from sys import stdin, stdout<br/>
        def even(char) : stdout.write(char); return select(even, 0, "");<br/>
        def odd(char)  : q = select(odd, 0, ""); stdout.write(char); return q<br/>
        def select(fn, skipspace, prefix) :<br/>
        char = stdin.read(1)<br/>
        if char.isspace() and skipspace : return select(fn, 1, prefix)<br/>
        elif char.isspace()             : return 0<br/>
        elif char.isalpha()             : stdout.write(prefix); return fn(char)<br/>
        elif char == "."                : return 1<br/>
        else                            : raise "Invalid input"<br/>
      </code>
      <code>
        if not select(even, 1, "") :<br/>
        while not select(odd, 1, " ") and not select(even, 1, " ") : pass<br/>
        stdout.write(".")<br/>
      </code>
      <hr/>
      <p>
        <a href="PascalLanguage.html">PascalLanguage</a>:
      </p>
      <code>
        program oddwords(input,output);<br/>
      </code>
      <code>
        function dospaces(starting: boolean) : boolean;<br/>
        begin<br/>
        while input^ = ' ' do get(input);<br/>
        case input^ of<br/>
        '.':  begin dospaces := false; writeln('.'); end;<br/>
        else  begin dospaces := true;  if not starting then write(' '); end<br/>
        end<br/>
        end;<br/>
      </code>
      <code>
        procedure oddmagic;<br/>
        var c: char;<br/>
        begin<br/>
        case input^ of<br/>
        '.', ' ': ; { do nothing }<br/>
        else begin c := input^; get(input); oddmagic; write(c); end<br/>
        end<br/>
        end;<br/>
      </code>
      <code>
        var parity: (odd, even);<br/>
        var starting: boolean;<br/>
        begin<br/>
        starting := true;<br/>
        parity   := even;<br/>
        while dospaces(starting) do<br/>
        begin<br/>
        starting := false;<br/>
        if parity = even then<br/>
        begin<br/>
        while (input^ <> '.') and (input^ <> ' ') do<br/>
        begin write(input^); get(input); end;<br/>
        parity := odd<br/>
        end<br/>
        else<br/>
        begin<br/>
        oddmagic;<br/>
        parity := even<br/>
        end<br/>
        end<br/>
        end.<br/>
      </code>
      <hr/>
      <p>
        In <a href="CommonLisp.html">CommonLisp</a>
      </p>
      <code>
        (defvar *finished* nil)<br/>
      </code>
      <code>
        (defun chomp ()<br/>
        (cond ((char= (peek-char) #\Space)<br/>
        (read-char)<br/>
        (chomp))))<br/>
      </code>
      <code>
        (defun getc ()<br/>
        (let ((c (read-char)))<br/>
        (case c<br/>
        (#\. (setf *finished* t))<br/>
        (#\  (chomp)))<br/>
        c))<br/>
      </code>
      <code>
        (defun even (s)<br/>
        (if (char/= (write-char (getc) s) #\Space #\.)<br/>
        (even s)))<br/>
      </code>
      <code>
        (defun odd ()<br/>
        (let ((str (reverse (with-output-to-string (s)<br/>
        (even s)))))<br/>
        (loop for c across (subseq str 1)<br/>
        do (write-char c))<br/>
        (write-char (elt str 0))))<br/>
      </code>
      <code>
        (defun main ()<br/>
        (let ((foo #'(lambda () (even *standard-output*)))<br/>
        (bar #'odd))<br/>
        (loop do (progn<br/>
        (funcall foo)<br/>
        (if *finished* (return))<br/>
        (rotatef foo bar)))))<br/>
      </code>
      <code>
        (main)<br/>
      </code>
      <hr/>
      <p>
        The <a href="JavaLanguage.html">JavaLanguage</a> versions above all seem unnecessarily verbose.  The <a href="CeeLanguage.html">CeeLanguage</a> version at the top seems
        straightforward enough, and it can easily be adapted to Java with some helper methods and type casting:
      </p>
      <code>
        public class <a href="OddWordProblem.html">OddWordProblem</a><br/>
        {<br/>
        static final int EOF = -1;//returned by in.read()<br/>
        static final int NIL = -2;//to be distinct from EOF<br/>
        int buffer = NIL;<br/>
      </code>
      <code>
        void putchar( char ch ) { System.out.print( ch ); }<br/>
        int getchar()<br/>
        {<br/>
        //hack to avoid having "throws IOException" on *EVERY* other method<br/>
        try { return System.in.read(); }<br/>
        catch ( java.io.IOException e ) { throw new <a href="RuntimeException.html">RuntimeException</a>( e ); }<br/>
        }<br/>
      </code>
      <code>
        int peek() { if ( buffer == NIL ) buffer = getchar(); return buffer; }<br/>
        char pop() { int result = peek(); buffer = NIL; return (char) result; }<br/>
        boolean alpha() { return peek() >= 0 && Character.isLetter( (char) peek() ); }<br/>
        boolean space() { return peek() >= 0 && Character.isWhitespace( (char) peek() ); }<br/>
        void chkend() { if(peek() == '.') { System.out.println(".\n"); System.exit(0); } }<br/>
      </code>
      <code>
        void spaces() { spaces(true); }<br/>
        void spaces(boolean f) { while(space()) pop(); chkend(); if(f) putchar(' '); }<br/>
        void even()     { while(alpha()) putchar(pop()); }<br/>
        void odd()     { if(alpha()) { int c = pop(); odd(); putchar((char)c); } }<br/>
      </code>
      <code>
        int main() { spaces(false); for(;;) { even(); spaces(); odd(); spaces(); } }<br/>
      </code>
      <code>
        public static void main( String[] args )<br/>
        {<br/>
        new <a href="OddWordProblem.html">OddWordProblem</a>().main();<br/>
        }<br/>
        }<br/>
      </code>
      <hr/>
      <code>
        """<a href="OddWordProblem.html">OddWordProblem</a> solution in <a href="PythonLanguage.html">PythonLanguage</a> using <a href="GeneratorsInPython.html">GeneratorsInPython</a>.<br/>
      </code>
      <code>
        >>> def test_oddword(instr):<br/>
        ...     import sys, StringIO, oddword<br/>
        ...     infile = StringIO.StringIO(instr)<br/>
        ...     def getchar(): return infile.read(1)<br/>
        ...     def putchar(c): sys.stdout.write(c)<br/>
        ...     oddword.oddword(getchar, putchar)<br/>
        ...<br/>
        >>> test_oddword('whats the matter with kansas.')<br/>
        whats eht matter htiw kansas.<br/>
        """<br/>
        class Error(StandardError): pass<br/>
        WB, END = '!', '.'<br/>
        def getletter(getc):<br/>
        c = getc()<br/>
        if not c.isalpha(): <br/>
        raise Error("First symbol must be a letter: `%s'" % c)<br/>
        space = False<br/>
        while True:<br/>
        if c.isspace(): space = True<br/>
        elif c == END: break # exit generator<br/>
        elif c.isalpha():<br/>
        if space:<br/>
        space = False<br/>
        yield WB # word boundary<br/>
        yield c<br/>
        else: raise Error("Invalid symbol: `%s'" % c) # EOF here too<br/>
        c = getc()<br/>
      </code>
      <code>
        def oddword(getc,putc):<br/>
        def printword(word, reverse, ws = ' '):<br/>
        if reverse: word.reverse()<br/>
        for c in word: putc(c)<br/>
        putc(ws)<br/>
      </code>
      <code>
        word = []; reverse = False<br/>
        for char in getletter(getc):<br/>
        if char == WB: # word boundary<br/>
        printword(word, reverse) # print previous word<br/>
        word = []; reverse = not reverse # begin new word<br/>
        else:<br/>
        if len(word) == 20: raise Error('Max word length exceeded')<br/>
        word.append(char)<br/>
        printword(word,reverse, '.') # print last word<br/>
      </code>
      <code>
        def testdoc():<br/>
        import doctest<br/>
        return doctest.testmod()   <br/>
      </code>
      <code>
        if __name__=='__main__':<br/>
        if testdoc()[0] == 0: print 'OK'<br/>
      </code>
      <p>
        I'm a newbie in <a href="PythonLanguage.html">PythonLanguage</a>, so the above code may be not a Pythonic one.
      </p>
      <hr/>
      <p>
        Here is a <a href="PascalLanguage.html">PascalLanguage</a> translation of the solution that <a href="EwDijkstra.html">EwDijkstra</a> published in his essay "Notes on Structured Programming" in the book <em>Structured Programming</em>.  It is interesting to note that:
      </p>
      <ul>
        <li>
           This solution was written by one of Dijkstra's classes, not by Dijkstra himself.
        </li>
        <li>
           In the book, this solution is developed over four pages as an example of how a group of people designed a program.
        </li>
        <li>
           It does not gracefully handle spaces at the beginning of the input.
        </li>
        <li>
           It could contain a buffer overflow bug if the implementation doesn't do bounds checking.
        </li>
      </ul>
      <code>
        program oddword(input, output);<br/>
      </code>
      <code>
        var forward : boolean;<br/>
        x : char;<br/>
        c : array [ 1 .. 20 ] of char;<br/>
        l, k, inc, term : integer;<br/>
      </code>
      <code>
        begin<br/>
        forward := true; read(x);<br/>
        repeat<br/>
        l := 0;<br/>
        repeat l := l + 1; c[l] := x; read(x) until (x = ' ') or ( x = '.');<br/>
        while x = ' ' do read(x);<br/>
        if forward then begin k := 0; inc := +1; term := l end<br/>
        else begin k := l + 1; inc := -1; term := 1 end;<br/>
        repeat k := k + inc; write(c[k]) until k = term;<br/>
        if x = '.' then write('.') else write(' ');<br/>
        forward := not forward<br/>
        until x = '.';<br/>
        writeln<br/>
        end.<br/>
      </code>
      <hr/>
      <p>
        Here's one in <a href="DelphiLanguage.html">DelphiLanguage</a> by <a href="JosephStyons.html">JosephStyons</a>:
      </p>
      <code>
        function ReverseOddWords(s : string): string;<br/>
        function StrReverse(s : string) : string;<br/>
        var i : integer;<br/>
        begin<br/>
        Result := <em>;</em><br/>
        for i := Length(s) downto 1 do<br/>
        Result := Result + s[i];<br/>
        end;<br/>
        var i                 : integer;<br/>
        oddword           : boolean;<br/>
        lastCharWasASpace : boolean;<br/>
        currentWord       : string;<br/>
        begin<br/>
        oddword := True;  //first word is odd<br/>
        lastCharWasASpace := False;<br/>
        currentWord := <em>;</em><br/>
      </code>
      <code>
        for i := 1 to Length(s) do begin  //for each letter...<br/>
        if ((s[i] = ' ') and not(lastCharWasASpace)) or (s[i]='.') then begin<br/>
        if oddword then<br/>
        Result := Result + StrReverse(currentWord) + s[i]<br/>
        else<br/>
        Result := Result + currentWord + s[i];<br/>
        currentWord := <em>;</em><br/>
        oddword := not(oddword)<br/>
        end<br/>
        else if s[i] <> ' ' then<br/>
        currentWord := currentWord + s[i];<br/>
        lastCharWasASpace := ' '=s[i];  //use this since we can't look forward or back<br/>
        end;<br/>
        end;<br/>
      </code>
      <hr/>
      <p>
        Another solution in common lisp... but it's not very functional programming
      </p>
      <code>
        (defun kill-spaces ()<br/>
        "Eliminates spaces from input and returns the next caracter to be read."<br/>
        (peek-char t))           ;nice feature of peek-char... removes every whitespace it finds<br/>
      </code>
      <code>
        (defun print-word (word)<br/>
        "Prints a list of characters."<br/>
        (dolist (c word) (write-char c))<br/>
      </code>
      <code>
        (defun odd-word ()<br/>
        "Reads a word and prints it reversed"<br/>
        (do ((c (peek-char) (peek-char))		; each iteration pushes a char in the list<br/>
        (word nil))<br/>
        ((or (char= c #\.)<br/>
        (char= c #\Space)) (print-word word))<br/>
        (push (read-char) word)))<br/>
      </code>
      <code>
        (defun even-word ()<br/>
        "Reads a word and prints it to output"<br/>
        (do ((c (peek-char) (peek-char)))<br/>
        ((or (char= c #\.)<br/>
        (char= c #\Space)))<br/>
        (write-char (read-char))))<br/>
      </code>
      <code>
        (defun odd-word-magic ()<br/>
        (do ((next-c (kill-spaces) (kill-spaces))        ; next-c is always the first char of a word or a "."<br/>
        (word-count 0 (1+ word-count)))<br/>
        ((char= next-c #\.) (write-char (read-char)))<br/>
        (if (not (zerop word-count)) ; if its the first word, no space<br/>
        (write-char #\Space))<br/>
        (if (oddp word-count)<br/>
        (odd-word)<br/>
        (even-word))))<br/>
      </code>
      <hr/>
      <p>
        Better Haskell version (ignoring the character-at-a-time requirement):
      </p>
      <code>
        import Data.List<br/>
      </code>
      <code>
        enumerate = zip $ cycle [0,1]<br/>
      </code>
      <code>
        oddwords x = foldl' add "" (enumerate ws) ++ "."<br/>
        where add "" (_,t) = t<br/>
        add s (0, t) = s ++ " " ++ t<br/>
        add s (1, t) = s ++ " " ++ reverse t<br/>
        ws = words $ takeWhile (/= '.') x<br/>
      </code>
      <hr/>
      <p>
        Somewhat obfuscated C++ version:
      </p>
      <code>
        #include<iostream><br/>
        #include<stack><br/>
        #define _ cout<<<br/>
        #define ___ cin<br/>
        int main( ){using namespace std;char _l,l_;<br/>
        bool __=1,l=0;stack<char>_l_ ;while(!l){_l=<br/>
        ___.get(); switch( _l){case'.':l=1;case' ':<br/>
        __=!__;while(!_l_.empty()){_ _l_.top();_l_.<br/>
        pop();}_ _l;while(___.peek()==' ') {l_=___.<br/>
        get();_' ';}break; default:if(__) {_l_.push<br/>
        (_l);}else{_ _l;}}}_ endl;}<br/>
      </code>
      <hr/>
      <p>
        Scala version in the style of the "Better Haskell version" (ignoring the character-at-a-time requirement):
      </p>
      <code>
        def cycle[T](seq: Seq[T]) = Stream.continually(seq).flatten     //  define cycle as per Haskell as Scala does not define it<br/>
      </code>
      <code>
        def enumerate[T](words: Seq[T]) = cycle (List(0,1)) zip words  <br/>
      </code>
      <code>
        def oddwords(input : String) = {<br/>
      </code>
      <code>
        def add(stringSoFar : String, wordAndOddIndicator : (Int,String)) = <br/>
        (stringSoFar, wordAndOddIndicator) match {<br/>
        case ("", (_, t)) => t<br/>
        case (s, (0, t)) => s + " " + t<br/>
        case (s, (1, t)) => s + " " + t.reverse<br/>
        }<br/>
      </code>
      <code>
        def ws(words : Seq[String]) = words takeWhile ("." !=)<br/>
      </code>
      <code>
        // split the string into words up to the first ".", first making sure that "kansas." becomes "kansas ."<br/>
        val words =  input.replaceFirst("""\.""", " .").split(" +").toList<br/>
      </code>
      <code>
        enumerate(ws(words)).foldLeft("")(add) + "."<br/>
        }   <br/>
      </code>
      <hr/>
      <p>
        Simple Scala version  (ignoring the character-at-a-time requirement):
      </p>
      <code>
        def oddwords(input : String) = {<br/>
      </code>
      <code>
        def reverseOddWords(is: List[String]) : List[String] = {<br/>
        is match {<br/>
        case a :: b :: xs => a :: b.reverse :: reverseOddWords(xs)<br/>
        case a :: xs => a :: reverseOddWords(xs)<br/>
        case xs => xs<br/>
        }<br/>
        }<br/>
      </code>
      <code>
        // split the string into words,  first making sure that "kansas." always becomes "kansas ."<br/>
        val words =  input.replaceFirst("""\.""", " .").split(" +").toList takeWhile("."!=)<br/>
      </code>
      <code>
        reverseOddWords(words).mkString(" ") + "."<br/>
        } <br/>
      </code>
      <hr/>
      <p>
        Implementation in <a href="BrainfuckLanguage.html">BrainfuckLanguage</a> (follows character at a time requirement):
      </p>
      <p>
        +>+<[
      </p>
      <code>
        >>>+[,[>+>+<<-]>>[<<+>>-]<br/>
        ++++[<-------->-]<br/>
        +<[>-<[-]]><br/>
        [-<<[<]<br/>
        +<[>->[.>]<[[-]<]<-]<br/>
        >[>[>]<-[[<]>+[>]<-]<[.[-]<]+>]<<br/>
        >>>]<br/>
        <<[>+>+<<-]>>[<<+>>-]<br/>
        ++[<----------------------->-]<br/>
        +<[>-<[-]]><br/>
        [-<<[<]<br/>
        +<[>->[.>]<[[-]<]<-]<br/>
        >[>[>]<-[[<]>+[>]<-]<[.[-]<]>]<br/>
        <<-->]<br/>
      </code>
      <p>
        <+]]
      </p>
      <hr/>
      <p>
        <a href="CategoryInManyProgrammingLanguages.html">CategoryInManyProgrammingLanguages</a>
      </p>
    </div>
  </body>
</html>