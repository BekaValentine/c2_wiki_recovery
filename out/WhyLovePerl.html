<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Why Love Perl
      </h1>
      <p>
        See <a href="WhyHatePerl.html">WhyHatePerl</a> for opposing viewpoints.
      </p>
      <hr/>
      <ul>
        <li>
           There are different Perl languages for different needs. Perl 5 is the widely used standard Perl and is well supported and understood. Perl 6, which is a different but closely related language to Perl 5, offers a new and different way of approaching programming problems for programmers and language designers.
        </li>
        <li>
           Perl 5 releases are predictable. Perl 5 is actively developed by a team of volunteers who make releases on published schedule. Development releases occur every month. Stable releases occur once a year in April.
        </li>
        <li>
           Perl 5's version numbering system is easy to understand. All release numbers start with "5.". The second number represents the major version number and the third is the minor release number. A stable release has an even major number while a development release has an odd number.
        </li>
        <li>
           Perl 5 has a published support schedule. Each major release of Perl 5 is supported for two years, except for critical security fixes, which are supported for three years.
        </li>
        <li>
           It's a <a href="MultiParadigmLanguage.html">MultiParadigmLanguage</a> -- <a href="CeeLanguage.html">CeeLanguage</a> programmers can write C-style programs, <a href="UnixShell.html">UnixShell</a> hackers can write shell scripts, and even <a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a> and <a href="LispLanguage.html">LispLanguage</a> lovers will find much that is familiar. 
        </li>
        <li>
           Built-in <a href="InternalIteration.html">InternalIteration</a> functions that <a href="JavaLanguage.html">JavaLanguage</a> makes incredibly complicated: detect, iterate/apply, split, join -- <a href="JeffBay.html">JeffBay</a> <em>grep, map, foreach</em>
        </li>
        <li>
           Appropriately simple postfix operators. You can say "do_something() if cond1 == cond2;", but you can't express arbitrarily complicated expressions that way (it would rapidly become unclear). 
        </li>
        <li>
           Big functionality in small amounts of code
        </li>
        <li>
           <a href="AssociativeArray.html">AssociativeArray</a>s (maps, to you <a href="CeePlusPlus.html">CeePlusPlus</a> folks) are <a href="FirstClass.html">FirstClass</a> objects, as are lists (told you Lispers would like it!) <em>Unfortunately, there's a lot more to it than that, from the perspective of a lisp programmer. See </em><a href="WhyWeLoveLisp.html">WhyWeLoveLisp</a>.<em></em>
        </li>
        <li>
           Built-in <a href="RegularExpression.html">RegularExpression</a> support makes string handling extremely easy. This is especially nice when you want to automate <a href="CodeGeneration.html">CodeGeneration</a>. -- <a href="BillyChambless.html">BillyChambless</a> 
        </li>
        <li>
           <a href="ThereIsNothingPerlCannotDo.html">ThereIsNothingPerlCannotDo</a>!
        </li>
        <li>
           <a href="PerlGolf.html">PerlGolf</a>
        </li>
        <li>
           <a href="PerlPoetry.html">PerlPoetry</a> -- honk() if $you->love('Perl');
        </li>
        <li>
           <a href="ContextSensitivity.html">ContextSensitivity</a>
        </li>
        <li>
           A Motley Crew of Developers -- <a href="http://www.pm.org/">http://www.pm.org/</a> -- <a href="JohnBeppu.html">JohnBeppu</a>
        </li>
        <li>
           The PerlCommunity. It's a way of life, a whole culture based upon just a few facts and a great degree of freedom. Perl6 is being designed by the PerlCommunity, although we asked (well, some did) <a href="LarryWall.html">LarryWall</a> to keep control of things... after all, he's the father of the beast, and we love it to be Perl... -- <a href="DavidDeLis.html">DavidDeLis</a>
        </li>
        <li>
           <a href="LexicalClosure.html">LexicalClosure</a>s. -- <a href="SethGordon.html">SethGordon</a>
        </li>
        <li>
           What takes 100 lines in other languages might take 10 in Perl
        </li>
        <li>
           Perl lets you think like <strong>you</strong> instead of trying to smash your brain into the shape a computer wants it to be.
        </li>
        <li>
           <a href="PerlTestingTools.html">PerlTestingTools</a>
        </li>
        <li>
           Easy to <a href="DoTheSimplestThingThatCouldPossiblyWork.html">DoTheSimplestThingThatCouldPossiblyWork</a> 
        </li>
        <li>
           <a href="TheCpan.html">TheCpan</a>: the best code repository anywhere ... -- <a href="DaveTauzell.html">DaveTauzell</a>
        </li>
        <li>
           It doesn't get in the way or try to tell you what's "good" for you.
        </li>
        <li>
           One of the most interesting descriptions of Perl I've ever read is that it's a language where you can easily "make braindumps executable" (although that statement was put into perspective when I learnt <a href="RubyLanguage.html">RubyLanguage</a>) (moved from PerlProsAndCons)
        </li>
        <li>
           You can do what you want to do and you can do it right away!! Perl should be taught in <a href="HighSchool.html">HighSchool</a>. -- PerlPathi
        </li>
        <li>
           Perl is just a bunch of useful unix libraries with a grammar thown over them and made portable by people fascinated with synergy. CPAN, on the other hand, is a remarkable social demonstration enabled by that synergy. -- <a href="WardCunningham.html">WardCunningham</a>
        </li>
      </ul>
      <hr/>
      <ul>
        <li>
           What takes 100 lines in other languages might take 10 in Perl (could we have a simple example?) -- <a href="DonaldNoyes.html">DonaldNoyes</a>
        </li>
      </ul>
      <p>
        Implement a basic version of uniq. I.e., write a program that goes through its input files and prints out the unique lines it sees. Try to make it perform reasonably well. In Perl that is short enough that you can write it on the <a href="CommandLine.html">CommandLine</a>:
      </p>
      <code>
        perl -ne 'print if 1 == ++$s{$_}' input files here<br/>
      </code>
      <p>
        In most other languages this program would be substantially longer.
      </p>
      <p>
        How would it look if instead of ' input file here, you would make it a directory and all its subdirectories? Would this be possible? -- <a href="DonaldNoyes.html">DonaldNoyes</a>
      </p>
      <p>
        By and large, the savings with Perl are due to comparing a <a href="ScriptingLanguage.html">ScriptingLanguage</a> with non-scripting languages like <a href="JavaLanguage.html">JavaLanguage</a> and <a href="CeeLanguage.html">CeeLanguage</a>. Perl does not have such a huge advantage against other scripting languages. (Particularly <a href="RubyLanguage.html">RubyLanguage</a>.) -- <a href="BenTilly.html">BenTilly</a>
      </p>
      <p>
        perhaps UniqInManyProgrammingLanguages to test both the original claim and this counter-claim?
      </p>
      <p>
        I know this sort of thing gives perl a bad name, but we can golf that script down to
      </p>
      <code>
        perl -pe '$s{$_}++&&undef$_'<br/>
      </code>
      <p>
        :-). My personal preference, however, would be
      </p>
      <code>
        perl -ne 'print unless $s{$_}++'<br/>
      </code>
      <p>
        -- <a href="DaveWhipp.html">DaveWhipp</a>
      </p>
      <p>
        Incidentally, the uniq replacements above don't actually produce the same answers as the real uniq(1) command (the real uniq(1) requires the input to be sorted)
        try with the input file
      </p>
      <code>
        1<br/>
        2<br/>
        1<br/>
      </code>
      <p>
        The reader is invited to draw his own conclusions on what if anything this says about the perl mindset ;-) -- <a href="DanBarlow.html">DanBarlow</a>
      </p>
      <p>
        <em>That brevity is more important than correctness? ;-)</em>
      </p>
      <p>
        That it's close to the <a href="ExtremeProgramming.html">ExtremeProgramming</a> mindset? In that the code solved the stated problem, i.e., 'Implement a basic version of uniq.', instead of some other problem.
      </p>
      <p>
        <em>But it's not in Basic, it's in Perl!</em> <ahem> <em>But seriously, folks, if it doesn't meet the requirements, what good is it? Brevity is all well and fine, but correctness is a lot more important to my clients, methinks. Particularly when you look at the mess Perl makes of the argument set - it's composed entirely of Perl-unique descriptors. Wonderful to a Perl guy; a complete and impenetrable mystery to anybody else.</em>
      </p>
      <p>
        <em>Just as in the futile arguing over the loverly characteristics of </em><a href="ExtensibleMarkupLanguage.html">ExtensibleMarkupLanguage</a> we are once more focusing on brevity and ignoring clarity. Why are we still doing this? "Doctor, it hurts when I do this." "Well, don't do that."<em></em>
      </p>
      <p>
        For what it's worth, it's easy to match the functionality of uniq more closely:
      </p>
      <code>
        perl -ne 'print unless $s eq $_; $s = $_'<br/>
      </code>
      <p>
        <em>That performs much more reasonably (memory-wise) than the first example. The first example will chew up memory on large files. You'd probably use the DB_File module or somesuch if you wanted the exact functionality of the first example.</em>
      </p>
      <hr/>
      <ul>
        <li>
           <a href="AssociativeArray.html">AssociativeArray</a>s (maps, to you <a href="CeePlusPlus.html">CeePlusPlus</a> folks) are <a href="FirstClass.html">FirstClass</a> objects, as are lists (told you Lispers would like it!)
        </li>
      </ul>
      <p>
        Let's try that with slightly different words. "Perl has a <a href="DataStructure.html">DataStructure</a> that it calls a list, which exposes an approximate subset of the functionality in a real <a href="LinkedList.html">LinkedList</a>". As a <a href="LispLanguage.html">LispLanguage</a> programmer I really don't find this any more exciting than the news that it supports subroutines would be to a <a href="CeeLanguage.html">CeeLanguage</a> programmer. (<a href="AwkLanguage.html">AwkLanguage</a> programmers, however, are thrilled to have both.)
      </p>
      <p>
        How about Perl shares six of the seven features of Lisp listed in the "What makes Lisp Different?" section of "Paradigms of Artificial Intelligence Programming" (<a href="http://hop.perl.plover.com/preface.html).">http://hop.perl.plover.com/preface.html).</a>
      </p>
      <p>
        <em>The thing to keep in mind about Lisp, however, isn't just that lists are </em><a href="FirstClass.html">FirstClass</a> objects--it goes much deeper than that.  In Lisp, programs are written <strong>as</strong> lists, and programs are literally just AST trees.  This, in turn, makes it very easy to alter Lisp to make it fit the program domain.  Languages that have syntax have trouble with this.  Perl has <strong>incredibly dense and complicated</strong> syntax, so it's at the opposite end of the spectrum compared to Lisp.  Because of this, it is highly unlikely that Perl will cross the threshold to become a Lisp.  --Alpheus<em></em>
      </p>
      <hr/>
      <p>
        I just saw <a href="http://cpan.uwinnipeg.ca/dist/Filter-Simple">http://cpan.uwinnipeg.ca/dist/Filter-Simple</a> which is really impressive. The lispiest thing I've seen in perl.
      </p>
      <hr/>
      <p>
        Perl isn't a language designed to be placed in a museum and looked upon as a thing of beauty. It isn't designed to follow a particular decades-old aesthetic of neatness, one that's progressed through languages like <a href="PascalLanguage.html">PascalLanguage</a> and and <a href="ModulaTwo.html">ModulaTwo</a> and <a href="EiffelLanguage.html">EiffelLanguage</a>. A classic tenet of such neatness is that the core language should be minimal, and everything you need is in a library. As a purist, that agrees with me. But at the same time, a language is used to get things done. Having flat, immediate access to a large number of useful features and coding styles is what makes Perl useful. For example, there's no need to bring in a <a href="RegularExpression.html">RegularExpression</a> library, then have to precompile each expression, referencing it by a handle. There are also little, catchy constructs that cover common situations. "total++" in <a href="CeeLanguage.html">CeeLanguage</a> isn't cryptic; it's clean and clear and it's shorter than "total = total + 1". You get used to the conciseness of idioms like:
      </p>
      <code>
        while (<>) {<br/>
        print if /START/ .. /STOP/;<br/>
        }<br/>
      </code>
      <p>
        to print all the lines from START to STOP in a file, inclusive.
      </p>
      <p>
        There's also a good use implicit information in Perl. You don't need to call a function to get the length of a list. You use a list in a scalar context. The information is already there, and using it leads to concise and free-flowing programs:
      </p>
      <code>
        $test = "a2b4c6d8";<br/>
        @list = ($test =~ /(.)/g);  # for a less general case use @list = split //, $test;<br/>
        %hash = @list;<br/>
      </code>
      <p>
        This code builds a hash of (a,2),(b,4),(c,6),(d,8) from the $test string.
      </p>
      <p>
        Perl isn't perfect. It falls down hard when it comes to nested <a href="DataStructure.html">DataStructure</a>s, even passing such structures to subroutines. But for a good chunk of everyday work, Perl is perfect.
      </p>
      <p>
        -- <a href="JamesHague.html">JamesHague</a>
      </p>
      <ul>
        <li>
           Using nested <a href="DataStructure.html">DataStructure</a>s, and passing them to subroutines by reference is a trivial task in Perl. What makes you say that Perl "falls down hard" when it comes to using them? -- JustCurious
        </li>
        <li>
           Compare nested data structures in <a href="PerlLanguage.html">PerlLanguage</a> to <a href="PythonLanguage.html">PythonLanguage</a>, for example.  In Python, all data structures can be nested right out of the box.  In Perl, there is separate syntax for flat structures and references to structures.  I agree that it's not as horrible as it used to, however.
        </li>
      </ul>
      <hr/>
      <p>
        It runs on just about any platform including Windows, Macs, VMS, most Unices (I am hesitant to say all but it has been on every Unix system I have seen) and <a href="MainFrame.html">MainFrame</a>s. Can you say 'Portable'?
      </p>
      <hr/>
      <p>
        I think that
      </p>
      <ul>
        <li>
           It doesn't get in the way or try to tell you what's "good" for you. 
        </li>
        <li>
           Perl lets you think like <strong>you</strong> instead of trying to smash your brain into the shape a computer wants it to be
        </li>
        <li>
           You can do what you want to do and you can do it right away!! Perl should be taught in <a href="HighSchool.html">HighSchool</a>. -- PerlPathi
        </li>
      </ul>
      <p>
        should be refactored in just one sentence. 
        <em>We could take a dig at the </em><a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a> crowd and say that <a href="PerlLanguage.html">PerlLanguage</a> is an accurate model of how people think :)<em></em>
      </p>
      <hr/>
      <p>
        Metaprogramming - perl has a lot of little, somewhat orthogonal tools that can play different parts in this.
      </p>
      <ul>
        <li>
           UNIVERSAL and AUTOLOAD
        </li>
        <li>
           Variable (including subroutine) attributes
        </li>
        <li>
           Symbol table access at runtime
        </li>
        <li>
           The different pieces of perl <a href="ObjectOrientation.html">ObjectOrientation</a> (packages, bless, @ISA)
        </li>
        <li>
           <a href="FunctionalProgramming.html">FunctionalProgramming</a> tools
        </li>
        <li>
           eval
        </li>
      </ul>
      <p>
        Try running through the <a href="CatalystFramework.html">CatalystFramework</a> tutorial, which uses DBIx::Class::Schema. Several of these are at work there, either visibly or behind the scenes.
      </p>
      <hr/>
      <p>
        <a href="CategoryPerl.html">CategoryPerl</a>
      </p>
    </div>
  </body>
</html>