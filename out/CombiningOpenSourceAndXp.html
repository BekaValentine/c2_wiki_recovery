<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Combining Open Source And Xp
      </h1>
      <p>
        The idea is to develop a site similar to <a href="http://www.SourceForge.org">http://www.SourceForge.org</a> or <a href="http://www.CoSource.com">http://www.CoSource.com</a> where, however, where the XP practices provide controlling of the <a href="OpenSource.html">OpenSource</a> development approach. The problem for a potential <a href="OpenSource.html">OpenSource</a> customer is that if they want to pay money to have some product developed by <a href="OpenSource.html">OpenSource</a> developers then they also want a guarantee that the product will be completed on time and within budget and to the quality they require. However, money should not become the sole motivating factor, this risks turning an <a href="OpenSource.html">OpenSource</a> project into a <a href="ClosedSource.html">ClosedSource</a> project.
      </p>
      <p>
        CoSource does this but doesn't have any means for the customer to check whether progress is being made (although they define a third party to judge when the project is completed). And this is where XP comes in: through <a href="UserStories.html">UserStories</a>, <a href="UnitTest.html">UnitTest</a>s and <a href="ContinuousIntegration.html">ContinuousIntegration</a> the customer can always check progress. Plus after each 2-4 week iteration they can terminate the project and only pay for the work done to that point.
      </p>
      <p>
        XP would not be enforced, can't anyway, but the intention is to offer tools which allow the customer and developers to a) communicate and share ideas, b) allow the customer to see whether progress is being made and c) both sides to check the quality. Tools should not be forced upon projects, however, customers would have the right to define which tools should be used for a project (after all they sponsor the projects). However, to a certain extent, a project should be given time to find it's own tools of choice.
      </p>
      <p>
        Benefits for customers:
      </p>
      <ol>
        <li>
           Many potential customers can combine forces and allow a product to be developed spreading the cost of development. They also don't need to employ their own developers.
        </li>
      </ol>
      <ol>
        <li>
           The quality should also be a draw card. As a customer, you can potentially get the best developers to work on your problem, plus you can check the code using <a href="UnitTest.html">UnitTest</a>s and user stories to ensure you're getting what you want.
        </li>
      </ol>
      <ol>
        <li>
           Plus a customer (like the developers) have the right to stop the project after each 2(or 4) week development cycle. The intention is that the customer monitors (i.e. onsite customer) the progress of the project.
        </li>
      </ol>
      <p>
        Benefits for developers:
      </p>
      <ol>
        <li>
           Getting to work from home and when they want. There are no fixed office hours and the developer can work when they want. Of course, the drawback is that paid-hours spent surfing the net are no longer paid ;-)
        </li>
      </ol>
      <ol>
        <li>
           Getting to work on projects that interest you, and getting to work on as many or as few as you like. Having no direct employer allows you the freedom to chose which project you would like to work on.
        </li>
      </ol>
      <p>
        Potential tools to implement the XP practices:
      </p>
      <p>
        Refactoring: supported through tools such as JRefactory and a tool which produced statistics on how much needs refactoring (pipe dream?).
      </p>
      <p>
        Unit and Acceptance Tests: xUnit and perhaps limited automatic generation from user stories - a new project role: User-Story-to-Acceptance-Test Translator!
      </p>
      <p>
        <a href="UserStories.html">UserStories</a>: Wiki like tool for <a href="UserStory.html">UserStory</a> entry/tracking.
      </p>
      <dl>
        <dt> </dt>
        <dd><em>How about </em><a href="XpPlanIt.html">XpPlanIt</a> for this? -<a href="DierkKoenig.html">DierkKoenig</a> or Storm (<a href="http://xpstorm.sourceforge.net/)''">http://xpstorm.sourceforge.net/)''</a></dd>
      </dl>
      <p>
        Pair Programming:
      </p>
      <ul>
        <li>
           kibitz (<a href="http://dev.scriptics.com/man/expect5.31/kibitz.1.html)">http://dev.scriptics.com/man/expect5.31/kibitz.1.html)</a> like tool or some sort of web based tool
        </li>
        <li>
           VNC: <a href="http://www.uk.research.att.com/vnc/">http://www.uk.research.att.com/vnc/</a>
        </li>
        <li>
           <a href="NetMeeting.html">NetMeeting</a> (even if it's from MS)
        </li>
        <li>
           <a href="SkyPe.html">SkyPe</a>
        </li>
      </ul>
      <p>
        Release Planning [Game]: Extension to the tool storing <a href="UserStories.html">UserStories</a> would allow the entry of estimation from developers and breaking down of <a href="UserStories.html">UserStories</a> into smaller ones.
      </p>
      <p>
        Continuous Integration: CVS + automatic <a href="UnitTest.html">UnitTest</a> execution, i.e. check in fails if <a href="UnitTest.html">UnitTest</a>s don't run at 100%. Each project would also have two branches (at least) one release quality and one development. The only person who would be allowed to move code from development to release would be the head developer. Only code that executes <a href="UnitTest.html">UnitTest</a>s to 100% can be checked into the development branch, but all developers can check in to that branch. This comes from OS, where a single developer is responsible for maintaining the main codebase.
      </p>
      <p>
        Iteration Planning: Something like Wiki to provide allow developers to enter their engineering tasks, and from there an integrated calendar application to handle the planning.
      </p>
      <p>
        Onsite Customer: replaced by allowing the customer CVS access and access to user stories and acceptance tests.
      </p>
      <p>
        BTW is it just me or are there a very limited number of tools supporting the XP development approach??? This gives me an idea: who would be interested in financially supporting or being a developer as part of an OS project to develop some XP tools?
      </p>
      <hr/>
      <p>
        <strong></strong><a href="SponsoredOpenSource.html">SponsoredOpenSource</a>:<strong></strong>
      </p>
      <p>
        Finally how can this all make money? That is, how do the developers get paid and when & how does the customer pay.
      </p>
      <p>
        Charging for User Stories:
        I wonder if there is a way customers could be charged per User Story. As you suggested, someone would need to work with the customer to write the stories. I guess the focus would be more on growing existing software, than on making new software. Teams of developers could bid on individual User Stories, or on collections of them. This would provide an approximation of the Planning Game, since the developers would set the price for each story, then let the customer decide whether to implement it, break it into separate stories, etc.
      </p>
      <p>
        But:
        I think charging the customer for User Stories will limit the number of user stories and therefore the description of the problem domain. A better strategy might be that customers only pay for those user stories that were implemented. This would imply that the customer would not pay at the end of the project, but after each iteration, which is probably a good thing.
      </p>
      <p>
        Basically each user story becomes a mini-project with it's own developers, time schedule and price.
      </p>
      <p>
        Payment for test success:
        Another strategy, although idealistic, would be to assume that all requirements can be recorded as automated tests. Given that assumption, the customers would write User Stories and tests. No money would change hands until a group of developers deliver software that passes all the tests. The first group to pass the tests wins. In this scenario, the customer would set the price. If the price was too high, nobody would work on it. So, if the feature was important for the customer, or urgently needed by the customer, they would naturally offer more money. I think www.CoSource.com works something like this, except without the tests.
      </p>
      <p>
        Payment based on rating:
        Also, it seems like some kind of code quality control would have to be enforced. Without this, a developer might put in unmaintainable code, just to get the next paycheck. Maybe some kind of developer rating system would help. Something like the <a href="SlashDot.html">SlashDot</a> moderation system. If somebody makes bad code, their rating goes down, and customers would be able to see these ratings before committing to work.
      </p>
      <p>
        Sure - my basic idea was to have a group of developers work on a project, after the project is completed, each developer rates all others based on their contributions and developers are paid accordingly. Of course, this has the problem that developers can "gang up" and award each other good ratings and thereby clean up. Therefore, you would need some sort of controlling for checking how many postings and check-ins each developer did. Or lines-of-code they wrote, or lines-of-doco ... etc.
      </p>
      <p>
        Of course there are always problems:
      </p>
      <p>
        Also, it seems like some kind of code quality control would have to be enforced. Without this, a developer might put in unmaintainable code, just to get the next paycheck. Maybe some kind of developer rating system would help. Something like the <a href="SlashDot.html">SlashDot</a> moderation system. If somebody makes bad code, their rating goes down, and customers would be able to see these ratings before committing to work.
      </p>
      <p>
        Refactoring could be another problem. If developers become too focused on delivering the next small chunk, then they might not want to make the investment to improve the internal code quality.
      </p>
      <p>
        -- <a href="GerritRiessen.html">GerritRiessen</a>
      </p>
      <hr/>
      <p>
        Interesting ideas!
      </p>
      <p>
        Open source (I thought) usually doesn't have a paying customer? Much of the discussion above is about <a href="SponsoredOpenSource.html">SponsoredOpenSource</a>, i.e. where a customer IS paying, rather than discussing Xp with <a href="OpenSource.html">OpenSource</a> per se.
      </p>
      <p>
        <em>Normally yes: an </em><a href="OpenSource.html">OpenSource</a> project does not have a sponsor, but the intention is to give developers the possibility of earning money (admittedly not as much as a full time job) working their own hours and giving them a freedom of choice on what they work.<em></em>
      </p>
      <p>
        <em>Also the intention is not to railroad traditional </em><a href="OpenSource.html">OpenSource</a>, i.e. if developers have a choice of working on a project that pays and one that doesn't and both interest them equally, then unless the developer is an idealist, the traditional form suffers. I don't know how this could be prevented. -- <a href="GerritRiessen.html">GerritRiessen</a><em></em>
      </p>
      <p>
        There's also an assumption on this page that Open Source code is done collaboratively by individuals not in the same geographic location. That is a bit of an obstacle to Xp.
      </p>
      <p>
        <em>True, but my view of XP (at the risk of being flamed) is more of a set of best practices which (and here is comes the problem if you leave some out) support each other in very subtle ways. So the intention is provide tools which allow these tools to applied so that the customer is guaranteed quality and can see progress. -- </em><a href="GerritRiessen.html">GerritRiessen</a><em></em>
      </p>
      <hr/>
      <p>
        <strong>Xp Friendly Open Source Projects?</strong>
      </p>
      <p>
        It's difficult to see some of the most important Xp practices working in an environment where people can't pair program and the customer is not on site. Maybe it could work.
      </p>
      <p>
        <em>Pair programming can supported using </em><a href="SkyPe.html">SkyPe</a> (although not open source) or something like kibitz. Of course it's difficult, but one should be able to provide tools for doing <a href="VirtualPairProgramming.html">VirtualPairProgramming</a>. Customer can be virtually on site by <em>regularly</em> checking the mailing lists, and <a href="UserStories.html">UserStories</a> - assumption being that a tool used to maintain <a href="UserStories.html">UserStories</a>, and their associated tasks, online. They would be able to checkout all the sources and <a href="UnitTest.html">UnitTest</a>s to ensure that progress is being made.<em></em>
      </p>
      <p>
        <em>In the end, I don't know how many of the XP practices will be supported, but the key is to provide controlling mechanisms to the traditional </em><a href="OpenSource.html">OpenSource</a> process. One way I see this happening is by using parts of XP, I can't predict what will happen but I think it could work :-) -- <a href="GerritRiessen.html">GerritRiessen</a><em></em>
      </p>
      <p>
        Two suggested projects which might be suitable for Open Source with Xp are:
      </p>
      <ul>
        <li>
           Write A TCP/IP stack test suite (test packet reassembly, correct handling of window size and Christmas Tree packets etc).
        </li>
        <li>
           Novel compiler architecture that encourages code refactoring and factoring of optimisations from the parser / compiler design.
        </li>
      </ul>
      <p>
        <strong>TcpIpTestSuite:</strong>
        Should be easy to get a real corporate customer who will help drive the process and contribute engineering time and experience, (rather than hard cash). A TCP/IP test suite is a component Linux is lacking in, there is a definite need for it (for Linux to test 3rd Party TCP/IP :) ), and for this project there is a very strong extra push to get a slick automated testing framework in place early since the elements of the test framework will reappear as part of the actual product!
      </p>
      <p>
        <strong>NovelCompilerArchitecture</strong>
        If anyone is interested some slightly novel compiler architecture ideas are sketched in <a href="RethinkingCompilerDesign.html">RethinkingCompilerDesign</a>. Here elements of the TestFramework would reappear as sample code delivered to the customer and sample code in the IDE. Heck - compilers even compile themselves so that's part of the test suite too. Of course we'd add torture tests too. I have some very specific ideas as to what <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a> means in a compiler - and it's a bit more extreme than most compilers are. The need for an on-site customer is possibly slightly reduced in writing a compiler, since anyone doing so is a programmer and should have insight into what 'customers' expect :), i.e. less contact with the real end-customer is required.
      </p>
      <p>
        Am I subverting things by suggesting that parts of the test code become part of the deliverable? Not at all. <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a> rules!
      </p>
      <p>
        -- <a href="JamesCrook.html">JamesCrook</a>
      </p>
      <hr/>
      <p>
        This SourceCast tool looks like it might be useful for this kind of development: <a href="http://www.collab.net/products/sourcecast/">http://www.collab.net/products/sourcecast/</a>
      </p>
      <p>
        The ProgramFactory looks like it uses a similar concept as well: <a href="http://www.ProgramFactory.com">http://www.ProgramFactory.com</a>
      </p>
      <p>
        <em>Or along the lines of the </em><a href="SourceForge.html">SourceForge</a> interface with extensions, but definitely a web-based tool.<em></em>
      </p>
      <hr/>
      <p>
        <a href="TheMozillaProject.html">TheMozillaProject</a> has <a href="ContinuousIntegration.html">ContinuousIntegration</a> on a grand heterogeneous scale. They have a <a href="MozillaTinderbox.html">MozillaTinderbox</a> with Linux, Mac, Win32, SunOS all building continuously over and over. -- <a href="StevenNewton.html">StevenNewton</a>
      </p>
      <hr/>
      <p>
        See also <a href="http://www.advogato.org/article/202.html">http://www.advogato.org/article/202.html</a> by <a href="AndrewMcKinlay.html">AndrewMcKinlay</a>
      </p>
      <hr/>
      <p>
        <strong>Moved here from </strong><a href="OpenSourceExtremeProgramming.html">OpenSourceExtremeProgramming</a><strong></strong>
      </p>
      <hr/>
      <p>
        Wouldn't it be great to have an Open Sourced project made with <a href="ExtremeProgramming.html">ExtremeProgramming</a>? After some thought this is the main problem:
      </p>
      <ul>
        <li>
           Where do we get user stories from?
        </li>
      </ul>
      <p>
        <em>How about : every developer is supposed to be doing </em><a href="ExtremeProgrammingForOne.html">ExtremeProgrammingForOne</a>. They write their own <a href="UserStories.html">UserStories</a>. They DTSTTCPW. They test. They submit (and you (the project lead) integrate) frequently. Submitted <a href="UnitTest.html">UnitTest</a>s and acceptance tests are run before integrating; if they are at 100%, and you like the extra functionality, release to the world. As <a href="RonJeffries.html">RonJeffries</a> has it, "The keys would be simplicity and testing. The keys are always simplicity and testing."<em></em>
      </p>
      <p>
        Other than that, it might work very nicely! Assuming CVS is used <a href="UnitTest.html">UnitTest</a>s could be easy to get - cvs checkout <a href="UnitTest.html">UnitTest</a>s - and all code submissions would need accompanying <a href="UnitTest.html">UnitTest</a>s. Instead of pair programming we could have many-eyed peer review by using a mailing list for patch/code submissions (at least from new contributors). This would also help with reducing redundant code. With many people reviewing most of the code, chances are most redundancies would be caught. What does anyone else think? -- <a href="NathanHeagy.html">NathanHeagy</a>
      </p>
      <p>
        - It seems, in some ways, similar to <a href="ExtremeHacking.html">ExtremeHacking</a>.
      </p>
      <hr/>
      <p>
        <a href="NathanHeagy.html">NathanHeagy</a> and I discussed this a bit more elsewhere, we came up with the idea of a CVS and Wiki combination where random people could drop by and change the code as long as the changes improve the 'score' of the predefined <a href="UnitTest.html">UnitTest</a>s.
      </p>
      <p>
        Seems to me that the project 'leader' would be the person who defines the <a href="UnitTest.html">UnitTest</a>s and at least starts the basic code bits.
      </p>
      <p>
        This idea also seems similar to some of <a href="FridemarPache.html">FridemarPache</a>'s enhanced Wiki thoughts. I've always liked those ideas, but could never come up with a workable way to implement them. An OpenSourceWiki sounds like it might decrease the 'threshhold' enough to get random people to change code. I think I would do it at least.
      </p>
      <p>
        Does anyone have thoughts or ideas about this? I have thought of the security problem, not sure what to do about it though.
      </p>
      <p>
        --<a href="ShaeErisson.html">ShaeErisson</a>
      </p>
      <p>
        Yes, open source development has a relatively high barrier to entry. You usually need to join voluminous mailing list, understand a culture, agree to the group's coding standards, and work in concert with others. This is difficult. But perhaps it is a good thing.
      </p>
      <p>
        <em>A high barrier to entry? Only on very large projects. Most open source projects have only a handful of coders and a fairly small codebase. Quite often you can grok the design easily enough to add the minor feature you need to add without disturbing much of the rest of the code. However, this is just my experience.</em>
      </p>
      <p>
        <em>Check out </em><a href="http://www.smalltalksource.org">http://www.smalltalksource.org</a> - it's a wiki for open source development.<em></em>
      </p>
      <hr/>
      <p>
        Given an open project of sufficient size, the probability of someone deliberately contributing an obscure bug (or <a href="HeisenBug.html">HeisenBug</a>) clever enough to thwart existing <a href="UnitTest.html">UnitTest</a>s approaches one, and is followed by the probability that the bug also introduces a security flaw. Human review of untrusted patches, while also not perfect, is still necessary. -- <a href="CharlesMiller.html">CharlesMiller</a>
      </p>
      <hr/>
      <p>
        Note that many projects use the XP principles outlined above. Patches are sent to a mailing list by contributors. The maintainer reviews the patches and commits; for large patches the list members will chime in with feedback before the patch is committed. Continuous integration (or as close as you can get) is achieved in this same way. Mozilla has even created tools (<a href="MozillaTinderbox.html">MozillaTinderbox</a>) for continuously building and testing the product (including fingering the last person who committed in case of a test breakage). Successful projects are the epitome of the 'simplest thing', failed projects are those that overdesign in the early stages.
      </p>
      <p>
        The more I think about it, the more I think that <a href="OpenSourceExtremeProgramming.html">OpenSourceExtremeProgramming</a> will have slightly different rules than <a href="ExtremeProgramming.html">ExtremeProgramming</a>. The idea is still that you have to take all the best practices of open source programming and do them all the time, the result is different in that the best practices from open source are slightly different (but overlapping) than conventional programming:
      </p>
      <ul>
        <li>
           DogFooding
        </li>
        <li>
           ReleaseEarlyAndOften
        </li>
        <li>
           Establish effective means of communicating with users and contributors
        </li>
        <li>
           <a href="KeepItSimple.html">KeepItSimple</a> / <a href="DoSimpleThings.html">DoSimpleThings</a>
        </li>
        <li>
           Recognize the least common denominator (this may be a corollary of the real rule: acquire as large a user base as possible - without users/customers the project dies)
        </li>
      </ul>
      <p>
        -- <a href="BrianStPierre.html">BrianStPierre</a>
      </p>
      <hr/>
      <p>
        Isn't <a href="OpenSource.html">OpenSource</a> already <a href="ExtremeProgramming.html">ExtremeProgramming</a> but in a different setting ? A lot of the practices and characteristics of <a href="OpenSource.html">OpenSource</a> are reflected in XP and vice versa. Here I'm thinking of testing, feedback from users, pair programming -- where IMHO <a href="OpenSource.html">OpenSource</a> practices long distance pair programming, high level of communication, high discipline, refactoring, collective code ownership ....
      </p>
      <p>
        However, XP works best with a customer, a single group of developers all at the same location, and a tight schedule. <a href="OpenSource.html">OpenSource</a> is best suited to a distribute group of developers, no direct customer, and no definite time schedule.
      </p>
      <p>
        Having advocated the combination of the two, or rather the notion of <a href="CorporateOpenSource.html">CorporateOpenSource</a>, I find myself moving away from that notion to one of never the twain shall meet! I.e. One can see parallels, but the combination would bring too much commonality that a mixture would not bring any improvements.
      </p>
      <p>
        Perhaps, wearing my corporate hat, an interesting topic would be the development of a <a href="CorporateOpenSource.html">CorporateOpenSource</a> methodology that borrows from <a href="OpenSource.html">OpenSource</a> but allows a multinational corporation, and there are plenty of those, to get full benefit of its developer resources. I.e. Corporation X wants to develop product Y. What does it do? It assigns a project team in location Z and gives them a deadline of XX days. Everybody on that team works 60 hour weeks to get the thing done, and then it only works in one language! Instead it could have assigned project teams in locations A,B,C perhaps ensuring that timezone distribution was such that no overlap occurred in development time of the individual teams. The corporation could then enjoy a development time of 24 hours per day and developers could enjoy a healthy working week of 40 hours. Plus the end product would be available in three different languages - product and manuals.
      </p>
      <p>
        -- <a href="GerritRiessen.html">GerritRiessen</a>
      </p>
      <hr/>
      <p>
        Flea was wrought as eXtremely as possible with only one team member:
      </p>
      <code>
        <a href="http://flea.sourceforge.net">http://flea.sourceforge.net</a><br/>
      </code>
      <ul>
        <li>
           <a href="TestInfected.html">TestInfected</a>
        </li>
        <li>
           <a href="RefactorMercilessly.html">RefactorMercilessly</a>
        </li>
        <li>
           <a href="FrequentReleases.html">FrequentReleases</a>
        </li>
        <li>
           <a href="DoSimpleThings.html">DoSimpleThings</a>
        </li>
      </ul>
      <p>
        -- <a href="PhlIp.html">PhlIp</a>
      </p>
      <hr/>
      <p>
        The <a href="OpenSource.html">OpenSource</a> projects I've found most interesting are those that were originally developed by corporate IT departments and then <a href="OpenSource.html">OpenSource</a>d for all the expected benefits - more review, more testing, longer life. Or they are projects that were developed by people working in corporate IT departments collaborating together for the same reasons.
      </p>
      <p>
        (For example, much of the Apache <a href="JakartaProject.html">JakartaProject</a>, TeaServlet...)
      </p>
      <p>
        The idea is that these are frameworks and toolkits that were developed in the course of developing applications or subsystems, rather than being complete packaged applications or subsystems themselves. That is, someone was getting paid to create a (<a href="ClosedSource.html">ClosedSource</a>) application or subsystem, and in the process found themselves building a framework or toolkit that they realized could just as well be spun off into its own package for the sake of reuse.
      </p>
      <p>
        This suggests a different view than was discussed above. Most of the discussion here has been assuming that the goal of the <a href="OpenSource.html">OpenSource</a> project will be to build an application, which some customer will pay for. Since <a href="ExtremeProgramming.html">ExtremeProgramming</a> is about building applications, it then is tempting to wonder how <a href="OpenSource.html">OpenSource</a> applications can be built with <a href="ExtremeProgramming.html">ExtremeProgramming</a> practices.
      </p>
      <p>
        But the alternative view is that it makes sense to keep application development <a href="ClosedSource.html">ClosedSource</a>, using all the <a href="ExtremeProgramming.html">ExtremeProgramming</a> practices as usual, while any frameworks or toolkits created in support of application development could be released as <a href="OpenSource.html">OpenSource</a>.
      </p>
      <p>
        So the attitude would be: Hey, in the course of building this application we created some packages that don't depend on the particular business problem we're solving for our customer, and which are probably really similar to what other people have written and are going to write over and over again. Since we don't like the idea of duplicated effort, let's release these packages as <a href="OpenSource.html">OpenSource</a> (<em>or</em> let's look around to see if someone else has already <a href="OpenSource.html">OpenSource</a>d something similar that we could use).
      </p>
      <p>
        Further, if this attitude really does enhance our productivity (by reducing duplicated effort, providing external testing and review of code, etc.), then we should look into how our <a href="ExtremeProgramming.html">ExtremeProgramming</a> practices can maximize this kind of reuse (as I describe briefly in <a href="ConsideringOpenSource.html">ConsideringOpenSource</a>). Specifically, <a href="RefactorMercilessly.html">RefactorMercilessly</a> can be applied, reducing the dependence of our framework and toolkit code on our core business solution code, which will:
      </p>
      <ol>
        <li>
           maximize the amount of code we can <a href="OpenSource.html">OpenSource</a>
        </li>
        <li>
           maximize the opportunities for using existing <a href="OpenSource.html">OpenSource</a> code
        </li>
        <li>
           maximize our contributions back to <a href="OpenSource.html">OpenSource</a> projects
        </li>
      </ol>
      <p>
        The last point involves <em>continuing</em> to <a href="RefactorMercilessly.html">RefactorMercilessly</a> even after incorporating some <a href="OpenSource.html">OpenSource</a> code. We shouldn't be afraid to go in and change the <a href="OpenSource.html">OpenSource</a> code as part of refactoring our application. This implies that <a href="CollectiveOwnership.html">CollectiveOwnership</a> over the <a href="OpenSource.html">OpenSource</a> code involves all the teams that are using that code. Each team treats the <a href="OpenSource.html">OpenSource</a> code as if it was just part of their own application; it is just where the different applications overlap. As long as each team's refactored contributions maintain some reasonable interface stability, there's no problem. If one team's refactoring introduces interface instability, then their contributions will be branched into a sibling project.
      </p>
      <p>
        (If they refactored but didn't branch, it would cause problems for the other teams; the only alternative to branching would be to not <a href="RefactorMercilessly.html">RefactorMercilessly</a>, which would mean that embracing <a href="OpenSource.html">OpenSource</a> would interfere with <a href="ExtremeProgramming.html">ExtremeProgramming</a> instead of enhancing it. The beauty of <a href="OpenSource.html">OpenSource</a> is that each team can use the <a href="OpenSource.html">OpenSource</a> package as long as it is helpful, and then take the code in whatever direction they want if their needs change. So this point about being able to refactor into the <a href="OpenSource.html">OpenSource</a> package is really the key advantage that using an <a href="OpenSource.html">OpenSource</a> package has over using a <a href="ClosedSource.html">ClosedSource</a> package with the same functionality.)
      </p>
      <p>
        This approach does have some implications for how the <a href="OpenSource.html">OpenSource</a> projects are maintained, but nothing really beyond how <a href="OpenSource.html">OpenSource</a> projects are already being maintained. For example, there must be <a href="UnitTest.html">UnitTest</a>s - but many of the ApacheJakarta projects are already using JUnit. There must also be <a href="CodingStandard.html">CodingStandard</a>s, <a href="ContinuousIntegration.html">ContinuousIntegration</a>, and <a href="FrequentReleases.html">FrequentReleases</a>, but those are nothing new for <a href="OpenSource.html">OpenSource</a> projects. <a href="UserStories.html">UserStories</a> and <a href="OnSiteCustomer.html">OnSiteCustomer</a> are irrelevant because they are handled by the application developers outside the scope of the <a href="OpenSource.html">OpenSource</a> projects. <a href="PairProgramming.html">PairProgramming</a> comes for free since all the developers are working in <a href="ExtremeProgramming.html">ExtremeProgramming</a> teams already.
      </p>
      <p>
        -- <a href="JustinSampson.html">JustinSampson</a>
      </p>
      <hr/>
      <p>
        Efforts to refactor <a href="ApacheAxis.html">ApacheAxis</a> raised some interesting issues of <a href="CombiningOpenSourceAndXp.html">CombiningOpenSourceAndXp</a>. After identifying the subsystems, we started by
        separating out a configuration subsystem. Some of the committers understood <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a>, but one or two argued for keeping complex but currently unused features for the sake of future flexibility. However, refactoring was helped by the Axis build including both unit and functional tests.
      </p>
      <p>
        The distributed nature of open source communities makes it more important, IMHO, to document the current design so that newcomers can more easily find out <em>why</em> the software is structured the way it is.
      </p>
      <p>
        -- <a href="GlynNormington.html">GlynNormington</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryExtremeProgramming.html">CategoryExtremeProgramming</a> <a href="CategoryOpenSource.html">CategoryOpenSource</a>
      </p>
    </div>
  </body>
</html>