<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Ward Number In Many Programming Languages
      </h1>
      <p>
        See also: <a href="WardNumber.html">WardNumber</a>, <a href="ArraySumInManyProgrammingLanguages.html">ArraySumInManyProgrammingLanguages</a>, <a href="CounterInManyProgrammingLanguages.html">CounterInManyProgrammingLanguages</a>, <a href="DotProductInManyProgrammingLanguages.html">DotProductInManyProgrammingLanguages</a>, <a href="HelloWorldInManyProgrammingLanguages.html">HelloWorldInManyProgrammingLanguages</a>, <a href="EightQueensInManyProgrammingLanguages.html">EightQueensInManyProgrammingLanguages</a>
      </p>
      <hr/>
      <p>
        <strong>Remember: </strong><a href="ConvertSpacesToTabsNotForCode.html">ConvertSpacesToTabsNotForCode</a><strong></strong>
      </p>
      <p>
        The code formatting on this page has already been messed up once by <a href="ConvertSpacesToTabs.html">ConvertSpacesToTabs</a>.  Don't do it again!
      </p>
      <hr/>
      <p>
        Some of the more popular languages have been factored off of this huge page:
      </p>
      <ul>
        <li>
           <a href="WardNumberInPerl.html">WardNumberInPerl</a> -- four <a href="PerlLanguage.html">PerlLanguage</a> entries
        </li>
        <li>
           <a href="WardNumberInLisp.html">WardNumberInLisp</a> -- <a href="LispLanguage.html">LispLanguage</a>, <a href="EmacsLisp.html">EmacsLisp</a>, and three <a href="SchemeLanguage.html">SchemeLanguage</a> entries
        </li>
      </ul>
      <hr/>
      <p>
        <strong></strong><a href="PythonLanguage.html">PythonLanguage</a><strong> -- </strong><a href="SteveHowell.html">SteveHowell</a>
      </p>
      <code>
        class wardnumber:<br/>
        def __init__(self, pairs):<br/>
        self.wardnumber = {}<br/>
        self.partners = {}<br/>
        for (p1, p2) in pairs:<br/>
        self.pair(p1,p2)<br/>
        self.pair(p2,p1)<br/>
        self.visit(['ward'], 1)<br/>
      </code>
      <code>
        def pair (self, me, you):<br/>
        if self.wardnumber.has_key(me):<br/>
        self.partners[me].append(you)<br/>
        else:<br/>
        self.partners[me] = [you]<br/>
        self.wardnumber[me] = None<br/>
      </code>
      <code>
        def visit(self, closer_folks, cnt):<br/>
        newer_folks = []<br/>
        for p1 in closer_folks:<br/>
        for p2 in self.partners[p1]:<br/>
        if not self.wardnumber[p2]:<br/>
        self.wardnumber[p2] = cnt<br/>
        newer_folks.append(p2)<br/>
        if len(newer_folks):<br/>
        self.visit(newer_folks,cnt+1)<br/>
      </code>
      <code>
        def output(self):<br/>
        folks = self.wardnumber.keys()<br/>
        folks.sort()<br/>
        for me in folks:<br/>
        print me, self.wardnumber[me]<br/>
      </code>
      <code>
        f = concat("pairs.py","r")<br/>
        exec f<br/>
        wardnumber(pairs).output()<br/>
      </code>
      <p>
        <em>This program accurately gives Ward a </em><a href="WardNumber.html">WardNumber</a> of 2.  The pairs.py file just initializes the self variable with an array of tuples of person names.<em></em>
      </p>
      <hr/>
      <p>
        <em>Another one in Python, slightly shorter. This correctly gives Ward a </em><a href="WardNumber.html">WardNumber</a> of 0. It expects an input file each of whose lines is a space-separated pair of names.  Uses some Python 2.2 features.<em></em>
      </p>
      <code>
        def dijkstra(G,v0):<br/>
        d = {}<br/>
        for v in G.keys(): d[v] = len(G)+1<br/>
        queue = [v0]<br/>
        d[v0] = 0<br/>
        while queue:<br/>
        v = queue.pop(0)<br/>
        for w in G[v]:<br/>
        if d[v]+1 < d[w]:<br/>
        d[w] = d[v]+1<br/>
        queue.append(w)<br/>
        return d<br/>
      </code>
      <code>
        def read_pairs(filename):<br/>
        G = {}<br/>
        for a,b in [line.split() for line in concat(filename)]:<br/>
        for (person, partner) in [(a,b),(b,a)]:<br/>
        if person not in G: G[person]=[]<br/>
        G[person].append(partner)<br/>
        return G<br/>
      </code>
      <code>
        results = dijkstra(read_pairs("pairs.txt"), "Ward").items()<br/>
        results.sort()<br/>
        for person,number in results:<br/>
        print person, number<br/>
      </code>
      <p>
        <em>Some caveats about this version: it uses a list to represent a queue, which may be inefficient when the queue becomes large. In various places I've not bothered to avoid evaluating the same expression several times.</em>
      </p>
      <hr/>
      <p>
        <em>Another Python version. Short and sweet, but 'partners' looks a bit inefficient!</em> -- MichaelDavies
      </p>
      <code>
        # Finds the minumum distance between two authors (the Erdo"s number)<br/>
        pairs = ( ('a', 'b'),('b', 'c'),('b', 'd'),('c', 'd'),('d', 'e'),('d', 'f'),<br/>
        ('e', 'i'), ('f', 'g'), ('g', 'h'),  ('h', 'i'),  ('j', 'k') )<br/>
      </code>
      <code>
        def partners(me):<br/>
        return [ p[0] for p in pairs if p[1] == me ] + [ p[1] for p in pairs if p[0] == me ]<br/>
      </code>
      <code>
        def erdosNumbersFrom(root):<br/>
        queue = [root]<br/>
        erdos = {root: 0}<br/>
        while queue <> []:<br/>
        this = queue.pop(0)<br/>
        e = erdos[this] + 1<br/>
        for p in partners(this):<br/>
        if erdos.setdefault(p, 9999) > e:<br/>
        queue.append(p)<br/>
        erdos[p] = e<br/>
        return erdos<br/>
      </code>
      <code>
        print "from 'f'", erdosNumbersFrom('f')<br/>
        print "from 'a'", erdosNumbersFrom('a')<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="ErlangLanguage.html">ErlangLanguage</a><strong></strong>
      </p>
      <p>
        <em>Here's my most incomprehensionable, in Erlang. -- </em><a href="LukeGorrie.html">LukeGorrie</a><em></em>
      </p>
      <code>
        -module(ward).<br/>
      </code>
      <code>
        -export([run/0, ward_number/1]).<br/>
        -import(lists, [member/2, reverse/1, foldl/3]).<br/>
      </code>
      <code>
        run() -> print_ward_numbers(ward_number(read_file("data.txt")), 0).<br/>
      </code>
      <code>
        print_ward_numbers([], _)	-> ok;<br/>
        print_ward_numbers([H|T], N) -> io:format("~p: ~p~n", [N, H]),<br/>
        print_ward_numbers(T, N+1).<br/>
      </code>
      <code>
        %% ward_number([Pair]) => [Group]<br/>
        %% Pair  = {Name, Name}<br/>
        %% Returns a list of lists of names, sorted by ward number.<br/>
        ward_number(Pairs) -> ward_number(Pairs, 1, [[ward]]).<br/>
      </code>
      <code>
        ward_number(Pairs, N, Groups) -><br/>
        case [Who || {true, Who} <- [in_next(Groups, A, B) || {A,B} <- Pairs]] of<br/>
        []	-> reverse(Groups);<br/>
        Next -> ward_number(Pairs, N+1, [Next|Groups])<br/>
        end.<br/>
      </code>
      <code>
        in_next(Groups, A, B) -><br/>
        case {group_member(A, Groups), group_member(B, Groups)} of<br/>
        {true, false}  -> {true, B};<br/>
        {false, true}  -> {true, A};<br/>
        _		-> false<br/>
        end.<br/>
      </code>
      <code>
        group_member(X, G) -> [L || L <- G, member(X, L)] /= [].<br/>
      </code>
      <code>
        read_file(Fname) -><br/>
        {ok, Bin} = file:read_file(Fname),<br/>
        [{A,B} || [A,B] <- [[list_to_atom(T) || T <- string:tokens(Line, " ")] ||<br/>
        Line <- string:tokens(binary_to_list(Bin), "\n")]].<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="RubyLanguage.html">RubyLanguage</a><strong> -- </strong><a href="JimWeirich.html">JimWeirich</a>
      </p>
      <code>
        class Programmer<br/>
        attr_reader :mates, :name, :ward_number<br/>
        def initialize(name)<br/>
        @name = name<br/>
        @mates = []<br/>
        @ward_number = 10**20<br/>
        end<br/>
        def examine_level(level)<br/>
        return [] if level >= ward_number<br/>
        @ward_number = level<br/>
        mates<br/>
        end<br/>
        def <=>(other)<br/>
        name <=> other.name<br/>
        end<br/>
        end<br/>
      </code>
      <code>
        class WardNumberCalculator<br/>
        def intern(name)<br/>
        @by_name[name] || (@by_name[name] = Programmer.new(name))<br/>
        end<br/>
        def adjust_level(ground_zero)<br/>
        level = 0 <br/>
        current, pending = [intern(ground_zero)], []<br/>
        while not current.empty?<br/>
        current.each { |p| pending += p.examine_level(level) }<br/>
        level += 1<br/>
        current, pending = pending, []<br/>
        end<br/>
        end<br/>
        def read_pairs(filename)<br/>
        @by_name = Hash.new<br/>
        pairs = concat(filename) { |file|<br/>
        file.each { |line|<br/>
        a, b = line.split.collect {|name| intern(name) }<br/>
        a.mates << b<br/>
        b.mates << a<br/>
        }<br/>
        }<br/>
        end<br/>
        def print<br/>
        for programmer in @by_name.values.sort<br/>
        puts "#{programmer.name}: #{programmer.ward_number}"<br/>
        end<br/>
        end<br/>
        end<br/>
      </code>
      <code>
        ward = WardNumberCalculator.new<br/>
        ward.read_pairs("ward.dat")<br/>
        ward.adjust_level("Ward")<br/>
        ward.print<br/>
      </code>
      <hr/>
      <p>
        <em>Here's another one</em> -- <a href="JasonArhart.html">JasonArhart</a>
      </p>
      <code>
        class Programmer<br/>
        def initialize(name)<br/>
        @name = name<br/>
        @partners = {}<br/>
        @ward_number = 0 if name == 'ward'<br/>
        end<br/>
        attr_reader :name, :ward_number<br/>
        def max_ward_number=(n)<br/>
        if @ward_number.nil? or @ward_number > n<br/>
        @ward_number = n<br/>
        @partners.each_value { |e| e.max_ward_number = @ward_number + 1 }<br/>
        end<br/>
        end<br/>
        def pair_with(other)<br/>
        unless @partners.include?(other.name)<br/>
        @partners[other.name] = other<br/>
        self.max_ward_number = other.ward_number + 1 unless other.ward_number.nil?<br/>
        other.pair_with(self)<br/>
        end<br/>
        end<br/>
        end<br/>
      </code>
      <code>
        programmers = {}<br/>
        open('ward.dat') do |file|<br/>
        for line in file<br/>
        a, b = line.strip.split.collect { |e| programmers[e] ||= Programmer.new(e) }<br/>
        a.pair_with(b)<br/>
        end<br/>
        end<br/>
      </code>
      <code>
        for programmer in programmers.keys.sort.collect {|k| programmers[k] }<br/>
        puts "#{programmer.name}: #{programmer.ward_number}"<br/>
        end<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="BackWardLanguage.html">BackWardLanguage</a><strong> -- </strong><a href="SteveHowell.html">SteveHowell</a>
      </p>
      <code>
        { al bob /pair<br/>
        bob cal /pair<br/>
        cal dave /pair<br/>
        dave ed /pair<br/>
        cal fred /pair<br/>
        al ward /pair<br/>
        dave ward /pair<br/>
        } /data Def<br/>
      </code>
      <code>
        { 1 Copy /names Set Add<br/>
      </code>
      <ol>
        <li>
           Copy Set Add 
        </li>
      </ol>
      <code>
        } /match Def<br/>
      </code>
      <code>
        { 2 Copy /match<br/>
        Swap /match<br/>
        } /pair Def<br/>
      </code>
      <code>
        /data<br/>
      </code>
      <code>
        { /wn Dict Obj 0 Assign<br/>
        } /names Set Forall<br/>
      </code>
      <code>
        { /level Obj Swap Assign<br/>
        /kids Set Clear<br/>
        { { { 1 Copy /wn Dict Obj Val<br/>
        }<br/>
        { Pop<br/>
        }<br/>
        { 1 Copy /kids Set Add<br/>
        /wn Dict Obj /level Obj Val Assign<br/>
        } If  <br/>
        } Swap Set Forall<br/>
        } /folks Set Forall<br/>
        /folks Set Clear<br/>
        { /folks Set Add <br/>
        } /kids Set Forall <br/>
        } /sweep Def<br/>
        ward /folks Set Add<br/>
        /i Obj 1 Assign<br/>
        { /folks Set Val<br/>
        } <br/>
        { /i Obj Val /sweep<br/>
        /i Obj Incr<br/>
        } While<br/>
        { 1 Copy Output<br/>
        /wn Dict Obj Val Output<br/>
        } /names Set Forall<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="JoyLanguage.html">JoyLanguage</a><strong></strong>
      </p>
      <p>
        trying hard to beat <a href="LukeGorrie.html">LukeGorrie</a>'s <a href="ErlangLanguage.html">ErlangLanguage</a> version, here's a first hack at a <a href="JoyLanguage.html">JoyLanguage</a> version. --<a href="ShaeErisson.html">ShaeErisson</a>
      </p>
      <code>
        DEFINE pairs == [["ward" "al"] ["al" "shae"] ["ward" "mike"] ["al" "joe"]] .<br/>
        DEFINE whackname ==  [!=] cons [filter] cons .<br/>
        DEFINE whackward == pairs "ward" whackname map .<br/>
        DEFINE rankone == whackward [size 1 =] filter flatten .<br/>
        DEFINE nowardpairs == pairs "ward" whackname map [size 2 =] filter .<br/>
        DEFINE makefilter == rankone [whackname] map .<br/>
        DEFINE flatten == [null] [] [uncons] [concat] linrec .<br/>
        DEFINE ranktwo == nowardpairs makefilter flatten map flatten .<br/>
        "rank zero is ward." putln.<br/>
        "rank one is " put rankone putln .<br/>
        "rank two is " put ranktwo putln .<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="SchemeLanguage.html">SchemeLanguage</a><strong></strong>
      </p>
      <code>
        (define pairings<br/>
        '((al . bob)<br/>
        (bob . cal)<br/>
        (cal . dave)<br/>
        (dave . ed)<br/>
        (cal . fred)<br/>
        (al . ward)<br/>
        (dave . ward)))<br/>
      </code>
      <code>
        (define (partners name)<br/>
        (foldl (lambda (pair base) <br/>
        (cond [(eq? name (car pair)) (cons (cdr pair) base)]<br/>
        [(eq? name (cdr pair)) (cons (car pair) base)]<br/>
        [else base])) <br/>
        '()<br/>
        pairings))<br/>
      </code>
      <code>
        (define (distance name group)<br/>
        (cond [(memq name group) 0]<br/>
        [else (+ 1 (distance name <br/>
        (apply append (map partners group))))]))<br/>
      </code>
      <p>
        Use it as follows:  
      </p>
      <code>
        (distance 'bob '(ward))	----> 2	<br/>
      </code>
      <code>
        (distance 'al '(fred))	----> 3<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="HaskellLanguage.html">HaskellLanguage</a><strong></strong>
      </p>
      <p>
        A short (but correct) implementation in <a href="HaskellLanguage.html">HaskellLanguage</a> (this seems to be one of the shortest ones).  I had a previous version here for a couple of hours, but that wasn't as elegant and it was harder to read. 
      </p>
      <p>
        The idea here is, we pick people out of an ever-shrinking set of unarranged people.  We do this by reading the list of already-arranged people (think of a snake eating its tail) and adding their neighbours to the end of the list.  The solution is elegant and shows some of the power of lazy evaluation, but unfortunately it has the side effect that if the set of people is disjoint (there are people with no paths in between), the routine will catch up itself when trying to find new paths to the rest of people, effectively making the snake eat itself.  (This is a nonending loop in practice, or more precisely, a(n) _|_ -terminated list.)
      </p>
      <code>
        import List((\\),delete,intersect,nub)<br/>
      </code>
      <code>
        examplepeers = [("panu", "jinx"), ("janne", "panu"), ("panu", "osma"),<br/>
        ("osma", "tero"), ("lard", "tero"), ("ward", "woe"),<br/>
        ("jinx", "woe"), ("ward", "lard"), ("woe", "binx"),<br/>
        ("binx", "zoo"), ("foo", "zoo")]<br/>
      </code>
      <code>
        symmetric_rel rel =<br/>
        nub $ map (\(x,y) -> (y,x)) rel ++ rel<br/>
      </code>
      <code>
        wardsnumbers start peer_pairs = wardsnumbers'<br/>
        where<br/>
        peer_rel = symmetric_rel peer_pairs<br/>
        wardsnumbers' = (0, start) : arrange_by wardsnumbers' people<br/>
        people = delete start $ nub $ map fst peer_rel<br/>
        arrange_by numbers [] = []<br/>
        arrange_by ((rank, person) : rest) peers_left =<br/>
        let nbrs = [ dst | (src, dst) <- peer_rel, src == person ] in<br/>
        [ (rank + 1, peer) | peer <- peers_left `intersect` nbrs ]<br/>
        ++ arrange_by rest (peers_left \\ nbrs)<br/>
      </code>
      <p>
        Try it out with
      </p>
      <code>
        wardsnumbers "ward" examplepeers<br/>
      </code>
      <hr/>
      <p>
        Here is my implementation in <a href="HaskellLanguage.html">HaskellLanguage</a>.
      </p>
      <code>
        module Ward (<br/>
        XNumber,<br/>
        xNumber,<br/>
        xNumberFromText<br/>
        ) where<br/>
      </code>
      <code>
        import List<br/>
        import Maybe<br/>
      </code>
      <code>
        type XNumber a = (a, Maybe Int)<br/>
      </code>
      <code>
        xNumber :: Eq a => a -> [(a, a)] -> [XNumber a]<br/>
        xNumber src pairs<br/>
        | src `elem` ids = bfs 1 pairs dist f<br/>
        | otherwise = error "xNumber: source not present in pairings"<br/>
        where<br/>
        ids = nub $ concatMap (\(a, b) -> [a, b]) pairs<br/>
        dist = map (\x -> (x, Nothing)) ids<br/>
        f = nub [ x | x <- ids, (x, src) `elem` pairs || (src, x) `elem` pairs ]<br/>
      </code>
      <code>
        bfs :: Eq a => Int -> [(a, a)] -> [XNumber a] -> [a] -> [XNumber a]<br/>
        bfs _ _ dist [] = dist<br/>
        bfs cd pairs dist v<br/>
        =	<br/>
        bfs (cd + 1) pairs dist' v'<br/>
        where<br/>
        dist' = foldl (visit cd) dist v<br/>
        v' = nub $ concatMap (neighbors pairs dist') $ reverse v<br/>
      </code>
      <code>
        visit :: Eq a => Int -> [XNumber a] -> a -> [XNumber a]<br/>
        visit cd dist v<br/>
        =	<br/>
        (v, Just cd) : v'<br/>
        where<br/>
        v' = filter (\(x, _) -> x /= v) dist<br/>
      </code>
      <code>
        neighbors :: Eq a => [(a, a)] -> [XNumber a] -> a -> [a]<br/>
        neighbors pairs dist v<br/>
        =	<br/>
        intersect unv reachable<br/>
        where<br/>
        unv = [x | (x, y) <- dist, y == Nothing]<br/>
        reachable = concat [[a, b] | (a, b) <- pairs, a == v || b == v]<br/>
      </code>
      <code>
        xNumberFromText :: String -> String -> [XNumber String]<br/>
        xNumberFromText src txt<br/>
        =	<br/>
        xNumber src $ map (\x -> let [a, b] = words x in (a, b)) $ lines txt<br/>
      </code>
      <code>
        showPairs :: String -> [XNumber String] -> IO ()<br/>
        showPairs src xs = do<br/>
        mapM_ (\(name, num) -> case num of<br/>
        Nothing -> putStrLn $ name ++ " has an undefined " ++ src ++ "Number"<br/>
        Just n -> putStrLn $ name ++ " has a " ++ src ++ "Number of " ++ show n<br/>
        ) xs<br/>
        putStrLn "End of list."<br/>
      </code>
      <code>
        main :: IO ()<br/>
        main<br/>
        = do<br/>
        src <- getLine<br/>
        txt <- getContents<br/>
        showPairs src $ xNumberFromText src txt<br/>
      </code>
      <p>
        If run as a program, it expects the name of the "source" person (e.g., Ward) on the first line of input.
        Each subsequent line should contain a whitespace-delimited list of exactly two people, representing a pair
        that has programmed together.  After reading the list, the program will output the "XNumber" (where X
        represents the name in the first line of input, e.g. Ward) for every person listed (or "undefined" if they
        have none).  There are also a couple of functions provided for processing such a list of pairs from within
        another program (and it's even polymorphic in the type of programmer identifier).
      </p>
      <p>
        Note that it accurately returns an X number for X of 2 (that is, if X actually appears in any pairs,
        otherwise it is undefined).  It would be a trivial change (and in fact would make the program look a little
        neater) to return the correct answer rather than the accurate one.  I leave this as an exercise for the reader.
      </p>
      <code>
        -- LoganHanks<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="PrologLanguage.html">PrologLanguage</a><strong></strong>
      </p>
      <p>
        I thought it should be easy to do in the <a href="PrologLanguage.html">PrologLanguage</a>. 
        Unfortunately, I don't know Prolog.
        While reading a simple tutorial, I cobbled up the following, which works,
        but a real Prologger might be able to produce somethign more elegant.
      </p>
      <code>
        pairing(al, bob).<br/>
        pairing(bob, cal).<br/>
        pairing(cal, dave).<br/>
        pairing(dave, ed).<br/>
        pairing(cal, fred).<br/>
        pairing(al, ward).<br/>
        pairing(dave, ward).<br/>
      </code>
      <code>
        pair(X, Y) :- pairing(X, Y).<br/>
        pair(X, Y) :- pairing(Y, X).<br/>
      </code>
      <code>
        ward_number_visited(ward, _, 0).<br/>
        ward_number_visited(X, Visited, _) :- member(X, Visited), !, fail.<br/>
        ward_number_visited(X, Visited, N) :-<br/>
        pair(X, Y), ward_number_visited(Y, [X|Visited], M), N is M+1.<br/>
      </code>
      <code>
        ward_number(X, N) :- findall(M, ward_number_visited(X, [], M), Lst),<br/>
        sort(Lst, [N|_]).<br/>
      </code>
      <p>
        Use it like this:
      </p>
      <code>
        ward_number(bob, N).<br/>
      </code>
      <p>
        -- <a href="StephanHouben.html">StephanHouben</a>
      </p>
      <p>
        The above is basically an exhaustive search of all possible paths for each individual. Below is a sample that efficiently calculates all the values. Output is a ranking table as a list of lists of names according to increasing <a href="WardNumber.html">WardNumber</a>.
      </p>
      <code>
        unvisited_neighbours(Relation, Visited, X, []) :-<br/>
        \+ ((call(Relation, X, Y), \+member(Y, Visited))), !.<br/>
        unvisited_neighbours(Relation, Visited, X, Nbrs) :-<br/>
        setof(Y, (call(Relation, X, Y), \+member(Y, Visited)), Nbrs).<br/>
      </code>
      <code>
        ranking_(_, [], _, []) :- !.<br/>
        ranking_(Relation, Front, Visited, [Front|Xs]) :-<br/>
        union(Front, Visited, Visited2),<br/>
        maplist(unvisited_neighbours(Relation, Visited2), Front, NbrSets),<br/>
        foldl(union, NbrSets, [], Nbrs),<br/>
        ranking_(Relation, Nbrs, Visited2, Xs).<br/>
      </code>
      <code>
        ranking(A, Relation, Xs) :- ranking_(Relation, [A], [], Xs).<br/>
      </code>
      <p>
        Note that the predicate that defines the actual graph is given as a parameter. Using the pair/2 predicate above, we get:
      </p>
      <code>
        ?- ranking(ward, pair, WardRanking).<br/>
        WardRanking = [[ward],[al,dave],[cal,ed,bob],[fred]]<br/>
      </code>
      <p>
        It does not end there, though. We can do much more with it:
      </p>
      <code>
        ?- L = [_, X | _], ranking(_, pair, L), member(bob, X).<br/>
        L = [[al], [bob, ward], [dave, cal], [fred, ed]],<br/>
        X = [bob, ward] ;<br/>
        L = [[cal], [bob, dave, fred], [ed, ward, al]],<br/>
        X = [bob, dave, fred] ;<br/>
        false.<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="IconLanguage.html">IconLanguage</a><strong></strong>
      </p>
      <p>
        My <a href="IconLanguage.html">IconLanguage</a> version breaks the 20-line barrier. This is my third attempt (the second was here for a few hours). The clever idea for the second attempt was to store the pairs as a set of sets, which turns parsing stdin into internal storage into a one-line operation ("every insert..."). The clever idea for the third attempt was to keep a set of people in the pair list who hadn't been printed, instead of lugging around an ever-growing list of people who had been. This should get rid of the n-squared behavior of each printing step, along with allowing the program to generate less garbage.
      </p>
      <p>
        I also fixed a bug where a pair with a <a href="WardNumber.html">WardNumber</a> of omega would cause the program to spin (does everyone else's program do this right?). Another possible bug I checked for is the case where JuliusCaesar is used as the root of the number graph (which should prevent anything from being printed).
      </p>
      <p>
        Put the depth-zero people (i.e., "ward") on the command line.
      </p>
      <code>
        procedure main(args)<br/>
        pairs := set()<br/>
        every insert(pairs, set(|read() ? [tab(upto(' ')), tab(many(' ')) & tab(0)]))<br/>
        toBeWritten := set()<br/>
        every toBeWritten ++:= !pairs<br/>
        WriteFromDepth(0, toBeWritten, set(args), pairs)<br/>
        end<br/>
      </code>
      <code>
        procedure WriteFromDepth(depth, toBeWritten, people, pairs)<br/>
        if  not member(toBeWritten, !people) then fail<br/>
        writes(depth, " ")<br/>
        every writes(member(toBeWritten, !people), " ")<br/>
        write()<br/>
      </code>
      <code>
        nextPeople := set()<br/>
        every member(people, !(pair := !pairs)) do<br/>
        nextPeople ++:= pair<br/>
        WriteFromDepth(depth + 1, toBeWritten --:= people, nextPeople --:= people, pairs)<br/>
        end<br/>
      </code>
      <p>
        -- <a href="BillTrost.html">BillTrost</a>
      </p>
      <hr/>
      <p>
        After spending two hours scratching my head over my <a href="HtagLanguage.html">HtagLanguage</a> implementation, I remembered that I haven't built-in support for local variables yet. And I was so happy about hte fact that it could do recursion.. sigh.
        -- <a href="SvenNeumann.html">SvenNeumann</a>
      </p>
      <p>
        <em>Will this </em>'ever<em>' be fixed?</em>
      </p>
      <hr/>
      <p>
        <strong></strong><a href="JavaLanguage.html">JavaLanguage</a><strong></strong>
      </p>
      <p>
        In <a href="JavaLanguage.html">JavaLanguage</a>, completely off the top of my head (not even looking up the APIs) and not bothering to try to compile it:
      </p>
      <code>
        class NamePair implements Comparable {<br/>
        private String names[2];<br/>
        // The second is allowed to be null; the first isn't<br/>
        private int nullSemanticHack;<br/>
        public int compareTo(Object o) throws <a href="ClassCastException.html">ClassCastException</a> {<br/>
        NamePair np = (NamePair)o;<br/>
        int result = names[0].compareTo(np.names[0]);<br/>
        if (result != 0) return result;<br/>
        // Otherwise, check the second name<br/>
        if (names[1] == null || np.names[1] == null) return nullSemanticHack;<br/>
        return (names[1].compareTo(np.names[1]);<br/>
        }<br/>
        public NamePair(String[] names, int nsh) {<br/>
        nullSemanticHack = nsh;<br/>
        this.names[0] = names[0]; this.names[1] = names[1];<br/>
        }<br/>
        public String getName(boolean first) {<br/>
        if (first) return names[0]; // else<br/>
        return names[1];<br/>
        }<br/>
        }<br/>
      </code>
      <code>
        public class WardNumberFinder {<br/>
        TreeSet pairs;<br/>
        Hashtable numbers;<br/>
        private static void promote(NamePair promotion) {<br/>
        String x = promotion.getName(true);<br/>
        String y = promotion.getName(false);<br/>
        // Here comes the ugly part. <a href="NullIsaHack.html">NullIsaHack</a>.<br/>
        if (!(numbers.get(x) || numbers.get(y))) return;<br/>
        Integer xnum = ((Integer)numbers.get(x));<br/>
        Integer ynum = ((Integer)numbers.get(y));<br/>
        if (!xnum || (xnum.getValue() - ynum.getValue() > 1)) {<br/>
        numbers.put(x, new Integer(ynum + 1));<br/>
        }<br/>
        if (!ynum || (ynum.getValue() - xnum.getValue() > 1)) {<br/>
        numbers.put(y, new Integer(xnum + 1));<br/>
        }<br/>
        }<br/>
        private static void solve(String source) {<br/>
        // Find all pairs starting with source.<br/>
        // Maybe these should be the other way around<br/>
        NamePair begin = new NamePair(source, null, -1);<br/>
        NamePair end = new NamePair(source, null, 1);<br/>
        Iterator i = pairs.subSet(begin, end).iterator();<br/>
        while (i.hasNext()) {<br/>
        NamePair np = (NamePair)i.next();<br/>
        String nextNode = np.getName(false);<br/>
        i.remove(); // Ah hell, there will be problems with concurrent <br/>
        // modification for sure. Oh well. Someone else can debug this hopefully?<br/>
        // Call for this node<br/>
        promote(np);<br/>
        // Call recursively<br/>
        solve(nextNode);<br/>
        }<br/>
        }<br/>
        public static void main(String[] args) {<br/>
        // First arg is Ward's name.<br/>
        // Following that, each pair of args is a pairing for the list.<br/>
        String wardsName = args[0];<br/>
        pairs = new TreeSet();<br/>
        numbers = new Hashtable();<br/>
        int i = 1;<br/>
        while (i + 1 < args.length) {<br/>
        pairs.add(new NamePair({args[i], args[i+1]}, 0));<br/>
        pairs.add(new NamePair({args[i+1], args[i]}, 0));<br/>
        i += 2;<br/>
        }<br/>
        // Now do our searching.<br/>
        numbers.put(wardsName, new Integer(0));<br/>
        solve(wardsName);<br/>
        // Output from the 'numbers'. Anyone not present has Ward number oo.<br/>
        Iterator i = numbers.keys().iterator();<br/>
        while(i.hasNext()) {<br/>
        String name = (String)i.next();<br/>
        System.out.println(name + " has Ward number " + numbers.get(name) + ".");<br/>
        }<br/>
        }<br/>
        }<br/>
      </code>
      <p>
        Hmm. I suspect Java isn't the right tool for this job ;) I'd have picked Perl, but there was already an implementation for Perl, so I thought I'd fill a gap.
      </p>
      <p>
        Anyone want to try this in any of the <a href="EsotericProgrammingLanguage.html">EsotericProgrammingLanguage</a>s? >;)
        -- <a href="KarlKnechtel.html">KarlKnechtel</a>
      </p>
      <hr/>
      <p>
        <strong></strong><a href="BourneAgainShell.html">BourneAgainShell</a><strong>  (</strong><a href="BourneShell.html">BourneShell</a>)
      </p>
      <p>
        Here's a real horror -- a bash version. Works in the FreeBSD /bin/sh, and probably Korn shell, too.  -- <a href="BillTrost.html">BillTrost</a>
      </p>
      <code>
        #!/bin/sh<br/>
        while read dee dum junk; do<br/>
        eval peers_$dee=\"\$peers_$dee $dum\"<br/>
        eval peers_$dum=\"\$peers_$dum $dee\"<br/>
        done<br/>
      </code>
      <code>
        until<br/>
        toEcho=<em> found=</em><br/>
        for hacker; do<br/>
        eval \$visited_$hacker false && continue<br/>
        toEcho="$toEcho $hacker"<br/>
        eval 'found="$found $peers_'$hacker'"'<br/>
        eval visited_$hacker=true<br/>
        done<br/>
        set -- $found<br/>
        [ $# -eq 0 ] <br/>
        do<br/>
        echo "$toEcho"<br/>
        done | (<br/>
        set --<br/>
        while read l; do<br/>
        echo $# $l<br/>
        set x $*<br/>
        done<br/>
        )<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="AssemblyLanguage.html">AssemblyLanguage</a><strong></strong>
      </p>
      <p>
        Linux/GAS/x86 in AT&T syntax.
      </p>
      <code>
        .MACRO PERSON name<br/>
        .data 0<br/>
        \name:<br/>
        .int 0x7FFFFFF0, str_\name<br/>
      </code>
      <code>
        .data 1<br/>
        str_\name:<br/>
        .asciz "\name"<br/>
        .data 0<br/>
      </code>
      <code>
        .ENDM<br/>
      </code>
      <code>
        .MACRO PAIR name1, name2<br/>
        .int \name1, \name2<br/>
        .ENDM<br/>
      </code>
      <code>
        .data<br/>
      </code>
      <code>
        persons_begin:<br/>
        PERSON al<br/>
        PERSON bob<br/>
        PERSON cal<br/>
        PERSON dave<br/>
        PERSON ed<br/>
        PERSON fred<br/>
        PERSON ward<br/>
        persons_end:<br/>
      </code>
      <code>
        pairs_begin:<br/>
        PAIR al, bob<br/>
        PAIR bob, cal<br/>
        PAIR cal, dave<br/>
        PAIR dave, ed<br/>
        PAIR cal, fred<br/>
        PAIR al, ward<br/>
        PAIR dave, ward<br/>
        pairs_end:<br/>
      </code>
      <code>
        format_str:<br/>
        .asciz "Person %s has ward number %d.\n"<br/>
      </code>
      <code>
        .text<br/>
      </code>
      <code>
        .global main<br/>
        main:<br/>
        pushal<br/>
        movl $0, ward /* initialize the thing */<br/>
      </code>
      <code>
        outer_loop:<br/>
        xor %bl, %bl<br/>
        mov $pairs_begin, %eax<br/>
        inner_loop:<br/>
        cmp $pairs_end, %eax<br/>
        je end_inner_loop<br/>
      </code>
      <code>
        mov (%eax), %ecx /* %ecx is person 1 */<br/>
        mov 4(%eax), %edx /* %edx is person 2 */<br/>
      </code>
      <code>
        mov (%ecx), %esi /* %esi is ward number of 1 (so far) */ <br/>
        mov (%edx), %edi /* %edi is ward number of 2 (so far) */ <br/>
      </code>
      <code>
        /* first, check if ward # 1 + 1 < ward # 2 */<br/>
        inc %esi<br/>
        cmp %esi, %edi<br/>
        jle next_person<br/>
        /* it is so, update ward number */<br/>
        mov $1, %bl<br/>
        mov %esi, (%edx)<br/>
        jmp continue_inner_loop<br/>
      </code>
      <code>
        /* next, check if ward # 1 > ward # 2 + 1 */<br/>
        next_person:<br/>
        dec %esi<br/>
        inc %edi<br/>
        cmp %esi, %edi<br/>
        jge continue_inner_loop<br/>
        /* it is so, update ward number */<br/>
        mov $1, %bl<br/>
        mov %edi, (%ecx)<br/>
      </code>
      <code>
        continue_inner_loop:<br/>
        add $8, %eax<br/>
        jmp inner_loop<br/>
      </code>
      <code>
        end_inner_loop:<br/>
        test %bl, %bl<br/>
        jnz outer_loop<br/>
      </code>
      <code>
        /* OK, time to print some results */<br/>
        mov $persons_begin, %ebx<br/>
        print_loop:<br/>
        cmp $persons_end, %ebx<br/>
        je end_print_loop<br/>
      </code>
      <code>
        push (%ebx)<br/>
        push 4(%ebx)<br/>
        push $format_str<br/>
        call printf<br/>
        add $12, %esp<br/>
      </code>
      <code>
        add $8, %ebx<br/>
        jmp print_loop<br/>
      </code>
      <code>
        end_print_loop:<br/>
        popal<br/>
        xor %eax, %eax<br/>
        ret<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="ForthLanguage.html">ForthLanguage</a><strong> -- </strong><a href="IanOsgood.html">IanOsgood</a>
      </p>
      <code>
        \ Ward number: adjust numbers as relations are declared<br/>
      </code>
      <code>
        : person create ( Ward# ) , 0 , does> @ ;<br/>
      </code>
      <ol>
        <li>
           person Ward
        </li>
      </ol>
      <code>
        : person 9999 person ;  \ override<br/>
        : !ward# ( n person -- ) >body ! ;<br/>
        : >ward# ( person -- n ) >body @ ;	\ or just execute<br/>
        : >pairs ( person -- ^pairs ) >body cell+ ;<br/>
      </code>
      <code>
        \ linked list (cell 0: link, cell 1: person)<br/>
        : >next ( node -- next-node ) @ ;<br/>
        : >data ( node -- data ) cell+ @ ;<br/>
        : add-head ( data list -- ) dup >next here rot !  , , ;<br/>
      </code>
      <code>
        : link-pair ( person1 person2 -- )<br/>
      </code>
      <ol>
        <li>
          dup >pairs add-head  swap >pairs add-head ;
        </li>
      </ol>
      <code>
        : ?lower-ward ( person  maybe-lower-ward# -- )<br/>
      </code>
      <ol>
        <li>
          + over >ward# over > if
        </li>
      </ol>
      <code>
        swap  2dup !ward#  >pairs	\ set lower Ward number<br/>
        begin >next dup while	( ward# node )<br/>
      </code>
      <ol>
        <li>
          dup >data swap recurse	\ lower partners too?
        </li>
      </ol>
      <code>
        repeat<br/>
        then 2drop ;<br/>
      </code>
      <code>
        : adjust-ward#s ( person1 person2 -- )<br/>
      </code>
      <ol>
        <li>
          dup >ward# ?lower-ward  swap >ward# ?lower-ward ;
        </li>
      </ol>
      <code>
        : find-person ( "name" -- person )<br/>
        bl word find if exit then  count type -1 abort"  who?" ;<br/>
      </code>
      <code>
        : pair ( "name1 name2" -- )<br/>
        find-person find-person ( person1 person2 )<br/>
      </code>
      <ol>
        <li>
          dup link-pair adjust-ward#s ;
        </li>
      </ol>
      <code>
        \ test data<br/>
      </code>
      <code>
        person al  person bob  person cal  person dave  person ed  person fred<br/>
      </code>
      <code>
        pair al bob<br/>
        pair bob cal<br/>
        pair cal dave<br/>
        pair dave ed<br/>
        pair cal fred	cr al . ed . \ 9999 9999<br/>
        pair al ward	cr al . bob . cal . dave . ed . fred . \ 1 2 3 4 5 4<br/>
        pair dave ward  cr al . bob . cal . dave . ed . fred . \ 1 2 2 1 2 3<br/>
      </code>
      <hr/>
      <p>
        <strong>C++ Templates</strong> (don't you just <strong>Love</strong> how templates can be used for functional programming?)
      </p>
      <p>
        I'm sorry about the readability of the code, but please do ask questions if you want an explanation (that might help me understand it myself). It's also quite large in comparison to the code here (501 lines), so I've put it on an external web server:
        <a href="http://www.persepolis.se/~salparot/ward_number/">http://www.persepolis.se/~salparot/ward_number/</a>
      </p>
      <p>
        Main code in ward.cc - utilities for some LISP constructs (conses, values and printing functions) in templ_lists2.h
      </p>
      <p>
        The general idea is a BFS search of the graph of pairs that just terminates as soon as the 'ward' symbol has been found. Well, the rest is in the code, which really is self-explanatory (if you're not picky on the definition of 'explanation').
        -- <a href="SimonBrenner.html">SimonBrenner</a>
      </p>
      <hr/>
      <p>
        <strong></strong><a href="OcamlLanguage.html">OcamlLanguage</a><strong></strong>
      </p>
      <p>
        Copied from the Scheme examples
      </p>
      <code>
        let pairings =<br/>
        ["al"  , "bob" ;<br/>
        "bob" , "cal" ;<br/>
        "cal" , "dave";<br/>
        "dave", "ed"  ;<br/>
        "cal" , "fred";<br/>
        "al"  , "ward";<br/>
        "dave", "ward"]<br/>
      </code>
      <code>
        (* assuming that each edge is only listed once *)<br/>
        let get_partners name =<br/>
        List.fold_left<br/>
        (fun base (x, y) -><br/>
        if      name = x then y :: base<br/>
        else if name = y then x :: base<br/>
        else                       base)<br/>
        []<br/>
        pairings<br/>
      </code>
      <code>
        let rec distance name group =<br/>
        if List.mem name group then<br/>
        0<br/>
        else<br/>
        succ (distance name<br/>
        (List.concat (List.map get_partners group)))<br/>
        (*<br/>
        Use as follows:<br/>
        distance "bob" ["ward"] (* returns 2 *)<br/>
        distance "al"  ["fred"] (* returns 3 *)<br/>
      </code>
      <ul>
        <li>
          )
        </li>
      </ul>
      <code>
        let ward_numbers = Hashtbl.create 10<br/>
      </code>
      <code>
        let rec assign_ward_number name number =<br/>
        try<br/>
        let old_number = Hashtbl.find ward_numbers name in<br/>
        if number < old_number then begin<br/>
        Hashtbl.replace ward_numbers name number;<br/>
        List.iter<br/>
        (fun partner -><br/>
        assign_ward_number partner (succ number))<br/>
        (get_partners name)<br/>
        end<br/>
        with Not_found -><br/>
        Hashtbl.add ward_numbers name number;<br/>
        List.iter<br/>
        (fun partner -><br/>
        assign_ward_number partner (succ number))<br/>
        (get_partners name)<br/>
      </code>
      <code>
        let () =<br/>
        assign_ward_number "ward" 0;<br/>
        Hashtbl.iter (Printf.printf "%s %d\n") ward_numbers<br/>
        (* outputs:<br/>
        cal 2<br/>
        dave 1<br/>
        al 1<br/>
        fred 3<br/>
        ward 0<br/>
        bob 2<br/>
        ed 2<br/>
      </code>
      <ul>
        <li>
          )
        </li>
      </ul>
      <p>
        --Anon
      </p>
      <hr/>
      <p>
        <em>Add your implementation here.</em>
      </p>
      <p>
        Hands up who can't understand the programs they posted here anymore :-). -- <a href="LukeGorrie.html">LukeGorrie</a>
      </p>
      <p>
        <em>Heck, I'm not sure I understand what I just posted!  -- </em><a href="BillTrost.html">BillTrost</a><em></em>
      </p>
      <hr/>
      <p>
        <a href="CategoryInManyProgrammingLanguages.html">CategoryInManyProgrammingLanguages</a>
      </p>
    </div>
  </body>
</html>