<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Incremental Unix Shell Development
      </h1>
      <p>
        In "The UNIX Philosophy"  Gancarz gives an important rule. It is something like this: "It's better to have something that works 90% of the time now, than something that works 100% of time later."
      </p>
      <p>
        The point is that it pays off rapidly to have simple 90% OK scripts + human intelligence for the remaining 10%.  You plugin the 90% of the remaining 10% (actually 9% of the original) when you figure out a neat way to do it.
      </p>
      <p>
        Typical growth can be classified as horizontal, vertical, and parallel. In horizontal growth the script works under most conditions and fails in certain special cases.  The growth consists of filling in some more special cases.  In Vertical growth the script solves part of the problem and then stops. The user has to provide the missing step.  Vertical growth occurs when a new set of steps is added to the end of a script.  Finally, In UNIX you have parallel growth where a pipe (or socket) connects the old and new parts.
      </p>
      <p>
        I've got scripts that are 10 years old and still growing.
      </p>
      <p>
        The other thing that happens is that once scripted you forget about the problem. Some of my pre-teen scripts often seem wiser than I am.
      </p>
      <p>
        --<a href="DickBotting.html">DickBotting</a>
      </p>
      <p>
        <em>I am not sure I agree with the idea of having something work 90% of the time.  I would suggest the goal is to have 90% (or some number) of the functionality working 100% of the time.  The implemented software needs to be reliable more than it needs to be complete.</em>
      </p>
      <hr/>
      <p>
        It sounds like one might want to aim for parallel growth, as connecting small programs with plumbing is the <a href="UnixWay.html">UnixWay</a>.
      </p>
      <p>
        Out of curiousity, could you provide examples of scripts in the "10 years old and still growing" and "smarter than I am" categories?
      </p>
      <hr/>
      <p>
        Here is one of my iterative development techniques:
      </p>
      <p>
        When doing lots of development in a shell environment, why type in the full path of the shell script when you want to edit it? Try this instead:
      </p>
      <code>
        if [ "$1" = "-edit" ] ; then<br/>
        exec "${EDITOR:-vi} $0"<br/>
        exit 1<br/>
        fi<br/>
      </code>
      <p>
        This replaces the invocation of the shell with an editor session that edits the script itself. It's a lot like <a href="WikiWikiWeb.html">WikiWikiWeb</a> that way.
      </p>
      <p>
        -- <a href="DavidCymbala.html">DavidCymbala</a>
      </p>
      <p>
        <em>Just be very careful to remove this functionality when you deploy. Its probably not exploitable most of the time, but it smells like a security hole just waiting for some careless sysadmin to set the </em>SetUid flag.<em></em>
      </p>
      <hr/>
      <p>
        I agree about the stability -- without it, you're looking at a third party developer who thinks they own the system (even if they don't know it).  They'll take down, override, or replace some innocuous program on the system that happens to be very important or start running a process so high in priority that only a hard reboot would stop it.
        <a href="WyattMatthews.html">WyattMatthews</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryUnix.html">CategoryUnix</a> <a href="CategoryUnixShellPattern.html">CategoryUnixShellPattern</a>
      </p>
    </div>
  </body>
</html>