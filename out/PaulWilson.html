<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Paul Wilson
      </h1>
      <p>
        Mid-life crisis intervention strategy: conquer hangups that have prevented me from accepting the perceived constraints of learning how to program a computer.
      </p>
      <p>
        Brief experiments with procedural programming (Basic, first on Timex Sinclair, later on original IBM PC) met with repeated failure at a very early stage, possibly because it quickly seemed apparent to me that I simply didn't want to program at all if it meant I had to know the solution to the problem first. (I know better now.) I think somewhere deep inside I simply refused to think like my father, an uber geek of the first water. (I need to expand on the psychological block I have to programming, a discipline I have wanted to master since the age of six, and have powerfully resisted all my life.)
      </p>
      <p>
        Not at all sure object orientation solves my problems, but willing to give Python a chance.
      </p>
      <p>
        Much more attracted to Lisp and functional style. Willing to be a one-man <a href="UnitTest.html">UnitTest</a> to <a href="PaulGraham.html">PaulGraham</a>'s dictum, "I don't expect to convince anyone (over 25) to go out and learn Lisp." I'm increasingly leaning towards making Lisp my native computer programming language, and learning Python as a utility language.
      </p>
      <p>
        Dedicated to understanding, not cookbook programming. Brushing up on finite math. Fairly well-read newbie wannabe perspective is that object oriented means perpetual ontology wars inside my head and in my code, but simple functions are simple, period, and composing them is equally simple. Ergo, details of hundreds of built-in functions aside, I just might be able to truly understand Lisp. And CLOS would let me have access to how I want classes to work in the first place. The very idea of macros in Common Lisp makes my head spin. For the kind of knowledge representation problems that interest me -- a professional student of the history of ideas -- I can see where this might be handy, and where Python might break down.
      </p>
      <p>
        Need to refactor this into something semi-coherent. I want to capture a "before" picture of where my confused head is at before "diving into Python" (<a href="MarkPilgrim.html">MarkPilgrim</a>'s excellent tutorial) or any of the several excellent Lisp tutorials I've found.
      </p>
      <p>
        I'll try to keep my purely factual contributions to this wiki in <a href="GoodStyle.html">GoodStyle</a> form, but thought this as good a place as any on the Web to keep myself honest.
      </p>
      <hr/>
      <p>
        <em>What are you programming? What are you going to make?</em>
      </p>
      <hr/>
      <p>
        '"What are you programming?"
      </p>
      <p>
        Right now, my willpower.
      </p>
      <p>
        I'm simply not in the mood to fail at teaching myself programming, once again. I'm blaming procedural programming and convincing myself I just wasn't prepared to compete with my father on his own turf. But I'll save that story for the book. ;)
      </p>
      <p>
        '"What are you going to make?"
      </p>
      <p>
        Probably, a mess of my mind!
      </p>
      <p>
        With Python, I want to try my hand at some basic text processing, relational database and Web applications. I think I'll let the Quixote framework be my guide: looks very clean and potentially understandable from here and it covers most of what I want to know about the sorts of programs that could solve most of the business problems I can imagine. "Novice programmers can also learn Quixote and once learned, their new-found skills can be applied to other Python programming tasks." <a href="http://www.quixote.ca/overview/paper">http://www.quixote.ca/overview/paper</a> I'll be the <a href="UnitTest.html">UnitTest</a> for that claim. Something relatively simple, but still requiring a relational database, perhaps a Web app and closely related desktop app for parking reading notes and sources.
      </p>
      <p>
        The truly hard problems, the ones I don't understand, those I'm saving for Lisp.
      </p>
      <p>
        With Common Lisp, I first need to get more comfortable with Emacs, probably by writing some extension. I'm thinking of a foldable outline mode with the added capability of cloning nodes or branches, kind of like the ancient outline processor More! or the Python "programmer's outlining editor" Leo, at <img src="http://webpages.charter.net/edreamleo/front.html." /> Not to reinvent an already existing mode, simply to make it my own, and as an exercise in graph theory. But I don't want to diddle with tools too much, I just want to feel at home in Emacs, a truly Baroque environment, but obviously the tool of choice for interacting with Common Lisp. I want to see if I can learn to actually think in Common Lisp. In many ways I imagine I already do think in a Lispy way and always have -- my first memory was deeply recursive. But I'll save that weird image for the movie. ;) (I'm certainly lazy enough to be a good Lisp programmer!) Then I want to concentrate on working through <a href="PaulGraham.html">PaulGraham</a> and <a href="PeterNorvig.html">PeterNorvig</a> so I can get started with some powerful intelligence amplifiers. I'd like to see if I can't train a neural net to resolve to a set of fuzzy rules. Imagine a classic marketing managers' problem: you have oodles of tabular data and lots of ways to dice and splice it, but are hamstrung when it comes to making a decision. You need help throwing away data, not necessarily even more data, even more correlations: you need good rules of thumb so you can turn on a dime and make a deal or let it go.
      </p>
      <p>
        What a boring business example, but I have some rough ideas for applying the same sort of computer-aided abstraction to the interpretation of semantically marked up humanities texts. For instance, it is trivial to mark up Othello with some mono-hierarchical XML representation of perceived meaningful elements, but damned hard to have such a representation tell you anything interesting about Iago. He said thus and such about his own character, and acted this way and that, and others said other things about his character, and acted towards him so and such. All that gives you is a table of say sos and do sos, but no way of weaving a coherent web of character traits. I'll have to think about that some more. A better example: The Sun Also Rises has many readily apparent themes, revolving around values and war and potency and style and many more, all easily marked on first occurrence, but some themes are apparently more important than others. What is their relationship? I want to experiment with such richly ambiguous texts as a means of generating, as well as checking, alternative interpretations. All interpretations are not created equal. An interpretation that accounts for more textual elements than another -- one that exercises more code, as it were -- may well be preferred to one that only picks up on a smaller subset of textual features that have been marked as significant. People do this very well, of course, but a trained neural net resolved to some fuzzy rules that subsume lesser semantic categories might be a great aid for understanding complex texts and interpretations. If that doesn't make much sense to you, just imagine how I feel! I want to build my own refracting textscope for macro and micro analysis of texts and I'm not quite sure how it will work. But in any case, I am sure that this is roughly how I wrote some of my best essays way back when and I still haven't found any computer aids for this process of enfolding meanings.
      </p>
      <p>
        Those are the sorts of problems that deeply interest me. Why are people so smart and computers so dumb? How can we help each other?
      </p>
      <p>
        Thanks for asking. TMI, I know. I hope my absolute newbieness and self-confessed wannabe smug Lisp weenie status doesn't offend anyone here. I'll keep my half-baked ideas to myself for a while. Except for here: I'd like to use this page to take notes on my progress. Not a blog, but a log of sorts. Somehow I don't understand, conducting my self-education in public makes it real for me. -- <a href="PaulWilson.html">PaulWilson</a> -- 1 August 2004 
      </p>
      <hr/>
      <p>
        <a href="CategoryHomePage.html">CategoryHomePage</a>
      </p>
    </div>
  </body>
</html>