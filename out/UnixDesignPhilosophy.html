<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Unix Design Philosophy
      </h1>
      <p>
        Mike Gancarz published a little book on this in 1995:
      </p>
      <p>
        <strong>The UNIX Philosophy</strong>
      </p>
      <p>
        Digital Press, Newton, MA 1995, 151 pp., $19.95, ISBN 1-55558-123-4
      </p>
      <p>
        He has two lists of tenets: 9 main ones and 10 lesser ones.
        Here are some examples:
      </p>
      <ul>
        <li>
           Small is beautiful. 
        </li>
        <li>
           Make each program do one thing well. 
        </li>
        <li>
           Build a prototype as soon as possible. 
        </li>
      </ul>
      <hr/>
      <p>
        The full list, with commentary by Simon Dobson, taken from <a href="http://www.cs.tcd.ie/Simon.Dobson/teaching/unix-philosophy.html">http://www.cs.tcd.ie/Simon.Dobson/teaching/unix-philosophy.html</a> :
      </p>
      <p>
        The major tenets 
      </p>
      <ul>
        <li>
           Small is beautiful. Small things have tremendous advantages over their larger counterparts. Among these is the ability to combine with other small things in unique and useful ways. 
        </li>
      </ul>
      <ul>
        <li>
           Make each program do one thing well. By focusing on a single task, a program can eliminate much extraneous code that often results in excess overhead, unnecessary complexity, and a lack of flexibility. 
        </li>
      </ul>
      <ul>
        <li>
           Build a prototype as soon as possible. Most users looking for a new piece of software won't know what they really want until they see it, so requirements documents are often misleading about the users' real needs. The Unix design philosophy makes prototyping a central part of the methodology: give the user something, anything, up-front to criticise, and work from there. 
        </li>
      </ul>
      <ul>
        <li>
           Choose portability over efficiency. If today's hardware just about runs a program with just about adequate efficiency, tomorrow's will run it with power to spare. So the developer's task is to make sure his program will run on that new hardware with minimal effort. 
        </li>
      </ul>
      <ul>
        <li>
           Store data and configuration info in flat ASCII files. Valuable data will generally out-live any one program, machine, programming language or use. Data is only useful as long as it's being used, and flat files help ensure that data is usable for the longest possible time. For complex data structures where flat text really isn't appropriate, use a structured text format like XML instead: you can always strip-out the mark-up to get at the raw data. 
        </li>
      </ul>
      <ul>
        <li>
           Use software leverage to your advantage. Many programmers have only a superficial understanding of the importance of re-usable code modules. Code re-use helps one take advantage of software leverage, a powerful concept that some Unix developers use to create numerous applications in a comparatively short time. 
        </li>
      </ul>
      <ul>
        <li>
           Use shell scripts to increase leverage and portability. Scripts generate huge leverage - every line of script can invoke several "proper" programs each with several thousand lines of code. A programmer who can't re-use other programs is condemned to re-write them. 
        </li>
      </ul>
      <ul>
        <li>
           Avoid captive user interfaces. A program which prevents to user using any other commands for the duration "captures" the user and prevents him from taking advantage of other commands. A program should be usable in many modalities to maximise its usefulness. 
        </li>
      </ul>
      <ul>
        <li>
           Make every program a filter. The fundamental nature of all software programs is that they can only modify data, never create it. Therefore they should be written to function as filters since they are filters. 
        </li>
      </ul>
      <p>
        The minor tenets 
      </p>
      <ul>
        <li>
           Allow the user to tailor the environment. No single decision will suit all users - so don't force one upon them. The more tailorable an environment is, the more users can match it to their needs and the more they'll like it. 
        </li>
      </ul>
      <ul>
        <li>
           Make operating system kernels small and lightweight. Despite the never-ending push for new features, Unix developers prefer to keep the most central part of the operating system small. They don't always succeed at this, but this is their goal. 
        </li>
      </ul>
      <ul>
        <li>
           Use lower case and keep it short. Using the lower case is a tradition in the Unix environment that has persisted long after the reason for doing so (that it's easier to read text with descenders on a teletype) disappeared. 
        </li>
      </ul>
      <ul>
        <li>
           Save trees. Data committed to paper is essentially dead. There are good reasons for keeping all text on-line and using powerful tools to manipulate it. 
        </li>
      </ul>
      <ul>
        <li>
           Silence is golden. A silent command is often more usable, providing the function asked for and nothing more. You can always provide wrappers for people who prefer a more conversational tone. (See <a href="RuleOfSilence.html">RuleOfSilence</a>, compare with <a href="SilentFailureNoisySuccess.html">SilentFailureNoisySuccess</a>)
        </li>
      </ul>
      <ul>
        <li>
           Think parallel. Most tasks are composed of sub-tasks which may be attacked in parallel. This also applies to user interactions. Parallelism can save a great deal of time and frustration. 
        </li>
      </ul>
      <ul>
        <li>
           The sum of the parts is greater than the whole. A large application built from a collection of smaller programs is more flexible and hence more useful than a single large program. The same functional capability may exist in both solutions, but the collection-of-small-programs approach is the more forward-looking of the two. 
        </li>
      </ul>
      <ul>
        <li>
           Look for the 90% solution. Doing 100% of anything is difficult. Doing only 90% is far more efficient and cost-effective. Handle the 90% and let the 10% fend for themselves - often they'll handle their own special requirements far better than you would anyway. (<a href="EightyTwentyRule.html">EightyTwentyRule</a>)
        </li>
      </ul>
      <ul>
        <li>
           Worse is better. That which is cheap but effective is far more likely to proliferate than that which is high quality and expensive. The PC-compatible world borrowed this idea and made quite a go of it.... 
        </li>
      </ul>
      <ul>
        <li>
           Think hierarchically. Hierarchies allow tasks and attributes to be applied uniformly across nested elements. This is a powerful idea that encourages decomposition and modularity. (Counterview: <a href="LimitsOfHierarchies.html">LimitsOfHierarchies</a>)
        </li>
      </ul>
      <hr/>
      <p>
        And some, equally important ones, not normally voiced.
      </p>
      <ul>
        <li>
           Implementation simplicity is more important that interface simplicity.
          <ul>
            <li>
               Not even jwz formulated it thus, IIRC.  It was "simplicity of implementation instead of simplicity of using code" or something thereabouts.  Unix interfaces are not particularly complicated; they just force extra work upon the user.
              <ul>
                <li>
                   Actually, <a href="RichardGabriel.html">RichardGabriel</a> said in his <a href="WorseIsBetter.html">WorseIsBetter</a> essay "the design must be simple, both in implementation and interface. It is more important for the implementation to be simple than the interface. Simplicity is the most important consideration in a design." <a href="http://www.jwz.org/doc/worse-is-better.html">http://www.jwz.org/doc/worse-is-better.html</a>
                </li>
              </ul>
            </li>
            <li>
               I would be interested in seeing an example of this design choice.
              <ul>
                <li>
                   <a href="CeeLanguage.html">CeeLanguage</a>, perhaps? <a href="EdIsTheStandardTextEditor.html">EdIsTheStandardTextEditor</a> might be even more apt. The original shell (pre-Bourne, even) was quite primitive and not especially good as an interactive shell.
                </li>
                <li>
                   <em>That misses the mark. The v6 shell was simple, certainly, but it was better than most, perhaps even better than all, other CLIs on small computers at the time (16 bit minicomputers, not larger e.g. 36 bit computers), and in that sense, was neither primitive nor bad as an interactive shell.</em>
                </li>
                <li>
                   Well, the Unix filesystem API is "simple" (open, read, write, seek, close, link, unlink, ...) but no system call is guaranteed to succeed (not even close(), pun intended) and few are guaranteed to either do something totally or nothing at all.
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
           Make it run on the cheapest/slowest hardware
          <ul>
            <li>
               Doesn't this conflict with "Choose portability over efficiency" above?
              <ul>
                <li>
                   Not really, since low-end hardware seems to reliably take over the market after a few iterations. Look at how many high-end systems are x86-based these days, and how few people cared when SGI died and took their shiny Indy boxes with them. For older examples, <a href="DigitalEquipmentCorporation.html">DigitalEquipmentCorporation</a>'s MiniComputers were pretty pitiful in 1960 but a decade or so later Unix (another low-end solution that won big) was able to ride them into a respectably dominant marketshare. Then DEC itself was killed from below when the x86 machines got interesting...
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <code>
        SGI: I'm not dead yet!<br/>
        NASDAQ: Here -- he says he's not dead!<br/>
        CUSTOMER: Yes, he is.<br/>
        SGI: I'm not!<br/>
        NASDAQ: He isn't.<br/>
        CUSTOMER: Well, he will be soon, he's very ill.<br/>
        SGI: I'm getting better!<br/>
        CUSTOMER: No, you're not -- you'll be stone dead in a moment.<br/>
        NASDAQ: Oh, I can't trade him like that -- it's against<br/>
        regulations.<br/>
        SGI: I don't want to be delisted!<br/>
        CUSTOMER: Oh, don't be such a baby.<br/>
        NASDAQ: I can't take him...<br/>
        SGI: I feel fine!<br/>
        SGI: I think I'll go for a walk.<br/>
        SGI (singing): I feel happy... I feel happy.<br/>
        CUSTOMER: You're not fooling anyone y'know. <br/>
      </code>
      <code>
        [with apologies to Monty Python and the Holy Grail]<br/>
      </code>
      <ul>
        <li>
           Follow the <a href="EightyTwentyRule.html">EightyTwentyRule</a>
        </li>
      </ul>
      <hr/>
      <p>
        See <a href="SmallIsBeautiful.html">SmallIsBeautiful</a>, <a href="DoOneThingAndOneThingOnly.html">DoOneThingAndOneThingOnly</a>, <a href="EarlyPrototyping.html">EarlyPrototyping</a>, <a href="PowerOfPlainText.html">PowerOfPlainText</a>, <a href="IncrementalUnixShellDevelopment.html">IncrementalUnixShellDevelopment</a>, <a href="PipesAndFilters.html">PipesAndFilters</a>, <a href="ManPage.html">ManPage</a>, <a href="RuleOfSilence.html">RuleOfSilence</a>, <a href="WorseIsBetter.html">WorseIsBetter</a>.
      </p>
    </div>
  </body>
</html>