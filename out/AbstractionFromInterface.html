<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Abstraction From Interface
      </h1>
      <p>
        [In part, this addresses some of <a href="MartinLippert.html">MartinLippert</a>'s questions from <a href="RefactoringFrameworkBasedApplications.html">RefactoringFrameworkBasedApplications</a>.]
      </p>
      <p>
        <strong>Forces:</strong>
      </p>
      <ul>
        <li>
           You have to deal with an interface that you find objectionable, inconvenient, or inappropriate -- it may not be well designed to meet your particular needs.
        </li>
      </ul>
      <ul>
        <li>
           You can't change the interface because the system "on the other side" of the interface is on a different release schedule:  It may be maintained by some other independent group in your company, it may be a 3rd party purchased vendor product, or it may be a framework in use by a number of projects -- not just yours.
        </li>
      </ul>
      <p>
        <strong>Solution:</strong>
      </p>
      <ul>
        <li>
           Put a layer of abstraction between yourself and the parts of the interface that display the greatest <a href="ImpedanceMismatch.html">ImpedanceMismatch</a> with your code.
        </li>
      </ul>
      <p>
        <strong>Particulars:</strong>
      </p>
      <p>
        If you inherit from an excessively large interface, having a "split personality" of functionality, then <a href="ExtractClass.html">ExtractClass</a> each logical piece of functionality.
      </p>
      <ul>
        <li>
           Seen in <a href="RefactoringWithDesawareNtServiceToolkit.html">RefactoringWithDesawareNtServiceToolkit</a>, where the IdwEasyService interface you must implement includes both service control (start/stop/pause/resume) and scheduling (timer) interfaces (and one or two others):  Extract the functionality of interest to your application to separate control and scheduler classes; you can control the interfaces of these classes.
        </li>
      </ul>
      <p>
        If you must work with an excessively complicated and robust interface that does much more than you need, build a simple adaptor for your use that hides the complexity of the full interface.  (<a href="AdapterPattern.html">AdapterPattern</a>)
        This is commonly an issue with database interfaces like ADO, DAO, RDO, ODBC and JDBC; each of these interfaces can and should be able to do much more than just the things you need to do for any particular application.
      </p>
      <ul>
        <li>
           Seen in <a href="RefactoringWithComPlusTechnologies.html">RefactoringWithComPlusTechnologies</a>, where the framework gives no particular support for interfacing with the database, making room for an entire library or framework to be introduced at that end.  The framework is also weak on the business objects end, suggesting <a href="CodeGeneration.html">CodeGeneration</a> or creative use of COM metadata for data driven processing -- another strong opportunity for code reuse building up to a full library or framework.
        </li>
      </ul>
      <p>
        <strong>Results:</strong>
        This approach can very easily lead to a <a href="LayeredApplicationFramework.html">LayeredApplicationFramework</a>, where you build custom framework(s) to meet your needs on top of existing frameworks that are somewhat resistant to change.
      </p>
      <hr/>
      <p>
        <a href="CategoryAbstraction.html">CategoryAbstraction</a>
      </p>
    </div>
  </body>
</html>