<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        God Language
      </h1>
      <p>
        A language that attempts to be everything to everybody, or at least address frequently-reoccurring concerns such as concurrency, security, collection-handling, persistence, scaling, distributed programming, exception handling, etc.
      </p>
      <p>
        For comparison, the opposite is generally separate services that attempt to be app-language neutral. 
      </p>
      <hr/>
      <p>
        Top's term for his personal experience of <a href="BlubParadox.html">BlubParadox</a>. {And for any language that isn't <a href="ExBase.html">ExBase</a> or <a href="BrainfuckLanguage.html">BrainfuckLanguage</a>...}
      </p>
      <p>
        <em>Paul Graham's </em><a href="GodLanguage.html">GodLanguage</a> would probably be a new form of Lisp with lots of libraries. I don't entirely disagree with that, but doubt it fits in with developers' existing human nature well. And, I doubt he'd buy the view that heavy types and objects will save the universe.<em></em>
      </p>
      <p>
        I've told you a million times, stop exaggerating!  "Save the universe," indeed!  However, when the requirements dictate "heavy types" (whatever those are) and objects, it's nice to have them.  A <a href="GodLanguage.html">GodLanguage</a>, as described at the top of this page, sounds great.  So does a new form of Lisp with lots of libraries.
      </p>
      <p>
        <em>The "requirements"? And is exaggeration different than </em><a href="HandWaving.html">HandWaving</a>? I can't keep your sin classification system strait.<em></em>
      </p>
      <p>
        Don't you mean "straight"?  Exaggeration is different from <a href="HandWaving.html">HandWaving</a>.  Exaggeration is "objects will save the universe", i.e., gross hyperbole.  <a href="HandWaving.html">HandWaving</a> is "Paul Graham's <a href="GodLanguage.html">GodLanguage</a> would probably be a new form of Lisp with lots of libraries", i.e., idle speculation without evidence.
      </p>
      <p>
        Yes, "requirements".  Y'know, those things that users are asking for, i.e., the reasons we write software.
      </p>
      <p>
        <em>Usually, it's an implementation decision, not a fundamental requirement.</em>
      </p>
      <p>
        Implementation decisions may be arbitrary, but they shouldn't be.  They should be based on requirements.
      </p>
      <p>
        <em>That's the million-dollar issue: how to turn software design from an art into a practical science. When there's too many variables involved, people tend to pick their favorite variables and </em><a href="HobbyHorse.html">HobbyHorse</a> them.<em></em>
      </p>
      <p>
        Why can't it be both?  Since every new application is a unique creation, software development is obviously a craft.  Crafts -- which range from making ornate cutlery to constructing skyscrapers -- are equal parts art, engineering, and science.  
      </p>
      <p>
        <em>The majority of the sky-scraper project has to be tested via the laws of physics. For the most part those are not a matter of opinion. (Disputes about the physics of buildings can usually be settled by using math and models. In some cases the economics of testing certain scenarios to their fullest may be an issue.) Different designs can be tested against the laws of physics in a fairly straight-forward way. Physics is the elephant in the room as far as dictating options. There's nothing of comparable size in software engineering. Machine performance is the closest, but it has gradually been shrinking over time such that the "art" side of things is larger and larger component percentage-wise. (Generally I see the mid 1970's as the break-even point where software issues appeared to pass hardware issues in importance. This is based on "software crisis" sort of articles that started popping up around that time.) Engineering doesn't have the type of great holy-wars and fad-cycles that software-engineering does. The </em>'variety of different solution paths<em>' appears far greater in software engineering than in physical engineering.</em>
      </p>
      <p>
        To be useful, software is ultimately constrained by functional and non-functional requirements, and perhaps aesthetics.  This also applies to most craft objects.  The variety of different solution paths for these is infinite, but frequently constrained in practice by tradition.  The construction of skyscrapers owes as much to tradition as it does to physics.
      </p>
      <ul>
        <li>
           Some of this comes from fear of getting sued (<a href="RealProfessionalsGetSued.html">RealProfessionalsGetSued</a>). If you try something without a history and it fails, you are far more likely to lose in a court case. In software we can take far greater risks with new tools and approaches in comparison because people are less likely to die. (Imagine being paid to build software for a medical safety device, you'd be far more likely to select Ada than <a href="RubyOnRails.html">RubyOnRails</a>. In other words, something that's been used in the field for a decade or two.)
        </li>
      </ul>
      <p>
        As for HobbyHorsing, yes, I've noticed your inclination to view everything through <a href="TableOrientedProgramming.html">TableOrientedProgramming</a> glasses. [moved closer to reply]
      </p>
      <p>
        <em>Catoring to </em><a href="HobbyHorse.html">HobbyHorse</a>s is not necessarily a bad thing. Fitting the <a href="WetWare.html">WetWare</a> of the developer can result in productivity gains I contend. But I don't claim that my HH will fit every mind. I don't claim One True Language/Paradigm/Methodology. You, on the other hand, seem to imply a logically-discoverable Single Right Way. But your justification and demonstration is very round-about and devoid of examinable scenarios/tests. Related: <a href="TooManyVariablesForScience.html">TooManyVariablesForScience</a>.<em></em>
      </p>
      <ul>
        <li>
           {Your view of the role of science is naive and, frankly, incorrect. You think the role of science and logic is 'discovery' of concepts - things that can be demonstrated. What science does is 'kill' models and concepts. Science is a rather negative discipline that forever says "you're wrong" and never, ever says "you're right". The best you can hope for science to say is: "I haven't figured out why your hypothesis is wrong. Yet.", and for it to say the same thing for long enough - under enough <em>new</em> observations - that the hypothesis becomes a theory. Further, from <a href="GoedelsIncompletenessTheorem.html">GoedelsIncompletenessTheorem</a> and <a href="RicesTheorem.html">RicesTheorem</a>, much the same can be said of mathematics and computation: math can prove some true things true, and some false things false, but there will forever be a gap where one cannot prove anything at all. That you imagine logical models derived of science would find a "Single Right Way" (or establish <em>any</em> "Right Way") mostly tells me that you really, truly, don't grok science.}
          <ul>
            <li>
               Discussion moved to <a href="ApplyingScienceDiscussion.html">ApplyingScienceDiscussion</a>.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           {The person you assert as claiming a "Single Right Way" has <strong>never</strong> claimed any such thing, and is rather insulted by your fabricated lies and insinuations. There is a meta-physical universe of difference between achieving a "Single Right Way" and simply rejecting the "Known Wrong Ways".}
        </li>
        <li>
           Well, all stated "Known Wrong Ways" seem to punch out a pattern in the paper that strongly resembles the type-centric <a href="GodLanguage.html">GodLanguage</a> concept when held up to the light. Technically you may be right. In practice it's merely a round-about version of "Single Right Way".
        </li>
        <li>
           {In practice, it's an attempt to systematically and incrementally achieve progress. Your insinuations about a "Single Right Way" are malicious and vile attempts to associate a reasonable approach with something absurd that you may then attack - a <a href="StrawMan.html">StrawMan</a>. Your entire line of sophistry on this issue is insulting.} 
          <ul>
            <li>
               If I mischaracterized it, it's because you failed to supply sufficient details, not because I am evil. <strong>Show</strong> it being better so that my description of it doesn't matter. You could say, "code snippet 5 shows that you are wrong because line 7 doesn't have to wait for message X to make an estimate...etc..." <a href="RaceTheDamnedCar.html">RaceTheDamnedCar</a>. Show your grand language/tool kicking P/R's butt in semi-realistic scenarios. Show you understand working with the real world instead of merely diddling with idealistic ivory-tower toys.  <strong>Show Don't Talk.</strong>
            </li>
          </ul>
        </li>
        <li>
           {And your comment on type-centrism is ridiculous, but is more likely because in your skewed perceptions you imagine any mention of 'types' in any context whatsoever is equivalent to raising them to a central position. <a href="TypeSafety.html">TypeSafety</a> (in the broad sense: proving programs won't have undefined behavior - a practice that might not involve "types" at all) is important to almost every other language feature, but <a href="TypefulProgramming.html">TypefulProgramming</a> and <a href="ManifestTyping.html">ManifestTyping</a> are not; of those, the former is of questionable value (not enough data on <a href="FeatureInteraction.html">FeatureInteraction</a>), and the latter is (if required) very problematic.}
        </li>
      </ul>
      <p>
        You confuse me with someone else.  I have, on occasion, countered ill-considered or poorly-defended (see <a href="HandWaving.html">HandWaving</a>) criticism (mostly yours).  I have, on occasion, expressed personal interest in <a href="ObjectOrientation.html">ObjectOrientation</a>, <a href="FunctionalProgramming.html">FunctionalProgramming</a>, the <a href="RelationalModel.html">RelationalModel</a> and <a href="ExtendedSetTheory.html">ExtendedSetTheory</a>, but I neither promote nor deprecate any of these.  As a scientist, I only promote rigour and deprecate imprecision.
      </p>
      <p>
        <em>I suggest you create a handle and </em>PersonalPage so that I don't confuse you with bracket guy (if you are different than bracket guy....bracket guys?).<em></em>
      </p>
      <p>
        I have a PersonalPage, but I believe in an <a href="EgolessWiki.html">EgolessWiki</a>.  I suggest you address the text in front of you, within the discussion(s) in which it appears, rather than make sweeping statements about who you assume I am.  <a href="AttackIdeasNotPeople.html">AttackIdeasNotPeople</a>.  I am sometimes bracket guy, sometimes italics guy, sometimes plain text guy, and sometimes all on one page, solely as needed to disambiguate points within a thread.
      </p>
      <p>
        <em>There's implications of prior debates floating around. I'll try to point them out if they appear again.</em>
      </p>
      <hr/>
      <p>
        <strong>High-End of Each Idiom</strong>
      </p>
      <p>
        Those proposing a <a href="GodLanguage.html">GodLanguage</a> on this wiki generally seem to want to take the "best known" common idioms of computing, such as concurrency, security, collection-handling, persistence, scaling, distributed programming, exception handling, etc. For example, it will come built-in with the best (alleged) security techniques known. 
      </p>
      <p>
        I see at least two potential problems with this. First, it will give it a high learning curve. Even if one only wants the basics of one of the aspects for a given project, say basic concurrency, one has to learn how the top-of-the-line security system works. It's like being forced to learn how to use a tractor when a shovel would be sufficient.
      </p>
      <p>
        The second is that a new "best known" idiom may come along, making existing code obsolete. Perhaps it may require a complete change of the language even to effectively use the newcomer. 
      </p>
      <p>
        The high-end chase puts a lot of faith in <a href="BigDesignUpFront.html">BigDesignUpFront</a>. -t
      </p>
      <p>
        I disagree. I don't need to know how top-of-the-line <a href="GarbageCollection.html">GarbageCollection</a> works in order to add numbers in a language possessing a garbage collector, and I won't need to know how top-of-the-line security works to learn and use standard concurrency and concurrency-control idioms. Admittedly, <em>someone</em> probably needs to think about security properties when developing concurrency-control patterns (lest they introduce high risk of <a href="PriorityInversion.html">PriorityInversion</a> or <a href="DeadLock.html">DeadLock</a> as a <a href="DenialOfService.html">DenialOfService</a> attack), but that burden should be on the standard library or language designer rather than on individual users. And though a particular means of expressing concurrency or collection-handling might be considered 'idioms' and become obsolete, the concurrency and collection concepts will be around for as long as we have at least 2 CPUs in this world. Sure, if a language becomes obsolete, some people might need to learn new language skills - but they'll never need to relearn <em>everything</em>. Such is the nature of progress. 
      </p>
      <ul>
        <li>
           <em>The basic concepts of security may still be there, but not necessarily the details of the language interface. There are usually many ways to express the same things.</em>
        </li>
        <li>
           Huh? 
        </li>
      </ul>
      <p>
        Also, language design isn't <a href="BigDesignUpFront.html">BigDesignUpFront</a>. If it were truly BDUF, you'd never hear of something like "algol derived" languages, you would not be able to trace lineages of language. The only reasonable way to understand language design is as an iterative process, with versioning and forks and plenty of history and experimentation to study.
      </p>
      <p>
        <em>But the iterative path may be much larger for a language that attempts to integrate so many concepts.</em>
      </p>
      <p>
        Sure. Why is that a problem?
      </p>
      <hr/>
      <p>
        There is only one God language.
      </p>
      <p>
        <img src="http://imgs.xkcd.com/comics/lisp.jpg" />
      </p>
      <p>
        <em>Well.  That explains a few things....</em>
      </p>
      <p>
        {I classify Lisp as a meta-language, not a language. However, I'm sure we can <a href="LaynesLaw.html">LaynesLaw</a> this up the wazoo.}
      </p>
      <ul>
        <li>
           Under which conditions is a meta-language not also a language?
        </li>
      </ul>
      <p>
        [Like many general-purpose programming languages, Lisp can be used to define sublanguages within its own environment.  It shares this capability with FORTH, C/C++ with macro pre-processing, and many others.  However, these are all regarded to be languages that have meta-language capability. None would be considered to be "a meta-language, not a language".  In that category (assuming by "language" you mean "programming language") are specialists like <a href="BackusNaurForm.html">BackusNaurForm</a>.  You seem to be emphasising Lisp's <a href="MetaLanguage.html">MetaLanguage</a> capability to the point of excluding everything else it does.  In typical practice, its <a href="MetaLanguage.html">MetaLanguage</a> capability is of relatively minor importance.]
      </p>
      <p>
        {One gets a different answer no matter which Lisp affectionado they ask.}
      </p>
      <p>
        [Maybe, but the rest of my point holds true.  Categorising Lisp as "a meta-language, not a language" is incorrect regardless which Lisp "affectionado" anyone asks.]
      </p>
      <p>
        {As <a href="MentalMasturbation.html">MentalMasturbation</a>, I wonder, has anybody tried to make an app programming language based on <a href="BackusNaurForm.html">BackusNaurForm</a>? Naurtran? Back++?}
      </p>
      <ul>
        <li>
           [I don't know.  I wonder, has anybody tried to make a cheese based on a bicycle?]
        </li>
        <li>
           Close enough? <a href="http://www.crunchgear.com/2010/06/04/new-bicycle-helmet-wafts-stinky-cheese-smell-from-your-head-when-you-fall/">http://www.crunchgear.com/2010/06/04/new-bicycle-helmet-wafts-stinky-cheese-smell-from-your-head-when-you-fall/</a>
        </li>
        <li>
           [<facepalm>]
        </li>
      </ul>
      <p>
        People have developed languages based on Knuth's <a href="AttributeGrammar.html">AttributeGrammar</a>s.
      </p>
      <hr/>
      <p>
        See Also: <a href="CompilingVersusMetaDataAid.html">CompilingVersusMetaDataAid</a>
      </p>
      <hr/>
      <p>
        <a href="NovemberZeroNine.html">NovemberZeroNine</a>
      </p>
    </div>
  </body>
</html>