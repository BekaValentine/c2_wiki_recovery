<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Quine Program
      </h1>
      <dl>
        <dt>quine</dt>
        <dd>in computing, a program producing its complete source code as its only output without simply opening the source file of the program and printing the contents (such actions are considered cheating).</dd>
      </dl>
      <p>
        This type of program is offered as a somewhat more interesting alternative to <a href="HelloWorld.html">HelloWorld</a> programs.
      </p>
      <p>
        Quines are named after the logician <a href="WillardVanOrmanQuine.html">WillardVanOrmanQuine</a>.
      </p>
      <hr/>
      <p>
        Why are quines so interesting ?
        Because they are "obviously impossible".
      </p>
      <ul>
        <li>
           Can you print "Hello, world." ?
        </li>
        <li>
           <em>Easily.</em>
        </li>
      </ul>
      <code>
        print("Hello, world.")<br/>
      </code>
      <ul>
        <li>
           So now you know how to print *anything*.
        </li>
        <li>
            <em>A few things are a bit tricky, but yes -- anything.</em>
        </li>
        <li>
           Ah, but can you print quotes around it ?
        </li>
        <li>
            <em>It's a bit tricky, but not a problem.</em>
        </li>
      </ul>
      <code>
        print("\"Hello, world.\"")<br/>
      </code>
      <ul>
        <li>
           You've just replaced the problem of the quotes with the problem of the slash.
        </li>
        <li>
            <em>No, I can print slashes as well:</em>
        </li>
      </ul>
      <code>
        print("quote: \" slash: \\ another slash: \\ another quote: \" The end.")<br/>
      </code>
      <ul>
        <li>
           Ah, but I bet you can't print the entire program.
        </li>
        <li>
            <em>Sure I can.</em>
        </li>
      </ul>
      <code>
        print("print(\"Hello, world.\")")<br/>
      </code>
      <ul>
        <li>
           Yes, that prints the hello world program. But ...
        </li>
        <li>
           <em>Oh, I see what you want.</em>
        </li>
      </ul>
      <code>
        print("print(\"print(\\\"Hello, world.\\\")\")")<br/>
      </code>
      <ul>
        <li>
           Yes, that prints *a* program. But it doesn't print *itself*.
        </li>
        <li>
           <em>It's a bit awkward, but I suppose you want this:</em>
        </li>
      </ul>
      <code>
        print("print(\"print(\\\"print(\\\\\\\"Hello, world.\\\\\\\")\\\")\")")<br/>
      </code>
      <ul>
        <li>
           Yes, that prints *a* program. But it doesn't print *itself*.
        </li>
      </ul>
      <p>
        ...
      </p>
      <ul>
        <li>
           Yes, that prints *a* program. But it doesn't print *itself*.
        </li>
        <li>
           <em>Oh. But that would ... that would require an infinite number of escapes.</em>
        </li>
      </ul>
      <code>
        print(" <some stuff> <infinite number of slashes >"Hello, world.<infinite number of slashes>" <more stuff> ")<br/>
      </code>
      <ul>
        <li>
           Sorry, my computer doesn't have an infinite amount of memory.
        </li>
        <li>
           <em>Well then. It's impossible for a finite-size source file to hold another copy of the source file inside itself. A thing cannot be bigger than itself.</em>
        </li>
        <li>
           Obviously. 
        </li>
      </ul>
      <hr/>
      <p>
        <strong></strong><a href="BasicLanguage.html">BasicLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        I made a correct QBASIC quine:
      </p>
      <code>
        A$ = "a!'dbde[39] c34);[97] 'a + c34);[98] 'b';[99] 'c';[100][101] 'e';[91] : PRINT 'CASE c';[93] ']';[33] A$;dCASE ELSE: PRINT MID$(A$, I, 1);dEND SELECTdNEXT Id"<br/>
        FOR I = 1 TO LEN(A$)<br/>
        SELECT CASE MID$(A$, I, 1)<br/>
        CASE CHR$(39): PRINT CHR$(34);<br/>
        CASE CHR$(97): PRINT "A$ = " + CHR$(34);<br/>
        CASE CHR$(98): PRINT "FOR I = 1 TO LEN(A$)";<br/>
        CASE CHR$(99): PRINT "CHR$(";<br/>
        CASE CHR$(100): PRINT<br/>
        CASE CHR$(101): PRINT "SELECT CASE MID$(A$, I, 1)";<br/>
        CASE CHR$(91): PRINT : PRINT "CASE CHR$(";<br/>
        CASE CHR$(93): PRINT "): PRINT";<br/>
        CASE CHR$(33): PRINT A$;<br/>
        CASE ELSE: PRINT MID$(A$, I, 1);<br/>
        END SELECT<br/>
        NEXT I<br/>
      </code>
      <hr/>
      <p>
        Possibly the shortest quine of all can be written in the (original, pre-Visual) BASIC language. It reproduces itself whether you list it or run it. Here it is:
      </p>
      <ol>
        <li>
           LIST
        </li>
      </ol>
      <p>
        <em>But this (and any other program) that simply outputs a source code listing should be considered cheating - for a quine to be a true quine, it must surely involve quotation.</em>
      </p>
      <p>
        [Yes, this is cheating. The canonical shortest quine using this sort of cheat was in c, with a compiler that would accept an empty file as input and construct an executable that echoed nothing to stdout. I can't recall if this was standard-conforming or just undefined behaviour though...]
      </p>
      <p>
        Almost all scripting languages allow the 'empty program' cheat. [Yeah, but it is less interesting with an interpreter - and this instance predates most scripting languages.]
      </p>
      <p>
        [It is questionable whether the 'empty program' approach even counts as cheating. It is cheating for a quine to access its own source code, either via file i/o or via special language functionality like "LIST", but an empty program does no such thing.]
      </p>
      <hr/>
      <p>
        <strong></strong><a href="BefungeLanguage.html">BefungeLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        A Befunge quine:
      </p>
      <code>
        :0g,:93+`#@_1+<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="BourneShell.html">BourneShell</a><strong></strong>
      </p>
      <hr/>
      <p>
        A trivial example in Bourne shell:
      </p>
      <code>
        #!/bin/sh<br/>
        cat $0<br/>
      </code>
      <p>
        but this is really cheating because it is using <strong>cat</strong> to read its source code. A real SRP contains a copy of its source code within the code itself.
      </p>
      <hr/>
      <p>
        Along the same lines, the one-line script:
      </p>
      <code>
        #!/bin/cat<br/>
      </code>
      <p>
        will achieve the same function without running a shell.
      </p>
      <hr/>
      <p>
        <em> What about my bash quine?</em>
      </p>
      <code>
        b=\' c=\\ a='echo b=$c$b c=$c$c a=$b$a$b; echo $a'<br/>
        echo b=$c$b c=$c$c a=$b$a$b; echo $a<br/>
      </code>
      <p>
        -- Tafuni Vito - Italy - vitotafuni_AT_gmail.com
      </p>
      <hr/>
      <p>
        Great. Here's a shell quine based on that one, but on one line:
      </p>
      <code>
        b=\' c=\\ a='echo -n b=$c$b c=$c$c a=$b$a$b\;; echo $a';echo -n b=$c$b c=$c$c a=$b$a$b\;; echo $a<br/>
      </code>
      <hr/>
      <p>
        I took Tafuni Vito's BASH quine above and made a fork bomb with it:
      </p>
      <code>
        b=\' c=\\ a='yes $( echo b=$c$b c=$c$c a=$b$a$b; echo $a ) | bash &'<br/>
        yes $( echo b=$c$b c=$c$c a=$b$a$b; echo $a ) | bash &<br/>
      </code>
      <p>
        It's a lot more heavy-duty than a traditional fork bomb, so don't complain to me if it made your system crash.
      </p>
      <hr/>
      <p>
        A Shell "quine":
      </p>
      <code>
        z=\' a='z=\\$z a=$z$a$z\; eval echo \$a'; eval echo $a<br/>
      </code>
      <p>
        These should be called "goedels" because the technique occurs in the development of the first incompleteness theorem by Kurt GÃ¶del in 1930 / 31.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="CeeLanguage.html">CeeLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        Here is a Quine in ANSI C.
      </p>
      <code>
        #include <stdio.h><br/>
      </code>
      <code>
        const char *data[] = {<br/>
        "  NULL};",<br/>
        "",<br/>
        "void print_string(const char *str)",<br/>
        "{",<br/>
        "  const char *ptr;",<br/>
        "  printf(\"  \\\"\");",<br/>
        "  for (ptr = str; *ptr != 0; ptr++)",<br/>
        "  if (*ptr == '\\\\')",<br/>
        "  printf(\"\\\\\\\\\");",<br/>
        "  else if (*ptr == '\"')",<br/>
        "  printf(\"\\\\\\\"\");",<br/>
        "  else",<br/>
        "  putchar(*ptr); ",<br/>
        "  printf(\"\\\",\\n\");",<br/>
        "}",<br/>
        "",<br/>
        "int main(void)",<br/>
        "{",<br/>
        "  const char **ptr;",<br/>
        "  printf(\"#include <stdio.h>\\n\\n\");",<br/>
        "  printf(\"const char *data[] = {\\n\");",<br/>
        "  for (ptr = data; *ptr != NULL; ptr++)",<br/>
        "  print_string(*ptr);",<br/>
        "  for (ptr = data; *ptr != NULL; ptr++)",<br/>
        "  printf(\"%s\\n\", *ptr);",<br/>
        "  return 0;",<br/>
        "}",<br/>
        NULL};<br/>
      </code>
      <code>
        void print_string(const char *str)<br/>
        {<br/>
        const char *ptr;<br/>
        printf("  \"");<br/>
        for (ptr = str; *ptr != 0; ptr++)<br/>
        if (*ptr == '\\')<br/>
        printf("\\\\");<br/>
        else if (*ptr == '"')<br/>
        printf("\\\"");<br/>
        else<br/>
        putchar(*ptr);<br/>
        printf("\",\n");<br/>
        }<br/>
      </code>
      <code>
        int main(void)<br/>
        {<br/>
        const char **ptr;<br/>
        printf("#include <stdio.h>\n\n");<br/>
        printf("const char *data[] = {\n");<br/>
        for (ptr = data; *ptr != NULL; ptr++)<br/>
        print_string(*ptr);<br/>
        for (ptr = data; *ptr != NULL; ptr++)<br/>
        printf("%s\n", *ptr);<br/>
        return 0;<br/>
        }<br/>
      </code>
      <hr/>
      <p>
        And here's another (much shorter) one invented by <a href="AldoCortesi.html">AldoCortesi</a> on an idle rainy day:
      </p>
      <code>
        int main(void){<br/>
        char str[]= "	int main(void){ char str[]= %c%s%c; printf(str, 0x22, str, 0x22);}";<br/>
        printf(str, 0x22, str, 0x22);}<br/>
      </code>
      <p>
        Also see: <a href="http://www.math.uchicago.edu/~chruska/recursive/selfish.html">http://www.math.uchicago.edu/~chruska/recursive/selfish.html</a>
        It contains additional examples.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="CobolLanguage.html">CobolLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        In contrast to these concise Zen haiku things pretending to be serious quines, a <a href="QuineProgramInCobol.html">QuineProgramInCobol</a> wants its own page.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="CommonLisp.html">CommonLisp</a><strong></strong>
      </p>
      <hr/>
      <p>
        Example in <a href="CommonLisp.html">CommonLisp</a>:
      </p>
      <code>
        ((lambda (x) (quasiquote ((unquote x) (quote (unquote x))))) (quote (lambda (x) (quasiquote ((unquote x) (quote (unquote x)))))))<br/>
      </code>
      <p>
        which your pretty-printer may let you abbreviate as:
      </p>
      <code>
        ((lambda (x) `(,x ', x)) '(lambda (x) `(,x ',x)))<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="CompilerErrorsAreYourFriends.html">CompilerErrorsAreYourFriends</a><strong></strong>
      </p>
      <hr/>
      <p>
        Years ago I came across a programming challenge (in a magazine I believe) that asked the competitors to write a <a href="QuineProgram.html">QuineProgram</a>.  When the answers were published, the one that I thought was particularly clever went as follows:
      </p>
      <ul>
        <li>
          Start with any compiler.
        </li>
        <li>
          Write a program that will not compile.
        </li>
        <li>
          Take the error report from the compiler and compile it.  This will most likely not compile.
        </li>
        <li>
          Take the new error report and compile it.  Repeat until the output matches the input.
        </li>
        <li>
          If you consider the compiler as an interpreter (rather than a compiler) you now have a program that produces its source code as it's ouput when <em>interpreted</em> by the compiler.
        </li>
      </ul>
      <p>
        -- <a href="ChrisHines.html">ChrisHines</a>
      </p>
      <hr/>
      <p>
        I tried this approach with GCC. However, I always end up with a cycle of length 2.
        Moreover, since GCC reports file names in its error messages, the name of
        the file is significant (how unelegant).
      </p>
      <p>
        -- <a href="StephanHouben.html">StephanHouben</a>
      </p>
      <hr/>
      <p>
        quine.c:1: parse error before '.' token
      </p>
      <hr/>
      <p>
        This works for me with mingw.
      </p>
      <code>
        Borland C++ 5.5.1 for Win32 Copyright (c) 1993, 2000 Borland<br/>
        bcc32_interpreter_quine.c:<br/>
        Error E2141 bcc32_interpreter_quine.c 1: Declaration syntax error<br/>
        Error E2223 bcc32_interpreter_quine.c 1: Too many decimal points<br/>
      </code>
      <ul>
        <li>
           2 errors in Compile ***
        </li>
      </ul>
      <hr/>
      <p>
        this works for me in <a href="SuperCollider.html">SuperCollider</a>:
      </p>
      <code>
        ERROR: Parse error<br/>
        in file 'selected text'<br/>
        line 1 char 10 :<br/>
        ERROR: Parse error<br/>
        in file 'selected text'<br/>
        -----------------------------------<br/>
        ERROR: Command line parse failed<br/>
        nil<br/>
      </code>
      <p>
        all parse errors seem to converge to this fixed point.
      </p>
      <hr/>
      <p>
        This technique doesn't always converge in C (GCC):
      </p>
      <code>
        ...<br/>
        > quine4.c:2152: error: stray â\342â in program<br/>
        > quine4.c:2152: error: stray â\200â in program<br/>
        > quine4.c:2152: error: stray â\230â in program<br/>
        > quine4.c:2152: error: stray â\â in program<br/>
        > quine4.c:2152: error: stray â\342â in program<br/>
        > quine4.c:2152: error: stray â\200â in program<br/>
        > quine4.c:2152: error: stray â\231â in program<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="CsharpLanguage.html">CsharpLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        Here's the <a href="AldoCortesi.html">AldoCortesi</a> quine in C#:
      </p>
      <code>
        class Quine {<br/>
        static void Main() {<br/>
        string f = "class Quine {{{2} static void Main() {{{2}  string f = {0}{1}{0};{2}  System.Console.WriteLine(f, (char)0x22, f, (char)10);{2}  }}{2}}}";<br/>
        System.Console.WriteLine(f, (char)0x22, f, (char)10);<br/>
        }<br/>
        }<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="EnglishLanguage.html">EnglishLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        Here's one in English language:
      </p>
      <code>
        Let the following text, enclosed in double quotes, be called Text A.<br/>
        (You can really ignore Text A.  Just take note of the three dollar<br/>
        signs it contains.)<br/>
      </code>
      <code>
        "Let the following text, enclosed in double quotes, be called Text A.<br/>
        (You can really ignore Text A.  Just take note of the three dollar signs<br/>
        it contains.) $$$ Take pencil and paper, and write the following three<br/>
        things down, separated as paragraphs.  (That's just boring copying.<br/>
        You needn't be interested in the text you're handling.)  First, all<br/>
        of Text A that precedes the three dollar signs.  Second, the whole of<br/>
        Text A, enclosed in double quotes.  Third, all of Text A that follows<br/>
        the three dollar signs.  Now step back and try to interpret what you<br/>
        have just written."<br/>
      </code>
      <code>
        Take pencil and paper, and write the following three things down,<br/>
        separated as paragraphs.  (That's just boring copying.  You needn't<br/>
        be interested in the text you're handling.)  First, all of Text A that<br/>
        precedes the three dollar signs.  Second, the whole of Text A, enclosed<br/>
        in double quotes.  Third, all of Text A that follows the three dollar<br/>
        signs.  Now step back and try to interpret what you have just written.<br/>
      </code>
      <p>
        Here is a variant on this idea: Change both "Now step back and try to interpret what you have just written." to "Now follow the instructions that you have just written." to make it into an infinite quine.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="ExtendedObjectTcl.html">ExtendedObjectTcl</a><strong></strong>
      </p>
      <hr/>
      <p>
        In <a href="ExtendedObjectTcl.html">ExtendedObjectTcl</a>
      </p>
      <code>
        Object ::quine<br/>
        ::quine proc printSelf {  } {<br/>
        foreach instance [ Object info instances ] {<br/>
        foreach proc [ $instance info procs ] {<br/>
        puts "Object $instance"<br/>
        puts "$instance proc $proc \{ [ $instance info args $proc ] \} \{<br/>
        [ $instance info body $proc ]<br/>
        \}"<br/>
        }<br/>
        }<br/>
        puts "::quine printSelf"<br/>
        }<br/>
        ::quine printSelf<br/>
      </code>
      <p>
        Does introspection count as cheating?
      </p>
      <hr/>
      <p>
        <strong></strong><a href="ForthLanguage.html">ForthLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        In <a href="ForthLanguage.html">ForthLanguage</a> (assuming that the <a href="SuperCollider.html">SuperCollider</a> quine isn't cheating):
      </p>
      <code>
        : QUINE [ SOURCE ] SLITERAL TYPE ; QUINE<br/>
      </code>
      <p>
        But if the quine is allowed to be interpreted code then you can just use this:
      </p>
      <code>
        SOURCE TYPE<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="FurryScript.html">FurryScript</a><strong></strong>
      </p>
      <hr/>
      <p>
        <a href="FurryScript.html">FurryScript</a> is normally used to generate random output, but it doesn't have to be, as shown by this program (allegedly written by the inventor of this programming language):
      </p>
      <code>
        ENIUQ[ DUP LT +SW +GT +< ENIUQ#> ]<br/>
        <ENIUQ[ DUP LT +SW +GT +< ENIUQ#> ]> ENIUQ#<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="GoLanguage.html">GoLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        A Go(<a href="http://golang.org)">http://golang.org)</a> quine:
      </p>
      <code>
        package main;import"fmt";func main(){s:="\"\\\"package main;import\"fmt\";func main(){s:=;fmt.Print(s[3:43]+s[:2]+s[:2]+s[1:2]+s[1:22]+s[1:3]+s[23:26]+s[1:3]+s[27:]+s[:1]+s[43:])}";fmt.Print(s[3:43]+s[:2]+s[:2]+s[1:2]+s[1:22]+s[1:3]+s[23:26]+s[1:3]+s[27:]+s[:1]+s[43:])}<br/>
      </code>
      <p>
        -- by qulinxao
      </p>
      <hr/>
      <p>
        <strong></strong><a href="HaskellLanguage.html">HaskellLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        Here's a really short quine in Haskell:
      </p>
      <code>
        ((++)<*>show)"((++)<*>show)"<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="HqNinePlusLanguage.html">HqNinePlusLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        How could we forget HQ9+ (<a href="HqNinePlusLanguage.html">HqNinePlusLanguage</a>)?
      </p>
      <code>
        q<br/>
      </code>
      <p>
        Another HQ9+ Quine:
      </p>
      <code>
        Hello, World<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="JavaLanguage.html">JavaLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        Java Quine:
      </p>
      <code>
        public class Quine {<br/>
        public static void main(String[] args) {<br/>
        String[] str = {<br/>
        "public class Quine {",<br/>
        " public static void main(String[] args) {",<br/>
        "  String[] str = {",<br/>
        "  };",<br/>
        "  for(int i=0;i<3;i++)System.out.println(str[i]);",<br/>
        "  for(int i=0;i<9;i++)System.out.println((char)34+str[i]+(char)34+',');",<br/>
        "  for(int i=3;i<9;i++)System.out.println(str[i]);",<br/>
        " }",<br/>
        "}",<br/>
        };<br/>
        for(int i=0;i<3;i++)System.out.println(str[i]);<br/>
        for(int i=0;i<9;i++)System.out.println((char)34+str[i]+(char)34+',');<br/>
        for(int i=3;i<9;i++)System.out.println(str[i]);<br/>
        }<br/>
        }<br/>
      </code>
      <p>
        --JasonWilson
      </p>
      <hr/>
      <p>
        Sorry, just had to:
      </p>
      <code>
        enum Q{T;System a;String b="enum Q{T;System a;String b=%c%s%c;{a.out.printf(b,34,b,34);a.exit(0);}}";{a.out.printf(b,34,b,34);a.exit(0);}}<br/>
      </code>
      <p>
        --lf
      </p>
      <hr/>
      <p>
        <strong></strong><a href="JavaScript.html">JavaScript</a><strong></strong>
      </p>
      <hr/>
      <p>
        A Javascript quine (works in Rhino, or anywhere else where 'print' means 'to a console', not 'to a printer'):
      </p>
      <code>
        (function a(){print('('+a+')()')})()<br/>
      </code>
      <hr/>
      <p>
        A javascript quine without using fact that prog have access to func def:
      </p>
      <code>
        _='"'+";document.write('_=',_[17],_[0],_[17],'+',_,_)";document.write('_=',_[17],_[0],_[17],'+',_,_)<br/>
      </code>
      <p>
        in Rhino maybe :
      </p>
      <code>
        _='"'+";print('_=',_[8],_[0],_8],'+',_,_)";print('_=',_[8],_[0],_8],'+',_,_)<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="JayLanguage.html">JayLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        Here's one in <a href="JayLanguage.html">JayLanguage</a>
      </p>
      <code>
        (,q,q,~]#~[:>:]=q=.<em></em>"_)'(,q,q,~]#~[:>:]=q=.''"_)'<br/>
      </code>
      <p>
        <em>aaarg there should be four consecutive single quotes after the first q=. and eight after the second one but I've been unable to convince Wiki to display more than three! Could a Wiki wizard fix this, please?</em>
      </p>
      <hr/>
      <p>
        <strong></strong><a href="LuaLanguage.html">LuaLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        Lua Quine
      </p>
      <code>
        s="s=%qprint(s:format(s))"print(s:format(s))<br/>
      </code>
      <p>
        <a href="http://lua-users.org/lists/lua-l/2008-05/msg00379.html">http://lua-users.org/lists/lua-l/2008-05/msg00379.html</a>
      </p>
      <hr/>
      <p>
        <strong></strong><a href="MicrosoftExcel.html">MicrosoftExcel</a><strong></strong>
      </p>
      <hr/>
      <code>
        =SUBSTITUTE(SUBSTITUTE("=SUBSTITUTE(SUBSTITUTE(#@#,CHAR(35),CHAR(34)),CHAR(64),#@#)",CHAR(35),CHAR(34)),CHAR(64),"=SUBSTITUTE(SUBSTITUTE(#@#,CHAR(35),CHAR(34)),CHAR(64),#@#)")<br/>
      </code>
      <p>
        --Jonathan Rynd
      </p>
      <hr/>
      <code>
        =SUBSTITUTE("=SUBSTITUTE(@,CHAR(64),CHAR(34)&@&CHAR(34))",CHAR(64),CHAR(34)&"=SUBSTITUTE(@,CHAR(64),CHAR(34)&@&CHAR(34))"&CHAR(34))<br/>
      </code>
      <p>
        --dave@burt.id.au
      </p>
      <hr/>
      <p>
        <strong></strong><a href="MsDos.html">MsDos</a><strong></strong>
      </p>
      <hr/>
      <p>
        Here is a quine in MS-DOS (that I made up myself):
      </p>
      <code>
        @echo off<br/>
        %1 %2<br/>
        call %0 goto e %%<br/>
        call %0 goto e %%3 echo.%%4<br/>
        echo :f<br/>
        goto f<br/>
        :e<br/>
        echo.%4@echo off<br/>
        echo.%4%31 %32<br/>
        echo.%4call %30 goto e %3%3<br/>
        echo.%4call %30 goto e %3%33 echo.%3%34<br/>
        echo.%4echo :f<br/>
        echo.%4goto f<br/>
        echo.%4:e<br/>
        :f<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="NemerleLanguage.html">NemerleLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        A basic AqABqB-style quine in <a href="NemerleLanguage.html">NemerleLanguage</a>:
      </p>
      <code>
        using System.Console;<br/>
        module quine {<br/>
        Main():void {<br/>
        def a = @"using System.Console;<br/>
        module quine {<br/>
        Main():void {<br/>
        def a = @;<br/>
        Write(a.Substring(0,72));Write(34:>char);<br/>
        Write(a);Write(34:>char);<br/>
        Write(a.Substring(72,(a.Length -72)));<br/>
        }<br/>
        }<br/>
        ";<br/>
        Write(a.Substring(0,72));Write(34:>char);<br/>
        Write(a);Write(34:>char);<br/>
        Write(a.Substring(72,(a.Length -72)));<br/>
        }<br/>
        }<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="PascalLanguage.html">PascalLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        Pascal/Delphi:
      </p>
      <code>
        const a=';begin write(^#^/^.^3^4^`^!^}#39,a,#39,a)end.';begin write(^#^/^.^3^4^`^!^}#39,a,#39,a)end.<br/>
      </code>
      <p>
        --Geoffrey Swift (<a href="http://www.trollied.org/~blimey/quines.php)">http://www.trollied.org/~blimey/quines.php)</a>
      </p>
      <hr/>
      <p>
        <strong></strong><a href="PathLanguage.html">PathLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        Some languages provide a bigger challenge than others when it comes to writing quines. Often it is easer to write part of a quine, then write another program that writes the rest.  An example is this quine in <a href="PathLanguage.html">PathLanguage</a>: <a href="http://www.phong.org/bf/quine2.path">http://www.phong.org/bf/quine2.path</a>
      </p>
      <hr/>
      <p>
        <strong></strong><a href="PerlLanguage.html">PerlLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        A 32-character quine in Perl:
      </p>
      <code>
        $_=q{print"\$_=q{$_};eval"};eval<br/>
      </code>
      <hr/>
      <p>
        A 31-character quine in Perl:
      </p>
      <code>
        print<<<em>x2,$/</em><br/>
        print<<<em>x2,$/</em><br/>
      </code>
      <p>
        Note: both trailing newlines are necessary!
      </p>
      <hr/>
      <p>
        A 28-character quine in Perl, which seems to be the shortest known non-cheating Perl quine (by Ilmari Karonen):
      </p>
      <code>
        printf+qw(printf+qw(%s)x2)x2<br/>
      </code>
      <hr/>
      <p>
        A 15-character quine in Perl, although this is a cheat, as it opens and reads its own source:
      </p>
      <code>
        open+0;print<0><br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="PhpLanguage.html">PhpLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        Here's a <a href="PhpLanguage.html">PhpLanguage</a> <a href="QuineProgram.html">QuineProgram</a>:
      </p>
      <code>
        <?<br/>
      </code>
      <code>
        # PHP Quine written by Ian Kjos - brooke@sf.net<br/>
      </code>
      <code>
        $y = "function q(\$q) {<br/>
        \$q = str_replace('\\\\', '\\\\\\\\', \$q);<br/>
        \$q = str_replace('\$', '\\\\\$', \$q);<br/>
        \$q = str_replace('\\n', '\\\\n', \$q);<br/>
        \$q = str_replace('\"', '\\\\\"', \$q);<br/>
        return \$q;<br/>
        }<br/>
      </code>
      <code>
        echo \"<?\\n\\n\";<br/>
        echo \"# PHP Quine written by Ian Kjos - brooke@sf.net \\n\\n\";<br/>
        echo '\$y = \"' . q(\$y) . '\";';<br/>
        echo \"\\n\\neval(\";<br/>
        echo '\$y);';<br/>
        echo \"\\n\\n\\n\";<br/>
        ";<br/>
      </code>
      <code>
        eval($y);<br/>
      </code>
      <hr/>
      <p>
        Here's another PHP quine. Is this cheating?? (Also, remove the extra line breaks if you run this, I can't get this wiki to accept single line breaks for some reason)
      </p>
      <code>
        <?php<br/>
        // PHP quine by Sam Barnum 360works.com<br/>
        // 2003-11-08<br/>
        $dna = 'PD9waHAKLy8gUEhQIHF1aW5lIGJ5IFNhbSBCYXJudW0gMzYwd29ya3MuY29tCi8vIDIwMDMtMTEtMDgKJGRuYSA9ICcqJzsKZWNobyBzdHJfcmVwbGFjZShjaHIoNDIpLCAkZG5hLCBiYXNlNjRfZGVjb2RlKCRkbmEpKTsKPz4K';<br/>
        echo str_replace(chr(42), $dna, base64_decode($dna));<br/>
        ?><br/>
      </code>
      <p>
        <em>No, it is not cheating. It is actually very good.</em>
      </p>
      <hr/>
      <p>
        And another one in PHP. From my friend [[<a href="mailto:yoz@atlas.sk">mailto:yoz@atlas.sk</a> Yoz]]
      </p>
      <code>
        <?<br/>
        $a='chr(60).chr(63).chr(10).chr(36).chr(97).chr(61).chr(39).$a.chr(39).chr(59).chr(10)."echo $a;".chr(10).chr(63).chr(62)';<br/>
        echo chr(60).chr(63).chr(10).chr(36).chr(97).chr(61).chr(39).$a.chr(39).chr(59).chr(10)."echo $a;".chr(10).chr(63).chr(62);<br/>
        ?><br/>
      </code>
      <hr/>
      <p>
        This php Quine makes it easy to add other actions easily. [[<a href="http://basicer.is-a-geek.com">http://basicer.is-a-geek.com</a> Basicer]]
      </p>
      <code>
        <?<br/>
        function selffunc($a) { print($a . "\n"); print("selffunc(\"" . addcslashes($a,"\n\\\"$") . "\");\n"); }<br/>
        selffunc("<?\nfunction selffunc(\$a) { print(\$a . \"\\n\"); print(\"selffunc(\\\"\" . addcslashes(\$a, \"\\n\\\\\\\"\$\") . \"\\\");\\n\"); }");<br/>
        function selfact($a) { print("selfact(\"" . addcslashes($a,"\n\\\"$") . "\");\n"); exec($a); }<br/>
        selffunc("function selfact(\$a) { print(\"selfact(\\\"\" . addcslashes(\$a,\"\\n\\\\\\\"\$\") . \"\\\");\\n\"); exec(\$a); }");<br/>
        function selffunc2($a) { print("selffunc2(\"" . addcslashes($a,"\\\"$") . "\");\n"); print($a . "\n"); }<br/>
        selffunc("function selffunc2(\$a) { print(\"selffunc2(\\\"\" . addcslashes(\$a,\"\\\\\\\"\$\") . \"\\\");\\n\");  print(\$a . \"\\n\"); }");<br/>
        //The Self Act Code executes any command.<br/>
        selffunc("//The Self Act Code executes any command.");<br/>
        selfact("\$a = fopen('log.txt','w'); fwrite(\$a,\"Hello\"); fclose(\$a);");<br/>
        selffunc2("?>");<br/>
        ?><br/>
      </code>
      <hr/>
      <p>
        A short PHP quine is available here: <a href="http://www.dionyziz.com/Quine">http://www.dionyziz.com/Quine</a>
      </p>
      <code>
        <?printf($c='<?printf($c=%s,\'\\\'\'.addslashes($c).\'\\\'\');','\<em>.addslashes($c).'\</em>);<br/>
      </code>
      <p>
        I wish this wiki had a way to add literal characters so that I could directly paste it over, but it won't let me.
      </p>
      <hr/>
      <p>
        My short (60 bytes) PHP quine:
      </p>
      <code>
        <?$a='<?$a=%c%s%c;printf($a,39,$a,39);';printf($a,39,$a,39);<br/>
      </code>
      <p>
        (Actually, the 8 bytes longer
      </p>
      <code>
        <?php $a='<?php $a=%c%s%c;printf($a,39,$a,39);';printf($a,39,$a,39);<br/>
      </code>
      <p>
        is the preferred form, since the short '<?' may not be supported on all servers)
      </p>
      <p>
        On the web I found the even shorter PHP quine, written by Trevor Sayre:
      </p>
      <code>
        <?php printf($a='<?php printf($a=%c%s%c,39,$a,39);',39,$a,39);<br/>
      </code>
      <p>
        or
      </p>
      <code>
        <?printf($a='<?printf($a=%c%s%c,39,$a,39);',39,$a,39);<br/>
      </code>
      <p>
        -- Tom van der Beek
      </p>
      <hr/>
      <p>
        With the use of non-standard Ascii characters, a 38 byte PHP quine can be produced:
      </p>
      <code>
        <?printf(~$s=ÃÃÂÂâââ¹â¢ÃÂÃÅÃÃÅÃÃÅÃÃ,$s);<br/>
      </code>
      <p>
        This will need to be saved with ANSI character encoding to work properly. Or alternatively, it may be generated with the following:
      </p>
      <code>
        <?printf(~$s="\xc3\xc0\x8f\x8d\x96\x91\x8b\x99\xd7\x81\xdb\x8c\xc2\xda\x8c\xd3\xdb\x8c\xd6\xc4",$s);<br/>
      </code>
      <p>
        -- Mike Tryczak (a.k.a. primo - <a href="http://www.phpgolf.org/user/primo)">http://www.phpgolf.org/user/primo)</a>
      </p>
      <hr/>
      <p>
        Yet another php quine, by vejux. Php specific. It processes its own output, not the source code, so it should not be concidered cheating. (Use single new lines)
      </p>
      <code>
        <?<br/>
        function c($b) { return "<"."?\n$b?".">\n$b"; } ob_start("c");<br/>
        ?><br/>
        function c($b) { return "<"."?\n$b?".">\n$b"; } ob_start("c");<br/>
      </code>
      <hr/>
      <p>
        Here's a <a href="PhpLanguage.html">PhpLanguage</a> <a href="QuineProgram.html">QuineProgram</a> by Opanasjuk Yegor (cheat):
      </p>
      <code>
        <?php<br/>
        $sFile = file_get_contents(__FILE__);<br/>
        echo $sFile;<br/>
      </code>
      <hr/>
      <p>
        Another (cheat) PHP quine:
      </p>
      <code>
        <?=file_get_contents(__FILE__);<br/>
      </code>
      <p>
        or alternatively:
      </p>
      <code>
        <?readfile(__FILE__);<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="PliLanguage.html">PliLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        The following is (probably) the shortest possible Quine in PL/I. It only compiles with he old V2.3.0 compiler and requires a few non-standard compiler options, COMPILE and MAR(1,90,0) (Source starts in column 1!)
      </p>
      <code>
        %dcl z%z=&apos;put edit&apos;;proc options(main;q=&apos;&apos;&apos;&apos;put list(m;do i=1,2;z(q)skip;do j=<br/>
      </code>
      <ol>
        <li>
          to 78c=substr(m(i),j;if c=q z(c;z(c;end;z(q&apos;,&apos;;dcl(c,q)char,m(2)char(99)init(
        </li>
      </ol>
      <code>
        &apos;%dcl z%z=&apos;&apos;put edit&apos;&apos;;proc options(main;q=&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;put list(m;do i=1,2;z(q)skip;do j=&apos;,<br/>
        &apos;1to 78c=substr(m(i),j;if c=q z(c;z(c;end;z(q&apos;&apos;,&apos;&apos;;dcl(c,q)char,m(2)char(99)init(&apos;,<br/>
      </code>
      <p>
        This entry has big trouble with repeated single quotes...
      </p>
      <hr/>
      <p>
        <strong></strong>PolyGlot<strong></strong>
      </p>
      <hr/>
      <p>
        Here's the classic Loophole Quine.  In addition to being the shortest ever quine in Python, it is an all-language PolyGlot, and in <a href="LazyKayLanguage.html">LazyKayLanguage</a>, it even acts as UNIX cat with no arguments.  Here it is:
      </p>
      <p>
        ...That's it.  Nothing.  0 bytes of self-replicating quine.  XD and LOL.
      </p>
      <hr/>
      <p>
        "Hello" is a quine in many languages?
      </p>
      <hr/>
      <p>
        If you're masochistic, you may want to write a quine that is also a polyglot (see <a href="HelloPolyGlots.html">HelloPolyGlots</a>). Here is a quine that works as <a href="CeeLanguage.html">CeeLanguage</a>, <a href="CeePlusPlus.html">CeePlusPlus</a>, <a href="PerlLanguage.html">PerlLanguage</a> and <a href="PythonLanguage.html">PythonLanguage</a>:
      </p>
      <code>
        #include <stdio.h><br/>
        #define q(a,...) a<br/>
        #define substr q<br/>
        #define eval(a) main(){char c[]=a,n=10;c[419]=0;printf(c+4,n,n,n,n,34,34,n,34,39,c+4,39,34,n); }/* Copyright (C) Thomas Schumm <phong@phong.org><br/>
        exec("from sys import*;substr=q=lambda y:exit(stdout.write(y[4:-46]%((10,)*4+(34,34,10,34,39, y[4:-46],39,34,10))))",None);#*/<br/>
        eval(substr(q("$p='#include <stdio.h>%c#define q(a,...) a%c#define substr q%c#define eval(a) main() {char c[]=a,n=10;c[419]=0;printf(c+4,n,n,n,n,34,34,n,34,39,c+4,39,34,n); }/* Copyright (C) Thomas Schumm <phong@phong.org>%cexec(%cfrom sys import*;substr=q=lambda y: exit(stdout.write(y[4:-46]%%((10,)*4+(34,34,10,34,39,y[4:-46],39,34,10))))%c,None);# */%ceval(substr(q(%c$p=%c%s%c;printf($p,(10)x4,34,34,10,34,39,$p,39,34,10)%c),1,-1))%c'; printf($p,(10)x4,34,34,10,34,39,$p,39,34,10)"),1,-1))<br/>
      </code>
      <p>
        <em>When I compiled and ran as C/C++, it didn't work (missing only a few characters)--a change made to gcc?</em>
      </p>
      <p>
        <em>Working fine for me with gcc 3.3.4...</em>
      </p>
      <p>
        The original is here (I may occasionally update it if it gets better or smaller):
        <a href="http://www.phong.org/bf/polyglotC++PerlPythonC.c">http://www.phong.org/bf/polyglotC++PerlPythonC.c</a>
        -- <a href="TomSchumm.html">TomSchumm</a>
      </p>
      <hr/>
      <code>
        ;; (*.) = {- *) let (@@) x y = x::y let e = [] let a = (*<br/>
        (letrec ((a '(<br/>
        ; -} -- *)<br/>
        "								" @@<br/>
        "			A polyglot quine in			" @@<br/>
        "			Haskell & O'Caml & Scheme			" @@<br/>
        "								" @@<br/>
        "  Usage:  runhugs thisfile		# www.haskell.org/hugs  " @@<br/>
        "	  ocamlc -o x thisfile.ml ;./x  # www.ocaml.org	 " @@<br/>
        "	  scsh -s thisfile		# www.scsh.net	  " @@<br/>
        "								" @@<br/>
        "" @@<br/>
        ";; (*.) = {- *) let (@@) x y = x::y let e = [] let a = (*" @@<br/>
        "(letrec ((a '(" @@<br/>
        "; -} -- *)" @@<br/>
        "" @@<br/>
        " e" @@<br/>
        ";; (*:) = [\" \" ++ show x ++ \" @@\" | x<-( *.)]; main = {-" @@<br/>
        "; -} mapM_ putStrLn (x ++ ( *:) ++ y); (x, _:y) = {-" @@<br/>
        "; -} span p (tail (dropWhile p ( *.))); p = (/= \"\"); infixr {-" @@<br/>
        "; -} @@; (@@) = (:); e = [] {- *) let rec s = function [] -> (*" @@<br/>
        "; *) [],[] | \"\"::y -> [],y | x::y -> let a,b = s y (*" @@<br/>
        "; *) in x::a,b let b,d = s (snd (s a)) let f = String.escaped (*" @@<br/>
        "; *) let c = List.map (fun x -> \" \\\"\" ^ f x ^ \"\\\" @@\") a" @@<br/>
        ";; List.iter print_endline (b @ c @ d) (*" @@<br/>
        ")) (f (lambda (x) (if (null? x) x (if (string? (car x)) (cons (" @@<br/>
        "car x) (f (cdr x))) (f (cdr x)))))) (g (lambda (x) (if (string=?" @@<br/>
        "\"\" (car x)) (cons '() (cdr x)) (let ((y (g (cdr x)))) (cons (" @@<br/>
        "cons (car x) (car y)) (cdr y)))))) (h (lambda (x) (if (null? x)" @@<br/>
        "#f (begin (display (car x)) (newline) (h (cdr x)))))) (i (lambda" @@<br/>
        "(x) (if (null? x) #f (begin (display \" \") (write (car x)) (" @@<br/>
        "display \" @@\") (newline) (i (cdr x))))))) (let ((b (g (cdr (g" @@<br/>
        "(f a)))))) (h (car b)) (i (f a)) (h (cdr b))))" @@<br/>
        "; -} -- *)" @@<br/>
        e<br/>
        ;; (*:) = [" " ++ show x ++ " @@" | x<-( *.)]; main = {-<br/>
        ; -} mapM_ putStrLn (x ++ ( *:) ++ y); (x, _:y) = {-<br/>
        ; -} span p (tail (dropWhile p ( *.))); p = (/= ""); infixr {-<br/>
        ; -} @@; (@@) = (:); e = [] {- *) let rec s = function [] -> (*<br/>
        ; *) [],[] | ""::y -> [],y | x::y -> let a,b = s y (*<br/>
        ; *) in x::a,b let b,d = s (snd (s a)) let f = String.escaped (*<br/>
        ; *) let c = List.map (fun x -> " \"" ^ f x ^ "\" @@") a<br/>
        ;; List.iter print_endline (b @ c @ d) (*<br/>
        )) (f (lambda (x) (if (null? x) x (if (string? (car x)) (cons (<br/>
        car x) (f (cdr x))) (f (cdr x)))))) (g (lambda (x) (if (string=?<br/>
        "" (car x)) (cons '() (cdr x)) (let ((y (g (cdr x)))) (cons (<br/>
        cons (car x) (car y)) (cdr y)))))) (h (lambda (x) (if (null? x)<br/>
        #f (begin (display (car x)) (newline) (h (cdr x)))))) (i (lambda<br/>
        (x) (if (null? x) #f (begin (display " ") (write (car x)) (<br/>
        display " @@") (newline) (i (cdr x))))))) (let ((b (g (cdr (g<br/>
        (f a)))))) (h (car b)) (i (f a)) (h (cdr b))))<br/>
        ; -} -- *)<br/>
      </code>
      <p>
        <em> D'oh, that's got me beat. -- </em><a href="TomSchumm.html">TomSchumm</a><em></em>
      </p>
      <hr/>
      <p>
        <strong></strong><a href="PostScript.html">PostScript</a><strong></strong>
      </p>
      <hr/>
      <code>
        (dup == =)<br/>
        dup == =<br/>
      </code>
      <p>
        (note this doesn't produce output to paper, but rather to the terminal; run it with gs)
        --Chris King
      </p>
      <hr/>
      <p>
        <strong></strong><a href="PythonLanguage.html">PythonLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        This one is inspired by the below <a href="RubyLanguage.html">RubyLanguage</a> example
      </p>
      <code>
        s = 's = {0!r}; print s.format(s)'; print s.format(s)<br/>
      </code>
      <hr/>
      <p>
        And here is another
      </p>
      <code>
        _="print '_='+chr(34)+_+chr(34)+'; exec(_)'"; exec(_)<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="RexxLanguage.html">RexxLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        <a href="RexxLanguage.html">RexxLanguage</a> has a SOURCELINE command that prints the source of a line of the program (meant for use with error messages), so the following should work as a Quine in REXX (don't have an interpreter to check right now):
      </p>
      <code>
        sourceline 1<br/>
      </code>
      <p>
        <em>That's cheating, though, akin to the bash one above that uses cat $0</em>
      </p>
      <hr/>
      <p>
        <strong></strong><a href="RubyLanguage.html">RubyLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        Here's one in <a href="RubyLanguage.html">RubyLanguage</a>
      </p>
      <code>
        puts(s = <<e, s, 'e')<br/>
        puts(s = <<e, s, 'e')<br/>
        e<br/>
      </code>
      <hr/>
      <p>
        And another in <a href="RubyLanguage.html">RubyLanguage</a>
      </p>
      <code>
        s="s=%s;printf s,s.dump";printf s,s.dump<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="SchemeLanguage.html">SchemeLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        For starters, here is the classic Quine in <a href="SchemeLanguage.html">SchemeLanguage</a>:
      </p>
      <code>
        ((lambda (x) `(,x ',x)) '(lambda (x) `(,x ',x)))<br/>
      </code>
      <p>
        Using outside-language facilities to access the source is considered cheating. E.g. opening the source as a text file would be cheating. But cheating in original ways is strongly encouraged. ;-)
      </p>
      <hr/>
      <p>
        <strong></strong><a href="SuperCollider.html">SuperCollider</a><strong></strong>
      </p>
      <hr/>
      <p>
        Here's one in <a href="SuperCollider.html">SuperCollider</a>.
      </p>
      <code>
        { thisFunction.asCompileString ++ ".value" }.value<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="SwiftLanguage.html">SwiftLanguage</a><strong></strong>
      </p>
      <hr/>
      <p>
        Here's one in <a href="SwiftLanguage.html">SwiftLanguage</a>
      </p>
      <code>
        {println($0+$0.debugDescription+")")}("{println($0+$0.debugDescription+\")\")}(")<br/>
      </code>
      <hr/>
      <p>
        <strong></strong>UnknownLanguage<strong></strong>
      </p>
      <hr/>
      <code>
        repeat x 2 : output xpose list 2 crlf <<"<br/>
        repeat x 2 : output xpose list 2 crlf <<"<br/>
      </code>
      <hr/>
      <p>
        <strong></strong>ZeeShell<strong></strong>
      </p>
      <hr/>
      <p>
        In AnarchyGolf the current directory contains only one file, which is the script itself. Which means in Zsh you can do the following two byte cheating quine:
      </p>
      <code>
        <*<br/>
      </code>
      <p>
        For a self-reproducing program in Oberon, see <a href="http://www.modulaware.com/mdlt/mdlt78.htm">http://www.modulaware.com/mdlt/mdlt78.htm</a>
        For a lot more see <a href="http://www.nyx.net/~gthompso/quine.htm">http://www.nyx.net/~gthompso/quine.htm</a>
      </p>
      <hr/>
      <p>
        OK I've got to ask: would it be cheating for the program to access its binary image, reverse compile itself, and write the result to stdout?
      </p>
      <hr/>
      <p>
        See <a href="SelfReplication.html">SelfReplication</a>, <a href="MixingLevels.html">MixingLevels</a>, <a href="SelfAssembly.html">SelfAssembly</a>
      </p>
      <hr/>
      <p>
        An old IOCCC entry forever cinched the spot of shortest quine - at one point, gcc would, given the right compiler switches, compile a zero-byte C program into a program that does nothing. Thus, it is a zero-byte program that produces a zero-byte output - a perfect quine!
      </p>
      <hr/>
      <p>
        <strong>An *actual* quine.</strong> Use Assembly since you have the instruction pointer readily in hand. You can save the instruction pointer, and have the program hard code how many lines it has, then use a loop to print each line of code. The entire program would simply be a way to decompile assembly statements into printable text. This isn't a cheat since assembly is loaded into memory because assembly is loaded into memory as a prerequisite to running the program. -- <a href="LeeLouviere.html">LeeLouviere</a>
      </p>
      <p>
        I'd call it cheating for a program to load from the program portion of its allocated space in memory, or any part of the non-writable portion of its memory that doesn't contain data literals.  You can make an assembly quine with these restrictions -- <a href="DavidRutter.html">DavidRutter</a>
      </p>
      <hr/>
      <p>
        These programs should be named `GÃ¶dels' or `Goedels'. The technique which underlies them is to be found in the proof of the first Incompleteness Theorem, and that occurs before Quine's ideas (cf. Kurt GÃ¶del's Collected Works I, p. 175).
        âKela
      </p>
      <hr/>
      <p>
        <a href="CategoryCoding.html">CategoryCoding</a>
      </p>
    </div>
  </body>
</html>