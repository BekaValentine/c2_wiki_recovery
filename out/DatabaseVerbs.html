<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Database Verbs
      </h1>
      <p>
        {If you don't like the thread-mode nature of this topic, then plese fix it without deleting the whole damned topic again, please.}
      </p>
      <p>
        Since I need to keep mentioning this concept over and over again, I decided to make a new topic in the spirit of <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a>.
      </p>
      <p>
        <a href="DatabaseVerbs.html">DatabaseVerbs</a> are <a href="TopMind.html">TopMind</a>'s term...
      </p>
      <p>
        {It is a <strong>topic name</strong>, not a "term"}
      </p>
      <p>
        <em>Now you're being unfair. These are in fact standard database operations that are never reimplemented. That point stands despite the fact that, yes, C/C++/Java/etc are Turing Complete and can be used to implement these and much more. I think the original phrasing "..are terms for typical database operations..." was completely fair. Possibly </em><a href="TopMind.html">TopMind</a> doesn't understand non-DB programming, but also possibly his detractors aren't steeped in DB paradigms. -- <a href="DougMerritt.html">DougMerritt</a><em>  </em>
      </p>
      <p>
        Where in the computer science or software developer literature would one find reference to the standard definition of the term <a href="DatabaseVerbs.html">DatabaseVerbs</a>?  If <a href="TopMind.html">TopMind</a> is not coining a term, then it is part of the DB paradigm, so it must have an extensive  background in the field which can be cited and discussed.
      </p>
      <p>
        {Again, it is a topic name, not a "term". If you have a better name for the concept/topic, your suggestions are welcome.}
      </p>
      <p>
        ...for typical programming operations such as:
      </p>
      <ul>
        <li>
           Search/find <em>(special case of "filter"?)</em>
        </li>
        <li>
           Filter 
        </li>
        <li>
           Sort
        </li>
        <li>
           Cross-reference or link (join)
        </li>
        <li>
           Add/Insert
        </li>
        <li>
           Change
        </li>
        <li>
           Delete
        </li>
        <li>
           Aggregation (group, sum, average, etc.)
        </li>
        <li>
           Save
        </li>
        <li>
           Lock (or other concurrency-related verbs)
          <ul>
            <li>
               See <a href="CollectionOrientedProgramming.html">CollectionOrientedProgramming</a> for more candidates
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <em>It could be argued that if you are doing these things explicitly, it isn't OOP, and that these actions fall into the category of 'procedural cop-outs' along with </em>get<em> and </em>set<em>. This view, however, requires a degree of ideological purity that would have been considered excessively fanatical by the Khmer Rouge. - </em><a href="JayOsako.html">JayOsako</a>, still under the nefarious influence of the Holub article (<a href="http://www.javaworld.com/javaworld/jw-07-1999/jw-07-toolbox.html)">http://www.javaworld.com/javaworld/jw-07-1999/jw-07-toolbox.html)</a> mentioned in <a href="MvcIsNotObjectOriented.html">MvcIsNotObjectOriented</a>.<em></em>
      </p>
      <hr/>
      <p>
        These aren't exclusive to databases, so they aren't really "database verbs".  They could just as easily be "file verbs" or "memory verbs".
      </p>
      <p>
        <em>Persistence Verbs</em> [maybe. Create, Retrieve, Update, Delete are the 4 activies normally associated with RDBs, leading to the common acronym CRUD.  Using CRUD rather than <a href="DatabaseVerbs.html">DatabaseVerbs</a> is more likely to be clear to everyone, and has the advantage that it's shorter.]
      </p>
      <p>
        <em>Most associate it with GUI's or UI's. CRUD is a GUI concept. I am </em>'not<em>' talking about GUI's here, and CRUD does not directly imply cross-referencing and searching.</em>
      </p>
      <p>
        [SQL works well, too. Question: aren't all the operations beyond those 4 considered to be subparts of them?  Wouldn't it be correct to say that Filter/Sort/Join really are just ways to parameterize the Retrieve operation?] <em>I am not sure what conceptual purpose that would serve here.</em>
      </p>
      <p>
        DRAM is not persistent, so these aren't just "persistence verbs".
      </p>
      <p>
        <em>How about "state alteration verbs"?</em>
      </p>
      <p>
        CRUD is not exclusive to databases.  You can perform all of those operations on files or memory.  Perhaps ReadWriteStorageVerbs is a better category for these words.
      </p>
      <p>
        {Things like cross-referencing, filtering, aggregation, and sorting are not necessarily directly tied to storage (persistence).}
      </p>
      <p>
        <a href="TopMind.html">TopMind</a> uses the phrase "database verbs" to accuse anyone who uses them outside a database of <a href="ReinventingTheDatabaseInApplication.html">ReinventingTheDatabaseInApplication</a>, as if only relational databases should be used to perform these behaviors. 
      </p>
      <p>
        <em>This topic is to consolidate a repeated concept, not to accuse. The context of the claim is usually that </em>'OO tends to reinvent them in inconsistent ways; whereas, relational "encapsulates" them into a set of well-defined and well-understood rules.<em>' They become "atoms" that you can rely on to be the same rather than deal with inconsistent roll-your-own variations.</em>
      </p>
      <p>
        But OO doesn't "reinvent" these verbs.  These verbs can be used to name similar behaviors in many different contexts.  OO helps us implement those behaviors.  Once implemented they become "atoms" that we rely on to "be the same".  What you keep calling "roll-your-own" we call "programming".  If a database (or library, or file system, or ORB, or whatever) already provides the implementation we need, we use that.  We can't use a database to do things a database doesn't do.
      </p>
      <p>
        <em>Which would not include those in the above list, I assume. Rolling your own when you don't have to is not recommended, I would note.</em>
      </p>
      <p>
        {<a href="EditHint.html">EditHint</a>: perhaps some of this below should be moved to <a href="AreTablesGeneralPurposeStructures.html">AreTablesGeneralPurposeStructures</a> or <a href="WhenAreDatabasesNotAppropriate.html">WhenAreDatabasesNotAppropriate</a> or <a href="DedicatedStructuresVersusRdbms.html">DedicatedStructuresVersusRdbms</a>. This current topic is more about interfaces than implementation.}
      </p>
      <p>
        Quite <em>often</em> you do have to roll your own. That's why databases don't solve numerous problems that the weenies claim they can solve. They solve specific problems: customer accounts, web based forums, repetetive data. 
      </p>
      <p>
        <em>What is an example of "non-repetative data" that wouldn't go well in a DB? I do wish there were dynamic relational implementations (see </em><a href="MultiParadigmDatabase.html">MultiParadigmDatabase</a>) for a more flexible approach, such as reducing concerns about hard-wired column widths. But the static DB's are still usually better than roll-your-own alternatives even with their annoyances.<em></em>
      </p>
      <p>
        The reason people don't ship databases with 100KB programs for example, is because the database is just too big for the customer to justify. And it's also too hard to install too.
      </p>
      <p>
        <em>I grew up in the Era of Clipper and Delphi. It was quite easy to ship these with a database engine. Often there were ways to update the code separate from the database engine such that the app executable was relatively small. For example, a typical application may have had a 300k database + library section, and the app part was about 50k. This was important in the modem age. There was also an option to put it together into one big EXE. I think products went away from these when OOP became popular, but such products showed it could be done. I agree that existing products are weak. But this is not because of limited possibilities, but because of fads.</em>
      </p>
      <p>
        {I grew up in the late era of Delphi. Can you point me to some clipper pages? Are they still around? Sounds interesting. Personally, I have been looking for embedded database solutions so I can ship a database with the application and not worry about size/installation. Yes, I do want to ship even a small database with my application instead of using an ini file many times (despite my previous comment.. that was more playing devil's advocate). Especially when the ini file gets complicated and larger than originally intended. Or the ini file starts having multi dimensions (turn two ini files into one with a database.) Or where XML would normally be used to store data by an XML weenie, I'd hope to use an embedded database. But you don't hear about it these days? Because people just don't see the light? My view is that sometimes OO encourages laziness. "Oh, don't waste time integrating a database with the application, just make a few extra objects for all these data snippets and be done with it." I'd still like something even smaller and more shippable than firebird and SQL though.} 
      </p>
      <p>
        They don't solve that specific problem, unless they are rolled. So roll your own smaller database, maybe even based on the original. Some database weenies might go as far as thinking that even ini files are flawed, and that even ini files should be run as database instead.
      </p>
      <p>
        <em>When table browsers were as nimble as text editors back in the early 90's, I saw no problem with that. Again, it is a matter of what is popular, not what is possible.</em>
      </p>
      <p>
        {Yes that would be nice.. I agree. It would be lovely to have a common tool to edit small database files, instead of all this XML. Even some of the config files bother me, because you have to sift through all the comments just to get to one little setting. It could be organized in a mini-database instead with a "comment" column.}
      </p>
      <ul>
        <li>
           Suggestions may be found under <a href="NimbleDatabase.html">NimbleDatabase</a>
        </li>
      </ul>
      <p>
        If you resort to database communism, every program including Ed and the Clock on the taskbar will be run off a database. But the database wasn't programmed in database, it was programmed in a programming language. Keep in mind that you can't program a database with a database. But you can program a program with a program. Some of the thrill about programming is about the thrill of being able to <em>program a database</em>. But you can't <em>database a program</em>.
      </p>
      <p>
        <em>I don't see what this has to do with anything. Everything is 1's and 0's underneath. However, that does not imply that we should program directly in binary. I agree that DB's may not be the best choice for </em><a href="SystemsSoftware.html">SystemsSoftware</a>, but I find them great for custom applications.<em></em>
      </p>
      <p>
        Well, I guess the real point I should have made was that some people are lazy and just find it easier to "roll their own" in OO..because you already have your compiler open (or your text editor) and it is easier to just create a few objects (or recently, XML files) and integrate them into the app. If there was an easy to use <a href="EmbeddedDatabase.html">EmbeddedDatabase</a> system that people could integrate into their applications, it would make it so much easier. I'd love to see all the XML replaced with embedded databases. And large config files could also be replaced with them. Still use config files for really small things though. 
      </p>
      <hr/>
      <p>
        <strong>These are in fact standard database operations that are never reimplemented. That point stands despite the fact that, yes, C/C++/Java/etc are Turing Complete and can be used to implement these and much more. I think the original phrasing "..are terms for typical database operations..." was completely fair. Possibly </strong><a href="TopMind.html">TopMind</a> doesn't understand non-DB programming, but also possibly his detractors aren't steeped in DB paradigms.  -- <a href="DougMerritt.html">DougMerritt</a><strong></strong>
      </p>
      <p>
        I don't know if I'm completely steeped in DB paradigms, but I've been soaking in them long enough to get wrinkled fingers.  The problem is that every time someone uses one of these verbs in OO code, Top sees that as evidence that an RDBMS should be used.  Although these verbs are used for typical database operations, use of these verbs doesn't demand the use of a database.  These verbs are used for typical set and file operations.  Database operations are one instance of those, but not the only instance.
      </p>
      <p>
        <em>Is it the topic name that bothers you, or the implication that seem to come with the topic name? Lets consider some alternative names, how about. -- top</em>
      </p>
      <p>
        It is the way you use the topic name.  These are mostly set verbs.  Databases manipulate sets, but they aren't the only tools that do so.
      </p>
      <p>
        <em>Ok, fair enough. Still, don't overreact. RDBMS is a definite paradigm, and for certain things, a handy one. It is a mistake to insist on using a relational database for every kind of programming, but it is also a mistake to go to the other extreme and, for instance, re-invent databases piecemeal and badly without making full ACID guarantees -- and this has in fact happened quite often. -- </em><a href="AnonymousDonor.html">AnonymousDonor</a> (not-top)<em></em>
      </p>
      <p>
        It is actually impossible to use a relational database as the baseis for many kinds of interesting and useful programming; creating devices that are aware of and responsive to their environment without recording and manipulating complicated state history data come immediately to mind.
      </p>
      <ul>
        <li>
           "Impossible"? Or merely not the most appropriate? I would like to request a specific <a href="UseCase.html">UseCase</a> to investigate. Is this related to the "unpredictable timing" issues raised in <a href="AreRdbmsSlow.html">AreRdbmsSlow</a>?
          <ul>
            <li>
              Impossible, yes, because databases are programmed from a programming language. You cannot program a programming language from a database. This isn't like the chicken and the egg situation. The database came from the programming language. There is no vice versa.
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <em>Skipping the ACID part and looking just at one of the operations that is a key part of the paradigm, filtering, it certainly isn't necessary to always use an RDBMS for filtering. One of the really handy things about the Unix shell is that it supports ad hoc searching and filtering of text files and streams, for instance. So filtering is part of the Unix shell programming paradigm, too.</em>
      </p>
      <p>
        <em>On the other hand, while filtering can be implemented in any programming language, it isn't part of the </em>'paradigm<strong> for most languages, and this makes a difference. When I create a new collection class in C++ or Java, I need to be on the ball and reimplement filtering on that class, too, or else I lose the power of the filtering paradigm. It is not </strong>pervasively available<em>' as it is in the shell.</em>
      </p>
      <p>
        <em>Is that an argument for always using an RDBMS? Heck no. It's an argument for doing all programming in the shell. Just kidding! :-) -- dm</em>
      </p>
      <p>
        All these things are pervasively available in Smalltalk, Ruby, Python and Lisp, among others. -- <a href="RobertChurch.html">RobertChurch</a>
      </p>
      <p>
        This issue taken up in <a href="DedicatedStructuresVersusRdbms.html">DedicatedStructuresVersusRdbms</a>.
      </p>
      <hr/>
      <p>
        <a href="EditHint.html">EditHint</a>: I am half-planning on renaming this topic to <a href="CollectionOrientedVerbs.html">CollectionOrientedVerbs</a>. Any objections? --top
      </p>
      <hr/>
      <p>
        See also: <a href="InterfaceFactoring.html">InterfaceFactoring</a>, <a href="WhenAreStandardsRestrictive.html">WhenAreStandardsRestrictive</a>, <a href="ModularProgramming.html">ModularProgramming</a>
      </p>
    </div>
  </body>
</html>