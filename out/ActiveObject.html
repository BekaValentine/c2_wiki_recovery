<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Active Object
      </h1>
      <p>
        An object executing in its own thread of control.
      </p>
      <p>
        The nice thing about this idea is that there is a one-to-one relation between an object and a thread, simplifying the understanding and handling of concurrency in a program.
      </p>
      <p>
        Common OO languages do not directly support this concurrency model, so one has to implement one's own wrappers and synchronization mechanisms to ensure a method invocation on such an <a href="ActiveObject.html">ActiveObject</a> from another thread (and it is usually another thread) is properly transferred into the execution of the method's implementation using the object's own thread.
      </p>
      <p>
        Also methods usually have an asynchronous invocation behavior. That is, the method invocation returns before the method has been finished (why else would someone provide an object with an own thread of control?). This, however, means that values which are supposed to be returned from the method are not ready/available when the method returns. This can e.g. be solved by using a <a href="FutureValue.html">FutureValue</a>.
      </p>
      <p>
        An alternative paradigm is that of <a href="FlowBasedProgramming.html">FlowBasedProgramming</a> or Linda (see <a href="LindaLanguage.html">LindaLanguage</a>) - in these systems, a process receives a stream of information packets or "tuples", applying processing to each one, and generating a stream of results. In this environment, there is usually no need for the sending process to wait for the results of the processing - they go <em>onwards</em>. In one of the papers on Linda, <a href="DavidGelernter.html">DavidGelernter</a> and <a href="NicholasCarriero.html">NicholasCarriero</a> state "processes in a parallel program usually don't care what happens to their data." However, if they do care, a <em>call</em> can be simulated by a <em>put</em> followed by a <em>get</em>.  DG and NC make this point also in their Linda paper. -- <a href="PaulMorrison.html">PaulMorrison</a>
      </p>
      <p>
        The <a href="ActiveObject.html">ActiveObject</a> pattern is described in the book <a href="PatternOrientedSoftwareArchitectureTwo.html">PatternOrientedSoftwareArchitectureTwo</a>.
      </p>
      <p>
        -- <a href="ThomasWeidenfeller.html">ThomasWeidenfeller</a>
      </p>
      <p>
        Simula had active objects with the standard simset module (I might misremember de name). Altough it wasn't using threads but corutines (sometimes implemented with treads or processes). There where other modules that implemented true paralellism in the same fashion, but they weren't standardised. Most Simula objects never leaved their "class body" during the execution of an application. I really miss Simula it was superior to most of its decendents. If it had been invented in USA, a modernised version would probably have been the dominating programming language today. -- Martin Jansson
      </p>
    </div>
  </body>
</html>