<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Extend Class
      </h1>
      <p>
        In <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> this refers to adding a method to a class in a different package than the package the class lives in. This is different to the inheritance mechanism, and I believe quite different to extending a class in <a href="JavaLanguage.html">JavaLanguage</a> (yes/no?). 
      </p>
      <p>
        This is one of the real strengths of <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>, and helps prevent the mushrooming of <a href="ParallelClassHierarchies.html">ParallelClassHierarchies</a> when you need to add another layer on to your model. 
      </p>
      <p>
        <a href="DanielPoon.html">DanielPoon</a>
      </p>
      <p>
        <em>Hmm, I'm no </em><a href="SmalltalkLanguage.html">SmalltalkLanguage</a> expert, but what's this "package" thing you speak of?<em></em>
      </p>
      <p>
        I guess a package maps to a source file in CPlusPlusLanguage. For a class in CPlusPlusLanguage, one source file contains the class definition. Other source files then implement those the methods in the class. 
      </p>
      <p>
        In <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>, one package defines the class, and usually some methods. Other packages then add methods to that class. There is however no reference to those additional methods in the original class definition. Class definitions specify data structure, not methods or interfaces. 
      </p>
      <p>
        This sort of thing is possible in <a href="ObjectiveCee.html">ObjectiveCee</a> as well, using categories.  Additional methods can be added to a class at runtime, using this syntax:
      </p>
      <code>
        @interface NSObject(MyAdditions)<br/>
        - yourself;<br/>
        @end<br/>
      </code>
      <code>
        @implementation NSObject(MyAdditions)<br/>
        - yourself<br/>
        {<br/>
        return self;<br/>
        }<br/>
        @end<br/>
      </code>
      <p>
        Compare to a usual class definition:
      </p>
      <code>
        @interface MyKeenObject : NSObject  {<br/>
        }<br/>
        ...<br/>
        @end<br/>
      </code>
      <code>
        @implementation MyKeenObject<br/>
        ...<br/>
        @end<br/>
      </code>
      <p>
        Categories provide a flexible, easy way to extend objects that already exist in the system.  The only limitations are: 
      </p>
      <p>
        Categories can add no additional instance variables.
      </p>
      <p>
        Categories, if they implement a method of the original object, zap that method whilst there-- it is impossible to call the 'normal' implementation.
      </p>
      <p>
        <em>They also break encapsulation - not normally a problem though in my experience</em>
      </p>
      <p>
        They do? How? Is it different(in terms of encapsulation, etc) from just appending the new method(s) to the original implementation?--<a href="JoeOsborn.html">JoeOsborn</a>
      </p>
      <p>
        Perhaps <em>break encapsulation</em> was a bit strong. If you extend a class in Smalltalk, these methods have full access to its instance methods. They are exactly the same as 'just appending the new methods(s) to the original implementation' in C++. In <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>, the class definition is purely a data structure definition. Methods are defined elsewhere. -- <a href="DanielPoon.html">DanielPoon</a>
      </p>
    </div>
  </body>
</html>