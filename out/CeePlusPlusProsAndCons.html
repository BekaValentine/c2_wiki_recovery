<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Cee Plus Plus Pros And Cons
      </h1>
      <p>
        <strong>Background information</strong>
      </p>
      <p>
        For a good description of the C language, see: <a href="http://en.wikipedia.org/wiki/C_programming_language">http://en.wikipedia.org/wiki/C_programming_language</a>
      </p>
      <p>
        The article on <a href="CeePlusPlus.html">CeePlusPlus</a> is at <a href="http://en.wikipedia.org/wiki/C%2B%2B">http://en.wikipedia.org/wiki/C%2B%2B</a>
      </p>
      <p>
        For a good description of the Object Oriented concept, see: <a href="ObjectOrientedForDummies.html">ObjectOrientedForDummies</a>; <a href="EncapsulationForDummies.html">EncapsulationForDummies</a>
      </p>
      <hr/>
      <p>
        <strong>Pros</strong>
      </p>
      <ul>
        <li>
           This is the closest to a <a href="UniversalProgrammingLanguage.html">UniversalProgrammingLanguage</a> as any <a href="ProgrammingLanguage.html">ProgrammingLanguage</a> is. There are C++ programmers in every country in the world. If you start an application in C or C++, chances are you won't spend 10 years looking for a programmer who can continue it.
        </li>
      </ul>
      <ul>
        <li>
           C++ is a <a href="MultiParadigmProgrammingLanguage.html">MultiParadigmProgrammingLanguage</a> spanning a broad range of <a href="LevelsOfAbstraction.html">LevelsOfAbstraction</a>. You can use it as portable <a href="AssemblyLanguage.html">AssemblyLanguage</a> like <a href="CeeLanguage.html">CeeLanguage</a>, you can do OO with classes, or you can do template <a href="MetaProgramming.html">MetaProgramming</a> at a much higher level of abstraction than most other languages. <em>I wonder what these "most" other languages are...</em>
        </li>
      </ul>
      <ul>
        <li>
           It creates native executables. No need to have an interpreter around. You receive the program and it's ready to run. Though you may need to have all the right versions of all the right shared libraries.
        </li>
      </ul>
      <ul>
        <li>
           You can port it to any OS with just minor modifications if you stick to the very strict confines of the <a href="CeePlusPlus.html">CeePlusPlus</a> standard.
          <ul>
            <li>
               ... but it is difficult to write a non-trivial program this way.  In particular, you get no support for graphics, concurrency, synchronization, networking, I/O (other than what stdio provides), multimedia, etc.
              <ul>
                <li>
                   It can be solved by Using portable libraries such as AdapativeCommunicationEnvironment, OpenGraphicsLibrary, and many others.  Think about how other portable languages can be implemented using C/C++.
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           It is quick, lightning speed sometimes (<a href="AsFastAsCee.html">AsFastAsCee</a>); but I am told this has nothing to do with the language but more to do with the way the programmer has built his code.
          <ul>
            <li>
               It has to do with the following:
              <ul>
                <li>
                   Large number of highly-optimized compilers avaiable
                </li>
                <li>
                   It compiles to native code, not <a href="ByteCode.html">ByteCode</a>
                </li>
                <li>
                   Low-level programming contructs enable lots of ad-hoc, programmer-specified optimizations that simply cannot be coded in a higher-level language
                  <ul>
                    <li>
                       Many feel that including such optimizations (especially without profiling telling you they are needed) is poor design practice.
                    </li>
                    <li>
                       In theory, a <a href="SufficientlySmartCompiler.html">SufficientlySmartCompiler</a> could produce similar levels of optimization on a higher-level language; in practice such compilers don't exist (or are unsuitable for production use).
                    </li>
                  </ul>
                </li>
                <li>
                   <a href="StaticTyping.html">StaticTyping</a>.  <a href="DynamicTyping.html">DynamicTyping</a> is wonderful for lots of things (this is <em>not</em> an anti-<a href="DynamicTyping.html">DynamicTyping</a> rant), but it imposes a performance penalty.
                </li>
                <li>
                   Arguably, the lack of <a href="GarbageCollection.html">GarbageCollection</a> improves performance.  (Many advocates of GC dispute this.  Unfortunately, most production languages which do use <a href="GarbageCollection.html">GarbageCollection</a> also use <a href="VirtualMachine.html">VirtualMachine</a>s, so an apples-to-apples comparison is difficult here).  The lack of <a href="GarbageCollection.html">GarbageCollection</a> is also important when memory is limited (for example, on game consoles) because efficient garbage collectors have a much larger memory overhead than a good manual allocator.
                </li>
              </ul>
            </li>
            <li>
               That said, for many applications being <a href="AsFastAsCee.html">AsFastAsCee</a> is simply unnecessary; and use of a higher-level language is a better choice (from an economic perspective; which is one that can be measured somewhat).  For some applications, C++ is indeed a better choice.  <a href="MooresLaw.html">MooresLaw</a> will likely cause the set of applications where C++ is the optimal choice to shrink--it has been shrinking for years now, though some <a href="SmugSmalltalkWeenie.html">SmugSmalltalkWeenie</a>s will tell you that it has always been the empty set. :)
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <p>
        <strong>Cons</strong>
      </p>
      <ul>
        <li>
           This is a difficult language; it's hard to learn, hard to practice.
        </li>
      </ul>
      <ul>
        <li>
           It does not hook, connect to modern-day databases such as MYSQL easily.
        </li>
      </ul>
      <ul>
        <li>
           Any non-trivial program will also be non-portable without a lot of extra work.
          <ul>
            <li>
               This is recognized in the development of reusable components portable to different systems, e.g. <a href="BoostLibraries.html">BoostLibraries</a>.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           It is not considered an internet-friendly programming language because of its poor string handling capability. Buffer overflow exploits are common in C programs, and nearly impossible in higher level languages. See <a href="CeeLanguageAndBufferOverflows.html">CeeLanguageAndBufferOverflows</a>. (I think this is more applicable to <a href="CeeLanguage.html">CeeLanguage</a> than C++ since you can use <a href="StandardTemplateLibrary.html">StandardTemplateLibrary</a>'s string class to avoid that)
        </li>
      </ul>
      <ul>
        <li>
           C++ doesn't have built-in automatic memory management. (but see <a href="GarbageCollectionInCpp.html">GarbageCollectionInCpp</a>)
        </li>
      </ul>
      <ul>
        <li>
           Researchers and anecdote both suggest that programmers are much less productive in C/C++ than in Java or other <a href="HighLevelLanguage.html">HighLevelLanguage</a>s. See also <a href="GreenspunsTenthRuleOfProgramming.html">GreenspunsTenthRuleOfProgramming</a>.  <em>Such comparisons also tend to reflect badly on Java (a close cousin to C++), though not quite as a badly as C++.</em>
        </li>
      </ul>
      <ul>
        <li>
           It does not support generalized overloading [see <a href="http://www.research.att.com/~bs/whitespace98.pdf]">http://www.research.att.com/~bs/whitespace98.pdf]</a>
        </li>
      </ul>
      <ul>
        <li>
           Large C++ projects often have long build times.  Some causes are textual includes (unless you are very disciplined and/or work hard to minimize dependencies), heavy use of templates, and large amounts of debug information that get produced.
        </li>
      </ul>
      <hr/>
      <p>
        See <a href="CeePlusPlusReigns.html">CeePlusPlusReigns</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryCpp.html">CategoryCpp</a>
      </p>
    </div>
  </body>
</html>