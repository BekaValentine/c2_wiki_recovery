<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Is Xp Unit Testing Best
      </h1>
      <p>
        Is the <a href="ExtremeProgramming.html">ExtremeProgramming</a> form of <a href="UnitTest.html">UnitTest</a>ing the best way to do your testing, or are there better ways?
      </p>
      <p>
        (Realize that to "do <a href="ExtremeProgramming.html">ExtremeProgramming</a> <a href="UnitTest.html">UnitTest</a>s properly," you have to adopt all the practices of <a href="ExtremeProgramming.html">ExtremeProgramming</a>.)
      </p>
      <p>
        Actually there are very few details in XP <a href="UnitTest.html">UnitTest</a>ing, and they're all kind of butt simple and obvious: 
      </p>
      <ul>
        <li>
           you have to have tests for everything that could break
        </li>
        <li>
           when something breaks downstream, you have to write a new unit test that finds that defect
        </li>
        <li>
           you have to integrate before releasing code and all the tests have to run at 100 percent
        </li>
      </ul>
      <p>
        So all the sarcasm about XP fanatacism aside, if you have a better way of testing, use it. XP just says you have to have <a href="UnitTest.html">UnitTest</a>s and offers some hints on how to do it.
      </p>
      <p>
        Recent XP usage is to do <a href="TestFirstProgramming.html">TestFirstProgramming</a>, which does seem to be a really good way to do things. Try it, you might like it.
      </p>
      <hr/>
      <p>
        <strong><em>Why?</em></strong>
      </p>
      <p>
        See <a href="IfXpIsntWorkingYoureNotDoingXp.html">IfXpIsntWorkingYoureNotDoingXp</a>.
      </p>
      <p>
        <em>Alternate answer:  If you're not using the </em><a href="ExtremeProgramming.html">ExtremeProgramming</a> form of <a href="UnitTest.html">UnitTest</a>ing, then you're not doing <a href="ExtremeProgramming.html">ExtremeProgramming</a>; you're doing something else.  You may succeed or fail, but you won't be doing <a href="ExtremeProgramming.html">ExtremeProgramming</a>.<em></em>
      </p>
      <hr/>
      <p>
        <em>[Discussion from </em><a href="UnitTestsReconsidered.html">UnitTestsReconsidered</a>.  Unsigned comments are assumed to be from <a href="SunirShah.html">SunirShah</a>.]<em></em>
      </p>
      <p>
        On this site, anything <em>not</em> XP must be defended, just like on Slashdot, anything not Linux (or BSD) must be defended. But more importantly, it could be that XP practices the better way, in which case I'd like to adopt it. Or, forgetting XP, there could be a better way that everyone should be aware of.
      </p>
      <p>
        My actual position is that testing should use a variety of methods, whatever is most efficient for the case at hand. <a href="BusinessValueFirst.html">BusinessValueFirst</a>, not what's written in the <a href="ThreeRingBinder.html">ThreeRingBinder</a>. On the other hand, consider the <a href="WorseIsBetter.html">WorseIsBetter</a> stance that many companies take, including <a href="NetScape.html">NetScape</a> to its great initial success. Often bugs are acceptable if you can beat your competitor to market. This is also a real life concern that can't be ignored by a professional.
      </p>
      <p>
        That being said, <a href="NetScape.html">NetScape</a>'s <a href="BigBallOfMud.html">BigBallOfMud</a> shot them in the foot later. Ok, so it's complicated. That's life.
      </p>
      <dl>
        <dt> </dt>
        <dd>You mentioned one of the reasons for not <a href="UnitTest.html">UnitTest</a>ing is that when the classes change that you end up having to change all the tests. However, in my opinion, this is a <em>good thing</em> about <a href="UnitTest.html">UnitTest</a>ing. It pushes you to pay more attention to the design of your public interfaces while allowing you to continually refactor their implementation (and the protected interfaces). If you design the public interfaces haphazardly, you pay by having to rewrite your <a href="UnitTest.html">UnitTest</a>s. After all, if ones <em>public</em> interfaces are changing that often, then something is very wrong. They are either an inconsiderate <em>provider</em> or they are not spending enough timing on the design. -- <a href="RobertDiFalco.html">RobertDiFalco</a></dd>
      </dl>
      <p>
        The fallacy here is assuming it's possible to get the design right the first time you code it. I'm a big fan of not getting the right design the first time, but jumping in and getting a feel for the solution space before I stabilize. Testing is deadly here. Moreover, any practice that makes you <em>pay</em>--that punishes you--for improving the design is <strong>wrong.</strong> It has to be. You should always be encouraged to make things better, and discouraged from making things worse. Anything other than that pushes the system in the wrong direction, towards <em>worse</em>.
      </p>
      <dl>
        <dt> </dt>
        <dd>How can you use the actual production code that is a client of your code if you haven't written your code yet? -- anon.</dd>
      </dl>
      <p>
        Obviously the client code is written. I implement enough so that the client code compiles, and then I keep writing until the functionality is complete. This is iterative, client-driven design. It's much like <a href="TestFirstDesign.html">TestFirstDesign</a>, except instead of using <a href="UnitTest.html">UnitTest</a>s (which have no callers), this keeps the design to the minimal necessary set. I've seen how <a href="UnitTest.html">UnitTest</a> driven design encourages the creation of complete stand-alone units, that could almost be shipped on their own! This is bad. Never implement more than you need to, no matter how cool it would be to add a Visitor to a Sequence collection.
      </p>
      <p>
        By the way, I don't strictly follow this, but it's the general heuristic I follow. I don't strictly follow anything, strictly speaking.
      </p>
      <dl>
        <dt> </dt>
        <dd>Okay, Sunir, let's take it from the top. You write a string class, how do you decide its okay to give to the rest of your team to use? How do you know your code does anymore than compile? After all, you say you only test things in applications and never in units. -- <a href="RobertDiFalco.html">RobertDiFalco</a></dd>
      </dl>
      <p>
        Oh, that's easy. The last time I wrote a string class was just for the fun of it, so I had no callers. I wrote a <a href="UnitTest.html">UnitTest</a>. It's true; I'm not trying to be smarmy. 
      </p>
      <p>
        Note that this isn't as much of a problem if you believe that <a href="MethodsShouldBePublic.html">MethodsShouldBePublic</a>. The problem is unit <em>code</em> written specifically for the unit <em>tests</em> that in turn must be tested. Encapsulation is evil.
      </p>
      <hr/>
      <p>
        <strong>Discussion</strong>
      </p>
      <p>
        I found <a href="CodeUnitTestFirst.html">CodeUnitTestFirst</a> to be different from whatever I was doing before, and to be different from programming with a lot of <a href="UnitTest.html">UnitTest</a>s. In that light, it seems to me that it might be fair to ask whether someone who writes CodeUnitTestFirstIsWeak has some experience with <a href="CodeUnitTestFirst.html">CodeUnitTestFirst</a>. If he has, and it wasn't favorable, I'd like to hear about that rather than the discussion above, which sounds rather speculative and supportive of some other approach rather than reflecting directly on the practice under question. Does that seem inappropriate or unfair? -- <a href="RonJeffries.html">RonJeffries</a>
      </p>
      <p>
        I hope I've explained my point of view fairly.
        <em>[...]</em>
        Well, I've at least defined what I consider to be <a href="UnitTest.html">UnitTest</a>s, so that should help. -- <a href="SunirShah.html">SunirShah</a>
      </p>
      <p>
        <em>[...which would be the </em><a href="StandardDefinitionOfUnitTest.html">StandardDefinitionOfUnitTest</a>, if I understand this right.  -- <a href="JeffGrigg.html">JeffGrigg</a>]<em></em>
      </p>
      <hr/>
      <p>
        <em>[A (somewhat biased) summary of </em><a href="SunirShah.html">SunirShah</a>'s XP comments on <a href="XpVsStandardDefinitionOfUnitTest.html">XpVsStandardDefinitionOfUnitTest</a> -- focusing on the "<a href="IfXpIsntWorkingYoureNotDoingXp.html">IfXpIsntWorkingYoureNotDoingXp</a>" issue:]<em></em>
      </p>
      <p>
        Problem:  XP is marketed as the "One True Solution" -- it's an all-or-nothing affair; you do all of XP, or you're doomed.  For example: Refactoring is good, but you don't need <a href="UnitTest.html">UnitTest</a>s to do it. (See <a href="CoreXpDependencies.html">CoreXpDependencies</a>)
      </p>
      <p>
        <em>This is a very controversial statement.  </em><a href="MartinFowler.html">MartinFowler</a>, for example, thinks you need <a href="UnitTest.html">UnitTest</a>s to refactor, and he probably knows something about the subject.  A real-life example of a refactoring that was carried out without unit tests, while maintaining confidence that the code behaves the same, and expending less effort to do so than using unit tests would have, would be helpful here.<em></em>
      </p>
      <dl>
        <dt> </dt>
        <dd>Don't you remember your university assignments? Who writes unit tests for those things? (Well, I do, so maybe I invalidate my own argument.) Yet most people can get them working in less than a day. Small scopes. This is not necessarily recommended practice if you have a customer willing to sue you, but an indication that doom and despair won't befall you without <a href="UnitTest.html">UnitTest</a>s... if you're "smart" enough. -- <a href="SunirShah.html">SunirShah</a></dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd>Not to mention the somewhat obvious observation that a suite of <a href="AcceptanceTest.html">AcceptanceTest</a>s gives you much <em>more</em> confidence that the code behaves the same. -- <a href="GeoffBache.html">GeoffBache</a></dd>
      </dl>
      <p>
        <a href="SunirShah.html">SunirShah</a>'s experience is that <a href="UnitTest.html">UnitTest</a>ing is often disastrous -- he's seen people stuck in mud give up and throw out all automated regression testing.
        <em>...which makes the XP experience, getting </em><a href="TestInfected.html">TestInfected</a> with <a href="UnitTest.html">UnitTest</a>s, very interesting to Sunir ? "you love what everyone else hates with a passion, for some definition of everyone."<em></em>
      </p>
      <p>
        Sunir advocates using a variety of testing methods, complexity reduction, eye balling, and good faith. For instance, relying on <a href="AcceptanceTest.html">AcceptanceTest</a>s, and doing <a href="UnitTest.html">UnitTest</a>s when necessary. For him, this approach works, while an extreme application of <a href="UnitTest.html">UnitTest</a>s has not.
      </p>
      <p>
        <em>Don't forget, if it's not automated, it's broken. If your entire system doesn't have automated quality control, you're hosed. </em><a href="UnitTest.html">UnitTest</a>s are part of that solution. Stress and load testing is another. Eye balling only works with aggressive eyes, and some domains can only be verified with eyes, like graphics and GUIs. Unsurprisingly, the GUI always contains the most bugs. Guess what domains I used to work in, which is why I'm so adamant you can't rely on <a href="UnitTest.html">UnitTest</a>ing alone. -- <a href="SunirShah.html">SunirShah</a><em></em>
      </p>
      <dl>
        <dt> </dt>
        <dd>More recently I've been working in domains where the online debugger is difficult to use and porting is the norm, not the exception. <a href="ConfigurationManagement.html">ConfigurationManagement</a> without regression tests is difficult, let alone developing code (<strong>No bugs!</strong>). Consequently, I've been <a href="UnitTest.html">UnitTest</a>ing more actively. However, the test code is expensive to write and is often wrong. Of course, the code that most needs the tests has tests that are the most wrong. Nonetheless, for the most normal parts of the system, the tests are cheaper than stepping through the code or learning and predicting all possible configurations under which it would be run (as would happen in code reviews). Then again, as you may have guessed, the unit tests were bad because we don't do <a href="PairProgramming.html">PairProgramming</a>--i.e. no aggressive code reviewing. Also, constantly poor tests are a flagrant sign of a lack of knowledge about the problem on my part, and consequently poor overall design. But that's why there are <a href="BugsInTheTests.html">BugsInTheTests</a>. -- <a href="SunirShah.html">SunirShah</a></dd>
      </dl>
      <p>
        <em>OK; when are </em><a href="UnitTest.html">UnitTest</a>s necessary?  XP's answer is "So often that you shouldn't even waste time thinking about it -- just write them."<em></em>
      </p>
      <p>
        XP's answer is really ingenious. Write one at a time, one implemented functional point at a time. That way you're guaranteed not to screw up. -- <a href="SunirShah.html">SunirShah</a>
      </p>
      <hr/>
      <p>
        I tend to rely on what I will call functional tests (as something different from either <a href="UnitTest.html">UnitTest</a>s or <a href="AcceptanceTest.html">AcceptanceTest</a>s), as this tends to keep the focus on what the user wanted.  You can have all of your <a href="UnitTest.html">UnitTest</a>s pass and still not have the program perform the desired functionality.  You can do test first design equally as well with functional tests as unit tests.  Just view your higher level classes as the test environment for your lower level functions.  Maintaining a full suite of <a href="UnitTest.html">UnitTest</a>s seems to be too high a price to pay and would seem to inhibit refactoring (due to the effort required to modify all of the affected <a href="UnitTest.html">UnitTest</a>s). -- <a href="WayneMack.html">WayneMack</a>
      </p>
      <hr/>
      <p>
        I would tend to agree here - as someone who does all of XP bar the <a href="UnitTest.html">UnitTest</a>s and seems to be getting on just fine. This was largely because I was doing automated regression testing with <a href="AcceptanceTest.html">AcceptanceTest</a>s before I heard of XP, followed the advice to solve your worst problem first, and found that testing never became a problem. The pragmatist in me said to not solve problems that don't exist.
      </p>
      <p>
        Here is very briefly, some thoughts to trigger some discussion, based on what people say on why you can't do XP without unit tests. (Please mentally note that "I" refers to "my team and I" throughout - I don't do this alone!)
      </p>
      <p>
        <em>"</em><a href="AcceptanceTest.html">AcceptanceTest</a>s are too coarse-grained and miss too many bugs".<em> This seems an obvious fallacy - if the </em><a href="AcceptanceTest.html">AcceptanceTest</a>s are missing the bugs, they are wrong. They should catch lots <em>more</em> bugs, because there are less "cracks" for the bugs to hide in. They should also catch bugs the customer actually cares about.
      </p>
      <dl>
        <dt> </dt>
        <dd>I don't think it's a fallacy.  It's very hard to be sure that you're <a href="AcceptanceTest.html">AcceptanceTest</a>s test all the boundary conditions deep inside the code.  Do you have an <a href="AcceptanceTest.html">AcceptanceTest</a> case that exposes the rare divide-by-zero error deep in the program?  How about the one bug that pops up when the disk fills up, but only when it fills up for a particular write statement?</dd>
      </dl>
      <p>
        <em>"Although they catch many bugs, it takes too long to run them to do it often enough".</em> There should be no reason why all <a href="AcceptanceTest.html">AcceptanceTest</a>s should be slow. By being prepared to sacrifice even a tiny amount of the <a href="EndToEndPrinciple.html">EndToEndPrinciple</a> for just some of your <a href="AcceptanceTest.html">AcceptanceTest</a>s, it should be easy to generate fast <a href="AcceptanceTest.html">AcceptanceTest</a>s. This may not always work, there will always be someone whose domain is fiendishly hard to <a href="AcceptanceTest.html">AcceptanceTest</a> quickly. That shouldn't stop the rest of us.
      </p>
      <p>
        <em>"Although you can do this, it takes too long to get from an </em><a href="AcceptanceTest.html">AcceptanceTest</a> failure to fixing a bug".<em> Again, this may be true sometimes, but I think it is true much less often than people say. You can always see what area of the system the bug is in, often to quite a detailed level, by looking at where behaviour first diverged. Comparison of detailed diagnostics can then often lead fast to a problem solution. Of course, you need to have detailed diagnostics, but I think this is valuable anyway.</em>
      </p>
      <p>
        <em>"By leaving out the </em><a href="UnitTest.html">UnitTest</a>s, you miss the benefits of <a href="TestFirstDesign.html">TestFirstDesign</a>".<em> This is true in a strict sense, but it is very possible (as we do) to do </em><a href="EvolutionaryDesign.html">EvolutionaryDesign</a> and Refactoring with just <a href="AcceptanceTest.html">AcceptanceTest</a>s. In my view, this is where much of the power of XP design paradigm comes from. In any case, most proponents of <a href="TestFirstDesign.html">TestFirstDesign</a> compare it with <a href="BigDesignUpFront.html">BigDesignUpFront</a> rather than <a href="EvolutionaryDesign.html">EvolutionaryDesign</a> with Refactoring - if anyone has any experience/empirical evidence of <a href="TestFirstDesign.html">TestFirstDesign</a> compared to other evolutionary approaches, I'd be very interested to see it.
      </p>
      <p>
        <em>"They're different, man, </em><a href="AcceptanceTest.html">AcceptanceTest</a>s are to give the Customer confidence, while <a href="UnitTest.html">UnitTest</a>s are to give the Developer confidence".<em> As a developer, I get my confidence from the customer's confidence. These should be the same thing. Confidence in my own design (or internal quality) can only come as I evolve it - it's not as if the presence of </em><a href="UnitTest.html">UnitTest</a>s proves that you have a good design.
      </p>
      <p>
        <em>"</em><a href="AcceptanceTest.html">AcceptanceTest</a>s are too hard to automate".<em> They shouldn't be. We wrote our own framework to automate them that has gradually evolved to be application-independent. I hope to write a paper about it soon.</em>
      </p>
      <p>
        Hope that gives some food for thought -- <a href="GeoffBache.html">GeoffBache</a>
      </p>
      <hr/>
      <p>
        I've also experienced problems with Automated<em></em><a href="RegressionTesting.html">RegressionTesting</a>, when applied in isolation:
        Over the long term, conventional (non-XP) projects tend to oscillate between griping about how hard it is to maintain the tests (so they let them get way out of date and then discard them as no longer useful), and griping that the application is too full of bugs and too costly to test by hand (so they have to rebuild the tests from scratch).
        <strong>Very expensive and painful.</strong>
        But that's the way that lots of conventional (non-XP) projects really work out there in the real world.
        Blame the <a href="PointyHairedBosses.html">PointyHairedBosses</a>, and uninformed/inexperienced project leads.
        -- <a href="JeffGrigg.html">JeffGrigg</a>
      </p>
      <p>
        The issue with <a href="UnitTest.html">UnitTest</a>s is that they are too fine grained.  One individual functional test can replace multiple individual unit tests.  The <a href="FunctionalTest.html">FunctionalTest</a> is unaffected by refactoring, while the <a href="UnitTest.html">UnitTest</a>s must be added, deleted, or modified to reflect refactoring.  If I assume that I am only making incremental changes in either refactoring or added functionality, then the <a href="UnitTest.html">UnitTest</a> does not provide any more problem isolation than the functional test.  The issue is not whether to provide regression testing, but whether regression testing needs to be at the class level. -- <a href="WayneMack.html">WayneMack</a>
      </p>
      <p>
        <em>A </em><a href="FunctionalTest.html">FunctionalTest</a> will cover one particular use of each unit collaborating in the functionality. Diligent application of <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a> will result in unit functionality being called upon for several uses. From these two hypotheses, can we predict whether defects might go undetected if we only have <a href="FunctionalTest.html">FunctionalTest</a>s, and no <a href="UnitTest.html">UnitTest</a>s? On the other hand: if the situation is such that an existing <a href="FunctionalTest.html">FunctionalTest</a> covers EverythingThatCouldPossiblyBreak, is there a decision we can make regarding adding one or more <a href="UnitTest.html">UnitTest</a>s to it?<em></em>
      </p>
      <p>
        See <a href="CompleteCoverageIsExpensive.html">CompleteCoverageIsExpensive</a>.
      </p>
      <p>
        Hmmm.... a <a href="FunctionalTest.html">FunctionalTest</a> that covers EverythingThatCouldPossiblyBreak is going to have a lot of repeated parts.  If we get <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a> on it, it's going to have a lot of reusable parts, which get called repeatedly.  Each reusable part will focus on one or (sometimes) a few classes.  We could group the parts according to which class they test.  We could even call each grouping a "<a href="UnitTest.html">UnitTest</a> suite" for the class it tests....
      </p>
      <p>
        <em>a </em><a href="FunctionalTest.html">FunctionalTest</a> that covers EverythingThatCouldPossiblyBreak is going to have a lot of repeated parts<em></em>
      </p>
      <p>
        Why?
      </p>
      <p>
        Diligent application of <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a> will result in class functionality that is only used in support of system functionality.  Refactoring creates dozens of support methods used to generate a single system level function.  Why not have a single <a href="FunctionalTest.html">FunctionalTest</a> replace the dozens of <a href="UnitTest.html">UnitTest</a>s?  In the end, isn't EverythingThatCouldPossiblyBreak dependent upon the system level usage and requirements?
      </p>
      <hr/>
      <p>
        See <a href="IsUnitTestingExtreme.html">IsUnitTestingExtreme</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryTesting.html">CategoryTesting</a>
      </p>
    </div>
  </body>
</html>