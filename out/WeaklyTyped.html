<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Weakly Typed
      </h1>
      <p>
        Disagreeing with the former definition below: a <a href="WeaklyTyped.html">WeaklyTyped</a> language or language construct is one that allows many operations without regard for whether they are defined for the types of the operands in question. The extreme of this is untyped languages, such as assembly language and BCPL, in which the only type is the machine word (also called MonoType).
      </p>
      <p>
        This contrasts with <a href="StronglyTyped.html">StronglyTyped</a> languages, in which almost all operations are checked (either statically or at run-time) for type correctness, with the exception of only a small number of loopholes/escapes from typesafety. They are usually <a href="TypeSafe.html">TypeSafe</a> -- unless the loopholes are used.
      </p>
      <p>
        See also <a href="StronglyTypedWithoutLoopholes.html">StronglyTypedWithoutLoopholes</a>.
      </p>
      <p>
        For instance Modula 3 is <a href="StronglyTyped.html">StronglyTyped</a>, but not <a href="StronglyTypedWithoutLoopholes.html">StronglyTypedWithoutLoopholes</a> because it allows the "unsafe" qualifier to force operations to be accepted that cannot be verified to be type safe. ANSI C is <a href="StronglyTyped.html">StronglyTyped</a>, but not <a href="StronglyTypedWithoutLoopholes.html">StronglyTypedWithoutLoopholes</a> because it allows a small number of type-unsafe operations, such as casting any pointer type to any other pointer type.
      </p>
      <p>
        <em>The number of directly type-unsafe operations in ANSI C is not small, and it has many causes of </em><a href="UndefinedBehavior.html">UndefinedBehavior</a> that also defeat type safety. The typesafe subset of the language is severely limited in expressiveness.<em></em>
      </p>
      <p>
        C is less <a href="StronglyTyped.html">StronglyTyped</a> than Modula 3 because it lacks some safety mechanisms altogether, e.g. array bounds checking. More accurately, C is fairly strongly statically typed, but lacks dynamic type checks of any sort.
      </p>
      <hr/>
      <p>
        A <a href="WeaklyTyped.html">WeaklyTyped</a> programming construct gets around the type system in your program.  In other words, type failures are possible and cause <a href="UndefinedBehavior.html">UndefinedBehavior</a> -- neither the compiler nor the runtime traps and rejects these errors. Contrast with <a href="StronglyTyped.html">StronglyTyped</a>.
      </p>
      <p>
        Examples:
      </p>
      <ul>
        <li>
           <a href="CeeLanguage.html">CeeLanguage</a> casts can convert between any pointer and any numeric type, or between pointers, or between numeric types (int to float, for example).  You cannot cast a struct to an int, however.
        </li>
        <li>
           <a href="CeePlusPlus.html">CeePlusPlus</a> reinterpret_cast<> can convert between any pointer types.
        </li>
      </ul>
      <p>
        Some languages more or less force use of <a href="WeaklyTyped.html">WeaklyTyped</a> constructs upon one. C is a good example: to store pointers in a collection, you have to cast them to void* (losing all type information) and cast them back again on retrieval.
      </p>
      <p>
        Others make it available, but you don't have to use it, and generally shouldn't unless you have a really good reason. C++ is a good example: times when you actually need reinterpret_cast<> are few and far between.
      </p>
      <p>
        Languages where <a href="WeaklyTyped.html">WeaklyTyped</a> constructs are accepted as idiomatic programming practice are often called <a href="WeaklyTyped.html">WeaklyTyped</a> themselves, although it's still possible to write programs in them that aren't <a href="WeaklyTyped.html">WeaklyTyped</a> at all, e.g. this C program that returns double the number of arguments it's passed:
      </p>
      <code>
        int main(int argc, char *argv[], char *envp[]) {<br/>
        int n = argc * 2;<br/>
        return n;<br/>
        }<br/>
      </code>
      <hr/>
      <p>
        I've also seen <a href="WeaklyTyped.html">WeaklyTyped</a> used for languages which are typesafe, but contain/allow a large number of implicit type conversions--i.e. a language such as <a href="JavaScript.html">JavaScript</a> which allows operations such as "2" * "3" (which gives you 6; as <a href="JavaScript.html">JavaScript</a> doesn't know how to multiply strings, it converts 'em to integers and multiplies those.  Incidentally, "2" + "3" isn't 5 in <a href="JavaScript.html">JavaScript</a>, it's "23"--the + operator is defined for strings, and is concatenation and not addition).
      </p>
      <p>
        In other words, a bit of <a href="SyntacticSugar.html">SyntacticSugar</a> (one which is useful in small programs, but more likely to cause problems in large programs as unexpected type conversions cause weird and bizarre problems--as this can easily turn an incorrect program that failes to compile or halts at runtime into a different incorrect program which dies at an unrelated places, or (worse) terminates normally but produces incorrect results).
      </p>
      <p>
        C++ can be made weakly typed (under this definition), as it is quite easy to provide a nest of implicit type conversions, both into a given type (through overloading the assignment operator and the <a href="CastConstructor.html">CastConstructor</a>), and out of a given type (via OperatorTee).
      </p>
      <hr/>
      <p>
        See <a href="http://www.lisp-p.org/tat/">http://www.lisp-p.org/tat/</a>
      </p>
      <hr/>
      <p>
        The advantages of untyped or weakly typed languages over strongly typed languages is often touted as something a <a href="RealProgrammer.html">RealProgrammer</a> can take advantage of.  The details are rarely forthcoming in the articles I've read.  As a user of <a href="BorlandDelphi.html">BorlandDelphi</a> (based on strongly typed Pascal), can someone tell me a real-world example of how weak typing could be useful?  --<a href="JosephStyons.html">JosephStyons</a>
      </p>
      <ul>
        <li>
           It let's one lie, which is powerful but not necessarily the best. It let's one almost get away with anything, until they are caught lying. It is for bad boys.
        </li>
      </ul>
      <hr/>
      <p>
        perl would be an great example of a weakly typed languige
      </p>
      <code>
        print "Who is the richest man";<br/>
        chomp($ans = <>);<br/>
        if($ans=="Bill Gates"){ # wrong<br/>
        print "Correct"<br/>
        } else{<br/>
        print "Incorrect"<br/>
        }<br/>
      </code>
      <p>
        this is an type error because the answer is converted into an number 0 but if you use 'eq' then it will compare them like strings
      </p>
      <hr/>
      <p>
        dinamic typeing is useful but not weak typeing.
      </p>
      <ul>
        <li>
           interesting that the misspelling in this article can be dynamically corrected. Bah, I'm too lazy. I'll leave it and let someone else do it. Did he need a strong statically typed spell checker? (but note that words are overloaded and the analogy can be argued)
        </li>
      </ul>
      <hr/>
      <p>
        See also: <a href="WeakTypesLie.html">WeakTypesLie</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryLanguageTyping.html">CategoryLanguageTyping</a>, <a href="CategoryTypingDebate.html">CategoryTypingDebate</a>
      </p>
    </div>
  </body>
</html>