<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Functoids In Cpp
      </h1>
      <p>
        <a href="FunctoidsInCpp.html">FunctoidsInCpp</a> is about the library <em>Functional Programming in C++</em> (FC++) written by Brian McNamara and Yannis Smaragdakis which is described at <a href="http://people.cs.umass.edu/~yannis/fc++/">http://people.cs.umass.edu/~yannis/fc++/</a> and <a href="http://cgi.di.uoa.gr/~smaragd/fc++/">http://cgi.di.uoa.gr/~smaragd/fc++/</a> and also mentioned in <a href="CppTemplateMetaprogramming.html">CppTemplateMetaprogramming</a> (book).
      </p>
      <p>
        The library includes polymorphic functoids and also a language for <a href="LambdaExpression.html">LambdaExpression</a>s. The user can convert a function into a <em>full functoid</em> which can be curried. The intention of the original authors was to provide for programming in the style of <a href="HaskellLanguage.html">HaskellLanguage</a> within <a href="CeePlusPlus.html">CeePlusPlus</a>.
      </p>
      <p>
        There is an interesting history, in that it was considered a few years ago for inclusion in the <a href="BoostLibraries.html">BoostLibraries</a>. This was not proceeded with, but has lead to a situation where there exists a <em>boostified</em> version which uses the boost namespace. This is not now being actively developed, but there are extensions being made to the previous version FC++.1.5 with a view to a new release. This involves increasing the maximum number of parameters on functions and functoids from 3 to 4. I have made use of this to build <a href="LazyEvaluation.html">LazyEvaluation</a> into my software for <a href="CliffordAlgebra.html">CliffordAlgebra</a>.
      </p>
      <p>
        -- <a href="JohnFletcher.html">JohnFletcher</a>
      </p>
      <p>
        See also <a href="FunctionalProgrammingInCpp.html">FunctionalProgrammingInCpp</a>, <a href="FunctoidsInCppDiscussion.html">FunctoidsInCppDiscussion</a>, <a href="FunctoidsInCppMonadExamples.html">FunctoidsInCppMonadExamples</a>, <a href="FunctionalProgrammingLanguage.html">FunctionalProgrammingLanguage</a>, <a href="LogicProgrammingInCpp.html">LogicProgrammingInCpp</a>, <a href="FunctionalToolsForObjectOrientedTasks.html">FunctionalToolsForObjectOrientedTasks</a>
      </p>
      <p>
        This is one of the <a href="HeaderOnlyCeePlusPlusPackages.html">HeaderOnlyCeePlusPlusPackages</a>.
      </p>
      <hr/>
      <p>
        <strong>February 2007</strong> There is now a sourceforge site for this software at <a href="http://sourceforge.net/projects/fcpp.">http://sourceforge.net/projects/fcpp.</a> For the moment this is a release of the last version on the old web site. Further versions are being planned.
      </p>
      <p>
        <strong>February 2008</strong> I have gone on extending this to provide for more parameters. 4 and 5 parameters functions are well supported, and work now extends to 6 and 7 parameters. This may seem extravagant. They are needed for the implementation of the <a href="FunctionalPatternSystemForObjectOrientedDesign.html">FunctionalPatternSystemForObjectOrientedDesign</a> - see <a href="ObjectFunctionalImplementation.html">ObjectFunctionalImplementation</a>. 
      </p>
      <p>
        <strong>November 2009</strong> I have been developing <a href="VariadicFunctoidsInCpp.html">VariadicFunctoidsInCpp</a>. This extends <a href="FunctoidsInCpp.html">FunctoidsInCpp</a> so that there can be functoids (e.g. plusN) with an arbitrary number of arguments. I have also been exploring interworking with the <a href="BoostLambdaLibrary.html">BoostLambdaLibrary</a>, using methods similar to the interworking with the <a href="StandardTemplateLibrary.html">StandardTemplateLibrary</a> already in FC++. See an example of this on <a href="VariadicFunctoidsInCpp.html">VariadicFunctoidsInCpp</a>.
      </p>
      <p>
        <strong>December 2009</strong> I have extended the work on <a href="ObserverPatternInCeePlusPlus.html">ObserverPatternInCeePlusPlus</a> to include <a href="LazyPtrProxy.html">LazyPtrProxy</a>.
      </p>
      <p>
        <strong>January 2010</strong> I have been working on extending <a href="LogicProgrammingInCpp.html">LogicProgrammingInCpp</a>. That is quite interesting, as the code turns out to be a very good example of <a href="ContinuationPassingStyleInCeePlusPlus.html">ContinuationPassingStyleInCeePlusPlus</a>.
      </p>
      <p>
        I have also found a page here on <a href="FunctionalReactiveProgramming.html">FunctionalReactiveProgramming</a>. That set me off to see if anyone had ever done work on this in C++. Most of the work on I have found so far has been based on <a href="HaskellLanguage.html">HaskellLanguage</a> and that means that (I think) it should be possible to build it on top of the FC++ implementation of a good deal of Haskell primitives. So far I have only found one such paper which is <a href="SpecifyingBehaviorInCpp.html">SpecifyingBehaviorInCpp</a>. If anyone else knows anything about this or further work please contact me.
      </p>
      <p>
        <strong>May 2011</strong> I have added <strong>invcompose</strong> (inverse composition) based on work on the pages <a href="FunctionalComposition.html">FunctionalComposition</a> and <a href="InverseFunctionalComposition.html">InverseFunctionalComposition</a>.
      </p>
      <p>
        <strong>March 2012</strong> I am having some problems with FC++ when compiling with <a href="CeePlusPlusEleven.html">CeePlusPlusEleven</a>. The problem occurs when working on lists with members which are std::pair. The copy constructor is deleted, see <a href="ImplicitlyDeletedCopyConstructor.html">ImplicitlyDeletedCopyConstructor</a>, so the code does not compile. I have now overcome these problems, working with Clang(<a href="CeeLanguageFamilyFrontEnd.html">CeeLanguageFamilyFrontEnd</a>) as the compiler. I am now looking at a new version of FC++ using the new facilities of <a href="CeePlusPlusEleven.html">CeePlusPlusEleven</a>. This is looking quite promising.
      </p>
      <p>
        <strong>June 2012</strong>
      </p>
      <p>
        An era has ended with the removal of the original FC++ web site which has been there for many years. It is clear that FC++ has been influential on the ideas of others who have put together a number of other libraries, many of them included in the <a href="BoostLibraries.html">BoostLibraries</a> although it never has been. <a href="BoostPhoenixLibrary.html">BoostPhoenixLibrary</a> in particular acknowledges it. It is interesting that the lambda now included in <a href="CeePlusPlusEleven.html">CeePlusPlusEleven</a> is not polymorphic.
      </p>
      <p>
        <strong>November 2013</strong>
      </p>
      <p>
        I have been working to understand better the monads implemented in FC++. I had previously added an Either monad. I have now found some interesting things in <a href="PatternsInFunctionalProgramming.html">PatternsInFunctionalProgramming</a> which has lead me to include some new functoids in the prelude.
      </p>
      <p>
        <strong>Warning</strong> In the code as released, some functions on a non terminating lazy list will never return. One obvious example is the following:
      </p>
      <code>
        length(enumFrom(1));<br/>
      </code>
      <p>
        There is an exception mechanism but it has not been used for this. I am putting a maximum length on the list type and then throwing an exception to avoid a computer crash.
      </p>
      <p>
        <strong>February 2014</strong>
      </p>
      <p>
        For years, as you can read above, I have been working away quietly on this, and not making any impression on anyone. I started to think that there was synergy between FC++ and some of the <a href="BoostLibraries.html">BoostLibraries</a> and in particular the <a href="BoostPhoenixLibrary.html">BoostPhoenixLibrary</a>. As a result of my expressions of interest I have now become the maintainer of the <a href="BoostPhoenixLibrary.html">BoostPhoenixLibrary</a> and will be looking for ways to use FC++ there.
      </p>
      <p>
        -- <a href="JohnFletcher.html">JohnFletcher</a>
      </p>
      <hr/>
      <p>
        <strong>Example</strong>
      </p>
      <code>
        int bar(int a,int b,int c,int d)<br/>
        { cout << "baa baa baa baa" << endl; return 0; }<br/>
        int bar3(int a,int b,int c)<br/>
        { cout << "baa baa baa" << endl; return 0; }<br/>
      </code>
      <p>
        For the above functions, the following are all defined to be valid C++ using FC++.
      </p>
      <code>
        Fun4<int,int,int,int,int> poobah = ptr_to_fun(&bar);<br/>
        Fun3<int,int,int,int> poobah3 = ptr_to_fun(&bar3);<br/>
        bind1and2and3and4of4( poobah, 1,1,1,1) ();<br/>
        bind1and2and3and4of4( poobah ) (1,1,1,1) ();<br/>
        bind1and2and3of3( poobah3, 1,1,1) ();<br/>
        bind1and2and3of3( poobah3)(1,1,1) ();<br/>
        poobah3 (1,1,1);<br/>
      </code>
      <p>
        Binders exist for all combinations of the parameters e.g. bind2of3, bind1and3of4 etc.
      </p>
      <p>
        A full functoid version can be as follows.
      </p>
      <code>
        namespace myimpl {<br/>
      </code>
      <code>
        struct XBAR {<br/>
        template<typename U, typename V, typename W, typename X> struct Sig;<br/>
        // For the moment assume all the same<br/>
        template <class T> struct Sig<T,T,T,T>: public FunType<T,T,T,T,T> {};<br/>
        template <class T><br/>
        T operator()( const T& a, const T& b, const T& c, const T& d) const {<br/>
        cout << "baa baa baa baa" << endl;<br/>
        return T(0);<br/>
        }<br/>
        } xbar;<br/>
      </code>
      <code>
        }<br/>
        typedef Full4<myimpl::XBAR> BAR;<br/>
        BAR newbar;<br/>
      </code>
      <p>
        This defines a function called <em>newbar</em> which can be called with arguments of any type, all the same in this example.
      </p>
      <code>
        cout << newbar (1,1,1,1) << endl;<br/>
        cout << newbar (1.5,1.5,1.5,1.5) << endl;<br/>
      </code>
      <p>
        I have been involved with these developments. The examples compile and run with <a href="GnuCpp.html">GnuCpp</a>. -- <a href="JohnFletcher.html">JohnFletcher</a>
      </p>
      <p>
        <em>Usually it is illegal to specify template specialization within a class descriptor.</em>  
      </p>
      <p>
        Do you have any reference for this statement? If so please post it here, as this is widely used in FC++. Note that the inner objects being specialised are structs, not member functions. -- <a href="JohnFletcher.html">JohnFletcher</a>
      </p>
      <ul>
        <li>
          Unless something has changed since the 2003 standard, template specializations must occur at the namespace scope, structs or otherwise.  I'll admit to not keeping up with this... I know this only because it nipped me in the arse a few months back when I was playing around with TemplateMetaProgramming (e.g. the all-combos 'nwise' file I wrote up).  Visual Studio allowed it, but GCC 3.4 did not.  I do not have a reference for it, but I recall being quite frustrated with it, and actually looking it up (I wanted to blame the compiler rather than my code...).
        </li>
      </ul>
      <p>
        <em>Further, the compile-time cost of doing so can be very high (given that return type can vary considerably based on the input types).  This cost should be minimized by, as much as possible, sharing signatures between functoids... e.g. by using a typedef to a signature-generator structure that </em>may<em> be shared between many different functoids, or might be in a little detail namespace.</em>
      </p>
      <code>
        struct xbar {<br/>
        typedef CPType siggen; // TMPL type that maps input-types to output type.<br/>
        // return_type<...> can handle all the gritty 'typename siggen::template gen<T,T,T,T>::type details'<br/>
        template<typename T> typename return_type<siggen,T,T,T,T>::type   <br/>
        operator()(const T& a, const T& b, const T& c, const T& d) {<br/>
        typename ltype<siggen,T,T,T,T>::type result(0);<br/>
        cout << "baa baa baa baa" << endl;<br/>
        return result;<br/>
        }            <br/>
        }; <br/>
      </code>
      <code>
        XBAR()(1,1,1,1);<br/>
        XBAR()(1.5,1.6,1.7,1.8);<br/>
      </code>
      <code>
        // To get the nice little partial-application facilities you mentioned, you'll need to still wrap this effectively in Fun4.<br/>
      </code>
      <p>
        The FC++ equivalent of what you are describing is the set of FunType template classes which define the return types. I am currently looking at the implications of <a href="ConceptCpp.html">ConceptCpp</a> in the new proposed C++ standard, which will make some of this work much easier. See <a href="FunctoidsInCppWithConceptCpp.html">FunctoidsInCppWithConceptCpp</a>. -- <a href="JohnFletcher.html">JohnFletcher</a>
      </p>
      <ul>
        <li>
           Even so, my experiences with <a href="TemplateMetaprogramming.html">TemplateMetaprogramming</a> (in particular, with running out of memory when performing insertion-sorts and very-deep template method calls) has me suggesting you shift the internal template entirely out of the class.  <strong>XBAR::Sig<T1,T2,T3,T4></strong> is still different from <strong>FOOBAR::Sig<T1,T2,T3,T4></strong> even if both inherit from <strong>FunType<T1,T2,T3,T4></strong>.  They'll each consume memory at compile-time.  It might not seem like much (and it isn't), but it adds up quickly when performing <a href="TemplateMetaprogramming.html">TemplateMetaprogramming</a> in certain manners... e.g. very deep function calls construction operators that use lots of N-type tuples and such.
        </li>
      </ul>
      <p>
        <em>The real trick is figuring out how C++ automatically recasts the inputs, and handling this detail in the signature generator... e.g. the siggen with 'double,float,int,long' as input types is quite possibly necessary.</em>
      </p>
      <code>
        double d = 1.2;<br/>
        float  f = 1.3;<br/>
        int    i = 1;<br/>
        long   l = 2;<br/>
        XBAR()(d,f,i,l);<br/>
      </code>
      <p>
        <em>C++ might cast this to double,double,double,double or might complain, depending on implementation.</em>
      </p>
      <p>
        I have been using <a href="PromotionTraits.html">PromotionTraits</a> to sort out this sort of problem. I have worked on this quite a lot since I wrote this page originally. -- <a href="JohnFletcher.html">JohnFletcher</a>
      </p>
      <p>
        <em>Nasty meta-code, ain't it?  ^_^</em>
      </p>
      <p>
        <strong>April 2012</strong> I can now replace the promotion traits with use of <strong>auto</strong> and <strong>decltype</strong> from <a href="CeePlusPlusEleven.html">CeePlusPlusEleven</a>.
      </p>
      <hr/>
      <p>
        <em>Discussion moved to </em><a href="FunctoidsInCppDiscussion.html">FunctoidsInCppDiscussion</a>.<em></em>
      </p>
      <hr/>
      <p>
        See also <a href="PatternImplementationDiscussion.html">PatternImplementationDiscussion</a> <a href="CeePlusPlusMonadsExample.html">CeePlusPlusMonadsExample</a> <a href="BoostPhoenixLibrary.html">BoostPhoenixLibrary</a> <a href="BoostFusion.html">BoostFusion</a> <a href="EveryCombinationInManyProgrammingLanguages.html">EveryCombinationInManyProgrammingLanguages</a> <a href="ContinuationPassingStyle.html">ContinuationPassingStyle</a> <a href="OverloadingCommaOperator.html">OverloadingCommaOperator</a> <a href="OoppExploringTheMultiparadigmShift.html">OoppExploringTheMultiparadigmShift</a>
      </p>
      <hr/>
      <p>
        Examples of use are to be found at 
        <a href="ContinuationPassingStyleInCeePlusPlus.html">ContinuationPassingStyleInCeePlusPlus</a> <a href="ContinuationPassingStyleInCppQuadraticEquationExample.html">ContinuationPassingStyleInCppQuadraticEquationExample</a> <a href="FunctoidsInCppExperiment.html">FunctoidsInCppExperiment</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryCpp.html">CategoryCpp</a> <a href="CategoryCppTemplates.html">CategoryCppTemplates</a> <a href="CategoryFunctionalProgramming.html">CategoryFunctionalProgramming</a> <a href="CategoryMultiparadigm.html">CategoryMultiparadigm</a>
      </p>
    </div>
  </body>
</html>