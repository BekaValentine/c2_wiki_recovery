<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Aleph Language
      </h1>
      <p>
        This is now called AfnixLanguage, and it can be found here:  <a href="http://www.afnix.org/">http://www.afnix.org/</a>
      </p>
      <hr/>
      <p>
        <a href="FunctionalProgramming.html">FunctionalProgramming</a> language with good support for <a href="ObjectOriented.html">ObjectOriented</a> programming.
        See the website <a href="http://www.aleph-lang.org/">http://www.aleph-lang.org/</a> (<em>That site has been sold off to the ubiquitous </em><a href="SearchEngine.html">SearchEngine</a> of the <a href="BrokenLink.html">BrokenLink</a>...the <a href="VultureSearchEngine.html">VultureSearchEngine</a>). From the website:
      </p>
      <p>
        <em>"Aleph is a multi-threaded functional programming language with dynamic symbol bindings that support the object oriented paradigm. Aleph features a state of the art runtime engine that supports both 32 and 64 bits platforms. Aleph comes with a rich set of libraries that are designed to be platform independent"</em>
      </p>
      <p>
        The latest available release is 0.8.1, from mid-2001, but the project is still being developed, and the author, <a href="AmauryDarsch.html">AmauryDarsch</a>, has assured me he's about to release version 0.9.0, so stay tuned. <a href="AlephLanguage.html">AlephLanguage</a> is <a href="FreeSoftware.html">FreeSoftware</a>.
      </p>
      <p>
        <a href="AlephLanguage.html">AlephLanguage</a> release 0.8.1 is a fantastic bundle of programming power. The interpreter/compiler and accompanying libraries compile flawlessly with gcc 2.96, and with just an easy to fix define-collision with gcc-3.2. Performance is very good, and the accompanying tests and examples are well documented. It also bundles (and makes available as a separate package, in PS and PDF) the complete Aleph documentation (in LaTeX, in three volumes (0: installation guide, 1: Programmer's Guide and 3:Library Reference)), of well over 250 pages of documentation, clear and easy to grasp. The 'standard library', so to call it, provides I/O, access to the system, networking abilities (Sockets, UDP, TCP, Mail) plus a Web/CGI library.
      </p>
      <p>
        <a href="AlephLanguage.html">AlephLanguage</a> provides <a href="FunctionalProgramming.html">FunctionalProgramming</a> capabilities by implementing first class functions: <em>lambdas</em> (closures), and <em>gammas</em> (symbol scope limitation); <a href="ObjectOriented.html">ObjectOriented</a> abilities and a rich set of prefactored classes (list, vector, graph, etc...) in a pretty <a href="LispLanguage.html">LispLanguage</a> syntax, although with a more flexible setup; multithreading with automatic object protection and a whole new <a href="RegularExpression.html">RegularExpression</a> system; the Libraries provide additional power through different objects in clear and well structured namespaces. --<a href="DavidDeLis.html">DavidDeLis</a>
      </p>
      <hr/>
      <p>
        <a href="HelloWorld.html">HelloWorld</a> in <a href="AlephLanguage.html">AlephLanguage</a>
      </p>
      <code>
        println "Hello World!"<br/>
      </code>
      <p>
        Factorial:
      </p>
      <ul>
        <li>
           classical:
        </li>
      </ul>
      <code>
        trans fact (n) {<br/>
        (if (< n 1) 1<br/>
        (* n (fact (- n 1))) }<br/>
      </code>
      <ul>
        <li>
           tail-recursive:
        </li>
      </ul>
      <code>
        const fact (n) { fact-helper n 1 }<br/>
        const fact-helper (n m) {<br/>
        (if (< n 1)<br/>
        m<br/>
        (fact-helper (- n 1) (* n m))) }<br/>
      </code>
      <p>
        A more meaningful example (0109.als in the distribution):
      </p>
      <code>
        # compute the scalar product of two vectors<br/>
        const scalar-product (u v) {<br/>
        trans result 0<br/>
        for (x y) (u v) (result:+= (* x y))<br/>
        eval result<br/>
        }<br/>
        # define 2 vector<br/>
        const v1 (Vector 1 2 3)<br/>
        const v2 (Vector 2 4 6)<br/>
        println "scale product [1 2 3][2 4 6] = " (scalar-product v1 v2)<br/>
      </code>
      <hr/>
      <p>
        <a href="CategoryProgrammingLanguage.html">CategoryProgrammingLanguage</a>
      </p>
    </div>
  </body>
</html>