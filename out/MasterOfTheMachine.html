<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Master Of The Machine
      </h1>
      <p>
        A <strong>master of the machine</strong> is someone who knows not just how to program, but
      </p>
      <ul>
        <li>
           Knows that the program that exists in his/her high-level language must get translated for "<em>la machine</em>". (see <a href="GeneralPurposeComputer.html">GeneralPurposeComputer</a>)
        </li>
        <li>
           Knows that the language of the machine is binary words, composing both <strong>data</strong> and <strong>instructions</strong> (cf. <a href="VonNeumannArchitecture.html">VonNeumannArchitecture</a>).
        </li>
        <li>
           Knows that there are space vs. time trade-offs for <em>everything</em>.
        </li>
        <li>
           Knows that the <a href="DigitalLogic.html">DigitalLogic</a> and <a href="BinaryArithmetic.html">BinaryArithmetic</a> are the <em>linguas-franca</em> that must be mastered and should not dabble in the dark arts of LISP (<a href="ClosuresConsideredHarmful.html">ClosuresConsideredHarmful</a>).
        </li>
      </ul>
      <p>
        I'd add
      </p>
      <ul>
        <li>
           Knows that binary words are realized by flip-flops (in the CPU) or CMOS gates (in RAM)
        </li>
        <li>
           Knows that instructions are realized by chains of logic operations driven (mostly) by uniform clock (this is what leads to the space-time trade-offs in the CPU)
        </li>
        <li>
           Knows that logic gates are realized by transistors (this is what leads to more complex operations being more 'expensive' than simpler (either in chip space or execution time)
        </li>
        <li>
           Knows that the transformation from the high-level description of the machine (the logic gates e.g. in VHDL) to the electric schematic (which gates connected by which impedances and capacitances to each other) is difficult
        </li>
        <li>
           Knows that transistors are realized by P and N doped regions (and gaps between) thus requiring highly purified silicon
        </li>
        <li>
           Knows that the actual multi-layer layout of the schematic onto the physical substrate (the assignment of regions of N and P doped silicon and the gaps between) is a complex under-constrained optimization process
        </li>
        <li>
           Knows that these regions are created by multiple 'etching' processes one onto each other (thus requiring an <em>extremely</em> optimized process with potentially high rejection rates)
        </li>
        <li>
           Knows the chemical properties of the etching process (thus knowing that CPU production creates lots of dangerous waste)
        </li>
        <li>
           And here it really leaves the domain of the machine and enters engineering and physics...
        </li>
      </ul>
      <p>
        <em>I think that happened after point number four.  But these are good.</em>
      </p>
      <p>
        I'd add
      </p>
      <ul>
        <li>
           Knows the electrical processes underlying transistor-transistor logic, CMOS and VLSI devices
        </li>
        <li>
           Knows the physics underlying transistor behaviour, design and implementation
        </li>
        <li>
           Knows the mathematics that allows us to accurately describe and model the physics
        </li>
      </ul>
      <p>
        Given all that, it's easier to stick with dabbling in the dark arts of LISP.
      </p>
      <p>
        <em>Heheh, those are pretty good. Beyond the non-physical abstraction of </em><a href="DigitalLogic.html">DigitalLogic</a>, I categorize as <a href="ComputerEngineering.html">ComputerEngineering</a> because the engineers really must design and build their chips towards what the Master-as-User wants and what the <a href="TuringMachine.html">TuringMachine</a> will need, otherwise, there's no use for a piece of fancy hardware, by itself (beyond the fetish of amazing hardware engineering, of course).<em></em>
      </p>
      <p>
        The <strong>master</strong> of the machine knows about electrical properties. Maybe not of all the CPU internals.
        But there <em>are</em> masters of machines which exploit such properties. Examples: There used to be C64 demos which used the IO bus to do pipelined binary arithmetic (because of the electical properties of that bus).
        And there are current security exploits of bus timings which allowed to jail-break the IPhone (if I remember correctly; something about the gaining access to protected memory by manipulating address bus lines while the CPU believed that it was access some other unprotected area).
      </p>
      <p>
        <em>Cool.</em>
      </p>
      <hr/>
      <p>
        See also <a href="OneTruePath.html">OneTruePath</a>, <a href="GeneralPurposeComputer.html">GeneralPurposeComputer</a>, <a href="MarkJanssen.html">MarkJanssen</a>
      </p>
      <p>
        <a href="CategoryHumor.html">CategoryHumor</a>
      </p>
    </div>
  </body>
</html>