<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Csharp Features
      </h1>
      <p>
        Some features of the <a href="CsharpLanguage.html">CsharpLanguage</a>:
      </p>
      <p>
        <a href="http://msdn.microsoft.com/vstudio/nextgen/technology/csharpintro.asp">http://msdn.microsoft.com/vstudio/nextgen/technology/csharpintro.asp</a>
      </p>
      <p>
        <strong>Some things that sound neat:</strong>
      </p>
      <ul>
        <li>
           everything is an object <em>(including the primitives!)</em> (although the compiler can/will determine when it's best to use a native primitive)
        </li>
        <li>
           multi-dimensional array support
        </li>
        <li>
           dynamic class loading
        </li>
        <li>
           operator overloading
        </li>
        <li>
           built-in security model. <em>Depends whether it actually provides any meaningful security.</em>
        </li>
        <li>
           attributes, ability to attach metadata to just about anything
        </li>
        <li>
           parameter arrays
        </li>
      </ul>
      <p>
        <em>Limited operator overloading in some respects - you can't overload == without !=, or < without >, for example. I would consider this a </em><a href="GoodThing.html">GoodThing</a>, myself, but <a href="YourMileageMayVary.html">YourMileageMayVary</a>.<em></em>
      </p>
      <ul>
        <li>
           structs are held and passed by value (<em>on stack??</em> yep)
        </li>
        <li>
           supports conditional compilation
        </li>
        <li>
           true and false are both keyword and boolean literal
        </li>
        <li>
           a foreach statement
        </li>
        <li>
           "delegates" are a language feature.
        </li>
        <li>
           will be better than VB ... <em>is better than VB</em>
        </li>
      </ul>
      <p>
        <em>In some but not all respects... optional parameters, while allowed in VB.NET and VB 6, are not in C# - which can give you some rather awkward issues when calling one from the other.</em> MS address this issue, and others like it, with the CLS (Common Language Specification). It is a set of conventions to follow when writing classes that will be used from other languages. If you ask it to (by applying certain Attributes to your class) the C# compiler will verify that you comply with the CLS. See <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconwritingcls-compliantcode.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconwritingcls-compliantcode.asp</a>
      </p>
      <ul>
        <li>
           with C#, every object is automatically a COM object
        </li>
      </ul>
      <p>
        <em>Ish. While you can register the (public) objects in a </em><a href="DotNet.html">DotNet</a> assembly as COM objects by running the appropriate utility, this <strong>doesn't</strong> happen by default. Also, if you want to control things like the <a href="ProgId.html">ProgId</a>, GUID (<a href="GloballyUniqueIdentifier.html">GloballyUniqueIdentifier</a>), or whatever, you have to explicitly insert attributes to make it happen.<em></em>
      </p>
      <p>
        <em>Actually, dotNet is not the same as COM, every C# object is indeed a language independent entity in the dotNet runtime world, but it is not a COM object.</em>
      </p>
      <ul>
        <li>
           supports the <a href="MicrosoftDotNet.html">MicrosoftDotNet</a> standard of Reflection/Reflection-Emit
        </li>
        <li>
           attribute based programming allows definition of custom attributes that are applied to a compiled entity and can be interpreted during both run-time and compile-time
        </li>
        <li>
           new pre-processor directives:
          <ul>
            <li>
               #line - lets you modify the compiler?s line number and (optionally) the file name output for errors and warnings.
            </li>
            <li>
               #region/endregion - used to group sections of code that will have the ability to be collapsed/expanded in the <a href="VisualStudioSeven.html">VisualStudioSeven</a> UI.
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <em>#line isn't new -- C has had it for decades...</em>
      </p>
      <p>
        <strong>Heated good/bad debates surround these features:</strong>
      </p>
      <ul>
        <li>
           <a href="GarbageCollection.html">GarbageCollection</a>
        </li>
        <li>
           It uses a preprocessor
          <ul>
            <li>
               not really - the 'preprocessor' directives are parsed by the compiler, they're just designed (and named) to be familiar to c/c++ programmers.
            </li>
          </ul>
        </li>
        <li>
           Compiles to platform native executable (without second step)
        </li>
        <li>
           Doesn't compile to platform independent ".class"-like file
        </li>
      </ul>
      <p>
        <em>How do you mean? C# compiles to IL which is just-in-time compiled, as other </em><a href="DotNet.html">DotNet</a> languages do. I'm not aware of any C# compiler that produces native code. And while a .NET assembly is not a one-.class-file-per-class arrangement as Java is, it <strong>is</strong> platform-independent.<em></em>
        <em>(Technically, the platform-independent IL and metadata is wrapped in a PE file which possibly contains a Win32-specific 'stub', but the code it contains is entirely platform independent.</em>
      </p>
      <ul>
        <li>
           Lots of attempts to remove 'unnecessary' brackets. Dangling else is solved by using the nearest corresponding if.
        </li>
        <li>
           There is no distinction between caught and uncaught exceptions
        </li>
        <li>
           goto
        </li>
        <li>
           switch statements follow the "no-fall-through" mechanism.
        </li>
        <li>
           switch statements can also be applied to strings (case-sensitive)
        </li>
        <li>
           properties are supported, i.e., what looks like a variable assignment or access in client code can have get and set methods associated with it. (please answer the <a href="PropertiesInCsharpQuestion.html">PropertiesInCsharpQuestion</a>)
        </li>
        <li>
           the addition of all of the unsigned types doesn't look like a win, but when you discover that the only implicit conversions are those which preserve information, it looks okay.
        </li>
        <li>
           You can turn on or off overflow checking for arithmetic operations in a block. Don't know if this propagates to the methods that are called in that block
        </li>
        <li>
           Inside a specially marked code block, developers are allowed to use pointers and traditional C/C++ features such as manually managed memory and pointer arithmetic (these blocks are called <em>unsafe</em>)
        </li>
      </ul>
      <p>
        <strong>Some folks feel these things are sad:</strong>
      </p>
      <ul>
        <li>
           has C++ style <a href="NameSpace.html">NameSpace</a>s
        </li>
        <li>
           break and continue can't have a label.
        </li>
        <li>
           Event handlers are less general than anonymous classes <em>there is no event handler, there are delegates, which are first class multicast functions, arguably better than anonymous classes, and definitely better in version 2.0 when anonymous delegates(lambda expressions) are released.</em>
        </li>
        <li>
           no covariant return types
        </li>
        <li>
           Provides large primitive data types and overflow checking constructs, but does not appear to convert to unbounded representations.
        </li>
        <li>
           the name resolution rules look too involved, although there are some interesting features wrt. interfaces. <em>it's a versioning feature, something java doesn't have.</em>
        </li>
        <li>
           methods are not virtual by default. <em>also a feature</em>
        </li>
        <li>
           <a href="DelegateQuestion.html">DelegateQuestion</a>
        </li>
        <li>
           no template-like mechanism (or did I miss something?) <em>version 2.0</em>
        </li>
        <li>
           <a href="PartialClasses.html">PartialClasses</a>
        </li>
      </ul>
      <p>
        <em>Doesn't exist yet, but is apparently planned for future versions. (Hopefully as some clean form of generic, rather than templates.) -- </em><a href="AlistairYoung.html">AlistairYoung</a>, as are the above italicized interpolations<em></em>
      </p>
      <p>
        <strong>Here's a weird feature:</strong>
      </p>
      <ul>
        <li>
           Par. 1.17 says "Versioning is an after-thought in most languages, but not in C#". Chapter 18, "Versioning", consists of a single, very blank, page.
        </li>
      </ul>
      <p>
        <em>See </em><a href="http://www.artima.com/intv/nonvirtual.html">http://www.artima.com/intv/nonvirtual.html</a> for some discussion of what's meant by versioning. Basically its all about the ability for some classes (e.g. ones in shared libraries) to be able to be upgraded without breaking other classes that rely on them.<em> </em>
      </p>
      <hr/>
      <p>
        Okay, so everything's an object.
      </p>
      <p>
        If that were true, the number 5 and the string "xyzzy" would have methods.
      </p>
      <p>
        <em>and they do</em>
      </p>
      <p>
        See <a href="RubyLanguage.html">RubyLanguage</a>, where (-5.abs) and ("xyzzy".length) are valid expressions that do just what they look like they do.
      </p>
      <p>
        -- <a href="NickBensema.html">NickBensema</a>
      </p>
      <p>
        <em>Nick, it is true. While the Int32 struct (what -5 would be typed as by default) doesn't have an Abs method (that's on the Math class), it does have some other methods, one of which is Format. The following C# works just as you describe:</em>
      </p>
      <code>
        "xyzzy".Length	// length of a the string<br/>
      </code>
      <ol>
        <li>
          Format("c", null) // formats the Int32 to a currency string 
        </li>
      </ol>
      <code>
        // using default system locale<br/>
      </code>
      <p>
        -- <a href="DrewMarsh.html">DrewMarsh</a>
      </p>
      <hr/>
      <p>
        Still, not EVERYTHING is an object. For example, a class in C# is not an object (though there may be objects that wrap classes).
      </p>
      <hr/>
      <p>
        This is simply a question, not a correction. Having watched the development of C++, with the large number of people, public discussion, man-hours, real-world deployments... that's a language I like (my bias). I'm skeptical of a language that was created by a single development team (*anyone's* development team - Sun, MS) in a vacuum, or with small focus groups. Is this the position of a well-grounded skeptic or am I just whining that closed development <em>sucks</em>?
      </p>
      <p>
        <strong>Sounds reasonable to me, and I rather like Java. (Don't know about C#) -- </strong><a href="EricHerman.html">EricHerman</a><strong></strong>
      </p>
      <p>
        <em>MS hasn't </em>entirely<em> developed C# by themselves. Other groups have been involved in the process, though Microsoft ran the show and made the other groups sign NDAs. While the process could have been a lot more open, it certainly wasn't entirely in secret. As MS is handing over C# to ECMA, future growth will be more open.</em>
      </p>
      <p>
        [From one perspective C# and Java are iterations in the refinement process of C++. Although each was written by a small group, they build on the work of other small groups.]
      </p>
      <p>
        Remember also that C++ started out as an in-house preprocessor for C. Languages tend to oscillate between proprietary and public development; each has its advantages and flaws.
      </p>
      <hr/>
      <p>
        One very nice feature of C# that wasn't mentioned is that C# makes it rather easy to attach <a href="CustomMetaData.html">CustomMetaData</a> to things like object data or classes. This makes it very easy to customize the behavior of your application when using <a href="MetaProgramming.html">MetaProgramming</a>. -- <a href="JesseJones.html">JesseJones</a>
      </p>
      <hr/>
      <p>
        Minor question: just how are non-virtual methods a feature? I'll concede any day they take a bit less time to bind, but I always viewed compile-time function binding as little more than a way of making an OO model behave in a way that's unnatural. Objects should act as what they are, not what we think they should/might be, or am I wrong here? If compile-time binding is desired, there should've been a mechanism for doing that explicitly, not the other way around. But then again, I'd suspect marketing aims to make the language as similar to C++ no matter what had their role to play too. -- DavidVallner (Biting his way through OO newbiedom.)
      </p>
      <hr/>
      <p>
        C# 3.0 has <a href="AnonymousFunction.html">AnonymousFunction</a>s that can be read at run-time as "expression trees". In the upcoming ASP.NET MVC framework, an application is that a link can be specified as a lambda calling the method in the appropriate controller; the lambda is read and converted into a URL for the appropriate controller, method and parameters.
      </p>
      <p>
        Lambda breaks edit-and-continue for the entire method, wasting so much time that it should nearly always be avoided.
      </p>
      <hr/>
      <p>
        <a href="CategoryCeeSharp.html">CategoryCeeSharp</a>
      </p>
    </div>
  </body>
</html>