<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Languages Without Garbage Collection
      </h1>
      <p>
        In <a href="GarbageCollection.html">GarbageCollection</a>, there is a list of garbage collected languages. It made me think: how many languages are <em>not</em> garbage collected? I'll try to make a list here:
      </p>
      <ol>
        <li>
           parts:
        </li>
      </ol>
      <ul>
        <li>
           languages where garbage is never created in the first place (i.e., languages without "malloc()" or any other way of creating new objects on the heap) -- a language without GarbageCreation -- all memory used is fixed at compile time.
        </li>
        <li>
           Languages where garbage can be created, but there is no built-in system for collecting it -- requiring manual garbage collection.
        </li>
      </ul>
      <p>
        no-new-objects:
      </p>
      <ul>
        <li>
           <a href="AlgolLanguage.html">AlgolLanguage</a>
        </li>
        <li>
           <a href="AssemblyLanguage.html">AssemblyLanguage</a> (?)
        </li>
        <li>
           <a href="CeeLanguage.html">CeeLanguage</a> using the MISRA recommendations for embedded automotive systems
        </li>
        <li>
           <a href="FortranLanguage.html">FortranLanguage</a>
        </li>
        <li>
           <a href="SlideRule.html">SlideRule</a> (<em>ha ha, very funny...</em>)
        </li>
      </ul>
      <p>
        new objects, but no automatic collection:
      </p>
      <ul>
        <li>
           <a href="AdaLanguage.html">AdaLanguage</a> (originally)
        </li>
        <li>
           <a href="CeeLanguage.html">CeeLanguage</a>
        </li>
        <li>
           <a href="CeePlusPlus.html">CeePlusPlus</a> (but see <a href="GarbageCollectionInCpp.html">GarbageCollectionInCpp</a>)
        </li>
        <li>
           <a href="CobolLanguage.html">CobolLanguage</a> (prior to OO-COBOL)
        </li>
        <li>
           <a href="ForthLanguage.html">ForthLanguage</a>
        </li>
        <li>
           <a href="ObjectiveCee.html">ObjectiveCee</a> (but the standard frameworks and runtimes use <a href="ReferenceCounting.html">ReferenceCounting</a> [and optionally <a href="GarbageCollection.html">GarbageCollection</a> in <a href="MacOsx.html">MacOsx</a> 10.5+ and <a href="GnuStep.html">GnuStep</a>])
        </li>
        <li>
           <a href="PascalLanguage.html">PascalLanguage</a>
        </li>
        <li>
           <a href="PliLanguage.html">PliLanguage</a>
        </li>
        <li>
           <a href="ExtendedObjectTcl.html">ExtendedObjectTcl</a>
        </li>
        <li>
           <a href="RustLanguage.html">RustLanguage</a>
          <ul>
            <li>
               no <em>runtime</em> automatic collection - calls to malloc/free are handled at compile-time
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <p>
        It seems that garbage collection is a very common technique, and is maybe even more popular than other kinds of memory management methods.
      </p>
      <p>
        <em>That's true for languages designed after around 1985.  Before then, it was more common for languages to not have automatic garbage collection.  Garbage collection was prevalent in "academic languages", (Lisp, Scheme, ML) but tended to be missing in the languages commonly used for commercial software development.  The prevalent (mis)conception was that garbage collection was too slow and unpredictable for "real programs".  Also </em><a href="RealProgrammer.html">RealProgrammer</a>s are sure that they can manage memory better than any automated garbage collector, leading to widespread belief that garbage collection is a crutch for unskilled programmers.  Thankfully, those attitudes are changing, primarily due to the acceptance of Java in the corporate world.<em></em>
      </p>
      <p>
        Lisp wasn't particularly 'academic' in 1985; CLTL1 came out in '84, and it was heading towards ANSI 
      </p>
      <p>
        ---
      </p>
      <p>
        Note that <a href="ReferenceCounting.html">ReferenceCounting</a> is considered to be a form of  <a href="GarbageCollection.html">GarbageCollection</a>.
      </p>
      <p>
        <em>Seems to me there should actually be more categories of languages, not primary based on memory management but on resource management. Basically you have: 1) Languages that neither support nor offer (semi) automated resourc management (for example C). 2) Languages that have or support fully automated resource management, but just for memory (for example Java). 3) Languages that support semi automated resource management for any resource (for example C++). 4) Languages that support both fully automated resource management (for memory) and semi automated resource management for any other resource (for example cPython).</em>
      </p>
      <hr/>
      <p>
        <a href="CategoryGarbageCollection.html">CategoryGarbageCollection</a>
      </p>
    </div>
  </body>
</html>