<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Principle Of Least Power
      </h1>
      <p>
        The <a href="PrincipleOfLeastPower.html">PrincipleOfLeastPower</a> is the notion that a subsystem/language/etc. which is designed for a certain task (as opposed to being a general purpose system/language) should have sufficient capability to do that task, and no more.
      </p>
      <p>
        <strong>Advantages of the </strong><a href="PrincipleOfLeastPower.html">PrincipleOfLeastPower</a> include:<strong></strong>
      </p>
      <ul>
        <li>
           Security. If users have the ability to configure a system with a general-purpose programming language, they have much greater power to do mischief. <a href="SeparationOfDataAndCode.html">SeparationOfDataAndCode</a> is a long-standing security <a href="BestPractice.html">BestPractice</a>. (Related: <a href="PrincipleOfLeastAuthority.html">PrincipleOfLeastAuthority</a>.)
        </li>
      </ul>
      <ul>
        <li>
           Ability to reason about and manipulate the settings. If a subsystem/language is not <a href="TuringComplete.html">TuringComplete</a>, then a program can reason about its effects without actually running it as a program. If a subsystem/language is <a href="TuringComplete.html">TuringComplete</a>, doing so is (in general) equivalent to the <a href="GeneralHaltingProblem.html">GeneralHaltingProblem</a>, which means that its behavior cannot in general be predicted without actually running it through to completion (if in fact it completes). (See <a href="RicesTheorem.html">RicesTheorem</a>.)
        </li>
      </ul>
      <p>
        <strong>Disadvantages:</strong>
      </p>
      <ul>
        <li>
           Loss of flexibility/extensibility. You can only specify things that the designers of the system intended; with a more general purpose approach one can add new capabilities.
          <ul>
            <li>
               But be aware that <a href="PrincipleOfLeastPower.html">PrincipleOfLeastPower</a> can be leveraged to improve flexibility/extensibility in a tiered or stratified language where one gains 'power' as one rises through the strata. Such stratification allows one to take advantage of <a href="LiberatingConstraint.html">LiberatingConstraint</a>s in lower layers without removing any power from the overall system. There is a cost in terms of 'immediate' convenience, but flexibility is maintained and composability (especially black-box composability where you don't have the source) is enhanced. A simple example of this approach is <a href="EffectTyping.html">EffectTyping</a>. A more complex example is my five-layer system described in QuestForThePerfectProgrammingLanguage. -- DavidBarbour
            </li>
            <li>
               <em>I generally agree. The goal may be to be a part of a larger system (stack of tools) and be the best part possible for its role rather than be the entire system. But this does add the burden of being integration-friendly.</em>
            </li>
            <li>
               No, no, it <strong>reduces</strong> the burden of being integration-friendly. <strong>To integrate one system with another is to compose two systems.</strong> Languages layered or stratified based on <a href="PrincipleOfLeastPower.html">PrincipleOfLeastPower</a> are more readily composable for two reasons: (1) you can make useful guarantees about the properties of composition of lower layers without knowing the exact details of the code being composed, (2) you have many options regarding at which 'strata' your system will compose with the language, and you may thus choose the most appropriate one based on what level of 'power' your system introduces. Anyhow, <strong>integration</strong> becomes easier. <strong>Implementation</strong>, on the other hand, is a bit more difficult; a language with many strata will generally have a couple syntactic and semantic primitives for each strata. -- DavidBarbour
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           Actually applying <a href="PrincipleOfLeastPower.html">PrincipleOfLeastPower</a> requires determining a <em>minimum</em> set of capabilities or features required for a subsystem to perform its task.  As such, it <em>literally</em> becomes an optimization problem in the mathematical sense (that of seeking minima and maxima in general, as opposed to focus on computation time/space).
        </li>
      </ul>
      <p>
        Just like hand-coded time/space optimizations, applying <a href="PrincipleOfLeastPower.html">PrincipleOfLeastPower</a> tends to take additional effort and affects flexibility and extensibility.  As it is an optimization problem, one might be well served by the <a href="RulesOfOptimization.html">RulesOfOptimization</a>: <a href="OptimizeLater.html">OptimizeLater</a> - it is better to use too much power and get a working, elegant solution to start, and it helps you learn exactly how much power is required.  Then aim at the 'bottlenecks': apply <a href="PrincipleOfLeastPower.html">PrincipleOfLeastPower</a> only where the greatest reductions can be usefully achieved.
      </p>
      <p>
        As a language design principle, of course, one is limited by issues of compatibility with the code people write while you're deciding how little power you can get away with, so perhaps some <a href="BigDesignUpFront.html">BigDesignUpFront</a> is called for, or at least limiting distribution.
      </p>
      <p>
        <strong>Examples of the </strong><a href="PrincipleOfLeastPower.html">PrincipleOfLeastPower</a> include:<strong></strong>
      </p>
      <ul>
        <li>
           XmlDataTypeDeclarations and <a href="XmlSchema.html">XmlSchema</a>s. These <a href="MetaLanguage.html">MetaLanguage</a>s (one is a subset of XML proper; the other an XML application) both can be used to describe the structure of a valid XML document; they contain only the features necessary to do that. See <a href="XmlIsaPoorCopyOfEssExpressions.html">XmlIsaPoorCopyOfEssExpressions</a> for discussion on this.
        </li>
      </ul>
      <ul>
        <li>
           Use of <a href="ConfigurationFiles.html">ConfigurationFiles</a> (which contain raw data, in some form) to specify configuration information for a subsystem. <a href="ConfigurationFiles.html">ConfigurationFiles</a> are scanned/parsed by a program to set up the system. <a href="ConfigurationFiles.html">ConfigurationFiles</a> of this sort contain no executable code.
        </li>
      </ul>
      <ul>
        <li>
           <a href="SeparationOfDataAndCode.html">SeparationOfDataAndCode</a> in general.
        </li>
      </ul>
      <ul>
        <li>
           <a href="ProtocolStack.html">ProtocolStack</a>s (<em>i.e.</em> the SevenLayerNetworkModel).
        </li>
      </ul>
      <ul>
        <li>
           Use of <a href="DomainSpecificLanguage.html">DomainSpecificLanguage</a>s (which may or may not be <a href="TuringComplete.html">TuringComplete</a>); see <a href="InterpreterPattern.html">InterpreterPattern</a>.
        </li>
      </ul>
      <p>
        <strong>Successful counterexamples</strong> (to show that sometimes extra power is a <a href="GoodThing.html">GoodThing</a> to have - at least sometimes):
      </p>
      <ul>
        <li>
           <a href="PostScript.html">PostScript</a>. Certainly, a <a href="TuringComplete.html">TuringComplete</a> programming language is not needed to describe images for rendering on a screen or printer. The design of <a href="PostScript.html">PostScript</a> has been a smashing success.
          <ul>
            <li>
               <strong>Incorrect; Postscript is </strong><a href="TuringComplete.html">TuringComplete</a> because it needed to be. <a href="LaTex.html">LaTex</a> is not <a href="TuringComplete.html">TuringComplete</a> (I think), and it does a very good job, but it cannot do all the things that Postscript does.<em>' </em>Wrong: <a href="LaTex.html">LaTex</a> is <a href="TuringComplete.html">TuringComplete</a>, since TeX is. Because it needs to be.<em></em>
              <ul>
                <li>
                   <a href="PostScript.html">PostScript</a> probably doesn't need to be <a href="TuringComplete.html">TuringComplete</a>. I would love to see a proof of that statement. I think <a href="PostScript.html">PostScript</a> is <a href="TuringComplete.html">TuringComplete</a> only because it's easy to get there without ever thinking about it, and it's easy to shrug it off and say "hey, it ain't harming anyone."
                </li>
              </ul>
            </li>
            <li>
               I quite understand why TeX needs to be. I meant the <a href="LaTex.html">LaTex</a> extensions by themselves, not including TeX primitives, are not <a href="TuringComplete.html">TuringComplete</a>, IIRC. To parse them is to understand them completely. :-) Non-<a href="TuringComplete.html">TuringComplete</a> text/page/document description languages are very handy, because one can e.g. fairly trivially strip them down to plain text for further processing.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           Unix rc files (executable configuration scripts). Some Unix admins love these, some hate these. Much of the configuration info in a Unix (or Unix-like) system is found in a set of executable shellscripts (which by necessity run with root privileges) in the /etc directory; many of these files have names like "rc.whatever". Changing many configuration parameters requires modifying these scripts directly. Convenient for the Unix guru; a <a href="RoyalPain.html">RoyalPain</a> for those trying to write graphical configuration/system administration tools for Unix.
        </li>
      </ul>
      <ul>
        <li>
           Full programming languages used as macro languages for applications. Examples include <a href="VisualBasic.html">VisualBasic</a> being used to write macros for <a href="MicrosoftOffice.html">MicrosoftOffice</a>; <a href="LispLanguage.html">LispLanguage</a> in <a href="EmacsEditor.html">EmacsEditor</a>; <a href="PerlLanguage.html">PerlLanguage</a> and <a href="PythonLanguage.html">PythonLanguage</a> in <a href="BbEdit.html">BbEdit</a>; shell escapes in many Unix utilities. VB's capabilities have often been misused to create "word viruses" (and a word processor should <em>not</em> be a breeding ground for such a thing). So far, I have yet to hear of an Emacs virus. Given that many people use Emacs as a shell rather than just an editor, such a thing could potentially be destructive, assuming one could be written. <em>See </em><a href="EmacsLispVirus.html">EmacsLispVirus</a>.<em></em>
        </li>
      </ul>
      <ul>
        <li>
           <a href="JavaLanguage.html">JavaLanguage</a> and <a href="JavaScript.html">JavaScript</a> used for client-side applets. Unfortunately, this has become primarily a way to deploy annoying advertisements, but Java is one of the few languages suitable for running untrusted code.
        </li>
      </ul>
      <p>
        <a href="TimBernersLee.html">TimBernersLee</a> wrote an article called "PrinciplesOfDesign" (<a href="http://www.w3.org/DesignIssues/Principles.html)">http://www.w3.org/DesignIssues/Principles.html)</a> which describes the <a href="PrincipleOfLeastPower.html">PrincipleOfLeastPower</a>.
      </p>
      <p>
        A similar principle is described in <a href="ConceptsTechniquesAndModelsOfComputerProgramming.html">ConceptsTechniquesAndModelsOfComputerProgramming</a> (p323; this is the Mozart/Oz book -- <strong>highly</strong> recommended), under the name "Principle of Least Expressiveness": "When programming a component, the right computation model for the component is the least expressive model that results in a natural program."
      </p>
      <ul>
        <li>
           Note that it doesn't say to <strong>always</strong> use the least possible expressive model; that will result in unnatural (awkward, hard to write, hard to read) programs in at least some cases.
        </li>
        <li>
           Note that it says <strong>model</strong>, not <strong>language</strong>. It can be counterproductive to be forced to switch languages often in order to get more or less expressive models, although at times switching languages is most effective, depending on which languages are available.
        </li>
        <li>
           Note that they are talking about general models of computation, in particular including at least:
          <ul>
            <li>
               Declarative sequential model (strict functional programming, deterministic logic programming, dataflow/logic variables, higher-order procedures). Component behavior is independent of rest of program.
            </li>
            <li>
               Declarative concurrent model (explicit threads, by-need/lazy computation, data-driven concurrency, demand-driven concurrency). Almost as simple as declarative sequential.
            </li>
            <li>
               Declarative model with exceptions: allows nondeterminism to be visible.
            </li>
            <li>
               Message-passing concurrent model (declarative plus ports/communication channels). Allows nondeterminism, and allows nondeterminism to be restricted to particular components.
            </li>
            <li>
               Stateful model (declarative model extended with explicit state). Allows components to keep history. Typical of sequential OO programming.
            </li>
            <li>
               Shared-state concurrent model (declarative extended with both explicit state and threads). Typical of concurrent OO programming.
            </li>
            <li>
               Relational model (declarative extended with search). Search space explored by testing choices until result is satisfactory. Encompasses Prolog-style logic programming.
            </li>
            <li>
               Constraint programming and still other models are discussed elsewhere in the book.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           All of these models are <a href="TuringEquivalent.html">TuringEquivalent</a>, demonstrating that there is much more to the principle than distinguishing between <a href="TuringEquivalent.html">TuringEquivalent</a> and sub-<a href="TuringEquivalent.html">TuringEquivalent</a> models. See also <a href="ModelsOfComputation.html">ModelsOfComputation</a>, <a href="TuringTrap.html">TuringTrap</a>, <a href="TuringTarpit.html">TuringTarpit</a>.
          <ul>
            <li>
               Oh yes, absolutely; that's what the book is <strong>about</strong>. They barely touch on sub-<a href="TuringEquivalent.html">TuringEquivalent</a> issues. It doesn't even talk about the Chomsky hierarchy, mentioned at top of page, which is appropriate for examining sub-<a href="TuringEquivalent.html">TuringEquivalent</a> mechanisms.
            </li>
            <li>
               Quote: "...and briefly explaining what new expressiveness each concept brings. All models are Turing complete, i.e., they are equivalent in computing power to a Turing machine. However, Turing completeness is only a small part of the story. The ease with which programs can be written or reasoned about differs greatly in these models. Increased expressiveness typically goes hand in hand with increased difficulty to reason about programs." (appendix D.3 "Concepts", p846)
            </li>
            <li>
               Unlike most largely-handwaving (even if correct) wiki discussions about expressiveness, they are quite specific, as the above list quoted from the book indicates.
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <p>
        Also, <a href="PrincipleOfLeastPower.html">PrincipleOfLeastPower</a> implemented via permissions can prevent a bug from going out of control.
      </p>
      <p>
        <em>And if implemented with </em><a href="ObjectCapabilityModel.html">ObjectCapabilityModel</a>, it can do so without a centralized trust authority, in a composable manner, and without the expensive proofs and challenges of identity required to establish permissions.<em></em>
      </p>
      <hr/>
      <p>
        See <a href="ProductivityRant.html">ProductivityRant</a>, <a href="LittleLanguage.html">LittleLanguage</a>, <a href="IssuesForLanguageDesigners.html">IssuesForLanguageDesigners</a> (adds to the above discussion)
      </p>
      <p>
        See <a href="ModelsOfComputation.html">ModelsOfComputation</a>, <a href="TuringTrap.html">TuringTrap</a>, <a href="TuringTarpit.html">TuringTarpit</a>, <a href="PrincipleOfLeastAuthority.html">PrincipleOfLeastAuthority</a>
      </p>
    </div>
  </body>
</html>