<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Large Software System Patterns
      </h1>
      <p>
        What patterns are commonly found in large software systems?
        I am thinking of things like:
      </p>
      <ul>
        <li>
           Infrastructure layer - the system has a large infrastructure layer which is designed (and often built) independently of the user functionality.
        </li>
        <li>
           <a href="MultiCaster.html">MultiCaster</a>
        </li>
        <li>
           DataMart
        </li>
        <li>
           <a href="PatternsForLoggingDiagnosticMessages.html">PatternsForLoggingDiagnosticMessages</a>
        </li>
      </ul>
      <p>
        Large systems may be distributed, requiring <a href="DesignPatternsForDistributedObjects.html">DesignPatternsForDistributedObjects</a>.
      </p>
      <hr/>
      <p>
        The happiest of the <a href="HappyPatterns.html">HappyPatterns</a> for large systems I've encountered is a process pattern, <a href="ContinuousRoundTrip.html">ContinuousRoundTrip</a> - that the system starts being fully connected from almost the first day, so that each part grows in function, but all the parts always continue to work together (needs AutomatedRegressionTests, implies <a href="EarlyAndRegularDelivery.html">EarlyAndRegularDelivery</a>, but they don't imply <a href="ContinuousRoundTrip.html">ContinuousRoundTrip</a>). Reminds me of <a href="EvolutionaryDelivery.html">EvolutionaryDelivery</a> advice. --<a href="AlistairCockburn.html">AlistairCockburn</a>
      </p>
      <hr/>
      <p>
        One place where it seems to me that Extreme Programming won't work is performance optimization in large systems.
      </p>
      <p>
        Certainly we start small and grow big (in functionality), but to get from a slow system to a fast system takes design (document pile is one inch thick).
      </p>
      <p>
        Profiling and optimization kills hot spots, but this only gets you so far. Sometimes you need to think about the whole architecture to get improvement by orders of magnitude.
      </p>
      <p>
        -- <a href="EricUlevik.html">EricUlevik</a>
      </p>
      <p>
        <em>Why does it take design rather than refactoring? Why doesn't profiling and optimizing the hot spots work? And, since XP has more design than most approaches (just not up front), wouldn't it work better for optimization?</em>
      </p>
      <p>
        I was thinking that to get from a slow system to a fast system takes optimization with real performance measurements to guide you.
      </p>
      <p>
        <a href="LazyOptimization.html">LazyOptimization</a> recommends defining a quality indicator, measuring it objectively and automatically and defining a threshold value. You can then add a <a href="UnitTest.html">UnitTest</a> or <a href="FunctionalTest.html">FunctionalTest</a> that tests whether the system meets the performance requirements. If performance drops below the threshold, you optimise for runtime speed, if performance exceeds the threshold you optimise for readability and programming speed. It think XP would work very well for performance optimisation. <a href="MartijnMeijering.html">MartijnMeijering</a>
      </p>
    </div>
  </body>
</html>