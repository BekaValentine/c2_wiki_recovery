<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Paul Graham
      </h1>
      <p>
        <img src="http://us.st11.yimg.com/us.st.yimg.com/I/paulgraham_1995_10967581.jpeg" />
      </p>
      <p>
        <a href="http://paulgraham.com">http://paulgraham.com</a>
      </p>
      <p>
        Paul Graham is an independent consultant specializing in Lisp. He received his PhD in Computer Science from Harvard University. He is the author of <a href="OnLisp.html">OnLisp</a> and <a href="AnsiCommonLisp.html">AnsiCommonLisp</a> and a collection of essays, <a href="HackersAndPainters.html">HackersAndPainters</a>. He believes that Lisp is a <a href="GoldenHammer.html">GoldenHammer</a>.
      </p>
      <p>
        He helped develop an e-stores system that was eventually purchased by Yahoo and made into Yahoo Stores, becoming wealthy in the process. An interesting debate about its implementation in Lisp and later rewrites can be found at <a href="http://discuss.fogcreek.com/joelonsoftware/default.asp?cmd=show&ixPost=31402.">http://discuss.fogcreek.com/joelonsoftware/default.asp?cmd=show&ixPost=31402.</a> Paul credits Lisp for enabling him to out-compete other contenders (before the Yahoo purchase). 
      </p>
      <p>
        He advocates <a href="BottomUpProgramming.html">BottomUpProgramming</a> and claims <a href="LispLanguage.html">LispLanguage</a> is uniquely suited to it.
      </p>
      <ul>
        <li>
           Hardly unique: <a href="ForthLanguage.html">ForthLanguage</a> and many <a href="MetaLanguage.html">MetaLanguage</a>s have the same virtues.
        </li>
      </ul>
      <p>
        <a href="http://www.paulgraham.com">http://www.paulgraham.com</a>
      </p>
      <hr/>
      <p>
        Lisp has the power of treating code as data:
      </p>
      <code>
        (defun sum (x)<br/>
        (apply #'+ x))<br/>
      </code>
      <p>
        <em>What makes Lisp suitable for bottom up programing is macros, which let you redefine the language's syntax.</em>
      </p>
      <p>
        I'd like to see examples that are applicable to the web-store result.
      </p>
      <ul>
        <li>
           Passing continuations around to create multi-page forms, according to his essays, was one of the ways he used Lisp to do things other languages wouldn't even let one think about at the time.
        </li>
      </ul>
      <ul>
        <li>
           <em>In a "traditional" language, one would probably first generate the meta data for the full list, and when the user presses the "Next" button/link, it would just draw from row X to row Y out of the saved meta data. Another way to do it is to generate each page's meta data first, and then pick the page the user selects. Of course it's different if you only want to generate the next set without traversing all the data items. Which technique is used may depend on how the data is stored and how fancy the queries get (sorting and filtering).</em>
        </li>
      </ul>
      <hr/>
      <p>
        I think the main advantage was his use of continuation-passing style - associating links with closures to create a direct style of programming that inspired <a href="SeasideFramework.html">SeasideFramework</a> - to create a sophisticated experience. Ten years later, this is still an little known, unused technique to the vast majority of web developers. He never described precisely what he did, but what I gathered is that he cooked up something analogous to Seaside's anchorWithAction:. For those who have never experienced this, imagine if you could write a web application very much the way you would a program that takes input on the console, from StandardInput, and get away with it.
      </p>
      <p>
        <em>This is more or less what the HTTP standard does: you get one giant input string and put out one giant output string (with the help of API's to parse, format, and combine as needed).</em>
      </p>
      <p>
        True, more or <strong>less</strong>.  <a href="JustIsaDangerousWord.html">JustIsaDangerousWord</a>.
      </p>
      <p>
        [And "computing" is naught but twiddling bits...]
      </p>
      <hr/>
      <p>
        See also: <a href="BeatingTheAverages.html">BeatingTheAverages</a>, <a href="WebStoresDiscussion.html">WebStoresDiscussion</a>, <a href="SmugLispWeenie.html">SmugLispWeenie</a>, <a href="BlubParadox.html">BlubParadox</a>, <a href="FraudulentMindset.html">FraudulentMindset</a>, <a href="IfFooIsSoGreatHowComeYouAreNotRich.html">IfFooIsSoGreatHowComeYouAreNotRich</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryAuthor.html">CategoryAuthor</a>, <a href="CategoryPerson.html">CategoryPerson</a>, <a href="CategoryLisp.html">CategoryLisp</a>
      </p>
    </div>
  </body>
</html>