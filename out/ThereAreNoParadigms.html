<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        There Are No Paradigms
      </h1>
      <p>
        <em>From </em><a href="FunctionalProgrammingIsNotaParadigm.html">FunctionalProgrammingIsNotaParadigm</a>...<em></em>
      </p>
      <p>
        Terms like Imperative Paradigm or Functional Paradigm are attempts to categorize languages on the basis of common features or an underlying abstract basis. But the fact that use of these terms turns into debates or inevitably leads to mention of examples that belong to multiple paradigms, or no clear paradigm, suggests that the terms are inadequate. Any serious discussion about language characteristics is not going to talk in terms of paradigms anyway; it is going to talk in terms of language features, such as whether or not there is support for first-class functions, encapsulation, procedures, logical inference, declarative syntax, inheritance, named parameters, higher-order functions, polymorphism, multiple dispatch, closures, blocks, continuations and so forth. Language features are less ambiguous and more easily recognized as being present or absent, unlike paradigm-hood which is invariably ambiguous and difficult to identify.
      </p>
      <p>
        For example, imagine a language that implements <em>all</em> of the aforementioned features. It would be perfectly reasonable to compare such a language to other languages, but perfectly meaningless to describe it strictly in terms of either an OO or functional paradigm. Therefore, I suggest that the term "paradigm" be stricken from further discourse, and that "object oriented", "procedural", "functional", "imperative", and "declarative" be eliminated as well, as these are merely meaningless (in any rigorous sense) references to specific paradigms. Henceforth, speak in terms of presence or absence of given features, e.g., language X implements first-class functions and multiple dispatch, while language Y implements neither but implements continuations. And so on.
      </p>
      <p>
        Another way to look at this is to focus on the HasA relationships a language has with the universe of language features, rather than the IsA relationship(s) a language has with some abstract definition.
      </p>
      <p>
        I would encourage everyone to at least <em>try</em> this approach in future language discussions. I believe the result will be a general elevation in the level of discourse, and a reduction in petty and peculiar arguments that attempt to show (for example) that object oriented programming or functional programming or procedural programming -- in other words, some arbitrary collection of language features -- is somehow collectively better or worse than another random grouping of features (whether given a popular label or not), for some ill-defined notion of "better" or "worse." -- <a href="DaveVoorhis.html">DaveVoorhis</a>
      </p>
      <p>
        <em>Or we can agree to use the common English meaning of "paradigm". Then any paradigm is just another way to view reality. They have no special status. Programmers are free to use whichever views fit specific circumstances. Languages are free to enable multiple views of reality. It seems like all of the arguments come from two sources: ignoring common definitions of words and/or assigning special significance to the word "paradigm".</em>
      </p>
      <p>
        Perhaps, but I believe the arguments come from a single source: failure to agree on what a given <x> paradigm actually means. -- <a href="DaveVoorhis.html">DaveVoorhis</a>
      </p>
      <ul>
        <li>
           Plus, then there is the issue that many users believe the enumerated paradigms are mutually exclusive (or should be); that "purity" is to be preferred over more a more complete set of capabilities.
        </li>
      </ul>
      <ul>
        <li>
           I agree. Mixing known-good things is a proven technique for creating even better things! Why, look at the mixture of clorox and windex! Two great cleaners. Mix them together and tackle difficult problems like rust! Errr... actually, don't do that. Even if you survive the chlorine gas long enough to dump your new bucket of hydrazine onto a pile of rust, the resulting explosion will do you in for sure. But it sure <strong>sounds</strong> like a good idea! :) -- <a href="MichaelSparks.html">MichaelSparks</a>
        </li>
      </ul>
      <ul>
        <li>
           Not necessarily. Mixing can be good if the ideas truly complement each other. Otherwise you end up with ParadigmPotporri for resume padding and <a href="MentalMasturbation.html">MentalMasturbation</a>. -- top
        </li>
      </ul>
      <ul>
        <li>
           Of course, mixing should be done carefully. Once, when faced with a seriously clogged bathroom sink, I closed the door to keep out the wife and cat and poured a generous glug of Draino(TM) and bleach down the hole. I nearly fainted from the resulting cloud of chlorine gas, and staggered out just in time. The sink, however, flowed freely thereafter. -- <a href="DaveVoorhis.html">DaveVoorhis</a> 
        </li>
      </ul>
      <hr/>
      <p>
        <em>Another way to look at this is to focus on the </em>HasA relationships a language has with the universe of language features, rather than the IsA relationship(s) a language has with some abstract definition.<em></em>
      </p>
      <p>
        I would add that some of the most profound relationships a language has with the universe of language features are the <strong>Lacks</strong> relationships. I.e. math and descriptions of mathematical functions Lacks an imperative operator. A functional language or sub-language of any mold Forbids imperatives or instructions within the language proper, for then it wouldn't be a functional language; however, any language that supports the functional paradigm simply Has the necessary mechanisms to describe functions by their characteristic inputs and outputs instead of the processing steps needed to compute the function. (I think a great deal of confusion grows simply because people mix: <X-type language> with <language that supports X-type paradigm>, i.e. <An Algebraic Language for Mathematics> and <A Language that supports the Algebraic Paradigm when describing Math> describe very different concepts.) Similarly, one could use the <strong>Forbids</strong> relationship to discuss typecheckers; a <a href="TypeSafe.html">TypeSafe</a> language Forbids the use of language structures that aren't computationally meaningful, or that violate certain language principles and internal assumptions. Without Forbids and Lacks relationships, I don't believe the discussed approach will work to provide any profound insights. -- DB
      </p>
      <p>
        <em>Profound insights? Good heavens. </em>'Lacks<strong> and </strong>Forbids<strong> relationships are fine, but if you're tempted to define an, er, algebra of language discourse or something, you're probably missing the point. The intent of the paragraph was not to frame a mechanism for achieving "profound insights", but simply to informally suggest means to reduce </strong><a href="LaynesLaw.html">LaynesLaw</a> debates that result from differing interpretations of what a given paradigm means, when in fact it's generally more productive to speak in either informal terms about language features, or in formal or informal terms about the theoretical or mathematical underpinnings of those features. References to "paradigm <x>" rarely convey anything but the most general, and easily misinterpretable, meaning.<em> -- DV</em>
      </p>
      <hr/>
      <p>
        <strong>Alternatives?</strong>
      </p>
      <p>
        People use these terms and most people in the field know more or less what the speaker is talking about. I don't see sufficient alternative terminology at this point to replace it. Imperfect communication is usually better than no communication (except in the nuclear launch control room).
      </p>
      <hr/>
      <p>
        See also <a href="ProgrammingParadigm.html">ProgrammingParadigm</a> <a href="http:wiki?search=Paradigm">http:wiki?search=Paradigm</a> <a href="ThereIsNoSpoon.html">ThereIsNoSpoon</a>
      </p>
      <p>
        <a href="OctoberZeroSix.html">OctoberZeroSix</a>
      </p>
      <p>
        <a href="CategoryDiscussion.html">CategoryDiscussion</a>, <a href="CategoryDefinition.html">CategoryDefinition</a>
      </p>
    </div>
  </body>
</html>