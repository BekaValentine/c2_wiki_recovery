<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Why We Hate Ruby
      </h1>
      <p>
        or <strong>PettyLittleRubyComplaints</strong> ...just following the WhyWeHate pattern.
      </p>
      <p>
        <em>Nobody </em>really<em> hates </em><a href="RubyLanguage.html">RubyLanguage</a>...right?<em> ...but only a close relationship exits as this reaction indicated.</em>
      </p>
      <ul>
        <li>
           Perlisms
          <ul>
            <li>
               Why does Ruby include some sugar to make your beautiful Ruby code look half Perl? Does Matz actually use these things or does he use the more <em>pure</em> Ruby alternatives? Is it to attract <a href="PerlLanguage.html">PerlLanguage</a> programmers? Does this work? Was Ruby more accessible to <em>me</em> because of this?
              <ul>
                <li>
                   <em>Because a prime Ruby directive is "easiest for the programmer". Adopting ONLY "if str ~= /foo (bar)/ then $1" from Perl avoids crud like Python's horrific re.search() method, which you can't even put into an if!</em>
                  <ul>
                    <li>
                       Sure you can- re.search returns a True value (MatchObject) on a match, and a False value (None) on no match. Unless you mean you want store the match, too, in which case that doesn't belong in an if condition anyway
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>
              Parentheses are usually not necessary around method arguments. But sometimes they are. Just like Perl. Arg.
            </li>
            <li>
               See <a href="ThereIsMoreThanOneWayToDoIt.html">ThereIsMoreThanOneWayToDoIt</a> below.
            </li>
            <li>
               Sometimes you <em>must</em> use the Perlisms. For example, there's no String#endswith method. So, instead of foo.endswith('bar'), you must use Perl syntax <a href="RegularExpression.html">RegularExpression</a> matching: foo =~ /bar$/
              <ul>
                <li>
                   This is no longer true. String class has an ends_with? method as of 1.9.
                </li>
                <li>
                   Why not: %r{bar$}.match(foo)? Or if that's still too Perlish for you: Regexp.new('bar$').match(foo)? Plus, Ruby allows you to add an endswith() method to String to wrap that if you want.
                </li>
                <li>
                   You expect me to do all that typing when foo =~ /bar$/ is much simpler? :-) Okay, okay, so I don't have to use the <a href="RegExp.html">RegExp</a> Perlism. But <em>not</em> using it is too much work.
                </li>
                <li>
                   There is an end_with? method; see <a href="http://www.ruby-doc.org/core/classes/String.html#M001180">http://www.ruby-doc.org/core/classes/String.html#M001180</a>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
          Semi-significant whitespace
          <ul>
            <li>
               Actually, this doesn't bother <em>me</em>, but I'm including it on the assumption that it bothers someone. (^_^)
            </li>
            <li>
               While not whitespace, the case-significant variables are annoying.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
          It's not <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>, though it tries really hard to be.
          <ul>
            <li>
               Control constructs that aren't implemented with blocks
            </li>
            <li>
               Verbose syntax for blocks that aren't the last parameter to a function
              <ul>
                <li>
                   A brief block syntax is good. If you have one, you should use it for <em>all</em> blocks.
                </li>
              </ul>
            </li>
            <li>
               See also <a href="RubyIsSmalltalkMinusMinus.html">RubyIsSmalltalkMinusMinus</a>.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <a href="ThereIsMoreThanOneWayToDoIt.html">ThereIsMoreThanOneWayToDoIt</a>
          <ul>
            <li>
               Interfaces in the Core API are bloated: Array.map == Array.collect, Enumerable.detect == Enumerable.find, Enumerable.find_all == Enumerable.select, Enumerable.to_a == Enumerable.entries, Hash.has_key? == Hash.include? == Hash.key? == Hash.member?, Hash.has_value? == Hash.value?, Hash.indexes == Hash.indices, Hash.length == Hash.size, Hash.merge! == Hash.update, String.succ == String.next, etc.
            </li>
            <li>
               No fewer than four ways to define class-scoped methods
            </li>
            <li>
               Blocks can be surrounded with braces. Or whitespace. Or keywords.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           Doesn't respect <a href="PrincipleOfLeastSurprise.html">PrincipleOfLeastSurprise</a>
          <ul>
            <li>
               The object_id value for integers is the integer multiplied by two, plus one.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           Idiomatic use of the '_' character for word separation (SnakeCase <a href="EmbeddedUnderscore.html">EmbeddedUnderscore</a>); it's just damn ugly.
          <ul>
            <li>
               Aside from it being damn ugly, it's also harder to type a shifted symbol on the top row when your fingers are on the home row typing lowercase letters.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           No <a href="TailCallOptimization.html">TailCallOptimization</a>.
          <ul>
            <li>
               You can turn this on in MRI Ruby 1.9, 2.0 and 2.1
            </li>
            <li>
               Also, Ruby's stack depth is exceeded far sooner than Python's.
              <ul>
                <li>
                   Which is impressive.
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           "Documentation" is scattered all over the internet.
          <ul>
            <li>
               I have to refer to Zen Spider's Ruby QuickRef to find the built-in Exception hierarchy, the online <a href="PickAxeBook.html">PickAxeBook</a> to read how to open a file, the <a href="RubyGarden.html">RubyGarden</a> wiki to learn about <a href="RubyCoerce.html">RubyCoerce</a>, etc., etc., etc.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           Core and Standard API docs are incomplete, misleading, or wrong.
          <ul>
            <li>
               The File class "is closely associated with class IO," yet the docs fail to say that File is a <em>subclass</em> of IO.
            </li>
            <li>
               Most Set methods return fresh Sets, yet the docs claim they return Arrays.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           RDoc-generated documentation sucks
          <ul>
            <li>
               The gray backgrounds are too dark. Spotting a method name against medium gray is difficult.
            </li>
            <li>
               Each unit in the Standard Library has its own <a href="CascadingStyleSheets.html">CascadingStyleSheets</a> file, making it nigh unto impossible to change style across the board, especially if you want to update your library.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           What's with the <a href="PragmaticProgrammer.html">PragmaticProgrammer</a> publisher appearing overnight and monopolizing the publication of Ruby books?
          <ul>
            <li>
               I call BS. Pragmatic published a couple first, because 1) no one else wanted to at that time, and 2) they have a very short pipeline.  "Monopolizing" would have been if they'd prevented other people from doing the same, which they haven't.  They were just "first with the most".
            </li>
            <li>
               <em>The main bullet point should be read with an </em><a href="IronyWarning.html">IronyWarning</a>.<em></em>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           Can't right associate operators
          <ul>
            <li>
               Suppose you define a Vector class and you define its '*' operator for 'vector * number'. That's fine, but good luck defining the same for 'number * vector'. Good luck making your multiplication commutative.
            </li>
            <li>
               You can do this, it is called <a href="RubyCoerce.html">RubyCoerce</a> and there are links there which explain it. I have used it to enable addition of numbers to user defined objects, including interfaced code written in <a href="CeePlusPlus.html">CeePlusPlus</a>. -- <a href="JohnFletcher.html">JohnFletcher</a>
            </li>
            <li>
               Yup. But the rdocs are not helpful, and this is not in the online Pickaxe. As usual, Ruby documentation is exasperating and how to do this in <a href="PythonLanguage.html">PythonLanguage</a> is so much more obvious. Plus, there's more to this saga... -- <a href="ElizabethWiethoff.html">ElizabethWiethoff</a>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           The Ruby community has a big problem with NIH (<a href="NotInventedHere.html">NotInventedHere</a>) and a superiority complex.
          <ul>
            <li>
               Rather than use common method names from other runtimes, it goes out of it's way to pick new and less intuitive names
              <ul>
                <li>
                   e.g. String.toLowerCase() becomes String.downcase()
                  <ul>
                    <li>
                       "downcase" is pretty common in my world. 
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           Horrible suffix characters that you thought you'd got rid of when you ditched BASIC
          <ul>
            <li>
               And some of them make for methods that differ based only on the suffix 
              <ul>
                <li>
                   e.g. String.chop vs String.chop! - where the latter does damage to the instance because Ruby has <a href="MutableStrings.html">MutableStrings</a>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <a href="MutableStrings.html">MutableStrings</a>
          <ul>
            <li>
               Seriously. Ick.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           The implementation is ugly and buggy. I've found two significant bugs; one of which is arguably a security hole.
        </li>
      </ul>
      <ul>
        <li>
           <a href="SmugRubyWeenie.html">SmugRubyWeenie</a>s
        </li>
      </ul>
      <ul>
        <li>
           <a href="RubyOnRailsRulesTheUniverse.html">RubyOnRailsRulesTheUniverse</a> <em>(oy!)</em>
        </li>
      </ul>
      <ul>
        <li>
           <a href="DomainSpecificLanguage.html">DomainSpecificLanguage</a> fever:
        </li>
      </ul>
      <code>
        look.ma no.parentheses!<br/>
        excited.weenies.every do |weenie|<br/>
        weenie.invents_a.domain_specific.language<br/>
        end<br/>
        <em>.nuff.said</em><br/>
      </code>
      <p>
        .
      </p>
      <ul>
        <li>
           But they still haven't got rid of the pipes. If they really wanted Englishification:
        </li>
      </ul>
      <code>
        look.ma no.parentheses.and.no.pipes!<br/>
        excited.weenies.every do with weenie<br/>
        weenie.invents_a.domain_specific.language<br/>
        end<br/>
        // examples damaged by <a href="TabMunging.html">TabMunging</a><br/>
      </code>
      <p>
        .
      </p>
      <ul>
        <li>
           Is it just me, or does using such DSL features of those lisp-wannabe language make for cryptic error messages versus a "real" DSL (custom compiler/interpreter)? The round-about innards of implementation seem to expose themselves when something goes wrong. Same with <a href="JavaScript.html">JavaScript</a>. I don't currently have any such examples to present, but will keep an eye for them. -t
        </li>
      </ul>
      <ul>
        <li>
           The only common superclass of True and False is Object.
        </li>
      </ul>
      <ul>
        <li>
           you don't get a stacktrace when you hit a SystemStackError; how useful! You need to fall back to ugly and inconvenient trickery like: <a href="http://stackoverflow.com/a/21585967/520567">http://stackoverflow.com/a/21585967/520567</a>
        </li>
      </ul>
      <hr/>
      <p>
        Lisp, <a href="SmallTalk.html">SmallTalk</a>, <a href="JavaScript.html">JavaScript</a>, and Perl walked into a bar and had an orgy near Fukishima, giving birth to a 30-pound bi-gender baby named Ruby.
      </p>
      <hr/>
      <p>
        If Ruby docs frustrate the daylights out of you, as they do me, you might find my Ruby API Guide (<a href="http://mysite.verizon.net/hpassel/rubyguide/)">http://mysite.verizon.net/hpassel/rubyguide/)</a> helpful. Even though it has a ways to go, I find myself referring to it all the time. It's helping me a <em>lot</em>. -- <a href="ElizabethWiethoff.html">ElizabethWiethoff</a>
      </p>
      <p>
        [<a href="DeadLink.html">DeadLink</a>?]
      </p>
      <hr/>
      <p>
        It suffer some of the pitfalls of Lisp, as described in <a href="GreatLispWar.html">GreatLispWar</a>.
      </p>
      <hr/>
      <p>
        <a href="CategoryRant.html">CategoryRant</a> <a href="CategoryRuby.html">CategoryRuby</a>
      </p>
    </div>
  </body>
</html>