<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Smalltalk Instead Of Python
      </h1>
      <p>
        <a href="PythonLanguage.html">PythonLanguage</a> and <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> seem comparable in many ways, but their origins and styles are very different. On this page we're trying to figure out when to use <a href="SmalltalkInsteadOfPython.html">SmalltalkInsteadOfPython</a>.
      </p>
      <hr/>
      <p>
        <strong>Syntax</strong>
      </p>
      <p>
        If, like most programmers, you come from an <a href="AlgolFamily.html">AlgolFamily</a> background, then Smalltalk syntax looks pretty obscure at first. Consider:
      </p>
      <ul>
        <li>
           One of the <a href="SmalltalkTutorials.html">SmalltalkTutorials</a>
        </li>
        <li>
           <a href="SmalltalkSyntax.html">SmalltalkSyntax</a>
        </li>
        <li>
           <a href="SmalltalkMessageRules.html">SmalltalkMessageRules</a>
        </li>
        <li>
           The short-but-sweet book: <a href="OnToSmalltalk.html">OnToSmalltalk</a>
        </li>
      </ul>
      <p>
        Python, on the other hand, is notoriously easy for an <a href="AlgolFamily.html">AlgolFamily</a> programmer to learn, and comes with several truly excellent tutorials. The main difference you'll find is that Python uses indentation rather than braces to control scope. (See <a href="PythonWhiteSpaceDiscussion.html">PythonWhiteSpaceDiscussion</a>.) It's not too much to expect any competent programmer to learn most of the Python syntax in a day, and to become fluent in a couple of weeks.
      </p>
      <hr/>
      <p>
        <strong>Speed</strong>
      </p>
      <p>
        <a href="JavaPython.html">JavaPython</a> is the speed of <a href="JavaLanguage.html">JavaLanguage</a> which is about as fast as <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>. <em>Are there any numbers on that claim? The professional Smalltalk vendors still claim that their </em><a href="VirtualMachine.html">VirtualMachine</a>s are faster than Java's.<em> Regular </em><a href="PythonLanguage.html">PythonLanguage</a> is as much as 2.5 times faster than Jython, according to the Jython faq. Some <a href="JustInTimeCompiler.html">JustInTimeCompiler</a>s may bring Jython up to par with regular Python. Does this mean <a href="SmallTalk.html">SmallTalk</a> is slower? <em>Jury's out</em> Who cares: use <a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a>. <em></em><a href="SmalltalkEmTee.html">SmalltalkEmTee</a> produces very fast compiled code on <a href="MicrosoftWindows.html">MicrosoftWindows</a>--DLLs, <a href="ActivexTechnology.html">ActivexTechnology</a> controls, the lot.<em></em>
      </p>
      <p>
        The development of <a href="PythonLanguage.html">PythonLanguage</a> has focused more on speed of development than speed of program execution. I certainly doubt that CPython is 2.5 times faster than <a href="JavaLanguage.html">JavaLanguage</a>, which is suggested above. But as you know, benchmarks only tell us how fast the actually benchmarked code is. There are some references to Python performance on the web. <a href="http://www.flat222.org/mac/bench/">http://www.flat222.org/mac/bench/</a> <a href="http://shootout.alioth.debian.org/">http://shootout.alioth.debian.org/</a> As usual, these tests focus on tiny, meaningless programs, so I'd take them with a pinch of salt. And they don't compare with SmallalkLanguage...  
      </p>
      <p>
        <em></em><a href="http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=vw&lang2=python">http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=vw&lang2=python</a> measures Python implementations and Smalltalk implementations.<em></em>
      </p>
      <p>
        Is <a href="JavaPython.html">JavaPython</a> really the speed of <a href="JavaLanguage.html">JavaLanguage</a>? Sure, Jython can be compiled into Java bytecode, but will it look just as the bytecode of a comparable Java program? I think the dynamic nature of Python/Jython will lead to more complex bytecode.
      </p>
      <p>
        <em>No, Jython is not the speed of Java. I think it's like 10x slower than Java, because many portions are interpreted. (10x slower for what kind of code? Numbers lie...) CPython is faster than Jython. I personally consider Jython to be niche, useful for environments where </em><a href="JavaLanguage.html">JavaLanguage</a> is entrenched or otherwise required.<em></em>
      </p>
      <p>
        <em>Python performance is Good Enough, for nearly any definition of "Good Enough". Because it is easy to use </em><a href="CeeLanguage.html">CeeLanguage</a> code with <a href="PythonLanguage.html">PythonLanguage</a>, portions of your code can be refactored to speed up your program. Of course, C is harder than Python, so you only do this as necessary, but there is always at least a path out. Also, you can use C libraries that are created and packaged by other people (which is what I do), and eventually the whole community benefits. -- <a href="IanBicking.html">IanBicking</a><em></em>
      </p>
      <hr/>
      <p>
        <strong>Tools</strong>
      </p>
      <p>
        <strong>Smalltalk:</strong> IDLE is some of the way there, but there's nothing comparable to the <a href="RefactoringBrowser.html">RefactoringBrowser</a>, or even an object inspector.
      </p>
      <p>
        <strong>Python:</strong> If you prefer an editor to an IDE, this is moot. A <a href="PythonRefactoringBrowser.html">PythonRefactoringBrowser</a> would be really nice though. Thank you, <a href="BicycleRepairMan.html">BicycleRepairMan</a>!
      </p>
      <p>
        But see more on this on <a href="IdeInsteadOfEditor.html">IdeInsteadOfEditor</a>.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="GemStone.html">GemStone</a><strong></strong>
      </p>
      <p>
        Once unique to the <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> world, a <a href="JavaLanguage.html">JavaLanguage</a> version (<a href="GemStonej.html">GemStonej</a>) is evolving nicely. <a href="GemStone.html">GemStone</a> gives extraordinary power to develop large-scale applications, and is used in telecom, manufacturing, logistics, finance, and commerce. See also <a href="GemstoneProject.html">GemstoneProject</a>. It's a high-performance server & scalable <a href="ObjectOrientedDatabaseManagementSystem.html">ObjectOrientedDatabaseManagementSystem</a>, capable of supporting over 1 billion objects.  
      </p>
      <p>
        You can of course build a large scale python system over any RDBMS, but <a href="GemStone.html">GemStone</a> would likely trump that solution in flexibility. However, as <a href="JavaPython.html">JavaPython</a> is able to do everything Java can do, use/aggregate/compose/derive from any <a href="JavaLanguage.html">JavaLanguage</a> class, there's no difficulty using <a href="GemStone.html">GemStone</a> from <a href="PythonLanguage.html">PythonLanguage</a>. You could also use <a href="JavaPython.html">JavaPython</a> in combination with the Oracle <a href="JavaVirtualMachine.html">JavaVirtualMachine</a>.
      </p>
      <p>
        <em>Note that </em><a href="GemStone.html">GemStone</a> Smalltalk is in many ways more flexible than the Java/<a href="JavaPython.html">JavaPython</a> route, primarily because it is more mature than <a href="GemStonej.html">GemStonej</a>. It also benefits from Smalltalk's rich reflection & metaobject libraries when designing rich & adaptive frameworks.<em></em>
      </p>
      <p>
        ZoDb (The Zope Object Database) is a (not-quite orthogonal) persistent store with transactional support, as well as other features. It is available separate from Zope, and many people use it as such. And it's <a href="OpenSource.html">OpenSource</a>. For a significant portion of the <a href="PythonLanguage.html">PythonLanguage</a> community, software is not valuable if it is <a href="ClosedSource.html">ClosedSource</a> (a notable difference from <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> circles), so an imaginary Gemstone/P would not matter much to us.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="ZopeApplicationServer.html">ZopeApplicationServer</a> (Zope)<strong></strong>
      </p>
      <p>
        What's more Zope provides a free Python <a href="ObjectOrientedDatabase.html">ObjectOrientedDatabase</a>, and a nice one. Nevertheless, ZoDb's scaling attributes haven't been stressed or demonstrated. If you want to do data warehousing in <a href="PythonLanguage.html">PythonLanguage</a>, you'll probably have to go the <a href="JavaPython.html">JavaPython</a>/<a href="GemStonej.html">GemStonej</a> route.
      </p>
      <p>
        Zope may not be the ideal choice for mass storage / retrieval of arbitrary Foreign Objects. Still, why not put Zope / ZoDb to the test by building a Web-Based Python Development Environment, complete with a <a href="PythonRefactoringBrowser.html">PythonRefactoringBrowser</a>?
      </p>
      <p>
        <em></em>ZoDb isn't really meant to be separated from Zope and used with other projects though, is it? I'm not asking this as an argument for <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>, but rather because I have other projects that I could use a good object store for, and I'm thinking of doing those projects in <a href="PythonLanguage.html">PythonLanguage</a> (as opposed to <a href="JavaLanguage.html">JavaLanguage</a> or <a href="CeeLanguage.html">CeeLanguage</a>).<em></em>
      </p>
      <p>
        There's an excellent article on just this topic: <a href="http://starship.python.net/crew/amk/python/writing/zodb-zeo.html">http://starship.python.net/crew/amk/python/writing/zodb-zeo.html</a>
      </p>
      <p>
        Zope is made up of several modules, which when used together form a Web Application Development Environment, but each can be used separately. ZoDb is a direct descendant of "Bobo", an <a href="OpenSource.html">OpenSource</a> <a href="PythonLanguage.html">PythonLanguage</a> module, that provides Persistence to Python Objects (an ODB). Typically ZoDb is used in conjunction with the Filestorage module, but the actual storage medium is abstracted, and there are existing alternatives.
      </p>
      <p>
        Perhaps the reference to data warehousing (above) is intended to caution against using the Zope native Object Database (ZODB) as an Object Data Warehouse. This is very different than using Zope as a Web Development Environment for building systems to access a "traditional" Data Warehouse. In this sense, Zope is very capable of managing the Python Objects that make up Zope itself, components of Web Applications created within Zope, as well as data held in external systems, which are "objectified" within the Zope context.
      </p>
      <p>
        If you're looking at a Zope solution, you'll quickly notice that the interfaces to back-end datastores are quite mature and flexible. Zope is very adequate for accessing any traditional "backend" (tabular data, any <a href="RelationalDataBaseManagementSystem.html">RelationalDataBaseManagementSystem</a> such as <a href="OracleDatabase.html">OracleDatabase</a>, <a href="PostgreSql.html">PostgreSql</a>). This is the realm of <a href="ColdFusion.html">ColdFusion</a>, <a href="ActiveServerPages.html">ActiveServerPages</a>, and <a href="PhpLanguage.html">PhpLanguage</a>. Of these only PHP is <a href="OpenSource.html">OpenSource</a> and cross-platform, and none are <a href="ObjectOriented.html">ObjectOriented</a>. Unlike these, Zope has a powerful security model, and is a capable <a href="ContentManagementSystem.html">ContentManagementSystem</a>. 
      </p>
      <hr/>
      <p>
        <strong>Closures</strong>
      </p>
      <p>
        <strong>Python:</strong> has <a href="FirstClassFunction.html">FirstClassFunction</a>s that can be used just like <a href="SmalltalkBlocksAndClosures.html">SmalltalkBlocksAndClosures</a> (as far as I know). The <a href="LambdaCalculus.html">LambdaCalculus</a> functions are just <a href="SyntacticSugar.html">SyntacticSugar</a> for one liners. They compile down to first class <a href="AnonymousFunction.html">AnonymousFunction</a>s.  
      </p>
      <p>
        <strong>Smalltalk:</strong> Something that I love to do in <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>, <a href="RubyLanguage.html">RubyLanguage</a> and <a href="LispLanguage.html">LispLanguage</a> but find frustrating in <a href="PythonLanguage.html">PythonLanguage</a> because of the lambdas:
      </p>
      <code>
        ^ anArray collect: [ :each | each transform ]<br/>
      </code>
      <p>
        goes to
      </p>
      <code>
        map(lambda x:x.transform(), anArray)<br/>
      </code>
      <p>
        in Python.  Fine, if a mite yucky.  Unfortunately...
      </p>
      <code>
        ^ anArray collect: [ :each | self transform: each ]<br/>
      </code>
      <p>
        goes to
      </p>
      <code>
        map(lambda x, self=self: self.transform(x), anArray)<br/>
      </code>
      <p>
        which is yucky as all get out when the list of objects you need to use inside the lambda gets at all long. Python 3000 offers some hope, but the semantics aren't the only problem with doing this kind of mapping in Python <em>(But see Python's nifty </em><a href="ListComprehension.html">ListComprehension</a> syntax below!)<em>; the syntax is surprisingly klugey. Plus, you don't get the really cool stuff the Collection protocol gives you in Smalltalk: no includes, no isEmpty... you do have a select, but it has the same problems the map does, etc.</em>
      </p>
      <p>
        <em>Note: the second map example can actually be rewritten like this, which is far more readable:</em>
      </p>
      <code>
        map( self.transform, anArray )<br/>
      </code>
      <p>
        However, code that would use blocks in Smalltalk is less readable when written with functions in Python because code that should belong together is written in two separate places. Also, functions need to be named, which often leads to the auxiliary functions having awkward names or names that carry little useful information.
      </p>
      <p>
        <strong>Python:</strong> In recent versions of Python (2.0 upwards)
        you can use <a href="ListComprehension.html">ListComprehension</a>s:
      </p>
      <code>
        return [x.transform() for x in anArray]<br/>
        return [self.transform(x) for x in anArray]<br/>
      </code>
      <p>
        Versions 2.1 and up have properly nesting scopes (in 2.1 you need to do a little magic dance to enable them, but that will goes away in 2.2), so the "foo=foo" hack is no longer needed.
      </p>
      <p>
        There are two forces here: one is that the built-ins in <a href="PythonLanguage.html">PythonLanguage</a> tend not to have methods; int('foo') instead of 'foo' asNumber. (As of Python 2.0, strings have methods; though there is still no method for converting to a number.) The other is that <a href="AnonymousFunction.html">AnonymousFunction</a>s are unpleasant in Python (though less so as of 2.1).
      </p>
      <p>
        Who cares about closures? I practically never use 'em, nor lambdas neither. When would you use <a href="ClosureInsteadOfObject.html">ClosureInsteadOfObject</a>?
      </p>
      <p>
        <em>A closure does two things: It avoids giving a name to a block of code that doesn't need it, and it keeps the block of code as close as possible to where it is being used.</em> 
      </p>
      <p>
        It does more than that, and just because you never use them doesn't mean they aren't extremely useful to those who do. Anonymous closures allow easy and clean use of <a href="HigherOrderFunction.html">HigherOrderFunction</a>'s, and allows a more <a href="FunctionalProgramming.html">FunctionalProgramming</a> style. The entire Smalltalk <a href="CollectionHierarchies.html">CollectionHierarchies</a> [sic, sorry] is based upon higher-order functions and closures, so being able to create closures with an extremely light syntax is a huge, huge boon.
      </p>
      <p>
        [It's a matter of preference, not a huge boon. I generally prefer named functions, purely as a stylistic and aesthetic matter. It's also slightly easier to refactor. Anonymous blocks are <strong>not</strong> required for <a href="FunctionalProgramming.html">FunctionalProgramming</a> or the use of HOFs. Reasonable people can agree to disagree about this, but I wouldn't call it a failing on the part of <a href="PythonLanguage.html">PythonLanguage</a> (any more than I would count <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>'s non-<a href="AlgolFamily.html">AlgolFamily</a> syntax against it).]
      </p>
      <p>
        Okay, so <a href="StacklessPython.html">StacklessPython</a> seems to make this a non-issue. Is there anything else to recommend Smalltalk over Python?
      </p>
      <p>
        <em>So </em><a href="StacklessPython.html">StacklessPython</a> adds <a href="CoRoutine.html">CoRoutine</a>s. I fail to see how that provides me with the flexibility of a closure/block. This is one of my problems with <a href="JavaLanguage.html">JavaLanguage</a>: <a href="AnonymousInnerClass.html">AnonymousInnerClass</a>es are a poor & clunky substitute.<em></em>
      </p>
      <p>
        See also <a href="PythonVsRuby.html">PythonVsRuby</a>, <a href="BlocksInRuby.html">BlocksInRuby</a>, <a href="BlocksInPython.html">BlocksInPython</a>, <a href="BlocksInManyLanguages.html">BlocksInManyLanguages</a>.
      </p>
      <hr/>
      <p>
        <strong>Books and Portability</strong>
      </p>
      <p>
        <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> has more books than <a href="PythonLanguage.html">PythonLanguage</a>, but more Python books are coming out. Some Smalltalk books are specialized to a particular vendor's implementation. This may cause minor problems of applicability, but overall most Smalltalk flavors are quite similar. Python essentially has only two mainstream implementations (Python and <a href="JavaPython.html">JavaPython</a>, both free), and those two implementations are available an many platforms. Smalltalk is also available on many platforms (<a href="SunSolaris.html">SunSolaris</a>, <a href="MicrosoftWindows.html">MicrosoftWindows</a>, <a href="AppleMacintosh.html">AppleMacintosh</a>, <a href="LinuxOs.html">LinuxOs</a>, etc.)
      </p>
      <p>
        <em>Smalltalk has a book by </em><a href="KentBeck.html">KentBeck</a> ([ISBN 013476904X]). Python doesn't.<em></em>
      </p>
      <p>
        <em>Actually, Python now has part of a book by </em><a href="KentBeck.html">KentBeck</a> ([ISBN 0321146530]).<em></em>
      </p>
      <p>
        <em>Python has several </em><a href="AnimalBook.html">AnimalBook</a>s ([ISBN 1565924649], [ISBN 1565921976], [ISBN 1565926218], [ISBN 1565925009]).  Smalltalk doesn't.<em></em>
      </p>
      <hr/>
      <p>
        <strong>Standards and Bindings</strong>
      </p>
      <p>
        Python's <a href="JavaLanguage.html">JavaLanguage</a>, <a href="CeePlusPlus.html">CeePlusPlus</a> (via the <a href="SimplifiedWrapperAndInterfaceGenerator.html">SimplifiedWrapperAndInterfaceGenerator</a>), XML, RDB and COM bindings are all excellent. Smalltalk (<a href="VisualWorks.html">VisualWorks</a> and <a href="VisualAge.html">VisualAge</a>) supports Java, C++, COM and Windows DLL bindings, though it lacks the auto-generated APIs of the <a href="SimplifiedWrapperAndInterfaceGenerator.html">SimplifiedWrapperAndInterfaceGenerator</a>. <a href="DistributedSmalltalk.html">DistributedSmalltalk</a> is a CORBA 2.x ORB. <a href="SqueakSmalltalk.html">SqueakSmalltalk</a> can translate a subset of itself into <a href="CeeLanguage.html">CeeLanguage</a>. And <a href="PythonLanguage.html">PythonLanguage</a> and <a href="SqueakSmalltalk.html">SqueakSmalltalk</a> are both <a href="OpenSource.html">OpenSource</a>.
      </p>
      <p>
        Python is far less insular than Smalltalk, as a language in general, and the implementations specifically. Python makes extensive use of libraries and programs not written for Python, and does not insulate the programmer from the system.
      </p>
      <hr/>
      <p>
        <strong>Marketability and Lifespan</strong>
      </p>
      <p>
        Neither language is terribly marketable compared with the corporate-supported languages, but <a href="PythonLanguage.html">PythonLanguage</a> is younger, livelier, and easily combined with/evolved from development with other languages, so it seems the more likely to proliferate. Python has strong community participation at all levels of development, including the core language development. The community is transparent and does not depend on commercial success (as the corporate-sponsored or owned <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> implementations do).
      </p>
      <p>
        Two versions of Smalltalk are supported by large corporations (<a href="IbmSmalltalk.html">IbmSmalltalk</a> and <a href="CincomSmalltalk.html">CincomSmalltalk</a>), and others are supported by smaller for-profit organizations. <a href="IbmCorporation.html">IbmCorporation</a> supports its products forever, and Smalltalk seems to have settled in a stable, respectable niche. <a href="SqueakSmalltalk.html">SqueakSmalltalk</a> provides an <a href="OpenSource.html">OpenSource</a> alternative.
      </p>
      <hr/>
      <p>
        <strong>Reflection and </strong><a href="MetaProgramming.html">MetaProgramming</a><strong></strong>
      </p>
      <p>
        <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> is known to have a very rich, reflective nature, second only to <a href="CommonLisp.html">CommonLisp</a>. How does Python fare?
      </p>
      <p>
        <a href="PythonLanguage.html">PythonLanguage</a> is very reflective. Everything in the language, including classes, namespaces and functions, is an object whose properties can be got and set. Python programs can construct and compile Python programs on the fly. Python objects can be serialized and deserialized with a single statement. There are some limitations - see the discussion on Closures - but it's difficult to see where they'd bite you.
      </p>
      <p>
        <em>Okay, but how about </em><a href="MetaClass.html">MetaClass</a>es?  I was surfing around Python.org, and only got the impression that it was a work-in-progress.<em></em>
      </p>
      <p>
        [My disclaimer, I don't know beans about Smalltalk.] Perhaps you are accustomed to an automated tool for implementing <a href="MetaClass.html">MetaClass</a>es, but if you are interested, here's an article with code samples showing use of <a href="MetaClass.html">MetaClass</a>es in Python: <a href="http://www2.linuxjournal.com/lj-issues/issue73/3882.html">http://www2.linuxjournal.com/lj-issues/issue73/3882.html</a>
      </p>
      <p>
        <a href="PythonLanguage.html">PythonLanguage</a> has supported <a href="MetaClass.html">MetaClass</a> programming since version 2.2 or so. <a href="DavidMertz.html">DavidMertz</a>'s site also has a few articles on this.
      </p>
      <ul>
        <li>
           Does Python allow object swizzling? By this I mean that Smalltalk has a method called <strong>become:</strong> that effectively replaces one instance with another instance, changing all references in the system. <em>No, Python does not have this.</em>
        </li>
      </ul>
      <p>
        <em>By my understanding of </em>ObjectSwizzling, it does:<em></em>
      </p>
      <code>
        class foo:<br/>
        def __init__(self, datum):<br/>
        self.datum = datum<br/>
        def __str__(self): return "This is a foo with datum %s" % self.datum<br/>
      </code>
      <code>
        class bar:<br/>
        def __init__(self, thing):<br/>
        self.thing = thing<br/>
        def __str__(self): return "This is a bar; contents: %s" % (self.__dict__, )<br/>
      </code>
      <code>
        >>> x = bar(123)<br/>
        >>> print x<br/>
        This is a bar; contents: {'thing': 123}<br/>
        >>> x = foo(123)<br/>
        >>> print x<br/>
        This is a foo with datum 123<br/>
        >>> x.__class__<br/>
        <class __main__.foo at 0x00CF3AB0><br/>
        >>> x.__class__ = bar<br/>
        >>> x<br/>
        <__main__.bar instance at 0x00D64F30><br/>
        >>> print x<br/>
        This is a bar; contents: {'datum': 123}<br/>
      </code>
      <ul>
        <li>
           Does Python allow me to call methods through reflection? (i.e., like Java's <a href="MethodObject.html">MethodObject</a>s or Smalltalk's <strong>perform:</strong> ) <em>Yes, everything is available through reflection, including modifying class objects, adding methods, etc., at runtime.</em>
        </li>
      </ul>
      <p>
        There are several aspects to relation.  One is that we can look things up by name:
      </p>
      <code>
        >>> import string<br/>
        >>> string.__dict__['uppercase']<br/>
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ'<br/>
      </code>
      <p>
        Another is that we can evaluate code at runtime:
      </p>
      <code>
        >>> eval('"Hello" + "Wiki"')<br/>
        '<a href="HelloWiki.html">HelloWiki</a>'<br/>
      </code>
      <p>
        Et cetera. Evaluation is usually not necessary for reflection.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a><strong></strong>
      </p>
      <p>
        <a href="PythonLanguage.html">PythonLanguage</a> is trivial to integrate with <a href="CeeLanguage.html">CeeLanguage</a> or other native languages: just build a <a href="SharedLibrary.html">SharedLibrary</a>, import it, and start calling.
      </p>
      <hr/>
      <p>
        Just starting with Python, so I don't know: Does Python have Senders/Implementors? Inspectors? Editing in the debugger with restart? ENVY and similar tools to show editions of methods and replace them? Reflection? Hierarchy Browsers? Window drawing and event linking tools? 
      </p>
      <p>
        <em>bit of a mixed collection of requirements here... Python doesn't have the nice environment that has always been part of Smalltalk -- after all it started life as a </em><a href="ScriptingLanguage.html">ScriptingLanguage</a>. It does have several user interface toolkits of which I believe the TK port is most popular. It does have reflection, although maybe not quite as much as Smalltalk. It also has, at least for now, one version, there are no vendor wars to lose.<em></em>
      </p>
      <p>
        <em>Python's design actually makes on-the-fly editing difficult or impossible.  Classes are created by execution, not defined.  So:</em>
      </p>
      <code>
        >>> class A: <br/>
        ...	def answer(self): return "YES!"<br/>
        >>> a = A()<br/>
        >>> class A:<br/>
        ...	def answer(self): return "NO!"<br/>
        >>> a.answer()<br/>
        YES!<br/>
      </code>
      <p>
        As you may see, the a object is still bound to the old definition of A.  You can do some funny tricks with this, but for the most part it causes problems.<em></em>
      </p>
      <p>
        --
      </p>
      <p>
        But the effect is achievable with:
      </p>
      <code>
        >>> class A:<br/>
        ...     def answer(self): return "YES!"<br/>
        >>> a = A()<br/>
        >>> class A:<br/>
        ...     def answer(self): return "NO!"<br/>
        >>> a.answer()<br/>
        'YES!'<br/>
        >>> a.__class__ = A #reload class<br/>
        >>> a.answer()<br/>
        'NO!'<br/>
      </code>
      <p>
        or for a single function:
      </p>
      <code>
        >>> class A:<br/>
        ...	def answer(self): return "YES!"<br/>
        >>> a = A()<br/>
        >>> def just_say_no(self): <br/>
        ...	return "NO!"<br/>
        >>> A.answer = just_say_no<br/>
        >>> a.answer()<br/>
        NO!<br/>
      </code>
      <p>
        This happens to work in Ruby:
      </p>
      <code>
        irb(main):001:0> class A<br/>
        irb(main):002:1>   def answer;  return "YES!";  end<br/>
        irb(main):003:1> end<br/>
        => nil<br/>
        irb(main):004:0> a = A.new<br/>
        => #<A:0x298a510><br/>
        irb(main):005:0> a.answer<br/>
        => "YES!"<br/>
        irb(main):006:0> class A<br/>
        irb(main):007:1>   def answer;  return "NO!";  end<br/>
        irb(main):008:1> end<br/>
        => nil<br/>
        irb(main):009:0> a.answer<br/>
        => "NO!"<br/>
        irb(main):010:0><br/>
      </code>
      <p>
        I guess that's not too surprising, given the way Ruby is modeled after Smalltalk.
      </p>
      <hr/>
      <p>
        <strong>Comments</strong>
      </p>
      <p>
        Dammit, I like 'em both. Which says a lot for Python, because I'm a die-hard SmalltalkBigot (and a KnightOfTheSquareBracket). Python meets my bare minimum usability requirements: <a href="LateBinding.html">LateBinding</a> and <a href="GarbageCollection.html">GarbageCollection</a>. And it has a 1970's hacker community feel to it. And I'm really enjoying using it. --<a href="AnthonyLander.html">AnthonyLander</a>
      </p>
      <p>
        [Comments on file orientation moved to <a href="PythonRefactoringBrowser.html">PythonRefactoringBrowser</a>]
      </p>
      <hr/>
      <p>
        I'm very impressed with <a href="RubyLanguage.html">RubyLanguage</a>. Does anyone have any ideas on <a href="SmalltalkInsteadOfRuby.html">SmalltalkInsteadOfRuby</a> or RubyInsteadOfPython? (See <a href="PythonVsRuby.html">PythonVsRuby</a>) The only real drawback of Ruby that I see is that it is so young, but that will improve with time, of course, and by definition.
      </p>
      <dl>
        <dt> </dt>
        <dd>Since it looks like you have some experience with that, perhaps you could write something at <a href="RubyInsteadOfSmalltalk.html">RubyInsteadOfSmalltalk</a> :-) Would be a good starting point for further discussion and comparisons.</dd>
      </dl>
      <hr/>
      <p>
        One thing going for Python is that it does or can resemble the <a href="AlgolLanguage.html">AlgolLanguage</a>-roots style that is so common. One can more easily gradually transition instead of doing a mental 180.
      </p>
      <hr/>
      <p>
        At this point (March 2005), Python also has a much larger community and library. It also has high quality free/Free implementations, which (as I understand it), Smalltalk does not. Personally, I wouldn't recommend using smalltalk unless you've already got experienced smalltalk developers and/or existing smalltalk code you need to work from.
      </p>
      <p>
        <em>Squeak is both high quality and free. </em><a href="VisualWorks.html">VisualWorks</a> is free for development. Smalltalk/X (<a href="SmalltalkEcks.html">SmalltalkEcks</a>) is even free for commercial users.<em></em>
      </p>
      <hr/>
      <p>
        <a href="CategoryProgrammingLanguageComparisons.html">CategoryProgrammingLanguageComparisons</a> <a href="CategorySmalltalk.html">CategorySmalltalk</a> <a href="CategoryPython.html">CategoryPython</a>
      </p>
    </div>
  </body>
</html>