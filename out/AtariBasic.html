<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Atari Basic
      </h1>
      <p>
        The <a href="BasicLanguage.html">BasicLanguage</a> interpreter for Atari 8-bit computers could be purchased on cartridge.  Atari XL and XE machines had BASIC built into <a href="ReadOnlyMemory.html">ReadOnlyMemory</a>.
      </p>
      <p>
        Unique features include:
      </p>
      <p>
        <strong>Bit-mapped graphics commands</strong> -- GRAPHICS <mode>; COLOR <number>; PLOT <column>,<row>; DRAWTO <column,row>; and you could read the screen with LOCATE <column>,<row>,<variable> All rather intuitive when compared to <a href="AppleComputer.html">AppleComputer</a>'s HLINE and VLINE.  Commodore computers had to do all their graphics with POKEs until later models like the C128 came out. (See <a href="CommodoreBasic.html">CommodoreBasic</a>.) Unfortunately, there were no built-in commands for sprites.
      </p>
      <p>
        <strong>Computed </strong><a href="GoTo.html">GoTo</a>s.<strong> --- The argument to goto could be a variable.</strong>
      </p>
      <p>
        <strong>Primitive string indexing.</strong>
        Instead of LEFT$(A$,3), you used A$(1,3).
        Instead of MID$(A$,4,2), you used A$(4,5).
        RIGHT$ required the use of LEN().
        Instead of A$ = A$ + B$, you used A$(LEN(A$)+1) = B$.
      </p>
      <p>
        ...
      </p>
      <p>
        <strong>Idioms</strong>
      </p>
      <p>
        Atari BASIC was rather wasteful when it dealt with integers.  It treated all numbers as floating-point numbers, which took six bytes and was rather processor-intensive (the 6502 had no native floating point support).  You could save a considerable amount of RAM by defining constants at the beginning of the program.
      </p>
      <ol>
        <li>
           O0=0:O1=1:O2=2:O3=3:O53248=53248:O10=10
        </li>
        <li>
           FOR x = O1 TO O10
        </li>
      </ol>
      <p>
        String literals in a program could contain any byte except 34 (quote) or 155 (ATASCII CR). So you could put in-line <a href="AssemblyLanguage.html">AssemblyLanguage</a> into your program by combining the ADR function, which returned a pointer to any string, with the USR function, which executed a system call.  This was often done to load larger <a href="MachineLanguage.html">MachineLanguage</a> programs or font data into a <a href="BasicLanguage.html">BasicLanguage</a> program.
      </p>
      <p>
        Atari 8-bit sprites are essentially eight- or two-pixel wide bitmaps that run the entire height of the screen. So you had to use some kind of machine language code if you wanted to move them vertically, or even to set them up without making the user wait.  (A FOR loop to move the sprite through memory would take about a second to run; that's how slow <a href="AtariBasic.html">AtariBasic</a> was.)
      </p>
      <hr/>
      <p>
        <a href="AtariBasic.html">AtariBasic</a> was, for a long time, the only reasonable "high" level language [<a href="HighLevelLanguage.html">HighLevelLanguage</a>] available for the 8-bit Atari line.  Pilot and <a href="LogoLanguage.html">LogoLanguage</a> were available but they were even slower than <a href="AtariBasic.html">AtariBasic</a> was, and <a href="AtariBasic.html">AtariBasic</a> was plenty slow (most serious programming was done in <a href="AssemblyLanguage.html">AssemblyLanguage</a>).  <em></em><a href="ForthLanguage.html">ForthLanguage</a> was also available, but not often used.  There was also a Forth dialect called WSFN (Which Stands For Nothing).<em></em>
      </p>
      <p>
        The 6502 was far too wimpy to host anything resembling a reasonable <a href="CeeLanguage.html">CeeLanguage</a> environment. The processor only supported a 256-byte stack, for instance.  I believe there was a C compiler for the Atari, but it wasn't widely used.  (There was a commonly-used compression program called ARC that boasted of being compiled with Lightspeed C.)
      </p>
      <p>
        Deep Blue C: <a href="http://www.atariarchives.org/APX/showinfo.php?cat=20166">http://www.atariarchives.org/APX/showinfo.php?cat=20166</a>
      </p>
      <p>
        Incidentally, there are no curly braces in the ATASCII character set. That changed when OSS (Optimized Systems Software) release the <a href="ActionLanguage.html">ActionLanguage</a>.
      </p>
      <p>
        A system where you actually had to use digraphs to write C code.
      </p>
      <hr/>
      <p>
        The best thing about <a href="AtariBasic.html">AtariBasic</a> was that they had abbreviations for nigh all its commands. In fact, some programs took advantage of the abbreviations to squeeze the most into the max line length. Of course, a listing would not show the abbreviations, so if you were typing in a listing of somebody else's program, you might have to know all the abbreviations to be able to do so. Best of all, though, since the abbreviations all ended in period (.), many of the abbreviations, which only dropped a single character, took just as many characters to type as the original! (IIRC, "DIM" was abbreviated "DM.")
      </p>
      <p>
        <em>Actually, if you typed a dot, it would interpret that word as the first token in its list that began with the letters leading up to it.  So DM. wouldn't work, but DI. would.  A period expanded to REM.  It's not like they could fit another table of abbreviations in 8K of ROM, could they.  And it would store the token, not the abbreviation, so the program listing would always have the full word, except in the case of the question-mark for PRINT.</em>
      </p>
      <hr/>
      <p>
        <a href="CategoryHistory.html">CategoryHistory</a>
      </p>
    </div>
  </body>
</html>