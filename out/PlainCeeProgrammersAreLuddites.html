<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Plain Cee Programmers Are Luddites
      </h1>
      <p>
        Luddites were a social movement who protested against the Industrial Revolution and protested against technology. They prefer "the old way" of doing things.
      </p>
      <p>
        Many PlainCee programmers are like Luddites. Some plain cee fanboys resist new technology because it isn't plain cee. They think everything else is bloatware; plain Cee is king to them, because C is simple. I'm not a huge fan of C++ since it is a complex mess of a language, but at least C++ has strings. One can be disciplined enough to use a subset of C++ and not all of it. 
      </p>
      <p>
        PlainCee doesn't even have strings.  It only has pointers to chars. This is primitive and anti-technology, as are Luddites. Anyone who prefers using pointers to chars over strings (like in PHP) is a luddite that resists improvements to our technology. You could still have a Cee like fast language with strings, such as <a href="GoLanguage.html">GoLanguage</a>.
      </p>
      <p>
        Why C is Obsolete (by the completely unbiased ;-) author of <a href="CeePlusPlus.html">CeePlusPlus</a>, <a href="BjarneStroustrup.html">BjarneStroustrup</a>): 
      </p>
      <p>
        <a href="http://www.youtube.com/watch?v=KlPC3O1DVcg">http://www.youtube.com/watch?v=KlPC3O1DVcg</a>
      </p>
      <hr/>
      <p>
        Sometimes the old way is the best way.  For the uses for which <a href="CeeLanguage.html">CeeLanguage</a> was intended (systems programming, embedded systems), there is still no better tool.  For other tasks, where programmer time is more important than processing time and memory efficiency, a more convenient language like Go, Python or shell script can be more appropriate. <a href="HorsesForCourses.html">HorsesForCourses</a>.
      </p>
      <p>
        <em>ATS Language is a better tool than C for the tasks for which C was intended.</em>
      </p>
      <p>
        <a href="AppliedTypeSystem.html">AppliedTypeSystem</a> does look like a promising research language. The page of examples tackles many areas where provability would be an asset. I'd also like to see some work on cross-compiled embedded targets. I hope the author has a plan for world domination; too many of these research languages die after the thesis is written.
      </p>
      <p>
        Plain Ol' C is still the language of choice for creating most <a href="EmbeddedSystems.html">EmbeddedSystems</a> applications these days. It's equivalent to a super-assembler; you have access to the machine down at the metal but can stay away when you don't want to get too messy. The stuff that needs to port can do so, and the stuff that needs to tie to a particular piece of hardware can do that. C will die when the Earth's core cools off.
      </p>
      <p>
        <em>Being there first is a significant advantage - but one measured in decades, not millennia.</em>
      </p>
      <p>
        Yeah, um, order of precedence isn't the factor here. C is the tool of choice when creating hardware-based systems because of its close-to-the-metal capabilities. More brain power has been spent optimizing C compilers than everything else combined over the last twenty years or so. Other language systems are great for other application spaces, but when you need to make an electronic gizmo do its thing then C is still your first choice, every time.
      </p>
      <p>
        <em></em><a href="CeeLanguage.html">CeeLanguage</a> did not become the tool of choice or receive so much optimization effort by its technical merit. <a href="PathDependence.html">PathDependence</a> in the development of Unix and (importantly) access to one of the earliest `free` compilers played very significant roles in its adoption. Similarly, <a href="JavaScript.html">JavaScript</a> is receiving much optimization effort. Being there first, positioning, and <a href="PathDependence.html">PathDependence</a> are very significant factors in language success. I expect such forces will keep C the king for many years yet. Though the new pressures for effective parallel programming are already acting to dethrone it.<em> </em>
      </p>
      <ul>
        <li>
           C will still be protected for quite a long time as the baseline language for inter-language communication, since the accepted standard for shared libraries (and the POSIX interface) is still based around the C calling conventions, which makes C a natural language for shim layers and systems programming.
        </li>
      </ul>
      <hr/>
      <p>
        No matter what language you use, there is always a risk of obsolescence. If the language does what it does in its niche fairly well and a significantly better replacement has yet to come along, then stop worrying about obsolescence and use it. The "in" language rarely remains in for more than a decade, and probably the average "in" time is more like 5 years.
      </p>
      <p>
        <em>Yeah, tell that to Cobol people, who are still getting paid to produce work in 2013. The lasting fact is that the bulk of electronic hardware today is driven by C. Everything else together doesn't come close. C is in your garage door opener, your microwave oven, your wall thermostat, your desktop telephone, your dishwasher, your vacuum cleaner, all over the place in your car, and it is probably sitting on your wrist. You can not swing a dead cat and not hit an electronics application written in C. C has been the de facto standard embedded systems language for 30 years and continues to be used all over the world in new electronic product development today.</em>
      </p>
      <p>
        <em>Therefore, the idea that C will disappear as a "fad" language in the next five years or so is wildly mistaken.</em>
      </p>
      <hr/>
      <p>
        <a href="CategoryRant.html">CategoryRant</a>
      </p>
    </div>
  </body>
</html>