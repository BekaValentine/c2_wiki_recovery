<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Accidental Difficulty
      </h1>
      <p>
        From <a href="FredBrooks.html">FredBrooks</a>' <a href="NoSilverBullet.html">NoSilverBullet</a>. Accidental difficulty in programming arises from the tools and processes we use. It's not inherent in the nature of programming itself. Accidental difficulty can be removed by improving tools and processes. Brooks later said that maybe the name "<a href="IncidentalDifficulty.html">IncidentalDifficulty</a>" would have caused fewer misunderstandings. See also <a href="EssentialDifficulty.html">EssentialDifficulty</a>.
      </p>
      <p>
        In fact, it's probably easier to understand <a href="AccidentalDifficulty.html">AccidentalDifficulty</a> as the dual of <a href="EssentialDifficulty.html">EssentialDifficulty</a>; or all that difficulty which is not essential.
      </p>
      <p>
        Occasionally, people like to point up a tool or process or technology as a source of accidental difficulty. That's not exactly right. The accident is the arbitrary decisions that are required in order to get something done. Essentially, I want to sit. Accidentally, I grab a chair, or a tree stump, or a railroad tie, or a park bench. Accidentally, I have to find something sit-on-able and decide that it's a valid thing to sit on. Accidentally, I have to move my arse to the sitting-place.
      </p>
      <p>
        There's quite a bit of the accidental in programming, but Brooks asserted that it's less than 90% of the programming effort.
      </p>
      <p>
        <em>I believe Brooks insofar as believing that there is no </em>'singular<strong> cause for more than 90% of the programming effort across all domains.  I.e. there is no one thing to target with a </strong><a href="SilverBullet.html">SilverBullet</a>.  That doesn't preclude that there are 'singular accidents' causing 90% productivity penalties in specific domains, nor does it preclude that the sum-total of all accidents across domains accounting for 90% or more of programming efforts, on average.  Indeed, once we start accounting for competitive <a href="NonFunctionalRequirements.html">NonFunctionalRequirements</a> and communications between computational services, I wouldn't be surprised if 95% or more of what we encounter is '<a href="AccidentalDifficulty.html">AccidentalDifficulty</a>'.<em></em>
      </p>
      <p>
        <em>One question a programmer might ask is: if I had theoretically perfect tools (languages and IDEs and input devices and </em><a href="OperatingSystem.html">OperatingSystem</a>s and frameworks and libraries) and processes (methodologies, community, education, etc.), then, modulo the application-specific stuff, how many of me would I be worth as a programmer/IT person?  Ultimately, the answer to this question depends on the domain and the tools you already work with.<em>  </em>
      </p>
      <hr/>
      <p>
        If one is seeing a lot of <a href="AccidentalDifficulty.html">AccidentalDifficulty</a> caused by boiler-plate code or hand-written translations to and from tools and interfaces, something in the system is likely <a href="SimplySimplistic.html">SimplySimplistic</a>.  <a href="SimplySimplistic.html">SimplySimplistic</a> models and services and interfaces are too simple, failing to capture the <a href="EssentialDifficulty.html">EssentialDifficulty</a>, and thus force the <a href="EssentialDifficulty.html">EssentialDifficulty</a> to be duplicated by each user, increasing the <a href="AccidentalDifficulty.html">AccidentalDifficulty</a> with each duplication.  Sometimes you can extract this <a href="AccidentalDifficulty.html">AccidentalDifficulty</a> into a library or helper <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a>.  Sometimes you cannot.  If you cannot, your language tool may be <a href="SimplySimplistic.html">SimplySimplistic</a> itself, subject to the <a href="MissingFeatureSmell.html">MissingFeatureSmell</a>.
      </p>
      <p>
        In reference to <a href="FutureOfProgrammingLanguages.html">FutureOfProgrammingLanguages</a>, the best your languages and tools can do is become 'unobtrusive', not requiring you to perform any of this extra labor beyond saying what you need done and elaborating on what it means to do what you said needed done (either declaratively or procedurally).  The trick, for productivity and avoiding <a href="AccidentalDifficulty.html">AccidentalDifficulty</a>, is supporting this and simultaneously supporting the required <a href="NonFunctionalRequirements.html">NonFunctionalRequirements</a> and <a href="UserAntiStories.html">UserAntiStories</a>.
      </p>
      <p>
        So perhaps the way to judge languages in terms of <a href="AccidentalDifficulty.html">AccidentalDifficulty</a> is in terms of:
      </p>
      <ul>
        <li>
           Inability to refactor encountered <a href="FunctionalRequirements.html">FunctionalRequirements</a> (saying what to do, elaborating how to do it) to be <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a> in a sharable solution without leaking implementation details.  
        </li>
        <li>
           Inability to do either of the above while still meeting <a href="NonFunctionalRequirements.html">NonFunctionalRequirements</a> (performance, security, mobility, communications and multi-lingual access, realtime, time-to-market/use, etc.)  
        </li>
      </ul>
      <p>
        Since a language's ability to meet these NFRs tends to be measured 'relative' to other languages <strong>and</strong> the desire to meet them tends to be 'competitive' with other products in the same domain, it isn't possible to classify <a href="AccidentalDifficulty.html">AccidentalDifficulty</a> on an absolute scale, but only comparatively between (language x domain) pairs.  E.g. the <a href="AccidentalDifficulty.html">AccidentalDifficulty</a> introduced by <a href="VisualBasic.html">VisualBasic</a> for business forms (low rate of change, low object count, high latency acceptable) is considerably less than for producing multiplayer videogames (competitive high rate of change (for more interaction), competitive high object count, latency requirements, graceful degradation requirements, security issues for memory access in competitive play, etc.), even if both desire multi-language support and fast time-to-market/use.
      </p>
      <p>
        All <a href="TuringComplete.html">TuringComplete</a> languages are equivalent modulo <a href="AccidentalDifficulty.html">AccidentalDifficulty</a>.  Therefore, <a href="AccidentalDifficulty.html">AccidentalDifficulty</a>, of the two forms above, is the only thing that matters when objectively comparing <a href="GeneralPurposeProgrammingLanguage.html">GeneralPurposeProgrammingLanguage</a>s.
      </p>
      <hr/>
      <p>
        IMHO, <a href="AccidentalDifficulty.html">AccidentalDifficulty</a> is the <a href="EssentialDifficulty.html">EssentialDifficulty</a> of programming itself. -- <a href="NatPryce.html">NatPryce</a>
      </p>
      <hr/>
      <p>
        See <a href="AccidentalComplexity.html">AccidentalComplexity</a>, <a href="EssentialComplexity.html">EssentialComplexity</a>
      </p>
      <p>
        <a href="CategoryJargon.html">CategoryJargon</a>
      </p>
    </div>
  </body>
</html>