<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Java Is Compiled To Machine Code
      </h1>
      <p>
        The following compilation mechansims are knows:
      </p>
      <ul>
        <li>
           JIT (just-in-time compilation). Java bytecode is compiled into machine code when the Java runtime interpreter first hits on it. Next time the Java bytecode program is executed again, it is compiled again on the fly. Most alter java runtime systems actually contain a JIT.
        </li>
      </ul>
      <ul>
        <li>
           Post-compilation. Java bytecode is compiled into machine code by some kind of post-compiler. The resulting program is used instead of the bytecode, which can be discarded. Some Windows Java IDEs actually do this to generate ".EXE"s.
        </li>
      </ul>
      <ul>
        <li>
           Java source is directly compiled to machine code. The GNU compiler system is currently extended with a Java front-end enabling the compiler to generate machine code from Java.
        </li>
      </ul>
      <hr/>
      <p>
        Most vendor implementations of Java do just-in-time compilation to machine code.
        It's also possible to compile the ".class" files before run time (ask Oracle).
      </p>
      <hr/>
      <p>
        Unfortunately, compiling from bytecode -> machine-code is hardly as
        efficient (with respect to the generated code) as compilation from the
        Abstract Syntax Tree (AST) -> machine code. Lots of information is
        already lost in the process from going from AST to bytecode.
      </p>
      <p>
        <em>I suspect this is not such an issue in Java because of the close match between language and JVM. Last I checked it looked like decompilers were rebuilding perfect ASTs for the bytecodes they were working with. -- </em><a href="LukeGorrie.html">LukeGorrie</a><em></em>
      </p>
      <p>
        Check out how <a href="OberonLanguage.html">OberonLanguage</a> realises "Write Once, Run Anyway". They ship
        around the tree representation such as generated by the compiler front-end,
        then use the local (native) compiler back-end to generate machine code.
        This is much more efficient.
      </p>
      <hr/>
      <p>
        <em>"Microsoft's Java VM contains an innovative Just-in-Time (JIT) compiler that uses this compile-on-the-fly strategy. Instead of interpreting bytecodes one at a time, the JIT compiler translates bytecodes into native machine instructions and executes them on the host processor."</em>
      </p>
      <code>
        <a href="http://www.microsoft.com/Mind/0596/jakarta/jakarta.htm">http://www.microsoft.com/Mind/0596/jakarta/jakarta.htm</a><br/>
      </code>
      <p>
        [many others have JITs to]
      </p>
      <p>
        And in a recent presentation I saw on Oracle's implementation of Java in their servers, they said that they compile the ".class" files in advance (when packages are installed in the server?), and that this is very fast.
      </p>
      <p>
        <em>SGI were doing something like this in around 1996. Their IRIX VM would JIT classes as they were loaded, and then embed the mips code in the class files for next time. -- </em><a href="LukeGorrie.html">LukeGorrie</a><em></em>
      </p>
      <p>
        <strong>See also:</strong> <a href="HotSpot.html">HotSpot</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryJavaPlatform.html">CategoryJavaPlatform</a>
      </p>
    </div>
  </body>
</html>