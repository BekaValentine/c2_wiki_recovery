<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Restricted Programming Language
      </h1>
      <p>
        (Inspired by <a href="ProgrammingIsNotFun.html">ProgrammingIsNotFun</a>)
      </p>
      <p>
        "Restricted programming language" is my term for a language whose designers omit features because they're "too complex" or because some programmers have used them to write bad code.
      </p>
      <p>
        <a href="JavaLanguage.html">JavaLanguage</a> is a restricted <a href="ProgrammingLanguage.html">ProgrammingLanguage</a>. The designers chose to omit <a href="OperatorOverloading.html">OperatorOverloading</a> because they felt that overloading made the compiler and code too complex, and because it's possible for programmers to "abuse" it by, for example, using += to perform a stack push. <a href="CeeSharp.html">CeeSharp</a> supports overloaded operators, which will probably make it more popular than Java. (But, to be fair, Java's restrictions aren't <em>that bad,</em> mainly because Java gives you other features in return, such as garbage collection and generics.)
      </p>
      <p>
        I once used a restricted language which was only used in-house by a <a href="DataProcessing.html">DataProcessing</a> company. The designers purposely left recursion out, because they were worried about programmers accidentally causing <a href="InfiniteRecursion.html">InfiniteRecursion</a>s. All variables were global, because <a href="LocalVariables.html">LocalVariables</a> which appear and disappear as the program runs were thought to be over the heads of some of those looking at the program. This led to major headaches when writing code. (By contrast, in my style of <a href="ForthLanguage.html">ForthLanguage</a> programming, all variables are global, and I tend to avoid RECURSE. <em>(Sounds like a job for LOCALS| or a similar Forth construct.)</em> But at least if I accidentally create a new Forth variable with the same name as an old one, it's created separately, so I can't clobber the old one by mistake. <a href="HyperStaticGlobalEnvironment.html">HyperStaticGlobalEnvironment</a>.)
      </p>
      <p>
        <a href="CobolLanguage.html">CobolLanguage</a> is probably the ultimate restricted language. I say "probably" because I've been fortunate enough to be able to avoid COBOL.
      </p>
      <ul>
        <li>
           Not even close. They didn't intend to leave features out, although by the standards of the 21st century there's a lot missing. But back when it was introduced, it was quite powerful. There were things it was better at than <a href="FortranLanguage.html">FortranLanguage</a>, which was the primary alternative for many people, if they had any choice at all.
        </li>
      </ul>
      <p>
        Obviously not every language can have every feature. <a href="BjarneStroustrup.html">BjarneStroustrup</a> made the conscious decision to leave serialization out of <a href="CeePlusPlus.html">CeePlusPlus</a> because he was afraid it would incur a space overhead on every object, including objects that didn't use serialization. <a href="SchemeLanguage.html">SchemeLanguage</a> is deliberately confined to a small number of special forms because the designers want to avoid the "bloatedness" of <a href="CommonLisp.html">CommonLisp</a>. (Instead, they added a macro facility so you can define your own special forms. See <a href="DefineSyntax.html">DefineSyntax</a>. <em>This sounds like Common Lisp has no such macro facilities, which isn't true.</em>) <a href="ForthLanguage.html">ForthLanguage</a> is constrained in various ways so that it can be easy to implement. Nevertheless, these languages are targeted for programmers, and do not deny features to programmers on the ground that programmers, or others looking at the program code, would be too stupid to understand those features. However, this is, I think, the difference between <em>restrictions</em> and mere <em>limitations</em>: limitations are motivated by the nature of the problems that the language designer is trying to solve; restrictions are set out in advance of designing the language, usually in order to prevent programmers from doing things.
      </p>
      <p>
        When I get saddled with such a <a href="ProgrammingLanguage.html">ProgrammingLanguage</a> I often end up doing what looks like <a href="GoldPlating.html">GoldPlating</a>: my classical <a href="ComputerScience.html">ComputerScience</a> education has caused me to see certain problems in terms of recursion or the use of <a href="LocalVariables.html">LocalVariables</a>, and I can't unsee it, so I find myself doing by hand what I think the language implementation ought to have done. I find myself implementing stacks and storing all my values there. I find myself implementing <a href="ContinuationPassingStyle.html">ContinuationPassingStyle</a>. I find myself writing Forth-like code outside of <a href="ForthLanguage.html">ForthLanguage</a>. In <a href="JavaLanguage.html">JavaLanguage</a>, I find myself copying and pasting code because there are no templates, and using a class and an interface would incur too much overhead [<a href="CopyAndPasteProgramming.html">CopyAndPasteProgramming</a>]. <a href="ComplexityHasToGoSomewhere.html">ComplexityHasToGoSomewhere</a>. The code that gets written is very nearly unmaintainable to other people, <em>unless</em> the maintainer knows or figures out what has been done to produce this contorted code and can follow the process back and forth. Is it too much to hope that some maintainer will have an "<a href="AhHa.html">AhHa</a>" moment with my old code, that suddenly it will become clear to them, and they will start writing all their code like that? I suppose it would be a suitable revenge.
      </p>
      <hr/>
      <p>
        Just to make it clear, it is not a feature of the language or the lack thereof that makes the language "restricted." It's the motivation of the language designers when they chose to include or omit a feature.
      </p>
      <p>
        A restricted programming language is any language whose designers thought that <em>programmers would be too stupid</em> to do X, or refrain from doing Y, and that therefore the language should force them to do X and to refrain from doing Y.
      </p>
      <hr/>
      <p>
        Some people say that what makes a language high-level is what it allows you to do, e.g., higher-level languages allow you to represent more abstract concepts directly in the code.
      </p>
      <p>
        Other people say that what makes a language high-level is what it prohibits you from doing, e.g., if a language allows you to use pointers or do bitwise xor or use SSE instructions then it is not high level, no matter what abstractions it supports.
      </p>
      <p>
        I think the former view is good, while the latter is bad. It is praiseworthy to write a language where one does not <em>have</em> to use pointers (or bitwise xor). It is not praiseworthy to write a language where one is not <em>allowed</em> to use them. (The most common reason to use low-level features is to interoperate with code written in low-level languages. For example, <a href="CeeSharpLanguage.html">CeeSharpLanguage</a> supports "unsafe" code, in part so that, if you cannot use the dot-Net framework to accomplish your goal, you can interoperate with the Windows API, which is a C API.)
      </p>
      <p>
        I would say that language implementors who are out to deny access to features are creating <a href="RestrictedProgrammingLanguage.html">RestrictedProgrammingLanguage</a>s.
      </p>
      <p>
        I suppose an exception has to be made for languages where the program may have been written by untrustworthy people on the other end of the Internet. However, even in those cases, it is possible (albeit slow) to support "pointers" which are trapped inside a virtual machine. (Somebody once wrote a virtual machine in Java which can be used to execute C code, inside Java.)
      </p>
      <hr/>
      <p>
        I found the ultimate in restricted languages.  Take <a href="JavaLanguage.html">JavaLanguage</a> and remove primitive types, arrays, the ability to define classes and methods, and then use it for a web templating language by wrapping every statement in <a href="CaseSensitive.html">CaseSensitive</a> XML [<a href="ExtensibleMarkupLanguage.html">ExtensibleMarkupLanguage</a>] tags.  Some other features (like some equivalent statements crashing, but not the others) are merely bugs, but most of the language is an exercise in trying to make it "easy" and "enterprise-level."
      </p>
      <code>
        <ISPECT>String userLang = getUserPreferredLocale(theUser)</ISPECT><br/>
        <ISPECT>if (userLang==null)<br/>
        <ISPECT>String userLang = i18n.getDefaultLocale()</ISPECT><br/>
        </ISPECT><br/>
      </code>
      <p>
        <em>Egads -- it looks like </em><a href="BasicLanguage.html">BasicLanguage</a> is actually better than something else!<em></em>
      </p>
      <p>
        Sorry, you still have a long way to go before you get to the usability level of <a href="XsltLanguage.html">XsltLanguage</a>.
      </p>
      <hr/>
      <p>
        See <a href="BondageAndDisciplineLanguage.html">BondageAndDisciplineLanguage</a>.
      </p>
      <hr/>
      <p>
        <a href="CategoryProgrammingLanguage.html">CategoryProgrammingLanguage</a>
      </p>
    </div>
  </body>
</html>