<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Super Combinators
      </h1>
      <p>
        A combinator is a <a href="LambdaCalculus.html">LambdaCalculus</a> expression that satisfies the following two conditions:
      </p>
      <ul>
        <li>
           No variable name occurs free in it.
        </li>
        <li>
           No Lambda abstraction may occur inside a function application, i.e. something like <em>(\x.x) f</em> is not allowed.
        </li>
      </ul>
      <p>
        The functions S, K and I as mentioned in <a href="EssAndKayCombinators.html">EssAndKayCombinators</a>, are combinators.
      </p>
      <p>
        Combinators can always be written in a form that looks like this:
      </p>
      <code>
        Y f x = x (f x)<br/>
      </code>
      <p>
        i.e. the right-hand side contains only function application and arguments that have been bound in the left-hand side.
      </p>
      <p>
        It is possible to transform every <a href="LambdaCalculus.html">LambdaCalculus</a> expression (that contains no free variables) into a set of combinator definitions C_1 ... C_n and a single expression containing only applications of C_1 ... C_n.
        The SKI calculus, as described in <a href="EssAndKayCombinators.html">EssAndKayCombinators</a>, is an existential proof: just take C_1 = S, C_2 = I and C_3 = K. But for practical implementation of a <a href="FunctionalProgramming.html">FunctionalProgramming</a> language, a better idea is not to try to get around with a minimal set of combinators, but to find a (possibly large) set of combinators that naturally matches the lambda expression you are trying to evaluate.
      </p>
      <p>
        Such combinators can become a lot bigger than the small S, K and I combinators, therefore they are called <a href="SuperCombinators.html">SuperCombinators</a>.
      </p>
      <p>
        <a href="SuperCombinators.html">SuperCombinators</a> can rather easily be translated into C or assembly language. In this way, a <a href="FunctionalProgramming.html">FunctionalProgramming</a> language can be implemented efficiently.
      </p>
      <p>
        See also very terse overview <a href="http://www.ccs.neu.edu/home/matthias/369-s04/Transcripts/abstract-machines-for-graph-reduction-transcript.html">http://www.ccs.neu.edu/home/matthias/369-s04/Transcripts/abstract-machines-for-graph-reduction-transcript.html</a>
      </p>
      <p>
        Introduced by Turner (1979) and generalized by Hughes (1982):
      </p>
      <p>
        D. A. Turner. A new implementation technique for applicative languages. Software - Practice and Experience, 9:31--49, 1979.
      </p>
      <p>
        Hughes, J. M. (1982), Super-combinators: A new implementation method for applicative languages, in `1982 ACM Symposium on LISP and Functional Programming', Pittsburgh, Pensylvania, pp. 1--10.
      </p>
      <hr/>
      <p>
        <a href="CategoryFunctionalProgramming.html">CategoryFunctionalProgramming</a>
      </p>
      <p>
        See also <a href="FunctionalProgramming.html">FunctionalProgramming</a>, <a href="LambdaCalculus.html">LambdaCalculus</a>
      </p>
    </div>
  </body>
</html>