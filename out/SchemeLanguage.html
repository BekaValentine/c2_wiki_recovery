<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Scheme Language
      </h1>
      <p>
        Lisp done right, according to some. Others prefer <a href="CommonLisp.html">CommonLisp</a>, right at the other end of the oversimplified/baroque - or, if you prefer, elegant/full-featured - axis. Standard Scheme as defined by the <a href="RevisedReportOnAlgorithmicLanguageScheme.html">RevisedReportOnAlgorithmicLanguageScheme</a> is deliberately minimalistic. <a href="SchemeRequestsForImplementation.html">SchemeRequestsForImplementation</a> provide de facto standards for often needed (and often requested) features and extensions, like record types, multi-threading, exception handling and localization.
      </p>
      <p>
        Given its small size and minimalistic nature, some ask <a href="IsSchemeSuitableForDevelopingLargerSystems.html">IsSchemeSuitableForDevelopingLargerSystems</a>?
      </p>
      <p>
        Scheme was originally inspired by <a href="CarlHewitt.html">CarlHewitt</a>'s <a href="ActorsModel.html">ActorsModel</a>. It served as a proof by example that Actors' message-passing model of execution was equivalent to the more common function-call model. <a href="GeraldSussman.html">GeraldSussman</a> and <a href="GuySteele.html">GuySteele</a>, the original creators of Scheme, discovered that when implementing both models, they ended up with identical functions doing the work.
      </p>
      <p>
        In the words of <a href="GuySteele.html">GuySteele</a> (<a href="http://www.dreamsongs.com/ObjectsHaveNotFailedNarr.html):">http://www.dreamsongs.com/ObjectsHaveNotFailedNarr.html):</a> <em>The Scheme programming language was born from an attempt in 1975 to explicate </em><a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a> in terms that <a href="GeraldSussman.html">GeraldSussman</a> and I could understand. In particular, we wanted to restate <a href="CarlHewitt.html">CarlHewitt</a>'s theory of actors in words of one syllable, so to speak. One of the conclusions that we reached was that "object" need not be a primitive notion in a programming language; one can build objects and their behavior from little more than assignable value cells and good old <a href="LambdaExpression.html">LambdaExpression</a>s. Moreover, most of the objects in Hewitt's theory were stateless and unchanging once created; for those, lambda expressions alone were sufficient.<em></em>
      </p>
      <p>
        One outcome of this insight is that standard-compliant <a href="SchemeImplementations.html">SchemeImplementations</a> are required to support <a href="ProperTailCall.html">ProperTailCall</a>s.
      </p>
      <p>
        Scheme is seen by some as the Algol of the <a href="LispFamily.html">LispFamily</a> (see <a href="AlgolLanguage.html">AlgolLanguage</a> and <a href="LanguageFamilies.html">LanguageFamilies</a>), because:
      </p>
      <ul>
        <li>
           It has a considerably less dynamic feel than for example <a href="CommonLisp.html">CommonLisp</a>
        </li>
        <li>
           It introduced <a href="LexicalScoping.html">LexicalScoping</a> into the <a href="LispFamily.html">LispFamily</a> of <a href="ProgrammingLanguage.html">ProgrammingLanguage</a>s, a feature subsequently adopted by <a href="CommonLisp.html">CommonLisp</a> 
        </li>
        <li>
           It's a small language in the same way that Algol 60 was a small language.
        </li>
        <li>
           It lacks the ability to print an s-expression and parse it back in.
        </li>
        <li>
           The compiler operates on text, not s-expressions/forms
        </li>
        <li>
           The single namespace for variables and functions
        </li>
      </ul>
      <p>
        Scheme is used in the books <a href="StructureAndInterpretationOfComputerPrograms.html">StructureAndInterpretationOfComputerPrograms</a>, <a href="EssentialsOfProgrammingLanguages.html">EssentialsOfProgrammingLanguages</a>, <a href="LispInSmallPieces.html">LispInSmallPieces</a>, <a href="HowToDesignPrograms.html">HowToDesignPrograms</a>.
      </p>
      <p>
        <strong>External links</strong>:
      </p>
      <ul>
        <li>
           General information: <a href="http://www.schemers.org/">http://www.schemers.org/</a>
        </li>
        <li>
           <a href="SchemeRequestsForImplementation.html">SchemeRequestsForImplementation</a>, the Scheme library standards system: <a href="http://srfi.schemers.org/">http://srfi.schemers.org/</a>
        </li>
        <li>
           SLIB, a portable Scheme library: <a href="http://swissnet.ai.mit.edu/~jaffer/SLIB.html">http://swissnet.ai.mit.edu/~jaffer/SLIB.html</a>
        </li>
        <li>
           CSAN (Comprehensive Scheme Archive Network): <a href="http://strader.xs4all.nl/csan/index.html">http://strader.xs4all.nl/csan/index.html</a>
        </li>
        <li>
           Meet schemers in your area through <a href="MeetUp.html">MeetUp</a>: <a href="http://scheme.meetup.com">http://scheme.meetup.com</a>
        </li>
        <li>
           Online bibliography of Scheme-related research at <a href="http://library.readscheme.org/">http://library.readscheme.org/</a> (maintained by <a href="JimBender.html">JimBender</a>)
        </li>
        <li>
           Online Scheme Oriented wiki at <a href="http://community.schemewiki.org">http://community.schemewiki.org</a>
        </li>
        <li>
           PLEAC has a partial cookbook for (at least) Guile: <a href="http://pleac.sourceforge.net/">http://pleac.sourceforge.net/</a>
        </li>
        <li>
           <a href="WikiPedia.html">WikiPedia</a>: <a href="http://en.wikipedia.org/wiki/Scheme_programming_language">http://en.wikipedia.org/wiki/Scheme_programming_language</a>
        </li>
        <li>
           <a href="JohnLennon.html">JohnLennon</a>'s "Imagine" song as re-imagined by a Schemer: <a href="http://www.schemers.org/Miscellaneous/imagine.txt">http://www.schemers.org/Miscellaneous/imagine.txt</a>
        </li>
      </ul>
      <hr/>
      <p>
        On getting the code for a procedure:
      </p>
      <p>
        <em>R5RS does not define an external representation for procedure objects and closures, so there is no portable answer. However, depending on the implementation techniques used and the sophistication of its run time system or debugger environment a given Scheme implementation may let you inspect the machine code or </em><a href="ByteCode.html">ByteCode</a> representation and the bindings/environment for a given procedure object.<em></em>
      </p>
      <p>
        Also, it is possible without too much effort to redefine 'define' to store the definitions in a global map, thus making any non-primitive function's source available. With a little 'magic', it's actually quite easy to make an inspector with formatting, versioning, browsing, etc... :)
      </p>
      <hr/>
      <p>
        <em>Moved from LearningScheme</em>
      </p>
      <p>
        An excellent way to learn Scheme (and a lot more besides!) is to read <a href="StructureAndInterpretationOfComputerPrograms.html">StructureAndInterpretationOfComputerPrograms</a>. Reading SICP is not however something you can do in a weekend, so to get a taste you may like to read a <a href="WebSchemeTutorial.html">WebSchemeTutorial</a>. To play around, you'll need an interpreter like <a href="DrScheme.html">DrScheme</a>.
      </p>
      <p>
        If you read a "LISP" tutorial, be mindful that there are many dialects of LISP of which Scheme is one, and while they are similar you will not be able to run (for example) <a href="CommonLisp.html">CommonLisp</a> code in a Scheme interpreter. Generally things that relate to Scheme will say so directly, but if you're in doubt then a good rule of thumb is that names like <em>null?</em>, <em>zero?</em>, <em>define</em> are Schemey, whereas <em>zerop</em>, <em>defun</em>, and <em>setq</em> are more <a href="CommonLisp.html">CommonLisp</a>y.
      </p>
      <p>
        <em>Scheme bears roughly the same relationship to </em><a href="MacLisp.html">MacLisp</a> and <a href="CommonLisp.html">CommonLisp</a> as <a href="JavaLanguage.html">JavaLanguage</a> does to <a href="CeeLanguage.html">CeeLanguage</a> and <a href="CeePlusPlus.html">CeePlusPlus</a> - or to be a bit more accurate, the same relationship <a href="PascalLanguage.html">PascalLanguage</a> has to AlgolSixtyEight and <a href="AdaLanguage.html">AdaLanguage</a>, in that Scheme improved on <a href="MacLisp.html">MacLisp</a> by simplifying and regularizing it, and was designed in the early 1970s by a small group of developers for a specific purpose (testing the relationship between Actors and closures, initially, and later, as a language for teaching), whereas Common Lisp improved on <a href="MacLisp.html">MacLisp</a> by vastly expanding it and modernizing it, and was designed in the late 1970s and early 1980s by a large committee to support large project development across diverse platforms. - <a href="JayOsako.html">JayOsako</a><em></em>
      </p>
      <hr/>
      <p>
        <em>Evaluator in Silicon</em>
      </p>
      <p>
        <img src="http://mitpress.mit.edu/sicp/full-text/book/chip.jpg" />
      </p>
      <hr/>
      <p>
        See <a href="SchemeImplementations.html">SchemeImplementations</a>, <a href="LispSchemeDifferences.html">LispSchemeDifferences</a>, <a href="SchemeMacros.html">SchemeMacros</a>, <a href="SchemeWiki.html">SchemeWiki</a>, <a href="SocialProblemsOfLisp.html">SocialProblemsOfLisp</a>, <a href="CallWithCurrentContinuation.html">CallWithCurrentContinuation</a>, <a href="MitScheme.html">MitScheme</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryProgrammingLanguage.html">CategoryProgrammingLanguage</a> <a href="CategoryScheme.html">CategoryScheme</a>
      </p>
    </div>
  </body>
</html>