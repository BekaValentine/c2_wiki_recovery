<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Csharp Vs Cpp
      </h1>
      <p>
        Within the <a href="MicrosoftDotNet.html">MicrosoftDotNet</a> environment both <a href="CsharpLanguage.html">CsharpLanguage</a> and <a href="CeePlusPlus.html">CeePlusPlus</a> are offered, the latter has <em>With Managed Extensions</em> added to the product name since mid 2003.
      </p>
      <p>
        For comparison between the two, see <a href="http://groups.google.com/groups?th=bb6a628756b1703d">http://groups.google.com/groups?th=bb6a628756b1703d</a> where the second entry of the thread show some impressive capabilities of the latter, namely in <a href="ItJustWorks.html">ItJustWorks</a>, which is very important in <a href="ComInterOp.html">ComInterOp</a> that serves as a bridging technology between <a href="ComponentObjectModel.html">ComponentObjectModel</a> and <a href="DotNet.html">DotNet</a>.
      </p>
      <hr/>
      <p>
        <strong>Advantages of </strong><a href="CeeSharp.html">CeeSharp</a>:<strong></strong>
      </p>
      <ul>
        <li>
           Shorter build times than C++. <em>With CPP, even with modern computers, you wait and wait for the compiler to compile 100 000 lines of code generated by the preprocess for a hello world with #include "windows.h" in  it.</em>
          <ul>
            <li>
               Ever hear of PrecompiledHeaders?
            </li>
            <li>
               Yet if I compiled a hello world with #include "anythingElse.h" it's fine, perhaps the blame is on deciding to include every function definition for every task in one header file that must be included just to get a pushbutton.
            </li>
          </ul>
        </li>
        <li>
           Cross platform, able to deploy on different architectures. (Mono for Linux/Mac, .NET for Windows)
          <ul>
            <li>
               <em>Please clarify. It's usually the libraries that are at issue, not the root language.</em> 
            </li>
            <li>
               [C/C++ itself contains implementation dependencies.  The size of a C# int, for example, is signed 32 bits.  In C/C++ it's sizeof(int), which varies depending on implementation.]
            </li>
            <li>
               {Mono is only a partial implementation. It's implemented the common stuff, but some of the more esoteric items aren't done.}
            </li>
          </ul>
        </li>
        <li>
           Safe exception handling, every "crash" can be safely handled, where C++ just burns to the ground when something goes wrong.
          <ul>
            <li>
               {Heh. Don't they just wish.}
            </li>
          </ul>
        </li>
        <li>
           Large runtime, making otherwise hundred lines of code into a single line on more than one occasion.
        </li>
        <li>
           Windows GUI design is a lot easier than in C++ (MFC/ATL, yuck...)
        </li>
        <li>
           Fairly fast, but not as fast as C++, in general. (some algorithms are better implemented in C# than C++, like the square root function which seems to be faster)
        </li>
      </ul>
      <p>
        <strong>Advantages of </strong><a href="CeePlusPlus.html">CeePlusPlus</a>:<strong></strong>
      </p>
      <ul>
        <li>
           <a href="ResourceAcquisitionIsInitialization.html">ResourceAcquisitionIsInitialization</a> idiom - enables implicit and deterministic resource management for memory AND other system resources (files, windows, locks...).
        </li>
        <li>
           Possibility of usage of processor intrinsics. (SSE/SSE2/MMX)
        </li>
        <li>
           Inline assembly
          <ul>
            <li>
               {Not really a part of c++.}
            </li>
          </ul>
        </li>
        <li>
           Better optimizable; working on native code gives you exactly the instructions that are executed, instead of an intermediate language, making it more comprehendable, and easier to optimize (with IL you can't do a damn thing about the assembly that is generated).
        </li>
        <li>
           Not dependent on a 150 MB runtime (this is in fact my biggest gripe with anything .NET related; why can't they just link in parts from the runtime into the EXE? Same goes for Java)
        </li>
        <li>
           No garbage collector (why is this an advantage? if you want really fast code with no memory overhead at all, you will just use a pool of memory, and never have to think about memory allocation/deallocation again. There are several more reasons, all related to speed and predictability. And if you really do want a garbage collector because you're too lazy to write proper cleanup code, just use some random c++ garbage collector on the web anyways, or for that matter, C++/CLR)
        </li>
        <li>
           Lightweight standard library with a limited set of the most used primitives (vector, set, map, list, hash_map on some implementations..)
        </li>
      </ul>
      <p>
        Something that people don't seem to realize about C++ is that you can implement a lot these fancy language features from other languages in C++.  For example, people complain about having to deal with memory management...not only does STL get rid of the need for allocating memory in many cases, garbage collectors have been written for C++.  The response I usually get to that point is that "that requires additional upfront programming."  Well, yes.  *Someone* has to do the programming (just like *someone* did the programming to get a particular feature into a language).  Does it have to be you?  No, most of the features people want have already been implemented (ever hear of sourceforge?).  
      </p>
      <p>
        Anyway, I realize that there doesn't exist a language that is good for every job.  My point is that C++ is flexible enough and strong enough to achieve most of those jobs with relative ease (and even more ease once it's been done once).
      </p>
      <ul>
        <li>
           <em>And yet, when I nail those </em><a href="ExtraLegsOntoaDog.html">ExtraLegsOntoaDog</a>, it still barks.<em></em>
          <ul>
            <li>
               <em>You probably just need a few more rivets in the beak.</em>
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <p>
        Can we get a list of things one can do in C++, but not in C#, and the other way around?
      </p>
      <p>
        <em>If you mean tasks, then no. Both are </em><a href="TuringComplete.html">TuringComplete</a>. The question is not what can be done, but what is simpler for a given programmer in a given language. Maybe a list of how primary language features compare to each other is what you want?<em></em>
      </p>
      <hr/>
      <p>
        Here's a quick list:
      </p>
      <ul>
        <li>
           Events: <a href="CeeSharp.html">CeeSharp</a> has a first-class-citizen approach to type-safe events, and the events can have multiple listeners. (PublisherSubscriber model)
        </li>
        <li>
           Templates: <a href="CeeSharp.html">CeeSharp</a> 2.0 has Generics, which look a lot like templates with some extra type-safety (parameter X must be constructable, parameter Y implements virtual-base IThisInterface, etc). <a href="MicroSoft.html">MicroSoft</a> <a href="CeePlusPlus.html">CeePlusPlus</a> <a href="DotNet.html">DotNet</a> does both <a href="CeePlusPlus.html">CeePlusPlus</a> Templates *and* Generics, which must cause some confusion.
        </li>
        <li>
           <a href="ObjectOriented.html">ObjectOriented</a>: Although <a href="CeePlusPlus.html">CeePlusPlus</a> supports the ObjectOrientedParadigm, you don't have to use it. Everything in <a href="CeeSharp.html">CeeSharp</a> is an object.
          <ul>
            <li>
               Some people might consider the former an advantage - <a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a> in the same language.
            </li>
          </ul>
        </li>
      </ul>
      <p>
        - <a href="JamesWilkinson.html">JamesWilkinson</a>
      </p>
      <hr/>
      <p>
        See <a href="LanguagePissingMatch.html">LanguagePissingMatch</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryProgrammingLanguageComparisons.html">CategoryProgrammingLanguageComparisons</a>, <a href="CategoryCeeSharp.html">CategoryCeeSharp</a>, <a href="CategoryCpp.html">CategoryCpp</a>
      </p>
    </div>
  </body>
</html>