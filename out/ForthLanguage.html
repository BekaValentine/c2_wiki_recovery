<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Forth Language
      </h1>
      <p>
        <strong>Local Wiki Resources:</strong>
      </p>
      <ul>
        <li>
           <a href="StartingForth.html">StartingForth</a>: The classic Forth and programming tutorial by <a href="LeoBrodie.html">LeoBrodie</a>
        </li>
        <li>
           <a href="ThinkingForth.html">ThinkingForth</a>: The classic Forth book by <a href="LeoBrodie.html">LeoBrodie</a>
        </li>
        <li>
           <a href="ExampleForthCode.html">ExampleForthCode</a>: A few simple examples of FORTH code, to give you a minimal feel for it.
        </li>
        <li>
           <a href="ChuckMoore.html">ChuckMoore</a>: The inventor of Forth, <a href="ColorForth.html">ColorForth</a>, and ForthProcessors
        </li>
        <li>
           <a href="ForthValues.html">ForthValues</a>: Core values of Forth from 1970 to 1999
        </li>
        <li>
           <a href="ForthSimplicity.html">ForthSimplicity</a>: Explains the extreme simplicity of Forth
        </li>
        <li>
           <a href="ForthReadability.html">ForthReadability</a>: Shows how easily one can read each other's code
        </li>
        <li>
           <a href="ForthEfficiency.html">ForthEfficiency</a>: Examples of Forth's efficient use of resources
        </li>
        <li>
           <a href="ForthReusability.html">ForthReusability</a>: Shows how effective code sharing can be
        </li>
        <li>
           <a href="ForthPortability.html">ForthPortability</a>: Proves how easily you can move your code from one platform to the next
        </li>
        <li>
           <a href="ForthObjects.html">ForthObjects</a>: Object-Orientation in Forth, with a sample implementation (see also <a href="MopsLanguage.html">MopsLanguage</a> and <a href="NeonLanguage.html">NeonLanguage</a>)
        </li>
        <li>
           <a href="ForthScientificLibrary.html">ForthScientificLibrary</a>: Scientific and mathematical abstractions
        </li>
        <li>
           <a href="ForthInSmalltalk.html">ForthInSmalltalk</a>: <a href="WardCunningham.html">WardCunningham</a> relates an educational experience with his brother
        </li>
        <li>
           <a href="SmalltalkInForth.html">SmalltalkInForth</a>: Attempting to implement Smalltalk in Forth
        </li>
        <li>
           <a href="ForthInJava.html">ForthInJava</a>: ... rumors of Forth running on top of the <a href="JavaVirtualMachine.html">JavaVirtualMachine</a> ...
        </li>
        <li>
           <a href="PostScript.html">PostScript</a>: A closely related language that is optimized for printing (see <a href="ForthPostscriptRelationship.html">ForthPostscriptRelationship</a>)
        </li>
        <li>
           <a href="ForthCommunity.html">ForthCommunity</a>: the users of Forth
        </li>
        <li>
           <a href="ForthWikiProjects.html">ForthWikiProjects</a>: <a href="ForthWiki.html">ForthWiki</a> originated projects covering a range as wide as their contributor's horizons
        </li>
        <li>
           <a href="ForthVsLisp.html">ForthVsLisp</a>: A comparison of the two languages.
        </li>
        <li>
           <a href="ForthMacro.html">ForthMacro</a>: Extending the language.
        </li>
        <li>
           <a href="AnsForth.html">AnsForth</a>: the 1994 ANSI standard for Forth to which most modern systems comply
        </li>
        <li>
           <a href="OpenFirmware.html">OpenFirmware</a>: A Forth system built into the firmware of every Sun and Apple computer, as well as many servers from IBM.
        </li>
        <li>
           <a href="FiclLanguage.html">FiclLanguage</a>: Forth as an <a href="EmbeddedLanguage.html">EmbeddedLanguage</a>
        </li>
        <li>
           <a href="JoyLanguage.html">JoyLanguage</a>: a post-fix <a href="FunctionalProgrammingLanguage.html">FunctionalProgrammingLanguage</a>
        </li>
        <li>
           <a href="FactorLanguage.html">FactorLanguage</a>: another PostFix language borrowing ideas from <a href="CommonLisp.html">CommonLisp</a> and Forth
        </li>
        <li>
           <a href="ForthInLua.html">ForthInLua</a>: Forth is implemented in <a href="LuaLanguage.html">LuaLanguage</a>
        </li>
      </ul>
      <p>
        <strong>Getting Started With Forth:</strong>
      </p>
      <dl>
        <dt><a href="StartingForth.html">StartingForth</a></dt>
        <dd><a href="LeoBrodie.html">LeoBrodie</a>'s classic Forth and programming tutorial. Now with modernized online versions.</dd>
      </dl>
      <code>
        <a href="http://www.sunterr.demon.co.uk/guide.htm">http://www.sunterr.demon.co.uk/guide.htm</a> :	Guide to getting started with Win32Forth (includes download locations and introductory tutorials)<br/>
        <a href="http://www.geocities.com/dolphinconsultant/myforth.html">http://www.geocities.com/dolphinconsultant/myforth.html</a> :	Forth in Java (This page includes eForth implemented as a Java applet, allowing any Java-enabled browser to try Forth interactively. (Java source (160K) is also included))<br/>
      </code>
      <dl>
        <dt><a href="JsForth.html">JsForth</a> </dt>
        <dd>Forth in <a href="JavaScript.html">JavaScript</a>, running in a web browser window</dd>
      </dl>
      <code>
        <a href="http://wiki.forthfreak.net/index.cgi?ForthTutorials">http://wiki.forthfreak.net/index.cgi?ForthTutorials</a> :	online tutorials<br/>
      </code>
      <p>
        <strong>Discussing Forth with others:</strong> IRC and other Forth-related wiki: (<a href="EditHint.html">EditHint</a>: move to <a href="ForthWiki.html">ForthWiki</a> ?)
      </p>
      <code>
        <a href="news:comp.lang.forth">news:comp.lang.forth</a> :	The <a href="UseNet.html">UseNet</a> newsgroup for Forth.<br/>
        <a href="http://wiki.forthfreak.net/">http://wiki.forthfreak.net/</a> :	Forthfreak - a Forth-specific wiki with an inventory of many Forth resources<br/>
      </code>
      <dl>
        <dt>SleeplessNightWiki </dt>
        <dd>a wiki focused on <a href="QuartusForth.html">QuartusForth</a>, but with many general purpose pages as well</dd>
      </dl>
      <dl>
        <dt>#forth@irc.freenode.net (openprojects is now freenode)</dt>
        <dd>Introduction to irc at <a href="http://www.mirc.com/irc.html">http://www.mirc.com/irc.html</a></dd>
      </dl>
      <code>
        <a href="http://wiki.enst.fr/bin/view/Picforth/">http://wiki.enst.fr/bin/view/Picforth/</a> :	PicForth - a wiki focused on PicForth, which runs on those little under-$8 PIC microprocessors with ~8K words of program memory and a few hundred bytes of RAM ... unfortunately, not (yet) interactive. <em>Is there something similar for the Atmel AVR? -- </em><a href="DavidCary.html">DavidCary</a><em></em><br/>
      </code>
      <ul>
        <li>
           There is a free system called AVR-Byte Forth by Willem Ouwerkerk, but I don't have an address. Also see <a href="http://www.tinyboot.com/avr.html.">http://www.tinyboot.com/avr.html.</a> And both <a href="ForthInc.html">ForthInc</a> and MPE have commercial AVR compilers and dev systems, including free eval systems. -- <a href="IanOsgood.html">IanOsgood</a>
        </li>
      </ul>
      <code>
        <a href="http://annexia.org/forth">http://annexia.org/forth</a> :	JonesForth - A concise, wonderfully well-commented Forth implementation in assembly. Reads like a novel.<br/>
        <a href="http://www.forthwiki.com">http://www.forthwiki.com</a> :	Much more than just a wiki. FAQs, Forums, Articles, Blogs, Links and more.<br/>
      </code>
      <p>
        <strong>Other Internet Resources:</strong>
      </p>
      <code>
        <a href="http://www.forth.com/resources/evolution/index.html">http://www.forth.com/resources/evolution/index.html</a> :	A full history of Forth<br/>
        <a href="http://www.taygeta.com/forth.html">http://www.taygeta.com/forth.html</a> :	The Taygeta archive of Forth resources<br/>
        <a href="http://www.forth.com/">http://www.forth.com/</a> :	(Forth, Inc.) <a href="ForthInc.html">ForthInc</a> was the first company to sell Forth products, and was founded by the inventors of Forth.<br/>
        <a href="http://www.ultratechnology.com/">http://www.ultratechnology.com/</a> :	Recent work on hardware Forths, includes recent talks by Charles Moore<br/>
        <a href="http://www.forth.org/fig.html">http://www.forth.org/fig.html</a> :	The Forth Interest Group<br/>
        <a href="http://dec.bournemouth.ac.uk/forth/index.html">http://dec.bournemouth.ac.uk/forth/index.html</a> :	The Forth Research Page<br/>
        <a href="http://www.zetetics.com/bj/papers/">http://www.zetetics.com/bj/papers/</a> :	Good papers on Forth implementation<br/>
        <a href="http://forth.gsfc.nasa.gov/">http://forth.gsfc.nasa.gov/</a> :	Lists over 50 space-related uses of Forth<br/>
        <a href="http://dmoz.org/Computers/Programming/Languages/Forth/">http://dmoz.org/Computers/Programming/Languages/Forth/</a> :	The <a href="OpenDirectoryProject.html">OpenDirectoryProject</a> listing for Forth<br/>
        <a href="http://dir.yahoo.com/Computers_and_Internet/Programming_Languages/Forth/">http://dir.yahoo.com/Computers_and_Internet/Programming_Languages/Forth/</a> :	The Yahoo listing for Forth<br/>
        <a href="http://www.zforth.com/">http://www.zforth.com/</a> :	The Forth Programming Webring<br/>
        <a href="http://www.fig-uk.org/byof.htm">http://www.fig-uk.org/byof.htm</a> :	How to implement your own Forth<br/>
        <a href="http://www.quartus.net/products/forth/">http://www.quartus.net/products/forth/</a> :	<a href="QuartusForth.html">QuartusForth</a> for the Palm - A whole development system self-contained on a Palm<br/>
        <a href="http://www2.tunes.org/cgi-bin/TunesWiki?ForthOS">http://www2.tunes.org/cgi-bin/TunesWiki?ForthOS</a> :	Forth as OS<br/>
        <a href="http://ftp.uni-bremen.de/pub/mirrors/Taygeta-Archive/">http://ftp.uni-bremen.de/pub/mirrors/Taygeta-Archive/</a> :	<a href="UniversityOfBremen.html">UniversityOfBremen</a> Ftp Site<br/>
        <a href="http://home.vrweb.de/~stephan.becher/forth/">http://home.vrweb.de/~stephan.becher/forth/</a> :	StrongForth, a Forth dialect with strong type checking<br/>
        <a href="http://rainbowforth.sourceforge.net/">http://rainbowforth.sourceforge.net/</a> :	An AJAX-y implementation of <a href="ColorForth.html">ColorForth</a> called Rainbow Forth.<br/>
      </code>
      <hr/>
      <p>
        <strong>How did Forth get its name?</strong>
      </p>
      <code>
        Charles Moore::	<em>The first time I combined the ideas I had been developing into a single entity, I was working on an IBM 1130, a "third-generation" computer. The result seemed so powerful that I considered it a "fourth generation computer language." I would have called it Fourth, except that the 1130 permitted only five-character identifiers. So Fourth became Forth, a nicer play on words anyway.</em><br/>
      </code>
      <hr/>
      <p>
        Forth is a <a href="StackBasedLanguage.html">StackBasedLanguage</a> based on <a href="PostfixNotation.html">PostfixNotation</a>: Operations and function calls are placed <strong>after</strong> their arguments. They work by popping the arguments off the data stack, performing their operation, and then pushing the results back on the data stack.
      </p>
      <p>
        FORTH is often used in <a href="EmbeddedSystem.html">EmbeddedSystem</a>s:
      </p>
      <ul>
        <li>
           It packs <strong>LOTS</strong> of functionality into limited memory.
        </li>
        <li>
           Code (and much data) is ROM-able.
        </li>
        <li>
           Is a "<a href="HighLevelLanguage.html">HighLevelLanguage</a>" that encourages highly modular code. (OO in later releases.) (See <strong></strong><a href="HighLevelLanguage.html">HighLevelLanguage</a><strong> below)</strong>
        </li>
        <li>
           Can be interpreted at high speed (approaching that of machine code). Think "interactive hardware debugging".
        </li>
        <li>
           Easily compiled to machine code (but this is not usually done in most free implementations; only professional ones like <a href="ForthInc.html">ForthInc</a>, MPE, and <a href="QuartusForth.html">QuartusForth</a>).
        </li>
        <li>
           Integrated access to assembly language.
        </li>
        <li>
           Is "fully and easily extensible." (Only a few low-level routines of the runtime are <strong>not</strong> written in FORTH.)
        </li>
      </ul>
      <p>
        The boot monitor on <a href="SunMicrosystems.html">SunMicrosystems</a> workstations includes a very useful <a href="ForthLanguage.html">ForthLanguage</a> interpreter (<a href="OpenFirmware.html">OpenFirmware</a>). <a href="HoursOfFun.html">HoursOfFun</a>. <em>(The "stars" sample code at </em><a href="ExampleForthCode.html">ExampleForthCode</a> works at the "ok" boot prompt of any Sun workstation.)<em></em>
      </p>
      <p>
        In the 80s, Forth was also commonly used by astronomers (and their grad students!) to program the control systems of telescopes and other instruments. I don't have recent data to know if this is still the case.
      </p>
      <p>
        Originally, Forth was a <a href="ThreadedInterpretiveLanguage.html">ThreadedInterpretiveLanguage</a>. Among the variations used:
      </p>
      <ul>
        <li>
           <a href="IndirectThreadedCode.html">IndirectThreadedCode</a>
        </li>
        <li>
           <a href="DirectThreadedCode.html">DirectThreadedCode</a>
        </li>
        <li>
           <a href="TokenThreadedCode.html">TokenThreadedCode</a>
        </li>
        <li>
           <a href="SubroutineThreadedCode.html">SubroutineThreadedCode</a>
        </li>
      </ul>
      <p>
        These are fast, easy to implement, and allow very compact object code. Modern professional Forth implementations do optimized compilation.
      </p>
      <hr/>
      <p>
        <strong>"</strong><a href="HighLevelLanguage.html">HighLevelLanguage</a>" ...<strong></strong>
      </p>
      <p>
        FORTH is a "<a href="HighLevelLanguage.html">HighLevelLanguage</a>" that encourages highly modular code. (OO in later releases.) (<em>About the same level of abstraction as C?</em>)
      </p>
      <p>
        <em>(Realize that "higher level" is not always a good thing, as the most "high level" of languages are always specialized for particular domains, and work poorly in other domains.)</em>
      </p>
      <p>
        To address the question, I'd say that FORTH is slightly "lower level" than C. Knowing the workings of the interpreter, and manipulation of the virtual machine state are typical of FORTH programming. And the ease of transition in and out of assembly language also contributes to this conclusion.
      </p>
      <p>
        On the other hand, FORTH programs tend to be <strong>highly</strong> modular, leading to a programming style that's a bit less procedural than typical C functions.
      </p>
      <p>
        <em>(I'm probably talking beyond my experience, which is minimal, and was quite a few years ago.)</em> -- <a href="JeffGrigg.html">JeffGrigg</a>
      </p>
      <p>
        Yes, you can do assembly in C, but when's the last time you saw someone do it?
      </p>
      <p>
        ^-- uh, yesterday?
      </p>
      <p>
        <em>I've seen it in the low-level primitives, where, to be honest, it's more of a syntactic convenience than something fundamental. That is, doing assembly in FORTH makes it so that you don't have to use a separate compiler/assembler and have separate source files.</em>
      </p>
      <p>
        In Forth, you can define a word that has a different effect on the stack depending on the parameters passed to it via the stack. e.g. If it's Tuesday, put an integer on the stack, otherwise, take one off. <em>(This is allowed, but not encouraged.)</em> There are lots of other languages where any such effect would always be classed as a bug, which would suggest that Forth users commonly encounter what might be called "stack effect bugs." It would settle this little discussion if we could say that C doesn't have this problem, but of course, in C, there is printf, which is the first thing you see when you read an introductory book about C, and which is an absolute black hole for exactly the same kind of bugs. Ain't the world crazy? -- <a href="DanielEarwicker.html">DanielEarwicker</a>.
      </p>
      <p>
        <em>I read in the NASM documentation (</em><a href="NetWideAssembler.html">NetWideAssembler</a>) that in the C calling convention, the caller allocates space on the stack for the parameters and the <em>caller</em> cleans it up as well. Thus, printf can mess itself up, but if it can find its return address on the stack, the program as a whole should recover. I'm not sure I can say the same for scanf: you can trick it into overwriting its return address.<em></em>
      </p>
      <p>
        <em>Someone once said that the difference between a high-level language and a low-level language is that, in the lower level languages, you have to worry about the irrelevant. For example, in assembly languages, you have to handle the mechanics of register allocation and parameter-passing yourself. In C, you have to handle pointers. In C++, you still have to handle pointers. In a high-level language, such matters are handled for you.</em>
      </p>
      <p>
        <em>Forth is a low-level language when you start, because it doesn't come with a large vocabulary of ready-made words for every application. But you can define words to make Forth run at as high a level as you want it to. You can transparently redefine any word Forth already comes with, and you can even hide the stack if you want to write your own parser </em>(see <a href="ForthMacro.html">ForthMacro</a>)<em>. Because Forth doesn't impose a syntax of its own, this is cleaner than if you want to do something similar in C or C++ or Java.</em> -- <a href="EdwardKiser.html">EdwardKiser</a> (occasional Forth dabbler)
      </p>
      <p>
        I think Forth is best described as a <a href="MetaLanguage.html">MetaLanguage</a> or a <a href="MetaProgramming.html">MetaProgramming</a> language: it is a general-purpose language used to define <a href="DomainSpecificLanguage.html">DomainSpecificLanguage</a>s or application-specific languages. This is very powerful, but is also easily misused. -- <a href="KrisJohnson.html">KrisJohnson</a>
      </p>
      <p>
        Another word I've heard used in the attempt to describe this "both-high-low-level" aspect is "ProtoLanguage." It "becomes" the language you need for the domain or application. -- <a href="GarryHamilton.html">GarryHamilton</a>
      </p>
      <p>
        <em>How often does such metaprogramming actually happen to the degree that a truly "higher level" language gets written on top of forth instead of simply composed of words that more or less use the existing control structures?</em>
      </p>
      <p>
        This depends on your experience level with Forth. If you're using Forth after a lifetime of C(++), you'll tend to write code that is structured very much like C. You'll run into constant problems doing this, what with massive stack imbalance bugs due to losing track of what is and isn't on the stack, etc. After some time with it, <em>and</em> if you haven't given up in disgust, you'll eventually come to realize that Forth encourages not so much abstraction, but rather conversation. The abstraction comes as a side-effect of <em>conversing</em> with your computer. Hence Forth's emphasis on <em>words</em> rather than <em>functions.</em>
      </p>
      <p>
        For example, in C, if you want to write a program that prints a number in a variety of bases, you'd probably either have one function per base, or you'd pass the base as a parameter. In Forth, you simply "tell" it what base to print with. For example:
      </p>
      <p>
        In C:
      </p>
      <code>
        void print_inBase_(int aNumber, base b) {<br/>
        switch(b) {<br/>
      </code>
      <dl>
        <dt>case B_DEC</dt>
        <dd>printf("%d", aNumber); break;</dd>
      </dl>
      <dl>
        <dt>case B_HEX</dt>
        <dd>printf("%X", aNumber); break;</dd>
      </dl>
      <code>
        ...etc...<br/>
        }<br/>
        }<br/>
      </code>
      <code>
        ...<br/>
      </code>
      <code>
        {<br/>
        print_inBase_(0xDEADBEEF, B_DEC);<br/>
        print_inBase_(55, B_HEX);<br/>
        }<br/>
      </code>
      <p>
        In Forth:
      </p>
      <code>
        $DEADBEEF hex print 55 decimal print<br/>
      </code>
      <p>
        Now, seeing how this works in Forth, some might realize, "Oh, hey, this rules!" and attempt to implement C-coding this way too. I don't recommend this, because dealing with thread-local storage is often quite painful. However, this makes <em>perfect</em> sense for <em>objects</em> to do, and in fact, is already done -- viva fseek(), ioctl(), and many others. So, assuming you create a "printer object" of sorts, you could write your C client code better, this way:
      </p>
      <code>
        {<br/>
        print(inDecimal(p), 0xDEADBEEF);<br/>
        print(inHex(p), 55);<br/>
        }<br/>
      </code>
      <p>
        The key to making this work is that inDecimal()/inHex() obviously must return p itself, so that its print function can work! For this reason, it is <strong>not</strong> a coincidence that the default return value in Smalltalk is <strong>self</strong>.
      </p>
      <p>
        BTW, since printing numbers was such a common task for Chuck when he implemented his code for NRAO, he provided a short-cut word to do the deed: dot (literally typed as ".").
      </p>
      <code>
        $DEADBEEF hex . 55 decimal .<br/>
      </code>
      <p>
        This results in a program that has a fair number of module-scoped variables, and if your Forth supports multitasking, user-variables as well (think thread-local storage). Interestingly, because of the conversational manner in which you program, <em>saving</em> and <em>restoring</em> these variables often doesn't occur, particularly if they're user-variables. Sometimes you need to, but it tends to be relatively rare.
      </p>
      <p>
        For example, when programming graphics words for Forth, it is rare in Forth to see individual words take more than 2 or 3 parameters on the stack. So, to draw a box with some text in it, given some coordinates (L,T) (left, top of the box), we might see something like, oh, I dunno, this:
      </p>
      <ol>
        <li>
          variable text
        </li>
      </ol>
      <code>
        : ok	S"	OK  " text 2! ;<br/>
        : cancel	s" CANCEL" text 2! ;<br/>
        : top	2dup at over 64 + over horiz line ;				<em>Note that top, bottom, left, and right are "private" words,</em><br/>
        : bottom	( same as top but 12 pixels lower ) 12 + top 12 - ;		<em>in that after they're used in </em>'rect<em>', they may be safely</em><br/>
        : left	2dup at 2dup 12 + vert line ;					<em>redefined for other purposes later on in the program.</em><br/>
        : right	( same as left, 64 pixels over ) over 64 + over left 2drop ;	<em>See </em><a href="HyperStaticGlobalEnvironment.html">HyperStaticGlobalEnvironment</a><em></em><br/>
        : rect	top bottom left right ;<br/>
        : text	2 + swap 10 + swap at text 2@ type ;<br/>
        : button	rect text ;<br/>
      </code>
      <p>
        So, we'd probably use it something like this:
      </p>
      <code>
        ( draw our dialog box here )<br/>
        ...<br/>
      </code>
      <ol>
        <li>
           200 green color ok button	300 200 red color cancel button
        </li>
      </ol>
      <p>
        This style of programming meshes very well with <a href="ImmediateModeGui.html">ImmediateModeGui</a>s as well. Some other folks will see obvious parallels with the <a href="ParameterObject.html">ParameterObject</a> pattern.
      </p>
      <p>
        <em>It seems to me that unlike with a stack-based VM that another language like Java or Python sits on, all significant Forth programs are written by folks who are not only comfortable with, but prefer Forth's lack of syntax and RPN conventions. It's like scheme and lisp macros: with the exception of the mini-language of LOOP, every lisp macro tends to keep strictly to sexp notation and even evaluation order, despite the power of macros to truly extend syntax.</em>
      </p>
      <p>
        Correct. It is possible to define infix-style languages in Forth, just like in Lisp. However, it is rarely performed, because again, there is no <em>need</em> to. Once you work with Forth for a while, you become familiar enough with the language to get by on your own without having the need for translators. A little while further, and you become fluent in it. Further still, it supplants your previous mode of thought in programming, and suddenly, everybody else suffers from <a href="BlubParadox.html">BlubParadox</a>.
      </p>
      <p>
        <em>Not so much a negative criticism of forth (or lisp or scheme), but an observation that extensibility of a language tends to be used in very incremental ways, while those looking for radically new constructs tend to choose a different language entirely regardless of the expressive power of the macro suite.</em>
      </p>
      <p>
        Very interesting observation, indeed!
      </p>
      <p>
        <em>Possibly because all library code is still written in the "base" language</em>
      </p>
      <p>
        Well, at some point, <em>something</em> has to be written <em>in</em> the base language in order to provide higher-level services. If languages like <a href="CeeLanguage.html">CeeLanguage</a> has taught us anything, it's that libraries can provide a large number of services formerly thought to only be renderable portably in the language itself. <a href="CeeLanguage.html">CeeLanguage</a> demolished the ubiquity of <a href="PascalLanguage.html">PascalLanguage</a> and <a href="PliLanguage.html">PliLanguage</a> for that reason. -- SamuelFalvo
      </p>
      <hr/>
      <p>
        Food for thought: Could Forth be translated "on the fly" to a more "conventional" looking form? Perhaps stack annotations can help with functions... Forth might be a good base for an <a href="IntentionalProgramming.html">IntentionalProgramming</a> system then?
      </p>
      <p>
        <em>Hmm...translating Forth amounts to decompiling, which is in general difficult; what would you want the "conventional" form to be? I'm not sure I get your idea about a base for </em><a href="IntentionalProgramming.html">IntentionalProgramming</a>, possibly because I don't know the subject well enough.<em></em>
      </p>
      <ul>
        <li>
          many Forths come with a decompiler built right in. :-)  here is an example from GForth:
        </li>
      </ul>
      <p>
        see !
        Code !
        ( $402A4C )  mov     dword ptr 4168E0 , ebx  \ $89 $1D $E0 $68 $41 $0
        ( $402A52 )  mov     edx , dword ptr 4 [esi]  \ $8B $56 $4
        ( $402A55 )  mov     eax , dword ptr [esi]  \ $8B $6
        ( $402A57 )  add     esi , # 8  \ $83 $C6 $8
        ( $402A5A )  mov     dword ptr [eax] , edx  \ $89 $10
        ( $402A5C )  add     ebx , # 4  \ $83 $C3 $4
        ( $402A5F )  jmp     dword ptr FC [ebx]  \ $FF $63 $FC
        ( $402A62 )  mov     esi , esi  \ $89 $F6
        end-code
      </p>
      <code>
        ok<br/>
      </code>
      <p>
        ---
        A better fit would be Forth used as the virtual machine for a another language. So "conventional" language compiles to Forth, Forth executes program.
      </p>
      <p>
        <a href="MetaProgramming.html">MetaProgramming</a> is used in many Forth applications and libraries to better match the domain language. For example, the Forth Scientific Library, which uses <a href="ForthMacro.html">ForthMacro</a>s to allow infix mathematical expressions, and more convenient use of vectors and matricies. There are also <a href="ForthMacro.html">ForthMacro</a> libraries that allow you to define state machines by simply laying out the tables of state transitions.
      </p>
      <hr/>
      <p>
        My first lesson in factoring functions came from FORTH. Because FORTH doesn't usually use many (or any) variables (accessing data mainly on the stack), large FORTH routines (called <em>words</em>) are extremely hard to read. Readable FORTH depends strongly on small, <em>well named</em> words. When you finally get the right mix of words that work together, there is an "Ah-HA" feeling that says "This is right!". Reading Martin Fowler's <em>Refactoring</em> book can bring that same kind of feeling. -- <a href="JimWeirich.html">JimWeirich</a>
      </p>
      <p>
        I think you meant to say, Forth functions don't use named parameters. Inside the body of a C function, named parameters act just like local variables. -- <a href="DavidCary.html">DavidCary</a>
      </p>
      <p>
        <em>Actually, Forth does support variables, like this:</em>
      </p>
      <code>
        VARIABLE BWAHAHA \ create an uninitialized variable called BWAHAHA, one cell in size<br/>
      </code>
      <ol>
        <li>
           BWAHAHA ! \ store 1000 in it (1000 in the current base is... 1000)
        </li>
      </ol>
      <code>
        BWAHAHA @ . \ --> prints 1000<br/>
      </code>
      <p>
        <em>For a while I developed an over-fondness for a word called LOCALS| which allows you to create local variables inside a word. LOCALS| is very bad for you because you can't easily factor a word which uses it.</em>
      </p>
      <code>
        : HYPOT_SQ ( a b -- c ) \ define a word called HYPOT_SQ<br/>
        LOCALS| b a |	\ pops two parameters into local variables: first pops b, then pops a<br/>
        a a * b b * +	\ calculate sum of squares<br/>
      </code>
      <ol>
        <li>
           TO a	\ you can store in your locals (here I'm just wasting CPU to prove it)
        </li>
      </ol>
      <code>
        ;		\ semicolon automatically cleans up the locals<br/>
      </code>
      <ol>
        <li>
           4 HYPOT_SQ . \ --> prints 25
        </li>
      </ol>
      <p>
        <em>However, there is this thing called VALUE which is like a cross between LOCALS| and VARIABLE. However, I should clarify that these VALUEs are not the least bit local, so their use is non-reentrant. The locals really are local.</em>
      </p>
      <ol>
        <li>
           VALUE a \ create a VALUE called a, initially 0
        </li>
        <li>
           VALUE b \ create a VALUE called b, initially 0
        </li>
      </ol>
      <code>
        : HYPOT_SQ ( a b -- c )<br/>
        TO b	\ pop stack and store it in b<br/>
        TO a	\ pop stack and store it in a<br/>
        a a * b b * +	\ calculate sum of squares, which is left on stack<br/>
        ;<br/>
      </code>
      <ol>
        <li>
           4 HYPOT_SQ . \ --> prints 25
        </li>
      </ol>
      <code>
        a . \ --> prints 3 because a still contains it<br/>
      </code>
      <p>
        Have you read about LOCALS| at <a href="http://www.complang.tuwien.ac.at/forth/faq/faq-general-4.html#ss4.4?">http://www.complang.tuwien.ac.at/forth/faq/faq-general-4.html#ss4.4?</a> It recommends syntax more like
      </p>
      <code>
        : HYPOT_SQ { a b -- c } \ define a word called HYPOT_SQ<br/>
        \  and pops two parameters into local variables<br/>
        a a * b b * +	\ calculate sum of squares<br/>
      </code>
      <ol>
        <li>
           TO a	\ you can store in your locals (here I'm just wasting CPU to prove it)
        </li>
      </ol>
      <code>
        ;		\ semicolon automatically cleans up the locals<br/>
      </code>
      <p>
        <em>Of course for such a simple function I would probably just write</em>
      </p>
      <code>
        : SQ ( a -- b ) DUP * ;<br/>
        : HYPOT_SQ ( a b -- c ) SQ SWAP SQ + ;<br/>
      </code>
      <p>
        <em>but I wanted to illustrate the options you have. If you want to write something moderately complicated in Forth like a </em><a href="MergeSort.html">MergeSort</a> then you will need to use a VARIABLE or VALUE or two; the stack will quickly grow too complicated to handle otherwise.<em></em>
      </p>
      <p>
        <em>If a word uses variables or values you can factor it. -- </em><a href="EdwardKiser.html">EdwardKiser</a> (much more experienced now)<em></em>
      </p>
      <p>
        Generally great advice, <em>but,</em> not necessarily always a good thing to be taken to extremes. You can write <a href="SpaghettiCode.html">SpaghettiCode</a> with factored Forth words as you can anything else. At some point, you'll find that you're factoring so much that your complexity grows out of control. As <a href="ChuckMoore.html">ChuckMoore</a> states over and over again, <em>never</em> put more than 3 values on the stack at any one time in any given context (however, if there are 186291 values already on the stack, that's OK, you don't need to worry about those; your call<em>ing</em> words will deal with those somehow). BTW, that patterns like <a href="ParameterObject.html">ParameterObject</a> exist suggests clearly that this principle applies broadly, not specifically just to Forth.
      </p>
      <hr/>
      <p>
        For my <em>controversial statement of the day,</em> I'll say... <strong>Some people say that FORTH is a "dead language."</strong> While it was once very popular in embedded systems, the availability of MS-DOS/Windows C/C++ development tools for cross-development to more powerful embedded platforms has caused a number of people to switch to C/C++. If SUN has its way, Java will take the field. (...and I'm inclined to think that they will.) -- <a href="JeffGrigg.html">JeffGrigg</a>
      </p>
      <p>
        ForthLanguageAsDevelopmentTool describes how Forth as an extendable language grows until it models the structure of the target domain of the problem to be solved.
      </p>
      <p>
        <a href="FrankCarver.html">FrankCarver</a> asked if Java is "too big" for <a href="EmbeddedJava.html">EmbeddedJava</a> memory limited implementations.
      </p>
      <p>
        -- <a href="AnonymousDonor.html">AnonymousDonor</a>-s
      </p>
      <p>
        Anyone who says "<a href="ForthIsDead.html">ForthIsDead</a>", obviously doesn't know Forth.
        -- <a href="BillZimmerly.html">BillZimmerly</a>
      </p>
      <p>
        <em>Forth is not widely used, but its influence is bigger than its user base. To misquote Larry Wall, a </em>real<em> programmer can write Forth code in any language. I've written more Forth-like code in Java and C++ than I have in Forth!</em> -- <a href="EdwardKiser.html">EdwardKiser</a> (Note: my volume of Forth code has since caught up.)
      </p>
      <hr/>
      <p>
        The first language publicly available to program the original 128K Mac was MacForth [<a href="http://www.macforth.com/],">http://www.macforth.com/],</a> from CSI (Creative Solutions, Inc) in Rockville MD. (Mac development was then done on a Lisa.) MacForth was introduced in 2/84, before even the ring binder version of Inside Mac was available. (The one before the phonebook edition.) I wish I could remember the name of the implementor (great at forth, great as a hardware designer) to give him credit. CSI was sold some time ago, and moved to Western MD. I don't see them alive on the Web now, but may just have not looked hard enough. -- <a href="JimRussell.html">JimRussell</a>
      </p>
      <p>
        From the MacForth Plus Manual: <em></em>MacForth was created by Don Colburn and Dave Colburn.<em> -- </em><a href="FelixFranz.html">FelixFranz</a> 
        <em>Yes! Don Colburn was the name I couldn't recall. Very sharp guy.</em>
      </p>
      <hr/>
      <p>
        An interesting? note: A guy named Jean-Paul Wippler is considering using Forth as a super glue language to bind Python Perl and Tcl together in a project called Minotaur. URL: <a href="http://www.equi4.com/minotaur/minotaur.html">http://www.equi4.com/minotaur/minotaur.html</a>
      </p>
      <p>
        <em>is this wise?</em>
      </p>
      <p>
        Extremely. Forth is an ideal intermediary language, precisely because it's so agile. Otherwise, it wouldn't have been chosen for <a href="OpenFirmware.html">OpenFirmware</a>, which when you think about it, is a Forth system that must interface to a potentially wide variety of programming language environments.
      </p>
      <p>
        In addition, Forth is now at the heart of the Tamarin implementation of <a href="ActionScript.html">ActionScript</a>. It is used as an introspectable meta-language, to aid in tracing a running <a href="ActionScript.html">ActionScript</a> program so that one can wisely choose which bits to compile <a href="JustInTime.html">JustInTime</a>.
      </p>
      <hr/>
      <p>
        Is Forth still a good fit for modern commodity CPU architectures (Okay I'm talking Intel here), considering they tend to prefer registers to the stack? Is mapping the stack top to registers still the preferred optimization here? The question isn't whether Forth is obsolete, it obviously isn't, the question is whether it's really an ideal match for these particular architectures? The only other alternative seems to be assembly, but macro assembly is not something that lends itself to instant recompilation like Forth does, which allows the system to be kept largely free of "object code".
      </p>
      <p>
        <em>Nothing has changed on this subject for many, many years. Intel architectures are register-starved, so the lack of extreme register optimization found in most Forth implementations has much less effect on the first place than it does on a register-rich architecture, such as most RISC CPUs.</em>
      </p>
      <ul>
        <li>
           [This is silly - modern Inteloid CPUs have huge numbers of registers, hiding behind register re-naming. // I suspect register renaming won't much help an interpreter, though it may give a boost to JIT and the "dynamic superinstructions" in gforth. Interpreters typically have terrible behavior in deep pipelines anyway.]
        </li>
        <li>
           It's not "silly", it is in fact correct, but ok, it's worth discussing. The question is not merely how many total registers exist behind the scenes, although obviously the larger register file plus renaming helped Pentium performance. Firstly, please note, although Intel has added every optimization it can, so that the Pentium isn't too far behind in the speed races, nonetheless it's never been a contender for fastest cpu at a given clock rate. Its architectural legacy is just too much baggage. This is just a reminder that it's not a subtle point of theory, there are some decades of benchmarks, too.
        </li>
        <li>
           As to this particular issue, the externally visible architecture makes a difference, even if internally the code is translated to a completely different and more efficient form. Consider the extra machine instructions that need to be generated in order to e.g. recompute a constant, when there wasn't a spare register to hang onto the value for a while. Consider the extra data bandwidth used if the value is fetched rather than computed. Consider the register spills to/from the stack generated by the compiler when it runs out of registers. All of these things have a rather large cost, and in general it is quite impossible for the interior Pentium architecture to optimize them away.
        </li>
        <li>
           So, as I said, the Pentium is register starved, and I stand by that.
        </li>
      </ul>
      <p>
        <em>Also, as has always been true, "inner loops" can be very easily optimized in Forth by creating new words defined in assembly.</em>
      </p>
      <p>
        <em>Lastly, often the alternative is an even slower interpreted language.</em>
      </p>
      <p>
        State-of-the-art <a href="ForthCompiler.html">ForthCompiler</a>s from <a href="ForthInc.html">ForthInc</a> and MPE are as highly optimized as modern C compilers for the Intel architecture.
      </p>
      <p>
        <em>You are consistently misinterpreting my message as being anti-Forth, which was completely the opposite my intended points. The question was "is forth a good fit for modern CPUs?" And I answered that yes, it is, and why. You seem to be thinking I was saying "no, it's not".</em>
      </p>
      <hr/>
      <p>
        See also <a href="ForthWiki.html">ForthWiki</a> or make a fulltext search for Forth in this Wiki: <a href="http://c2.com/cgi/fullSearch?search=Forth">http://c2.com/cgi/fullSearch?search=Forth</a>
      </p>
      <hr/>
      <p>
        Please do not revert this page. Broken links have been fixed, obsolete links removed, and a new Forth URL added. <em>(NOTE: as of November 2012 there are broken links and pages that were last updated in 2000, </em>'a dozen years ago.<strong> Isn't it about time the Forth community got hip to the fact that </strong><a href="ForthIsDead.html">ForthIsDead</a>?)<em></em>
      </p>
      <p>
        Please, please -- some Forth addict clean up this page, eh? There are dead links and links to more dead links. Let's not let Wiki devolve into a repository of useless clutter, shall we?
      </p>
      <hr/>
      <p>
        <a href="CategoryProgrammingLanguage.html">CategoryProgrammingLanguage</a>, <a href="CategoryForth.html">CategoryForth</a>
      </p>
    </div>
  </body>
</html>