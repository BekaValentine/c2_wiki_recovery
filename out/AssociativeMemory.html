<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Associative Memory
      </h1>
      <p>
        Memory that is addressed by content rather than by address; <em>content addressable</em> is often used synonymously. An <a href="AssociativeMemory.html">AssociativeMemory</a> permits its users to specify part of a pattern or key and retrieve the values <em>associated</em> with that pattern. The <a href="TupleSpace.html">TupleSpace</a>s that are traditionally used to implement the <a href="GenerativeCommunication.html">GenerativeCommunication</a>s model are an <a href="AssociativeMemory.html">AssociativeMemory</a>.
      </p>
      <p>
        Imagine that you were writing a blog engine. Instead of storing blog entries in an array of some sort, addressed by memory address or index into the array, you just create "nodes" out in "space." You don't <em>address</em> these nodes with memory addresses. Rather, you attach information to the node like: "This is of type 'blog entry.'" "The author is so-and-so." "This is the date it was created." "These are the categories it belonged to." Stuff like that.
      </p>
      <p>
        When you want to retrieve an entry by date, you tell the <a href="AssociativeMemory.html">AssociativeMemory</a> that you want it to give you back "Nodes that are of type 'blog entry,' for which the date they were created on is X." The <a href="AssociativeMemory.html">AssociativeMemory</a> then looks through it's stores for <em>any node that fits that shape,</em> and then returns it to you.
      </p>
      <hr/>
      <p>
        It seems to me that <a href="AssociativeMemory.html">AssociativeMemory</a> is more about the <em>interface</em> you use to access the memory store, than it is about the memory itself.
      </p>
      <p>
        SELECT statements over a standard SQL database seems to be an <a href="AssociativeMemory.html">AssociativeMemory</a> as well, even though I'm not so sure that's what is intended. I believe that what is intended is that we don't have to think about how tables are laid out - just how an abstract graph is laid out, and pattern-matched against.
      </p>
      <p>
        <em>"Content-addressable" seems to be used almost exclusively for memory hardware that is designed for associative lookups.</em>
      </p>
      <p>
        Remove required tables? See <a href="MultiParadigmDatabase.html">MultiParadigmDatabase</a>.
      </p>
      <hr/>
      <p>
        How is this different from <a href="PredicateDispatching.html">PredicateDispatching</a>?
      </p>
      <p>
        <em>My impression is that </em><a href="PredicateDispatching.html">PredicateDispatching</a> + <a href="AssociativeMemory.html">AssociativeMemory</a> = implementation of <a href="GenerativeCommunication.html">GenerativeCommunication</a>. It is a declarative computation model(?): you state actions to be performed when certain data is seen, and then you specify the data. Notably, the end result is that it is the mere<em> existence </em>of the data which causes the invocation of a function.<em></em>
      </p>
      <p>
        <em>However, I'm confusing myself as I write this, so I may be out to lunch.</em>
      </p>
      <p>
        <em>-- </em><a href="WilliamUnderwood.html">WilliamUnderwood</a><em></em>
      </p>
    </div>
  </body>
</html>