<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Language Transcendent Computing
      </h1>
      <p>
        The idea may apply to both computer languages and human languages. However, I use this term in the computer language context for my <a href="BasilProject.html">BasilProject</a>. This term applies to use of an environment where one is able to work with, code in, and integrate any computer language, even one they designed. -- <a href="JonRiehl.html">JonRiehl</a>
      </p>
      <p>
        The human language version of this is <a href="ConceptOrientedProgramming.html">ConceptOrientedProgramming</a> (from DDJ June 1999.)
      </p>
      <hr/>
      <p>
        Have you seen Microsoft <a href="VisualStudio.html">VisualStudio</a>/DevEnv (aka <a href="VisualBasic.html">VisualBasic</a>, VisualInterDev, VisualJ++)? Microsoft has written an environment where they just plug in new languages as they need them. Same basic compiler, syntax highlighter, etc. for all their languages. I suspect the grammars come as COM objects. Also, their vapourware COOL VM seeks to run many languages in one universal virtual machine so you can call Smalltalk code from Cobol code! And, of course, there is EMACS. (Is this what you mean?)
      </p>
      <p>
        <em>Actually, </em><a href="VisualBasic.html">VisualBasic</a> doesn't seem to really be integrated into VS yet (as of 6.0). It's one of those things that causes me much annoyance. And there seems to be a lot of difference between Interdev and VC also, although those differences could be attributed to features that just weren't implemented in the respective COM objects.<em></em>
      </p>
      <ul>
        <li>
           <a href="DotNet.html">DotNet</a> gets part, but not all, of the way to <a href="LanguageTranscendentComputing.html">LanguageTranscendentComputing</a>. Like all <a href="VirtualMachine.html">VirtualMachine</a> definitions with a fixed interface between the <a href="VirtualMachine.html">VirtualMachine</a> and the environment it creates, <a href="DotNet.html">DotNet</a> can support multiple languages -- so long as they conform to the behavior supported by the <a href="VirtualMachine.html">VirtualMachine</a> interface. Alas, in spite of the marketing hype to the contrary, <a href="DotNet.html">DotNet</a> Smalltalk is <strong>not</strong> real Smalltalk. <a href="DotNet.html">DotNet</a> Java is <strong>not</strong> real Java. In fact, the languages supported by <a href="DotNet.html">DotNet</a> are little more than syntactic sugar layered on top of the underlying bytecode interface. In order to accomplish genuine <a href="LanguageTranscendentComputing.html">LanguageTranscendentComputing</a>, the <a href="VirtualMachine.html">VirtualMachine</a> must be implemented in one or more of the languages being supported in the environment, and must be accessible and modifiable by the environment. The result is a reflective tower of metacircular interpreters, each capable of running whatever language it exists to run. The tower is grounded in a carefully-crafted metacircular intepreter like 3-Lisp. Brian Cantwell-Smith and Patti Maes have published rather extensively on this topic.
        </li>
      </ul>
      <hr/>
      <p>
        These are all good technologies, but I am talking about automagically building native interfaces, versus using <a href="MiddleWare.html">MiddleWare</a> such as COM or CORBA. This makes distributing the objects a pain, but I'd probably just fall back on XML-RPC for that. Not that any <a href="MiddleWare.html">MiddleWare</a> is precluded. Such an environment could also provide an IDL integration. See <a href="BasilProject.html">BasilProject</a> (still high in vapor, but based in proof of concept.) -- <a href="JonRiehl.html">JonRiehl</a>
      </p>
      <p>
        <em>What is the benefit of doing this without </em><a href="MiddleWare.html">MiddleWare</a>?<em></em>
      </p>
      <p>
        The foundation of this concept was to build <a href="SimplifiedWrapperAndInterfaceGenerator.html">SimplifiedWrapperAndInterfaceGenerator</a> without the interface language. Thus wrappers for legacy code come automatically. The back ends for our parsers were extended to build control flow and data flow models for test generation. It was then that I felt as if I were programming outside of computer language. I am trying to capture that experience and provide the infrastructure to do that. -- <a href="JonRiehl.html">JonRiehl</a>
      </p>
      <p>
        <em>How are you going to avoid the explosion of mappings that the </em><a href="LinguaFrancaPattern.html">LinguaFrancaPattern</a> (as embodied in IDL or standard data encodings) exists to solve?<em></em>
      </p>
      <p>
        I think the explosion of mappings is avoided because mappings are based on need rather than providing a complete solution. <a href="LanguageTranscendentComputing.html">LanguageTranscendentComputing</a> would take place in the context of a framework rather than a universal solution. - Let me rephrase this, part of this idea is to support several central model targets, such as UML/IDL, as well as some form of intermediate language like the kind that is used by GCC. However, it would also be a platform for prototyping a <a href="LinguaFranca.html">LinguaFranca</a>. -- <a href="JonRiehl.html">JonRiehl</a>
      </p>
    </div>
  </body>
</html>