<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        There Are No Tables
      </h1>
      <p>
        There are no tables, just like <a href="ThereAreNoTypes.html">ThereAreNoTypes</a>.
      </p>
      <p>
        <a href="EverythingIsRelative.html">EverythingIsRelative</a>. There are only 1's and 0's. (Or maybe q-bits. Or maybe just my thoughts about q-bits.)
      </p>
      <p>
        I think creating a database that only deals with 1's and 0's is the best idea, because ultimately we can only empirically test the database properly at a 1's and 0's level.
      </p>
      <p>
        That's what the computer understands, and the database depends on its implementation.. Since the database runs on a computer dealing with 1's and 0's, it makes sense to map the database to the machine. This is even better than a blob or string based database because strings and blobs are just abstractions, whereas 1's and 0's are more relative to the CPU. <a href="EverythingIsRelative.html">EverythingIsRelative</a>.
      </p>
      <p>
        Example database:
      </p>
      <code>
        ___________<br/>
        |           | <br/>
        | 10101000  |<br/>
        |___________|<br/>
      </code>
      <hr/>
      <p>
        I don't get it. By the way, tables are in the head, but that doesn't make them useless. Relative things can still be useful. --top 
      </p>
      <p>
        EverythingIsInYourHead. Or Nothing is. With Top, there is no distinguishing the two. 
      </p>
      <p>
        <em></em><a href="NothingIsAnything.html">NothingIsAnything</a><em></em>
      </p>
      <hr/>
      <p>
        Note that I did NOT create the topic <a href="ThereAreNoTypes.html">ThereAreNoTypes</a>. If you are spoofing somebody, it ain't me, Mam. --top
      </p>
      <p>
        <em>You didn't create the topic, but you are a member of a group who links to, recommends, and points to that page, along with making immature childish comments like how types are anal, nanny state, or that types are heavy. You support the page as if it has validity, or you have supported it in the past. Creating a page called </em><a href="TopsTypeDeterminatorChallenge.html">TopsTypeDeterminatorChallenge</a>, implies that types need to be verified that they actually exist. You are indirectly implying that types don't exist until proven otherwise - or you imply that types are a scam, fraud, etc. You may not directly use these words explicitly, but it is what you imply.<em></em>
      </p>
      <p>
        This is too vague for me to respond to. And I don't think I reference <a href="ThereAreNoTypes.html">ThereAreNoTypes</a> very often. And, "types being anal" is a different topic than " types don't exist". You are wrestling with several strawmen with this topic.....and losing.
      </p>
      <p>
        <em>If I created a page called "</em>DogDeterminatorChallenge", this would imply that dogs don't exist until we can determine they exist using an algorithm. It's basically a claim that ThereAreNoDogs until proven otherwise.  The challenge is to determine whether dogs exist, because if dogs can't be falsified - then everything is a dog. This is not true - dogs do exist, and we know they exist - so creating that page wastes everyone's time. You said types can't be falsified, that they are everything and anything - just like object orientation can't be falsified is what you've said.  Your claim that types are anal proves that you think math is anal - which ruins your credibility entirely. It's basically saying math is stupid. Math has types - so therefore logically math is anal (stupid) according to you. Math has number types. Math is anal therefore (and stupid). Therefore you've lost all credibility. Furthermore, if types are anal, that proves types exist since something can only be anal if it is something that exists to be anal. You have lost the DeterminatorChallenge because you have admitted types exist, so there is no challenge - types can be falsified because "they are anal", whereas something that doesn't exist cannot be anal since it is nothing (zero). You are losing, and have lost many times, and lost your determinator challenge in this paragraph I just typed, in addition to losing via other methods.<em></em>
      </p>
      <p>
        No. Wrong. I was looking for an <em>objective</em> determinator. Looking for an objective determinator is NOT the same as rejecting the existence of the subject. If I inadvertently implied such, I apologize. And where did I claim that "types are anal" in general? I have agreed there are times and places to be fastidious. It's the absolutist "always use heavy typing" claims that I disagreed with. But that's a different topic than existence anyhow. Misconception Soup. Cut back on the caffeine and try to compartmentalize issues. -t
      </p>
      <p>
        <em>Who says always use heavy typing? heavy typing languages have variants and ways to escape typing, along with strings (strings are general purpose buckets you can use which are flexible and can store different things without having a specific type, other than string). And you have absolutist "always using table" claims - everything is better off in a table to you, but when GUI comes up you end up using XML documents and OOP in addition to using tables for some of the config!</em>
      </p>
      <ul>
        <li>
           Again, you are jumping around from topic to topic in a confusing kind of way. Although I "like" tables, I don't claim they are "objectively better". I just believe more people would like using them if better and/or more table-friendly languages and tools were available for them.
        </li>
        <li>
          <em>Relational is objectively better for certain applications (querying data) and </em>'it is not about psychology<strong>. </strong>EdCodd didn't use psychiatry or psychology to prove that relational was the way to go instead of trees and other alternatives. <em></em>
        </li>
        <li>
           I'm skeptical of this claim. Please present a summary of his argument(s) and a link. I will agree that the functional nature of relational algebra can make certain machine-based optimizations possible that a sequential version of the same thing may not be subject to, but that's more about performance than source-code maintainability.
        </li>
        <li>
           <a href="http://dl.acm.org/citation.cfm?id=362685">http://dl.acm.org/citation.cfm?id=362685</a>
        </li>
        <li>
           I've said before that I won't pay ACM's fee. And, I do not believe it offers any empirical studies, such as code change impact analysis, other than offering a few examples. (A handful of scenarios are fine for illustrating points, but should not be considered rigorous "proof" by themselves. Further, it strengthens your case if you give the other side(s) a chance to offer counter-scenarios.)
        </li>
      </ul>
      <p>
        I think we can agree there is a difference between "county/western" music and "pop" music, that each category "exists" (at least as a <a href="UsefulLie.html">UsefulLie</a>), and we can also agree that there is no objective technique so far for determining which is which (or which percent of each). Thus we have a case where the existence of a concept does not conflict with objectivity or lack of, of it. We could perhaps build a machine/algorithm that can determine, and if we both agree to use it as our reference source, our "working definition", then we can move to the next step. This is often how things work in practice: find common ground and then work with that to build on to solve disagreements. It doesn't have to be objective, just stable for the intended scope of usage or discussion.
      </p>
      <p>
        <em>Music is an art. Art is harder to make objective claims about.  Computers are precise and mathematical. An equal sign is not an apple type. Therefore I just falsifed types because if types were anything and everything, an equal sign could be an apple type.</em>
      </p>
      <p>
        Some aspects of computers are "precise and mathematical". How "best" to describe an algorithm when there are gazillion paths to the same end result is NOT precise and mathematical. Computers are loyal savants that follow instructions reliably (compared to humans). But they are not the things that maintain and change software (unless you made a really bad mistake). Humans are what do that, and thus humans are mostly was is being measured when comparing approaches to program design, not machines. <strong>Programming for the most part is NOT about machines</strong>, but about communicating ideas to other humans or future self in a clear manner. It's almost comparable to legal text, which is only for humans, but must be sufficiently unambiguous for the need. (I'd note that programs can also be ambiguous, such as printing to the "default" printer or generating HTML that may be rendered somewhat differently on different browsers.)
      </p>
      <p>
        <em>We should actually reject using table heavy programs until someone can solve the </em>TableDeterminatorChallenge and produce an algorithm that defines what tables are and what they aren't. This pretty much makes table oriented programming as bad as object oriented programming since no one has produced external evidence determining what is a table and what isn't.<em></em>
      </p>
      <p>
        Why? I never said "don't use types until an objective determinator exists". You seem to be mixing up two different issues.
      </p>
      <p>
        <em>Saying that languages with type checking are "anal" is another way of saying "don't use types". The word anal is a direct insult and an attempt to ruin the reputation of types and type theory (evolution is anal - too many scientists in their ivory tower picking hairs - that's why I'm a creationist).  Saying "Tag free programming" or "typeless programming" or "type free programming" is saying that types are essentially not important, not necessary, or irrelevant (i.e. types are basically stupid, or a focus on types is anal). It implies that we can get along just fine without types, using some other reinvention of types. It's similar to someone who thinks procedures and functions don't exist, so they rename it to "object methods" even though the resemblance of a method and a procedure is strikingly similar and is an obvious reinvention using new terminology.</em>
      </p>
      <p>
        I don't think I made such sweeping statements. I'd have to review the context. I suspect you either misinterpreted the scope of my statements, or magnified them in your head to be a cartoon version of what I actually said over time. I've said many times that there is a time and place for strong typing, and a time and place for light typing (or type-free). I'm a proponent of <a href="TheRightToolForTheJob.html">TheRightToolForTheJob</a>. There is also some element of personal preference: different people do better under different techniques/languages/tool flavors. I do my best to explain why my <a href="WetWare.html">WetWare</a> "likes" certain techniques, but don't expect your <a href="WetWare.html">WetWare</a> to necessarily match. -t
      </p>
      <hr/>
      <p>
        See also: <a href="AntiPattern.html">AntiPattern</a>, <a href="CategoryHumor.html">CategoryHumor</a>.
      </p>
      <hr/>
      <p>
        <a href="MarchTwelve.html">MarchTwelve</a>
      </p>
    </div>
  </body>
</html>