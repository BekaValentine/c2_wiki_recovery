<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Software Is Hateful And Abusive
      </h1>
      <p>
        From <a href="DoesSoftwareMakeUsersHappy.html">DoesSoftwareMakeUsersHappy</a>
      </p>
      <p>
        Okay, apparently some people don't accept that mainstream software is hateful and abusive. Time to discredit that notion I guess. We'll start by listing popular software and then point out the <strong>vicious</strong> features it has. A vicious feature is one that's deliberately harmful to users. Deliberate because the feature exists for no reason whatsoever or it would have been just as easy to program good behaviour as it was to program bad behaviour.
      </p>
      <p>
        <em>A list of specific software is useless - all that proves is that </em>'some<em>' software is bad.</em>
      </p>
      <p>
        Yeah, I guess the fact that "some" is all the software I use is irrelevant. Why don't you just give examples of software that isn't bad?
      </p>
      <ul>
        <li>
           <a href="MicrosoftWindows.html">MicrosoftWindows</a>
          <ul>
            <li>
               Off-limits since it is way too easy.
            </li>
          </ul>
        </li>
        <li>
           Unix
          <ul>
            <li>
               Ditto.
            </li>
          </ul>
        </li>
        <li>
           Lotus Notes
          <ul>
            <li>
               Double ditto.
            </li>
          </ul>
        </li>
        <li>
           <a href="MicrosoftWord.html">MicrosoftWord</a>
          <ul>
            <li>
               <a href="DigitalRightsManagement.html">DigitalRightsManagement</a>
            </li>
            <li>
               so many useless features that it's unusable; I can't give specifics since I just use wordpad when I have to.
            </li>
            <li>
               Multiple useless features instead of anything useful like, say, a versioned history of the document.
            </li>
          </ul>
        </li>
        <li>
           <a href="MicrosoftExcel.html">MicrosoftExcel</a>
          <ul>
            <li>
               <a href="DigitalRightsManagement.html">DigitalRightsManagement</a>
            </li>
            <li>
               deliberately hid the formula editor key
            </li>
          </ul>
        </li>
        <li>
           MediaPlayer
          <ul>
            <li>
               <a href="DigitalRightsManagement.html">DigitalRightsManagement</a>
            </li>
          </ul>
        </li>
        <li>
           Winamp
          <ul>
            <li>
               annihilates the entire playlist when you add a single song, sometimes does this even though you specified enqueue as default behaviour
            </li>
            <li>
               there's no objective reason why "annihilate the playlist" is even an option, Play should mean "Enqueue and jump to that song"
            </li>
            <li>
               can't cut and paste, just cut
            </li>
            <li>
               Seeker is teeny tiny to facilitate missing it
            </li>
          </ul>
        </li>
        <li>
           Quicktime
          <ul>
            <li>
               O Lord but that interface is an abomination! Can't even go full-screen mode even though I know it's a possibility somehow.
              <ul>
                <li>
                   <a href="QuickTime.html">QuickTime</a> isn't so bad these days. Its major annoyance is that you need to pay to activate features which are, you know, pretty much already there in the library. The UI just seals them off. You can't go full-screen without paying a fee to unlock that menu. 
                </li>
                <li>
                   <em>You could write reams about how stupid Apple's handling of Quicktime (the player) is. Quicktime (the multimedia API) is excellent. The player is a load of crap. I secretly suspect it's only kept around as a punishment assignment for engineers who get out of line. The "premium" stuff is a good example - you can write a player, even with minimal programming ability, that has all the of the "disabled" Qt Player features in an afternoon with XCode.</em>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
           <a href="OperaBrowser.html">OperaBrowser</a>
          <ul>
            <li>
               history shows only last time visited when you want either first time visited or all times visited
            </li>
            <li>
               history is all agglomerated together instead of being per-window and per-tab, making it useless
            </li>
            <li>
               sessions which you can't manage (gee, I just want to add these three tabs to that other session)
            </li>
            <li>
               whines 20 times with annoying "can't find page" dialogs every single time I open it
            </li>
          </ul>
        </li>
        <li>
           <a href="VisualWorks.html">VisualWorks</a>
          <ul>
            <li>
               3 different concepts to package code together (parcels, packages and categories) when what you really want is a single concept that allows recursive nesting and multiple logical containment
            </li>
            <li>
               a changelist tool that doesn't keep track of all user-initiated changes (adding a parcel is a change, though a single change)
            </li>
          </ul>
        </li>
        <li>
           <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>
          <ul>
            <li>
               all of the most common sources of code bugs represent language bugs. For instance, instance variables not automatically saved in subclasses of Collection, #at:put: returning argument, no initialize method in Object. Implementors really should have bitten the bullet and deviated from the language standard, they would have been <strong>trivial</strong> to fix once and for all.
            </li>
          </ul>
        </li>
        <li>
           Starcraft (a game no less!)
          <ul>
            <li>
               build menu shortcuts are accessed by meaningless names even though the menus are already in a 3x3 grid that could be accessed using <a href="MouseKeys.html">MouseKeys</a>
            </li>
          </ul>
        </li>
        <li>
           <a href="MicrosoftOutlook.html">MicrosoftOutlook</a>
          <ul>
            <li>
               can't select multiple (or all) emails to move them elsewhere
              <ul>
                <li>
                   <em>What? I do that all the time. Are you talking about the </em>'old<em>' web interface only?!?</em>
                </li>
              </ul>
            </li>
            <li>
               isn't threaded, so you have to keep switching between inbox and sent in order to read a thread, losing your place often (oh right, I guess that doesn't count since it would require stealing the code from trn)
            </li>
          </ul>
        </li>
      </ul>
      <p>
        For just about <strong>any</strong> application, it would be easier to turn operations into <a href="CommandObject.html">CommandObject</a>s, match them to reverse operations, and log them all in a stack than to add confirmation dialogs all over the place asking the user if they "really, really want" to do whatever they damn well just sodding TOLD the machine to do.
      </p>
      <p>
        Unfortunately, it would require some small degree of intelligence and professionalism, which things programmers distinctly lack as a group, for this to happen. I say intelligence because figuring out that confirmation dialogs are evil requires no empathy, just <em>sympathy</em>.
      </p>
      <ul>
        <li>
           Multiple level undo / redo is just as easy to code as single level undo / undo undo. Not that it's good enough but cactus stacks are harder to represent and hence to code.
        </li>
      </ul>
      <p>
        The only software I use that actually likes and cherishes the user is <a href="BlackAndWhite.html">BlackAndWhite</a>. The best that, say, Populous 3 achieves is to not hate the user. Actually, first person shooters are consistently better in that respect, probably due to having a well-known and extensively studied format. The design costs of a first person shooter's UI have been paid for long ago, by other people.
      </p>
      <p>
        See also: <a href="http://hates-software.com/,">http://hates-software.com/,</a> the natural home of software haters.
      </p>
      <hr/>
      <p>
        <strong>Can software be vicious?</strong>
      </p>
      <p>
        This is not "vicious". For software to be vicious or hateful, the above would have to be true, *and* the feature would have to be that way *because* users don't like it. Of the software below I'm familiar with, only Quicktime qualifies, because it's deliberately crippled, and that crippling is designed to annoy you into paying for the Pro version. The strongest case to be made for most of this software is that it is "poor", or "bad", but not "vicious" or "hateful". -- ChrisMellon
      </p>
      <p>
        Furthermore, software (being a thing) is capable of neither hate nor abuse; <em>programmers</em> are another matter altogether. (Not to mention programmers' bosses...) -- Anon
      </p>
      <p>
        This is very much like the question of Purpose on <a href="FoundDesignedDesignoid.html">FoundDesignedDesignoid</a>. My position is that it doesn't matter to the users whether or not the programmers are lovey-dovey peace & lovingkindness kind of folk or vicious bastards. The <em>reason</em> why software is vicious to them doesn't matter to the fact that it is vicious to them. And you're not going to get around this perception of users by saying inane things like "software has no feelings" and "software has no motives". I mean, what makes you think that <em>human beings</em> have feelings and motives? Other than the fact that you routinely deceive yourself in thinking that other human beings are fundamentally like yourself?
      </p>
      <p>
        I don't think anyone can take a single course in psychology, or listen to a single lecture for that matter, and still retain the idea that it matters <em>objectively</em> that computers / systems / things / objects "don't have feelings". So what? It doesn't stop actual human beings from ascribing feelings to them, nor does it stop them from acting, reacting and feeling based upon the feelings they have ascribed to those things "that have no feelings".
      </p>
      <p>
        There's a classic experiment about people's perceptions of various simple game-theoretic behaviours such as "altruism", "cooperation" and "greed". The researchers let the subjects see the behaviour of a <em>dumb computer program</em> and asked them to comment on it. The program had four modes and in two of them, all it did was compare two integers and output a 1 or 2 depending on the answer. In the third mode, it added two pairs of integers before doing the comparison. And in the fourth mode, it subtracted them. That's <strong>all</strong> it did. The people's perceptions of what it did were rather different.
      </p>
      <p>
        What the researchers got from the experiment was that people rarely perceived cooperation for what it was. What's more relevant here is that people routinely said things like "he's acting like an asshole" and "he's out to screw the other guy" or "he's being very nice".
      </p>
      <p>
        Software has no feelings? Who cares?
      </p>
      <p>
        -- RK
      </p>
      <p>
        <a href="MayZeroFive.html">MayZeroFive</a>
      </p>
    </div>
  </body>
</html>