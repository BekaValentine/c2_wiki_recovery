<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Meta Programming
      </h1>
      <p>
        A metaprogram is a program that manipulates other programs (or itself) as its data. The canonical example is a compiler.
      </p>
      <p>
        Metaprogramming is the act of writing metaprograms.
      </p>
      <p>
        Examples of metaprograms are:
      </p>
      <ul>
        <li>
           the compiler or interpreter of your favourite language
        </li>
        <li>
           Lex and Yacc
        </li>
        <li>
           CORBA's IDL compiler
        </li>
        <li>
           a Quine (a program that, when executed, prints a copy of its own source code -- see <a href="QuineProgram.html">QuineProgram</a> for examples)
        </li>
        <li>
           Programs to generate EJB code and XML from database metadata
        </li>
        <li>
           <a href="EnhancedCweb.html">EnhancedCweb</a> (or perhaps, this counts as 'PataProgramming?)
          <ul>
            <li>
               Using an "Eval" function in dynamic languages to execute a generated string as programming code.
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <em>Most uses of the term these days refer to a particular special case. Metaprogramming is what you do with </em><a href="CeePlusPlus.html">CeePlusPlus</a> templates or <a href="CommonLisp.html">CommonLisp</a> macros: defining the content of (part of) a program by writing code that generates it. The code in question usually consists of a template and some instructions on how to fill it in; but the instructions can potentially be rather complicated. With <a href="CommonLisp.html">CommonLisp</a> macros, you can transform or generate code in arbitrarily sophisticated ways. C++ templates are rather more painful, but also very powerful. Other languages that support this kind of metaprogramming pretty well include Scheme and Dylan.<em></em>
      </p>
      <p>
        Does <a href="ForthLanguage.html">ForthLanguage</a> count? In Forth you generate the bytecode rather than source, but other than that it works in a similar way.
      </p>
      <hr/>
      <p>
        I don't know who wrote the above, but I think it is wrong.  That is the subset of <a href="MetaProgramming.html">MetaProgramming</a> called <a href="GenerativeProgramming.html">GenerativeProgramming</a>.  <a href="MetaProgramming.html">MetaProgramming</a> in <a href="CommonLisp.html">CommonLisp</a> is about the <a href="MetaObjectProtocol.html">MetaObjectProtocol</a>.  In Smalltalk, it is about hacking <a href="DoesNotUnderstand.html">DoesNotUnderstand</a>: and subclassing Behavior.  It is about programming at the "meta" level, i.e. about changing your interpreter or changing how code is compiled.  -- <a href="RalphJohnson.html">RalphJohnson</a>
      </p>
      <p>
        <em>Some of us consider the above to be </em><a href="ThreeStarProgramming.html">ThreeStarProgramming</a><em></em>
      </p>
      <p>
        <em>In </em>TeX, you can change category codes to change the way the file is read. You could do this to make it read and interpret CSV files or XML files, or whatever.<em></em>
      </p>
      <p>
        A lot of languages do not allow <a href="MetaProgramming.html">MetaProgramming</a> in the meaning that <a href="RalphJohnson.html">RalphJohnson</a> explained. This is why there exist such a lot of <a href="PreCompiler.html">PreCompiler</a><strong>'s (e.g. </strong><a href="AspectJay.html">AspectJay</a>). --<a href="HaskoHeinecke.html">HaskoHeinecke</a>
      </p>
      <p>
        The <a href="ForthLanguage.html">ForthLanguage</a> allows <a href="MetaProgramming.html">MetaProgramming</a>.  A programmer can extend or change the compiler.
      </p>
      <p>
        <em>Forth allows changing and extending the compiler, as well as code generation, reading with a different syntax, and a lot of other things that were not actually invented until later programming languages were invented to invent those new features!</em>
      </p>
      <hr/>
      <p>
        <a href="MetaProgramming.html">MetaProgramming</a> seems closely related to the more powerful notions of <a href="CategoryReflection.html">CategoryReflection</a>.  How are they distinct?
      </p>
      <p>
        I think it's the other way around: both <a href="GenerativeProgramming.html">GenerativeProgramming</a> and <a href="CategoryReflection.html">CategoryReflection</a> are subsets of <a href="MetaProgramming.html">MetaProgramming</a>. <a href="CategoryReflection.html">CategoryReflection</a> is probably simpler when the language allows it, but <a href="GenerativeProgramming.html">GenerativeProgramming</a> is probably more efficient since the work is usually done at compile-time.
        --SamuelGelineau
      </p>
      <hr/>
      <p>
        Two other interesting questions are:  Why is metaprogramming done, and <em>should</em> it be done?  
      </p>
      <p>
        Note: In this section, the discussion is limited to "application-specific" metaprogramming, where a project team or organization hacks up some custom language, along with implementing a translator for it (the translator can be anything from a runtime interpreter, macro hackery (either for an internal preprocessor such as CPP or an external one such as EmFour), or an external custom tool (whether a quick-and-dirty Perl script or a complete compiler).  Writing a translator for a general purpose programming language is outside the scope of this discussion--we all know why this is done, and agree that it should be.  :)
      </p>
      <p>
        Why is it done?
      </p>
      <ul>
        <li>
           To get around limitations in the primary development language(s).  (See <a href="GreenspunsTenthRuleOfProgramming.html">GreenspunsTenthRuleOfProgramming</a>).  Usually, this sort of thing is done when either a) there is a management edict to use a particular language (or set of languages), use of a different language is not allowed--but doing <a href="MetaProgramming.html">MetaProgramming</a> with the development language as the target is politically acceptable; or b) the team includes one or more <a href="ThreeStarProgrammer.html">ThreeStarProgrammer</a>s who consider such a task to be a particularly pleasurable form of <a href="MentalMasturbation.html">MentalMasturbation</a>.  Often times, the languages of this sort that result are domain-independent (and often <a href="TuringComplete.html">TuringComplete</a>).
        </li>
        <li>
           To encapsulate domain-specific knowledge.  These languages are generally more domain-dependent. 
        </li>
        <li>
           To allow <em>users</em> to configure and/or program a system (it is assumed that the user will not be likely be capable of modifying the program source directly, or might not even have access to that source).  Examples include all sorts of configuration files and the like.  Depending on the needs, a custom config file format (or something based on a standard meta-language, such as XML) might be best--see <a href="PrincipleOfLeastPower.html">PrincipleOfLeastPower</a>.  (If a general purpose language is needed, embedding an existing language suited for such purposes, such as <a href="TclTk.html">TclTk</a>, <a href="EmacsLisp.html">EmacsLisp</a>, etc. might be a better idea).
        </li>
      </ul>
      <p>
        Is meta-programming a good idea?
      </p>
      <p>
        Depends on two things:  a) how domain-specific the meta-language is, and b) how complex it is.  Generally, domain-specific meta-languages are more justifiable (if you need domain independence, there are many fine choices available off-the-shelf; designed by folks whose domain expertise is programming languages), and simpler is better.  
      </p>
      <p>
        However, there are many <a href="StumblingBlocksForDomainSpecificLanguages.html">StumblingBlocksForDomainSpecificLanguages</a> (remainder of content moved there).
      </p>
      <hr/>
      <p>
        The highest form of metaprogramming is the MetalinguisticAbstraction, usually implemented with a <a href="MetaCircularEvaluator.html">MetaCircularEvaluator</a>. The <a href="StructureAndInterpretationOfComputerPrograms.html">StructureAndInterpretationOfComputerPrograms</a> book has a great section on this. Essentially, it moves language design decisions to the programmer from the language designer. Whether this is good or bad depends entirely on the programmer in question.
      </p>
      <hr/>
      <p>
        The basic problem is that any general-purpose programming language without a metaprogramming model that is designed to be as pleasant and expressive as the language itself will eventually frustrate the user with it's limitations.  No-one can design the perfect language, and yet allowing users to extend the language in generic ways is avoided with a <a href="BondageAndDiscipline.html">BondageAndDiscipline</a> mentality.  Consider how <a href="JavaLanguage.html">JavaLanguage</a> lasted so long without GenericObjects (practically a necessity for typesafe OOP) and no usable metaprogramming model to allow users to do it themselves.  Consider how popular <a href="CodeGeneration.html">CodeGeneration</a> and Reflection are in <a href="CsharpLanguage.html">CsharpLanguage</a> - effectively a substitute for metaprogramming - although it relies on the language (or the codegen system) being expressive enough to prevent the developer from having to manipulate the actual codegenned (and thus unstable) code.
      </p>
      <p>
        Even <a href="CeePlusPlus.html">CeePlusPlus</a> templates were made with a <a href="BondageAndDiscipline.html">BondageAndDiscipline</a> mindset.  They were intended to be a limited subset of macros primarily designed for allowing type-safe but (compile-time) dynamically typed code... and very little else without using convoluted, hidden, functionality.  How does one iterate across the members of a class in order to define a new class that wraps all of the existing members of the previous?  That's a fairly standard action in OOP languages, and yet rarely provided within the language's metaprogramming facilities.  Or create an enum and a corresponding list of strings where the contents of the string are identical to the symbolic names of the Enum values, without violating <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a>.
      </p>
      <p>
        This is why the <a href="LispLanguage.html">LispLanguage</a> has remained in use, dispite being ugly, anachronistic, and divided - simply because the <a href="LispLanguage.html">LispLanguage</a> community has always focussed on avoiding confining abstractions and <a href="BondageAndDiscipline.html">BondageAndDiscipline</a> mentalities.  From this perspective, even <a href="PythonLanguage.html">PythonLanguage</a> is a <a href="BondageAndDiscipline.html">BondageAndDiscipline</a> concept, as <a href="GuidoVanRossum.html">GuidoVanRossum</a> fought long and hard against adding syntax that would allow for user-defined block and flow-control structures.  
      </p>
      <p>
        <em>Or maybe the reason </em><a href="LispLanguage.html">LispLanguage</a> has remained in use is because you can do procedural programming in Lisp (you can easily create side effects since it isn't pure).<em></em>
      </p>
      <p>
        Unfortunately, it doesn't look like this mentality will change in mainstream programming - <a href="CsharpLanguage.html">CsharpLanguage</a> version 3.0 will further avoid a non-painful <a href="MetaProgramming.html">MetaProgramming</a> approach by adding everything but the kitchen sink to the language. --<a href="MartinZarate.html">MartinZarate</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryMetaprogramming.html">CategoryMetaprogramming</a>
      </p>
    </div>
  </body>
</html>