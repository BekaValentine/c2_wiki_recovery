<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Modern Dinosaur
      </h1>
      <p>
        Dinosaur in the sense of being terribly outdated, having been tried in the past and having failed. Unfortunately, a vast majority of people are unwilling to know anything about the past, so they keep reinventing squared wheels. So here we have the <a href="ModernDinosaur.html">ModernDinosaur</a>s plenty of them.
      </p>
      <p>
        Associated with the <a href="NotInventedHere.html">NotInventedHere</a> syndrome.
      </p>
      <hr/>
      <p>
        The most obvious examples:
      </p>
      <ul>
        <li>
           <a href="HierarchicalDatabase.html">HierarchicalDatabase</a>s and <a href="NetworkDatabase.html">NetworkDatabase</a>s (XML, Object Oriented databases)
        </li>
        <li>
           <a href="UnifiedModelingLanguage.html">UnifiedModelingLanguage</a> ( for those who still have doubts see Klaus-Dieter Schewe: <em>UML: A Modern Dinosaur? - A Critical Analysis of the Unified Modelling Language</em>, <a href="http://citeseer.ist.psu.edu/386839.html">http://citeseer.ist.psu.edu/386839.html</a> ) <em>{Does anybody have a reference to an HTML version of this document? PDF and some of the other format choices are rendering poorly for me.}</em>
        </li>
      </ul>
      <hr/>
      <p>
        <em>I would like to point out that Schewe (and, obviously, the author of this page) adheres to a plainly wrong image of dinosaurs as "mentally retarded, mighty rulers oppressing for a long time the development of higher developed forms of life such as birds and mammals". That old prejudice isn't supported by paleontologists any more. There is no reason to think that they where "retarded". The very fact that they dominated their environment for so many million years shows that they were as intelligent and effective as necessary, and if they were able to "oppress" (a meaningless term when referring to biological evolution) mammals it is exactly because mammals where not intelligent and efficient enough to beat them. I recommend </em><a href="StephenJayGould.html">StephenJayGould</a>, of course.<em></em>
      </p>
      <hr/>
      <p>
        <em>Thinkest thou that we should merge this with yon </em><a href="ZombieTechnologies.html">ZombieTechnologies</a> list?<em></em>
      </p>
      <p>
        Well, not quite. First of all that somebody wrongly put relational databases on the <a href="ZombieTechnologies.html">ZombieTechnologies</a>. If I add object databases in there we're left without any database at all that justifies its existence.Putting relational databases on the list of zombie technologies is only justified by the fact that they have been in use for a long time (or have they ? ), but with this kind of argument we can also put Euclidean Geometry on the list of zombies, and it's just not right. We have to admit that some human knowledge is fundamentally good and consistent and will stay with us even for centuries.
      </p>
      <p>
        Second,the motivation given for Zombies is that they have been continuing to exist, despite advances in technologies for various reasons. Dinosaur are things that have been forgotten and re-invented in another shape, hence what I call the reinvention of a squared wheel as opposed to the reinvention of a wheel - which is not good but not bad either.
      </p>
      <p>
        XML is a new and cool thing. In fact it is a resurected dinosaur (hierarchical data model).UML is also new and cool, and it's also a reinvented square wheel. 
      </p>
      <p>
        At least that's the sense I wanted to give to <a href="ModernDinosaur.html">ModernDinosaur</a>, maybe the syntagm is not the best one, but at least it is used by somebody else before me with the same meaning. 
      </p>
      <hr/>
      <p>
        This list is bogus.  Both of the things on this list work.
        They don't work all the time, everywhere, but then nothing does.
        Instead of just insulting them, perhaps you should describe the weaknesses
        in them, and then perhaps we could figure out when we should use them and
        when we should not use them.  But just making lists like this is a waste
        of time.  
      </p>
      <p>
        By the way, just because something is a recycled idea that failed in the past doesn't make it a dinosaur.  Generally it takes many attempts to make an idea work.  Also, the time might not have been right for it the first time, but perhaps it will be this time.  The question is whether it works now, not whether it failed in the past.
      </p>
      <p>
        <em>The automobile was an early 19th century invention that didn't really start to work until the late 19th century, mostly because of problems with the road systems of the early 19th century.</em>
      </p>
      <p>
        It is ironic that OODBMS are a lot like hierarchical databases,
        and are trying to supplant RDBMSs, which supplanted hierarchical databases. 
        But this does not tell us much about which is better.
      </p>
      <p>
        -<a href="RalphJohnson.html">RalphJohnson</a>
      </p>
      <p>
        Well, this list is a point of view. The fact that a thing works doesn't give it a title of glory over other things. IMS did work and still does, COBOL programs did work and some still do. Still new development efforts with either COBOL or IMS are almost non-existent. Is this for a good reason, or just because of industry fads ?
      </p>
      <p>
        If you still have doubts which model (hierarchical or relational) is better, and more important, based on what criteria, I think that <a href="AnIntroductionToDatabaseSystems.html">AnIntroductionToDatabaseSystems</a> will do. So the question is whether it works now. But what did fundamentally change from the past ? What were the weaknesses from the past that are covered now by the revamped products (alas we don't have a revamped theoretical foundation behind the products). 
      </p>
      <hr/>
      <p>
        Lots of old ramblings moved to <a href="ModernDinosaurDiscussion.html">ModernDinosaurDiscussion</a>.
      </p>
      <hr/>
      <p>
        UML is a special thing in the list at least because not a database. It is supposed to be on a higher level, a <em>modeling language</em>, even an unified one. Unfortunately it looks like it doesn't have a model behind it, at least not a theoretical one, and not even a simpe one that you can read in the UML specification. I think the paper that I linked to is pretty concludent, I could add some links on this site, and the opinion of others . But I could also quote directly from UML:
      </p>
      <code>
        The Unified Modeling Language (UML) is a language for specifying, visualizing, constructing,<br/>
        and documenting the artifacts of software systems, as well as for business modeling and other<br/>
        non-software systems. The UML represents a collection of the best engineering practices that<br/>
        have proven successful in the modeling of large and complex systems. [UML 1.3 specification available at www.omg.org]<br/>
      </code>
      <p>
        So, why is it called modeling language then, where is the model ? Where's the unification ? <em>I'm sure you know that what is being unified is three separate pre-existing methodologies - those of Booch, Jacobson, and Rumbaugh.  It has much less to do with OOPL commonalities.</em> What are the commonalities from the object models of Java, Smalltalk, C++, Ada, Delphi, Visual Basic (to name but a few of OO languages in relevant use today and in use long before 1999 when the actual), how they were unified in a single model ? These questions are only rhetoric, unfortunately. By the way, why is it called UML instead of Object UML, since function is not a first class concept , relation is not a concept at all. It's just marketing <em>chaff</em> starting from the name.
      </p>
      <hr/>
      <p>
        <em>But just making lists like this is a waste of time. </em>
      </p>
      <p>
        That's a valid point. The list was just a set of examples. People might disagree with the presence of various items on the list. However one can hardly argue with the validity of the term itself (I first saw it in the cited paper on UML and I said to myself: <em>Wow, that's a very good one</em>). <a href="ModernDinosaur.html">ModernDinosaur</a>s are among us whether we like it or not, whether we might sympathize with some of the dinosaurs or not.
      </p>
      <p>
        What would qualify a technology as a <a href="ModernDinosaur.html">ModernDinosaur</a>? 
      </p>
      <ul>
        <li>
          First it would have to be something reinvented. It has to be a reinvention of something that failed in the past.
        </li>
        <li>
          Second, the <a href="ModernDinosaur.html">ModernDinosaur</a> will not address the issues that made the previous thing fail. If it did, it will no longer be a dinosaur.
        </li>
        <li>
          <em>(Optional )</em> Most often is a reinvention without any aknowledgement. Sometimes the ingratitude to its ancestors comes from ignorance, the new inventors simply did not know that somebody thought of the same issues before them. Other times they do know, but they don't want to acknowledge the past, because of marketing reasons. The previous thing that failed just ruined its name. Hierarchical model's failure in term of public image is much larger than in terms of technical issues, so nobody is likely to come forward and say: <em>I have a new idea based on the hierarchical model</em>. The divorce with the past of <a href="ModernDinosaur.html">ModernDinosaur</a>s usually makes matter worse, they are likely to repeat the errors of the past and they are likely to at least double the effort in reinventing what the previous product had good.
        </li>
      </ul>
      <p>
        The things from the list arguably qualify under the first and second clause.
      </p>
      <p>
        Where is the value in putting them on such a list ? 
      </p>
      <p>
        Well, most of the people in <a href="SoftwareDevelopment.html">SoftwareDevelopment</a> are not aware of the previous dinosaur. It's just a simple matter of knowledge: it shall be known that this thing has been previously tried and failed. We should then investigate what the new invention brings new, how does it deal with the flaws from the past, and make informed decisions on whether and how to use each of them.
      </p>
      <p>
        For example I was aware of many things that were wrong with UML. I always thought that UML <em>would ventually become a dinosaur</em>. The fact that I now know that UML is in fact a <a href="ModernDinosaur.html">ModernDinosaur</a> (and what was the previous dinosaur) did help me in understanding UML better.
      </p>
      <hr/>
      <p>
        I know of two specific criticisms leveled against "network databases" (NDBMS). First, the query languages for them have been hard to learn and seemingly long-winded compared to relational query languages (such as SQL, which is not the best possible relational language IMO). OODB query languages have suffered similar criticisms (<a href="http://www.byte.com/art/9710/sec6/art6.htm).">http://www.byte.com/art/9710/sec6/art6.htm).</a>
      </p>
      <p>
        <em></em><a href="GemStone.html">GemStone</a> allows SQL access to its persistent objects in both its Smalltalk and Java product lines.  Next?<em></em>
      </p>
      <p>
        {Are you suggesting that <a href="GemStone.html">GemStone</a> allows the same information to be simultaneously and efficiently accessed from a relational, networked, and hierarchical perspective? Quite a feat if true.}
      </p>
      <p>
        The second criticism is that relationships have to be explicitly planned for in advance. In relational the relationships tend to be virtual (physical indexes are for speed purposes and in theory do not affect the interface to data), while in NDBMS you pretty much had to specify links or indexes in advanced of using them. IOW, it is harder to have "calculated links".
      </p>
      <p>
        <em>So, how are foreign keys different?  Somehow you don't have to plan for them in advance?</em>
      </p>
      <p>
        {The user of the info does not have to worry about how the foreign key got populated. Besides you can still create <a href="CalculatedRelations.html">CalculatedRelations</a> that are not based on explicit foreign keys. For example, cross-reference a search result set based on a sub-string search in a title field to something else to research possible name connections.}
      </p>
      <p>
        The very name "hierarchical database" suggests similar criticism for them also: They are hard-wired to a "tree" relationship. Relational philosophy would tend view a tree simply as *one of many* possible (simultaneous) relationships. IOW, a "tree" is a view, and not a physical structure nor a database in itself.
      </p>
      <p>
        <em>I see.  So the "tree" view in Oracle doesn't start from ALL_TABLES?  Why not?  In </em><a href="GemStone.html">GemStone</a> the analog to ALL_TABLES is a persistent JNDI node.  There's nothing to stop you from binding separate Maps per persistent class, keyed by primary identifier, holding all instances of that persistent class, and letting the instances refer to each other not by object pointer but by foreign key.  That would make it pretty analogous to relational tables.  But in practice what makes the most sense is to only bind registries of those objects that need to be independently findable.  All other objects are reached by object pointer navigation from aggregate roots.  Yes that means you need an initial understanding of anticipated access patterns, but that hardly represents a "failure".  It never caused any of my projects to fail.<em></em>
      </p>
      <p>
        <em>{The "out of style" database paradigms of the 1960's also did not cause outright failure. They just had more complex query languages and lacked </em><a href="CalculatedRelations.html">CalculatedRelations</a>. Lack of these is not a show-stopper, just like writing your app in COBOL is not a show-stopper. From your discription, it seems that the application developer has to manually arrange stuff that a <a href="RelationalDatabase.html">RelationalDatabase</a> would normally take care of out-of-the-box, or at least remove or reduce from the concern of the app developer. Relational query languages tend to ask for what you want, and not how to get it. (Imperitive-vs-Declarative link anyone?)}<em></em>
      </p>
      <hr/>
      <p>
        On another note, it is understandable to experiment with new manifestations of old technology, but shouldn't they be withheld from mainstream until the kinks are worked out? IOW, if we know that similar technologies failed in the past, then new incarnations should be well tested by *volunteer* organizations before going mainstream it would seem. Or perhaps one can argue that the only way to truly road-test a technology is to have it be mainstream for a while. This may perhaps be true, but it is kind of disappointing because it means that developers and organizations are guinea pigs whether they want to be or not.
      </p>
      <p>
        <em>"Be withheld" ... "should be well tested by *volunteer* organizations".  That's wishful utopian thinking.  We'll always be guinea pigs.  The winners leverage innovation to increase value (e.g., productivity) without overly increasing risk.</em>
      </p>
      <p>
        {Yes, but we don't know the winners until it is too late to do anything about the non-winners. Perhaps technology should be presented like stocks: high risk and low risk. There have been a lot of failed ideas on the way, or at least ideas that did not live up to their billing but find useful niches. CASE and Expert Systems come to mind. If an organization invested heavily in Expert Systems when they were big, they probably later regretted it.}
      </p>
      <hr/>
      <p>
        See also: <a href="ZombieTechnologies.html">ZombieTechnologies</a>
      </p>
      <hr/>
      <p>
        It might be argued that what we now call <a href="RelationalDatabases.html">RelationalDatabases</a> are actually NetworkDatabases that use SQL as a query language (soon to be replace by XQuery?).
      </p>
      <p>
        <em>Soon to be replaced ? Well, some people might differ.</em>
      </p>
      <p>
        For example one of the major differences between Network and Relational databases was that <a href="RelationalDatabases.html">RelationalDatabases</a> had to be location independant (the place the data was physically stored had to bear no relation to the content). This didn't actually work, and now '<a href="RelationalDatabases.html">RelationalDatabases</a>' mostly include the ability to locate data physically based on its properties (for speed).
      </p>
      <p>
        <em>You could be saying that, but this would be more hand waving than argumentation. Location independence did work and it's getting better every day.</em>
      </p>
      <p>
        What I am saying is that <a href="RelationalDatabases.html">RelationalDatabases</a> become more and more like NetworkDatabases all the time - so which one is the Dinosaur?
      </p>
      <p>
        <em>Yep. People can say all kinds of things.</em>
      </p>
      <p>
        {Is this related to the <a href="ChrisDate.html">ChrisDate</a> assertion that existing products fail to properly implement relational theory?}
      </p>
      <p>
        <em>Even the broken version of </em><a href="RelationalDatabases.html">RelationalDatabases</a> is better than the old NetworkDatabases. Imagine, if you can stomach it, a record in what should be called "recipe card" normalization with a finite number of hard coded links to other records. I spent large amount of time writing COBOL chasing what amounted to pointers merely to update the pay grades of emplyees, for example. All sorting and searching was done in the program itself. There was no relation between records, just a finite number of links. If you followed the wrong link, you could spend a large amount of thim chasing down the wrong information. When I look at so called "Object Oriented" databases being developed it just makes me angry that people with little understanding of of the past are trying to recreate it. And poorly at that. SQL and current RDBMS are not perfect, but they are a huge step forward. And yes, they can replicate a network since they are relational. But even when they do so they are still much more efficient, both in programmer time and machine time. --pjl<em></em>
      </p>
      <hr/>
      <p>
        One should be careful to extract what is useful from older concepts, and not dismiss anything "old" as useless. A craftsman does not abandon his/her manual screwdriver or hammer just because power ones are available in some cases they are still the best tool for certain jobs. That doesn't mean you should resist advancements either but be aware of software/hardware development history while being open to the new, look beyond hype and backlash to hype to choose the right solution for the task at hand. Knowledge of dinosaurs is useful even though they no longer exist (and some of their "peers" like insects continue to thrive).
      </p>
      <p>
        <em>After being forced to work with </em><a href="HollerithPunchCard.html">HollerithPunchCard</a>s as an intern, sometimes I just have to disagree and say that some legacy technologies just plain suck to the bones. (However, the damned things will probably survive a nuclear electromagnetic flash, with my luck, and I'll end up having to use them someday during WW III.)<em></em>
      </p>
      <hr/>
      <p>
        An idea for the list: <a href="GraphicalUserInterface.html">GraphicalUserInterface</a>, especially those FieldAndScreen monstrosities that make my head hurt. :-) -- <a href="JonGrover.html">JonGrover</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryHistory.html">CategoryHistory</a>
      </p>
    </div>
  </body>
</html>