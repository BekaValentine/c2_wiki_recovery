<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Active Code Generation
      </h1>
      <p>
        The process of generating code that will never require any human intervention for it to compile and function properly. Works best when the code is regenerated/refreshed as part of <a href="ContinuousIntegration.html">ContinuousIntegration</a>.
      </p>
      <p>
        <a href="CodeGeneration.html">CodeGeneration</a> can't be an entirely bad idea; without it, we wouldn't have assemblers or compilers.
      </p>
      <p>
        [<a href="CodeGeneration.html">CodeGeneration</a>.  Opposite of <a href="PassiveCodeGeneration.html">PassiveCodeGeneration</a>.]
      </p>
      <p>
        <em>Wouldn't these be more clearly named as </em>CompleteCodeGeneration versus IncompleteCodeGeneration?<em></em>
      </p>
      <hr/>
      <p>
        The above does not quite match the definitions I've read.  What I thought Active Code Generation meant was that it could be re-run on the same input as many times as desired (unlike a wizard, for instance).  That would include code such things as code with <a href="CeePreProcessor.html">CeePreProcessor</a> macros in it, in that you can run the same .c file through the preprocessor again.
      </p>
      <hr/>
      <p>
        To support the comment that assembers/compilers are code generators:
      </p>
      <p>
        Both take as input a stream of data of interest to the user (in this case a programmer) and generate machine language instructions from it. Some people have been known to hot patch the machine instructions to change the behavior of the generated program, but this is generally considered a bad idea.
      </p>
      <p>
        Some compilers, as a portability technique, compile to the source of another language as an intermediate step.
        The original <a href="CeeLanguage.html">CeeLanguage</a> compilers, for example, often compiled to assembly language, which was then run through the assembler to produce machine language. And there are many language compilers that used C for this intermediate step.
        But the intermediate steps don't matter unless someone modifies or tries to maintain the code at that step.
      </p>
      <hr/>
      <p>
        Very true. Everything is based on automation. The chip in your keyboard is automation. If you want to think "future" you have to think automation. If there is no sunshine, how are you going to survive? The sun is automated, you don't do the work. Everything, and I mean everything, is based on automation.
        Automation is such a general term, that it shouldn't be used in argument. It's like trying to argue whether something is "nice" or not. You could most likely find something nice about anything. Likewise, you can find automation within anything that has anything to do with a compIuter and your life.
      </p>
      <p>
        <em>However because we have </em><a href="FreeWill.html">FreeWill</a> we get to make decisions. Though <a href="InstinctAsIntelligence.html">InstinctAsIntelligence</a> exists we probably would not want to live life only by instinct, never having to think or solve problems. If everything is automated then there is nothing to do. Your homework gets done for you, the network takes care of itself, computers write their own programs - seems ideal but then who needs programmers or technicians in that case? The <a href="MicroSoft.html">MicroSoft</a> ad where Sales creates their own website and no one stops you in the hall with questions looks rosy but (a) never happens in practice (b) if it did then you are out of a job (or get less pay). I think <a href="ActiveCodeGeneration.html">ActiveCodeGeneration</a>, like <a href="ArtificialIntelligence.html">ArtificialIntelligence</a> is good, solves one set of problems but gives freedom to solve new problems which are not automated. It is a moving target. You still need code or some formalism anyway you may be "automatically" generating C or Java from UML or higher level language but then that process needs to be automated too. The UML did not magically appear out of thin air you had to design it. Creating this higher level specifation is also a kind of "human intervention" and one step in a larger process.<em></em>
      </p>
      <hr/>
      <p>
        See also <a href="MixedCodeGeneration.html">MixedCodeGeneration</a>, <a href="CodeGenerationIsaDesignSmell.html">CodeGenerationIsaDesignSmell</a>
      </p>
    </div>
  </body>
</html>