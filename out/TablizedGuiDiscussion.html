<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Tablized Gui Discussion
      </h1>
      <p>
        [under construction]
      </p>
      <p>
        The attribute and perhaps method grouping/sorting problem discussed in <a href="NodeJsAndHofGuiDiscussion.html">NodeJsAndHofGuiDiscussion</a> suggests that <a href="TableOrientedProgramming.html">TableOrientedProgramming</a> could be used to manage GUI specifications. 
      </p>
      <p>
        I am going to present a draft GUI schema so that we have a reference set of structures to work with. Keep in mind that the actual tables don't have to be in a RDBMS to function as GUI-related tables, although it would be easier to use off-the-shelf tools such as a <a href="TableBrowser.html">TableBrowser</a> if one did.
      </p>
      <p>
        It will generally be assumed that the table design is not language-specific so that it can be used by multiple languages. (A limitation with many GUI engines is that they are hard-wired to a given programming language.)
      </p>
      <p>
        Languages-specific wrappers/API's can be created.
      </p>
      <code>
        <strong>widget</strong> table<br/>
        ---------<br/>
        widgetID<br/>
        parentWgtID  // container or "outer" widget. Zero for root.<br/>
        wgtType      // window, form, button, image, input-box, label, etc.<br/>
        wgtTitle<br/>
        wgtPosition  // see [to be inserted]<br/>
        wgtContent<br/>
        wgtDefault   // default content for new or reset widgets (including list default if applic.)<br/>
        wgtStyle<br/>
      </code>
      <code>
        <strong>widgetAttrib</strong> table (to roughly emulate <a href="DynamicRelational.html">DynamicRelational</a>)<br/>
        --------<br/>
        widgetRef  // foreign key to widget<br/>
        attribName<br/>
        attribValue<br/>
        // primary key is widgetRef + attribName<br/>
      </code>
      <code>
        <strong>eventListener</strong> table (may not be needed, depending on model)<br/>
        ---------<br/>
        eventL_ID<br/>
        nameSpace<br/>
        guiObjRef  // GUI object to watch<br/>
        eventType  // Type of event watched (click, double-click, etc.)<br/>
        priority   // 0 to 9<br/>
        runObjRef  // object name or address to run, depending on hook-up technique<br/>
        runMethodRef<br/>
      </code>
      <code>
        <strong>lists</strong> table   // used for drop-down lists, etc. (if not bound to RDBMS table)<br/>
        ------------<br/>
        listID<br/>
        listValue<br/>
        listDescript   // by convention, listValue is displayed if listDescript not given<br/>
        listSequence   // double-precision<br/>
        // primary key is listID + listValue<br/>
      </code>
      <code>
        [more to come]<br/>
      </code>
      <p>
        ...
      </p>
      <p>
        --top
      </p>
      <p>
        <em>Managing GUI specifications with </em><a href="TableOrientedProgramming.html">TableOrientedProgramming</a> is an interesting idea, one that harks back to the "data-driven development" movement that was popular in the 1980s.  However, GUIs tend be edited in one of two ways:<em></em>
      </p>
      <ul>
        <li>
           <em>Via native code, either because the quantity of GUI editing -- maybe just a dialogue box here and there -- doesn't warrant external tools, or because we need the flexibility that native code affords.</em>
        </li>
        <li>
           <em>Via a WYSIWYG GUI painter, which inevitably generates code somewhere but we almost never have to look at it.  Editing the GUI is by clicking, dragging, etc. on a "live" GUI.</em>  
        </li>
      </ul>
      <p>
        <em>Thus, I'm not sure where a </em><a href="TableBrowser.html">TableBrowser</a> would be useful.<em></em>
      </p>
      <p>
        <em>I suppose I could see it being a useful adjunct to the Properties editor inside a WYSIWYG GUI painter, so that you could (for example) look at the titles of all the radiobuttons grouped together.  That might be handy.</em>
      </p>
      <p>
        I agree that an off-the-shelf <a href="TableBrowser.html">TableBrowser</a> wouldn't handle a good many needs and that IDE integration is probably the best approach. If there are not a lot of fields or widgets, then markup is probably sufficient, at least for the non-coded parts, but if you are dealing with CRUD applications with gajillion fields, then to have the ability to sort, filter, etc. by various ad-hoc factors becomes very useful.
      </p>
    </div>
  </body>
</html>