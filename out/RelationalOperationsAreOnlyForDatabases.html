<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Relational Operations Are Only For Databases
      </h1>
      <p>
        A lot of people seem  to believe that <a href="RelationalOperationsAreOnlyForDatabases.html">RelationalOperationsAreOnlyForDatabases</a> that they can not be used for other non persistent operations...
        I dont think that is a <a href="GoodIdea.html">GoodIdea</a>, I think that if we have AritmeticOperators and BooleanOperators as PrimitiveOperators in our <a href="ProceduralLanguages.html">ProceduralLanguages</a> or <a href="ObjectOriented.html">ObjectOriented</a> languages, we should also have RelationalOperators to manipulate local collections, that would open the door for very powerful optimizations like parallel search for data, parallel aggregate function execution, parallel translation from one data structure to another (from Dictionary to Array for example), etc. It would also make some algorithms a lot easier to maintain and ready, making software development more conceptual (like in <a href="ConceptProgramming.html">ConceptProgramming</a>)
      </p>
      <p>
        See also: <a href="RelationalBreaksEncapsulation.html">RelationalBreaksEncapsulation</a>
      </p>
      <hr/>
      <p>
        Yes, that is what everybody says, <a href="RelationalBreaksEncapsulation.html">RelationalBreaksEncapsulation</a>... why we say that only against Relational? Procedural also breaks encapsulation, Functional also breaks encapsulation... in fact, if we were to have "perfect" encapsulation, then objects wouldn't collaborate with each other, if we can live with the fact that procedural needs to somehow manipulate objects, why we can not live with the fact that Relational also has to "touch" objects to do its work?
      </p>
      <ul>
        <li>
           Note that "breaking encapsulation" is not necessarily bad. The point is that the "rules" of OO are not valid or not accepted in the relational world, and perhaps visa versa. The two are thus somewhat at odds with each other. (EncapsulationBreaksRelational.)
        </li>
      </ul>
      <ul>
        <li>
           The "rules" of OO can be perfectly valid and accepted in the relational world, as long as it is recognised that the <a href="RelationalModel.html">RelationalModel</a> is categorically <strong>not</strong> an alternative to OO (or vice-versa), but is simply an expressive and composable means for defining and manipulating collections of values.  The <a href="RelationalModel.html">RelationalModel</a> and OO approaches complement each other.  OO and Relational are only "at odds" when one tries to force a 'tuple/row' = 'class instance' equivalence.  That equivalence is demonstrably wrong, and has been persuasively debunked by <a href="HughDarwen.html">HughDarwen</a> and <a href="ChrisDate.html">ChrisDate</a> in <a href="TheThirdManifesto.html">TheThirdManifesto</a>.  If one uses a 'tuple attribute value / row^column intersection' = 'class instance' equivalence, then an implementation of the <a href="RelationalModel.html">RelationalModel</a> within an OO language simply (and powerfully) adds Relation and Tuple to the usual Stack, Vector, Hash, Map, etc. collection classes.  Conversely, an implementation of the OO model within a <a href="RelationalLanguage.html">RelationalLanguage</a> simply (and powerfully) provides a useful means for defining tuple attribute types.  It is not the case that <a href="RelationalBreaksEncapsulation.html">RelationalBreaksEncapsulation</a> -- any more than using any other collection mechanism or type definition system breaks encapsulation. -- <a href="DaveVoorhis.html">DaveVoorhis</a>
        </li>
      </ul>
      <p>
        <em>Functional and procedural don't actually break encapsulation.  Functional accepts only those parameters to a function that you offer it, and so never needs to peek under someone else's skirt.  Procedural performs as requested of it, which may involve sending messages to or accepting messages from other components... but it needn't knowledge of or access to how those other components are implemented.</em>
      </p>
      <hr/>
      <p>
        <a href="ObjectVsModel.html">ObjectVsModel</a>, <a href="RelationalBreaksEncapsulation.html">RelationalBreaksEncapsulation</a>, <a href="JulyZeroSeven.html">JulyZeroSeven</a> (for this an the related pages)
      </p>
    </div>
  </body>
</html>