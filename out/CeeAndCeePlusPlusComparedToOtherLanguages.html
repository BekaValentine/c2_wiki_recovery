<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Cee And Cee Plus Plus Compared To Other Languages
      </h1>
      <p>
        <strong>C/C++ (</strong><a href="CeeCeePlusPlus.html">CeeCeePlusPlus</a>) compared to <a href="RubyLanguage.html">RubyLanguage</a><strong></strong>
      </p>
      <p>
        Let's start with Ruby: what does Ruby do that C++ cannot do?
      </p>
      <ul>
        <li>
           Lets you write the same program in much less time.
        </li>
        <li>
           Lets you write the same thing in far fewer lines, which means fewer bugs and more understandability.
        </li>
        <li>
           Has built-in support for many things that require constant regurgitation of tedious idioms in C (e.g. iterating through a sequence)
        </li>
        <li>
           Lets you extend the language without resorting to using an error-prone text-substuting preprocessor
        </li>
        <li>
           Provides pleasure instead of the urge to tear your hair out.
        </li>
        <li>
           Eliminates a vast class of memory-related bugs
        </li>
        <li>
           Lets you test out code interactively in the interpreter
        </li>
      </ul>
      <p>
        What does C or C++ do that Ruby cannot do?  <em>I would love to see counter-examples for any of the following. -- </em><a href="DevilsAdvocate.html">DevilsAdvocate</a><em></em>
      </p>
      <ul>
        <li>
           Write device drivers.
        </li>
        <li>
           Write embedded code.
        </li>
        <li>
           Write code <a href="AsFastAsCee.html">AsFastAsCee</a>
          <ul>
            <li>
               <em></em><a href="DevilsAdvocate.html">DevilsAdvocate</a>: <a href="http://shootout.alioth.debian.org/gp4/benchmark.php?test=regexdna&lang=all">http://shootout.alioth.debian.org/gp4/benchmark.php?test=regexdna&lang=all</a> (Not a repeat performance, though.) See also RubyInline<em></em>
            </li>
          </ul>
        </li>
        <li>
           Write shrink-wrapped consumer applications.
          <ul>
            <li>
               <em></em><a href="http://www.enterbrain.co.jp/tkool/RPG_XP/eng/newfunctions.html">http://www.enterbrain.co.jp/tkool/RPG_XP/eng/newfunctions.html</a> -- Sufficiently shrink-wrapped?<em></em>
            </li>
          </ul>
        </li>
        <li>
           Embed assembly.
          <ul>
            <li>
               <em></em><a href="http://www.zenspider.com/ZSS/Products/RubyInline/">http://www.zenspider.com/ZSS/Products/RubyInline/</a> -- It can inline C and C compilers can inline assembly...<em></em>
            </li>
          </ul>
        </li>
        <li>
           Encourage <a href="OpenSource.html">OpenSource</a> collaboration (<em>sucks, but true; </em><a href="OpenSource.html">OpenSource</a> is a PopularityContest<em>).</em>
          <ul>
            <li>
               <em></em><a href="RubyOnRails.html">RubyOnRails</a>?<em></em>
            </li>
          </ul>
        </li>
        <li>
           Write code portable to <insert obscure platform> (<em>maybe ignorant; how portable is the Ruby engine?</em>)
          <ul>
            <li>
               <em></em><a href="http://en.wikipedia.org/wiki/Ruby_programming_language#Operating_systems">http://en.wikipedia.org/wiki/Ruby_programming_language#Operating_systems</a> -- <em>Some</em> consumer electronics missing - Palm and iPod, for instance<em></em>
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <em>This list was a bit dated. Maybe all but the top four should be removed. --</em><a href="JesseMillikan.html">JesseMillikan</a><em></em>
      </p>
      <p>
        <em>Both can do the same things--any program written in one can be written in the other, given enough time and effort.</em> <strong>Please read </strong><a href="TuringTarpit.html">TuringTarpit</a>.<strong></strong>
      </p>
      <p>
        <em>Ruby is most frequently used in scripting applications.  It is a </em><a href="DynamicallyTyped.html">DynamicallyTyped</a> language, and usually interpreted.  Contrast with C++, which is <a href="StaticallyTyped.html">StaticallyTyped</a> and usually compiled to machine instructions.<em>  </em>
      </p>
      <hr/>
      <p>
        <strong>C/C++ compared to </strong><a href="PythonLanguage.html">PythonLanguage</a><strong></strong>
      </p>
      <p>
        Python being the big winner of the <a href="ShortestWikiContest.html">ShortestWikiContest</a>.
        <em>See Ruby</em>
      </p>
      <hr/>
      <p>
        <strong>C/C++ compared to </strong><a href="DelphiLanguage.html">DelphiLanguage</a><strong></strong>
      </p>
      <p>
        <em>Delphi is an object-oriented extension to Pascal.  It's pretty much supported by one particular vendor, and designed for business applications.  Personally, I would only use Delphi for legacy stuff--meaning code which is written for an existing system implemented in Delphi.  Nothing against the language per se, just that it isn't something freely available and portable to lots of different platforms</em>
      </p>
      <p>
        There are at least 2 open source implementations of Delphi, and besides that a freely downloadable GPL distribution from Borland for educational purposes. 
      </p>
      <p>
        One Open Source implementation (www.freepascal.org) runs on 5 architectures and 20+ OSes, and that count is still increasing monthly
      </p>
      <hr/>
      <p>
        Perl and Python are scripting languages. C and C++ are system languages.
        They are different types of languages, for different applications.
      </p>
      <hr/>
      <p>
        <strong>C/C++ compared to </strong><a href="VisualBasic.html">VisualBasic</a><strong></strong>
      </p>
      <p>
        What does <a href="VisualBasic.html">VisualBasic</a> do that C or C++ cannot do?
      </p>
      <p>
        When I'm single-stepping through a program, looking at the source code in the debugger, I can (usually) change the code and continue stepping through the new code. With all the C development environments I know about, any change to the code requires a recompile before I can step through the new code. <em>MSVC has supported Edit and Continue since version 6.0 for small changes (no type changes).</em>
      </p>
      <p>
        What does C or C++ do that <a href="VisualBasic.html">VisualBasic</a> cannot do?
      </p>
      <ul>
        <li>
           I can embed assembly language in C and C++
        </li>
        <li>
           (device drivers cannot be written in <a href="VisualBasic.html">VisualBasic</a>).
        </li>
        <li>
           One has to go through the routine of declaring a Function every time one has to use an API in <a href="VisualBasic.html">VisualBasic</a>, unlike C++ where it is already declared in the .h file
        </li>
        <li>
           <a href="VisualBasic.html">VisualBasic</a> is available only on Windows
        </li>
      </ul>
      <hr/>
      <p>
        <strong>C/C++ compared to </strong><a href="PostScript.html">PostScript</a>/<a href="ForthLanguage.html">ForthLanguage</a><strong></strong>
      </p>
      <p>
        What does <a href="PostScript.html">PostScript</a>/Forth do that C or C++ cannot do?
      </p>
      <ul>
        <li>
           As soon as I type in a "function" in <a href="PostScript.html">PostScript</a>/Forth, it gets compiled and I can immediately execute that function from the command-line. C/C++ seems to require some sort of "test subroutine" and a much longer edit-compile-run cycle.
        </li>
        <li>
           Factor into smaller functions with less penalty.
        </li>
        <li>
           Extend the compiler and add new syntax within the language.
        </li>
        <li>
           Develop and debug device drivers interactively.
        </li>
      </ul>
      <p>
        What does C or C++ do that <a href="PostScript.html">PostScript</a>/Forth cannot do?
      </p>
      <ul>
        <li>
           There don't seem to be many good IDEs for Forth. Yet.
        </li>
      </ul>
      <p>
        [Now hold on a doggone minute! Forth IS ITS OWN IDE! And an interactive one at that!  Just because it doesn't have the "slick" look some are used to doesn't mean it's not extremely powerful -- it is.  Forth is a programming language, a compiler, an editor, a methodology, an IDE, and a floor wax all in one package.
      </p>
      <ul>
        <li>
           Libraries are not very standardized or complete.  The ANS Forth standard has very minimal library support compared to C and C++ standard libraries.  (<a href="PostScript.html">PostScript</a>, of course, only has "libraries" to deal with print and graphics issues.)
        </li>
      </ul>
      <p>
        [Its a semantic thing.  In Forth, rather than "libraries," it has "vocabularies" and "wordlists."  There are many of them, but one of the main tenets of Forth is to only code what you need, and libraries carry a lot of baggage with them.  In Forth, adding and using a few well-chosen "words" may be all one really needs.
      </p>
      <ul>
        <li>
           It seems the main thing Forth does that C and C++ do not do is carry an ideology around with it. Related is the desire of Forth proponents to unask or redefine questions such that Forth is already the answer; if a problem doesn't quite fit on the Procrustean bed of what Forth excels at, parts of it get chopped off.
        </li>
      </ul>
      <hr/>
      <p>
        <strong>C/C++ compared to all other languages</strong>
      </p>
      <p>
        What would you do in C/C++ that you wouldn't do in any other language? <em>Interface with an OS that exposes a C/C++ API?</em>
      </p>
      <p>
        Ignoring for a moment the whole turing-complete line of argumentation, I can write device-drivers, DSP code, code for small embedded systems in a language that allows both close control over the generated machine code and use of high-level object oriented and generic programming constructs. Whew! --<a href="AndrewQueisser.html">AndrewQueisser</a>
      </p>
      <p>
        [You know, preferences aside -- Forth can do all these things; in fact, it excels at each of them.  One could even easily argue that Forth does these particular things better and more easily than C/C++.]
      </p>
      <p>
        I would write robust, secure, and fast code with modern C++ idioms including specifically RAII. - SmugCppWeenie
      </p>
      <ul>
        <li>
           <em>Please define what you mean by "secure"... - Smug </em><a href="ObjectCapabilityModel.html">ObjectCapabilityModel</a> Weenie.<em></em>
        </li>
      </ul>
      <hr/>
      <p>
        <a href="CategoryComparisons.html">CategoryComparisons</a> <a href="CategoryCee.html">CategoryCee</a> <a href="CategoryCpp.html">CategoryCpp</a>
      </p>
    </div>
  </body>
</html>