<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Graphical User Interface
      </h1>
      <p>
        A form of <a href="UserInterface.html">UserInterface</a> in which information is presented in the form of pictures, usually on a bitmapped display, and often controlled by a pointing device (mouse, touch screen, etc.).  Known also by the acronym GUI (pronounced "gooey").
      </p>
      <p>
        Invented over many years by a bunch of researchers, prominent among them <a href="DougEngelbart.html">DougEngelbart</a>.
      </p>
      <p>
        Given a good strong push by Xerox at <a href="XeroxParc.html">XeroxParc</a> in the 1970s.
      </p>
      <p>
        Improved and popularized by <a href="AppleComputer.html">AppleComputer</a> with their 1983 Lisa and 1984 Macintosh lines of computers.
      </p>
      <p>
        Mated with Unix (as all technologies eventually are) in the form of the X windowing system (a.k.a. "X Windows") in the late 1980s.
      </p>
      <p>
        Further changed by Microsoft, who probably have the most GUI instances in the field at the 
        moment.
      </p>
      <p>
        See <a href="WimpInterface.html">WimpInterface</a>, <a href="CommonUserAccess.html">CommonUserAccess</a>. Contrast with: <a href="CommandLineInterface.html">CommandLineInterface</a>
      </p>
      <p>
        What about a <a href="CommandLineGuiCombo.html">CommandLineGuiCombo</a>?
      </p>
      <hr/>
      <p>
        GUIs are generally recognized as being very good for visual tasks, especially document editing and some common kinds of file management, and helping the user perform uncommon or unfamiliar tasks.
      </p>
      <p>
        Many more-complicated tasks can be more easily accomplished with a character-based language, which is why the <a href="CommandLineInterface.html">CommandLineInterface</a> is still around.
      </p>
      <hr/>
      <p>
        GUIs should really be implemented using some variation on <a href="ModelViewController.html">ModelViewController</a> because the rate of change of the presentation is different from the rate of change of the underlying logic. <a href="TheHumbleDialogBox.html">TheHumbleDialogBox</a> explains how to do this, under the assumption your controls are simple and ready-made. In practice, many GUIs are implemented in a hairball of mixed model/presentation code that makes everything, beginning with testing, difficult.
      </p>
      <hr/>
      <p>
        <em>Many more-complicated tasks can be more easily accomplished with a character-based language, which is why the </em><a href="CommandLineInterface.html">CommandLineInterface</a> is still around.<em></em>
      </p>
      <p>
        This is a widely held and unsupported myth. First, the specification of what "more-complicated" means is unspoken. Next, this undefined "complexity" is cited as <em>the</em> reason why the <a href="CommandLineInterface.html">CommandLineInterface</a> is still around -- when in fact, another undefined term is what we mean by "still around", another is "<a href="CommandLineInterface.html">CommandLineInterface</a>", and so on and so forth. Further, the essential characteristic of the <a href="GraphicalUserInterface.html">GraphicalUserInterface</a> is NOT that its information is in the form of pictures, but is instead that the interface is constructed using a noun-verb paradigm. A <a href="GraphicalUserInterface.html">GraphicalUserInterface</a> can be and has been constructed using a character-based language.
      </p>
      <p>
        The "selection" of the object to which a command is to be applied is commonly (in a <a href="GraphicalUserInterface.html">GraphicalUserInterface</a>) made using a mouse or similar pointing device, but does not have to be. Once a selection has been made, in fashion, the set of "commands" appropriate for that object can be narrowed and presented to the user, and then interpreted in the context of the selected object. This is what allows "open" to be a meaningful user operation for a file, a folder, an email, and so on. While its true that select-and-click using a mouse is well-supported, its also true that a command line could be constructed that says "/usr/foo/bar/somefile.c open".
      </p>
      <p>
        The key attribute of an icon-oriented user interface is that it presents a limited number of objects. Various human factor studies have demonstrated that for a limited number of items, we recognize spatial position more effectively than other choices. Interestingly enough, this recognition is <strong>hurt</strong>, not helped, when those objects are gridded in a uniform array. Our senses recognize and remember <strong>disordered</strong> collections of a limited number of shapes (estimates of the number vary from something like 7 to something like 20). Most of us, with only a little practice, "see" groups of up to five things without having to count them individually. When a choice has to be made from more than whatever that number of objects is, then textual labels are much more effective than anything else, especially when they are sorted in some order. This does not, however, mean that a <a href="CommandLineInterface.html">CommandLineInterface</a> is more suited for "complex" tasks. It means only that navigational selection is not as effective with a large number of choices.
      </p>
      <p>
        There are a host of reasons why the <a href="CommandLineInterface.html">CommandLineInterface</a> (whatever that means) is still around (whatever THAT means). Some reasons are:
      </p>
      <ul>
        <li>
           Old software and systems that are still in use
        </li>
        <li>
           Groups and individuals that view <a href="CommandLineInterface.html">CommandLineInterface</a> as "strong" and <a href="GraphicalUserInterface.html">GraphicalUserInterface</a> as "weak".
        </li>
        <li>
           Job security
        </li>
        <li>
           Elitism
          <ul>
            <li>
               Some people dislike using a mouse
            </li>
          </ul>
        </li>
      </ul>
      <p>
        The factors that drive this perception strike me as related to factors that drive the use of "terse" languages like Perl. This is not to be necessarily judgemental for or against Perl or <a href="CommandLineInterface.html">CommandLineInterface</a>s -- it is to say that whatever the factors are, there are many of them, and most of them have little or nothing to do with things like complexity or ease of use.
      </p>
      <p>
        <em>It is unclear to me exactly what the above is arguing. I would ask the writer, or anyone else supporting GUIs as the best way to interact with a computer, how can I, using a GUI, accomplish the following:</em>
      </p>
      <dl>
        <dt> </dt>
        <dd><strong>find . -type f -exec md5sum '{}' ';' | \</strong></dd>
      </dl>
      <dl>
        <dt>	 </dt>
        <dd><strong>gawk '{m[$1]=m[$1] " " $2;c[$1]++}END{for (i in m) print c[i],m[i]}' | \</strong></dd>
      </dl>
      <dl>
        <dt>	 </dt>
        <dd><strong>sort -rn | less</strong></dd>
      </dl>
      <p>
        <em>which finds all multiple occurrences of files starting in the current directory. Forcing one interface or the other loses the opportunity to combine the strengths of both, and denies the existence of different ways of thinking.</em>
      </p>
      <p>
        [Indeed. A <a href="CommandLineInterface.html">CommandLineInterface</a> is essentially a textual programming language with an extremely low overhead to do useful things (zero lines of <a href="BoilerPlateCode.html">BoilerPlateCode</a>: no 'void main', no 'import Filesystem', etc.). If our <a href="OperatingSystem.html">OperatingSystem</a>s' GUIs were based on <a href="GraphicalProgrammingLanguage.html">GraphicalProgrammingLanguage</a>s, perhaps we would achieve a similar level of facility. As it is, most GUI content is programmed in textual languages, and the overhead is significant enough to stop most people before they bother starting (a huge <a href="OpportunityCost.html">OpportunityCost</a>!).]
      </p>
      <hr/>
      <p>
        I like express the "GUI problem" with simpler examples. Take a typical "use cases":
      </p>
      <ul>
        <li>
           update files from cvs and compile
        </li>
      </ul>
      <p>
        (Any similar "do X then Y' use case would suffice. For example, a few days ago I wanted to "defrag hard-disk (overnight) and shutdown when done".).
      </p>
      <p>
        The GUI mindset approaches this use case by says "lets create menu item (or button, whatever) that expresses this use case. This is natural, because GUIs are gramatically weak: they (in general) have no way to express this type of relationship. Some will let you create a user-defined macro for the conjunction (and then associate it with a menu/button/keypress/whatever).
      </p>
      <p>
        The CLI appraoch doesn't need any of this, because the underlying grammar of the CLI has this built in. Even if you had such a weak shell that you couldn't do
      </p>
      <code>
        cvs update && make<br/>
      </code>
      <p>
        You could still use type-ahead to do:
      </p>
      <code>
        cvs update<br/>
        make<br/>
      </code>
      <p>
        When the first command is complete, the second will run. This would be a fundamentally undesirable behavior in a GUI, because when something doesn't happen immediately, there's a natural tendency to hit the menu/button/keypress again.
      </p>
      <p>
        <em>This problem is trivially solved, through the use of command objects and a scripting interface. For example, Macintosh users did things like this with </em><a href="AppleScript.html">AppleScript</a> or Hypercard. The scripting tool allows the user to create a command object, which understands verbs like "Do It" and "Undo It". One command object is created for "CVS Update", another for "make". The two command objects are chained into another command object (yes, they compose). Click "do it" and it's done. The CLI interface is "easier" only if you have already memorized the shell language.<em></em>
      </p>
      <p>
        I think that reply proves my point. The GUI approach to the use-case "do foo and then bar" is to create a new "command object" that implements the composition (A lot of newbie OO programmers suffer the same affliction). The CLI approach doesn't need such a "command object" to be created via a "scripting language" because the interface metaphore is already a script. It doesn't require the composition to be expressed (encapsulated) as a tangible thing because the metaphore is already based on serialization (and there's no additional shell language to learn: you just type the commands and hit the 'return' key at the end of each one). If one wants to reuse the specific sequence multiple times then, of course, in either interface you would create a separate object, script or alias to represent it.
      </p>
      <p>
        <em>"You just type the commands..." -- conveniently skipping over the part where you memorize all of them. Then memorize the switches and arguments of each one. Then remember the ones where the arguments go in a different order. Then remember the ones that pipe and the ones that do not. The "scripting language" in a decent GUI doesn't need to be memorized or learned, the system just remembers it. Go back and look at </em><a href="AppleScript.html">AppleScript</a>, in the Macintosh ca 1988.<em></em>
      </p>
      <p>
        You keep trying to avoid the issue. My initial postulate was that you knew the two commands that you wanted to run, so the question of knowing options, etc. is moot. Whichever interface one is using, creating a script is trivial -- but what if you just want to do "a then b" without creating a "script"?. My point was that the CLI metaphor is more closely aligned with that concept than is the GUI. That isn't even really a value-judgement: if ad-hoc composition is not a primary value, then it doesn't matter that such scripting is not the defining characteristic of the GUI metaphor.
      </p>
      <p>
        <em>Your "initial postulate" assumes away the issue. "Assuming pigs could fly, then ..." I think you're assuming the outcome of the argument you're trying to make. I don't see this exchange getting anywhere. I made the mistake of thinking you were interested in learning how a GUI addresses a certain class of problems. I'm not interested in perpetuating the GUI vs CLI religious war that has been going on for two decades now.</em>
      </p>
      <p>
        I think you're right: no light was shed. These wars are of no interest to me either. I tried hard to avoid making any value-statements that might perpetuate such wars but I was obviously unsuccessful, for which I am sorry. Your belief in my aim in my original statement does indeed appear mistaken. I did indeed "assume away" the issue you wanted to address (syntax/vocabulary), because that is not the issue that I was trying to explore (grammar). I appologise for my inability to clearly express the thoughts that I was attempting to express.
      </p>
      <p>
        <em>"The GUI mindset"? "Grammatically weak"? I accept your apology, it does appear that you failed to avoid making value statements. If it is "grammar" that interests you, then perhaps it might be more constructive for us to explore the question of visual versus lexical grammars -- perhaps a contrast-and-compare or something similar.</em>
      </p>
      <p>
        [Regardless of whether <strong>he</strong> was making value statements, it is possible to <strong>objectively</strong> say that it is rare for GUIs to support a syntax more complicated than "ACTION <noun_list>" or "NOUN <action_list>", whereas it is common for CLIs to support more complex syntax. That's not a value judgement, that's a linguistic description...is it ok with you so far? If so, then I, for one, would be interested to hear more about what more complex kinds of visual grammars you are aware of, beyond those common ones.]
      </p>
      <ul>
        <li>
           <a href="DragAndDrop.html">DragAndDrop</a>:  ACTION <object> <subject>
          <ul>
            <li>
               In the <a href="MacOsx.html">MacOsx</a> <a href="InterfaceBuilder.html">InterfaceBuilder</a>, I've also seen this used to define relations.
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <p>
        The best of GUIs complement and support the best of CLIs, and vice versa. I prefer KDE Konsole because it leaves several shells open in one window, for example, with copy-n-paste between them.
      </p>
      <p>
        In a CLI, you can arrow up and edit your command. You can write long complex commands; writing commands is separate from initiating them. This is a good thing <em>when you decide to use it</em>. In theory, the decision to use one or the other kind should not be imposed upon you. In normal practice, lazy programmers only implement one side of this equation. --<a href="PhlIp.html">PhlIp</a>
      </p>
      <p>
        Absolutely. And with new utilities like <a href="QuickSilver.html">QuickSilver</a>, the lines between GUI and CLI can be blurred, to the benefit of both. -- <a href="RobertDaeley.html">RobertDaeley</a>
      </p>
      <hr/>
      <p>
        <strong>Touch-screen versus Mouse - Merger Prediction</strong>
      </p>
      <p>
        Tablets and smartphones are making touch interfaces more common and popular. It's often presented as an either/or run-off between the mouse and the finger (touch-based). But I predict in the future that an office interface will have both kinds of interfaces and that a tablet will replace the mouse. One will sometimes use (look at) the tablet directly, and other times use it like a mouse, controlling the cursor for the upright screen, similar to the touch-pad on some laptops, but with greater size and movement room because a tablet is a larger surface. The upright screen will sometimes mirror the tablet screen, and sometimes be a 2nd screen which has different content than the tablet. One will switch the method or mode as needed.  In some cases, the "tool bar" may only appear on the tablet, but larger, such that the main screen is freed up to show the document or content.
      </p>
      <p>
        The tablet may have to better recognize multiple fingers and identify the pointing finger (or user-chosen finger choice), otherwise, holding all but one finger up all day is taxing on the hand. One will also typically grab the "ex-mouse" tablet for meetings so that they have their full (or virtual) desktop with them for reference or quick demos.  
      </p>
      <p>
        --top, Jan. 2013
      </p>
      <p>
        <em>and you will take the tablet home and use it as a remote control for your television set, and your boss will pop up on the television set and tweet to you on the tablet that you are watching the same tv show</em>
      </p>
      <ul>
        <li>
           This is already sort of the case with Apple's Magic TrackPad.
        </li>
      </ul>
      <ul>
        <li>
           <em></em>TrackPad has no screen. A tablet is basically a TrackPad with a screen. But it helps illustrate the general idea, so thanks for the tip.<em></em>
        </li>
      </ul>
      <hr/>
      <p>
        Gripe: Don't include default screen-savers or wall-paper with pretty flowers or birds or whatnot. Most guys hate that, especially if it takes a while to figure out where to change it. Find something more generic that is less likely to offend somebody.
      </p>
      <p>
        <em>You're offended by flowers and birds??? And you think "most guys" are offended too? *boggle*  Speaking as a guy, I've never noticed.  What </em>'aren't<em>' you offended by?</em>
      </p>
      <p>
        Here is your new screen-saver. Call it "God handing out your report card".
      </p>
      <p>
        <img src="http://apod.nasa.gov/apod/image/0306/carina_hst.jpg" />
      </p>
      <p>
        <em>That's brilliant.  For the next twenty minutes, I'm going to respect you a little.</em>
      </p>
      <p>
        [Awesome pic. But I'm a bit lost on how it's on-topic.]
      </p>
      <p>
        It's evidence that God's UI is gesture-based.
      </p>
      <hr/>
      <p>
        <a href="CategoryUserInterface.html">CategoryUserInterface</a>
      </p>
    </div>
  </body>
</html>