<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Git Version Control
      </h1>
      <p>
        Git is a free & open source, distributed version control system designed to handle everything from small to very large projects with speed and efficiency. 
      </p>
      <p>
        Every Git clone is a full-fledged repository with complete history and full revision tracking capabilities, not dependent on network access or a central server. Branching and merging are fast and easy to do.
      </p>
      <p>
        See <a href="http://git-scm.com/">http://git-scm.com/</a>
      </p>
      <p>
        GIT is a "directory content manager" designed to handle absolutely massive projects with speed and efficiency, and the release of the 2.6.12 (and later) versions of the <a href="LinuxKernel.html">LinuxKernel</a> as well as more and more other projects switching to it would indicate that it does this task well.
      </p>
      <p>
        GIT was initially written by <a href="LinusTorvalds.html">LinusTorvalds</a> (to replace <a href="BitKeeper.html">BitKeeper</a>) with help of a group of hackers 'round the net. It is currently maintained by Junio C Hamano.
      </p>
      <p>
        Git is tuned to the workflows of large, distributed, multi-branch <a href="OpenSource.html">OpenSource</a> projects.
      </p>
      <p>
        Other <a href="DistributedVersionControl.html">DistributedVersionControl</a> systems include <a href="MercurialVersionControl.html">MercurialVersionControl</a>, <a href="SvkVersionControl.html">SvkVersionControl</a>, <a href="GnuArch.html">GnuArch</a>, <a href="MonoTone.html">MonoTone</a>, and DARCS (<a href="DavidsAdvancedRevisionControlSystem.html">DavidsAdvancedRevisionControlSystem</a>).
      </p>
      <hr/>
      <p>
        <strong>Q.</strong> <em>So how does this compare to </em><a href="SubVersion.html">SubVersion</a> and <a href="SvkVersionControl.html">SvkVersionControl</a>?<em></em>
      </p>
      <p>
        <strong>A.</strong> <a href="SubVersion.html">SubVersion</a> is intended to be an advanced <a href="ConcurrentVersionsSystem.html">ConcurrentVersionsSystem</a>, with more modern underpinnings. As such, SVN kept the "checkout from a remote repository" paradigm and direct compatibility with most of CVS's commands. However, both SVN and SVK are slow, even compared with CVS. And if you lose your connection to the SVN server, then you are out of luck.
      </p>
      <p>
        "And if you lose your connection to the SVN server, then you are out of luck." - <em>It goes a bit deeper than that. After all, you can work around an intermittent connection to your SVN or CVS server. (The </em><a href="BestPractice.html">BestPractice</a> encouraged by modern <a href="GnuEmacs.html">GnuEmacs</a> installs seems to be that you run your own local <a href="VersionControl.html">VersionControl</a> server and frequently commit all your little minute-by-minute changes and branches to that. Then when you synchronize with the "real" repository the image that you use is drawn from the head of your local server.) The fundamental difference is that Git really is distributed - it has no concept of a "central" or canonical server or version-tree, or even of a hierarchial tree of more and less central repositories. In practice, development does tend to follow those patterns, of course. But in a version-control system that assumes or relies on them, any behaviour that doesn't neatly fit the model is poorly supported and requires extra effort (like setting up a local VC repository as described above). Plausible examples of such behaviour:<em></em>
      </p>
      <ul>
        <li>
           <em>You create and try out three or four possible versions of a new function while offline at 12,000m, then land and send the alternatives to some colleagues back home for advice on which to choose. Your friends offer their opinions and suggest some changes, catching a bug in one of the alternatives. Finally you choose and commit one of the versions to a public repository.</em>
        </li>
      </ul>
      <ul>
        <li>
           <em>Two or more different versions of a piece of software are maintained by different projects. They periodically cooperate by exchanging code. (This is somewhat close to what actually happens in Linux development, which is why the CVS/SVN model fits it poorly.)</em>
        </li>
      </ul>
      <p>
        <em>Git naturally supports such actions. In a slogan, Git provides </em><a href="MechanismNotPolicy.html">MechanismNotPolicy</a>.<em></em>
      </p>
      <p>
        SVK is closer in principle to Git, with its mirrored repositories, advanced branching, and <a href="CherryPicking.html">CherryPicking</a>. Still much slower than Git, though.
      </p>
      <p>
        On the other hand, Git has a richer (and totally different) command set, and thus a steeper learning curve. Since Git encourages you to branch and merge a lot, there are more opportunities to screw up your repository and repositories you merge back into. I liken Git to the power/responsibility of the Unix command line. There are also convenience layers for Git, such as Cogito, which make it easier to use.
      </p>
      <p>
        While git certainly provides plenty of opportunity to screw up your repository, it also makes it easy enough to undo your changes, and provides a handy GUI tool (<em>gitk</em>) so that you can see the structure of your repository. It thus encourages you to <a href="CommitEarlyAndOften.html">CommitEarlyAndOften</a>.
      </p>
      <p>
        See also <a href="http://git.or.cz/course/svn.html">http://git.or.cz/course/svn.html</a> (Git for SVN users).
      </p>
      <p>
        <em>As of 2011, there's </em>MsysGit to run Git on Windows (you can get Git with <a href="CygWin.html">CygWin</a> as well).<em></em>
      </p>
      <p>
        In 2010 there are now GUI interfaces called <em>gitk</em> <em>git-gui</em> and <em>gitg</em>. There are others including a version of <a href="TortoiseSvn.html">TortoiseSvn</a>.
      </p>
      <hr/>
      <p>
        "And if you lose your connection to the SVN server, then you are out of luck." -- I have never had any problem with this -- just run:
      </p>
      <code>
        svn cleanup<br/>
      </code>
      <p>
        at the root of your project tree, and retry the operation.  It has <em>always</em> worked for me, and it even properly resumes where it left off the last time.
      </p>
      <p>
        That being said, I <em>love</em> <a href="GitVersionControl.html">GitVersionControl</a> far more than I like SVN, and strongly advocate its use whenever possible.  However, I've had the unfortunate experience of using git-svn on a highly unreliable network.  I have discovered this isn't such a good thing.  git-svn cannot properly resume after a failed network connection, and as a result, it leaves not only the svn meta-information in a corrupted state, it ALSO leaves the git meta-information in a corrupted state too!  In short, <strong>don't even think</strong> of using git-svn over flakey networks.
      </p>
      <p>
        I have not yet had the opportunity to test raw git over a flakey connection, so please don't ascribe my git-svn experiences to git proper.  I'm just writing a heads-up for those who are thinking of employing git-svn on a network that is potentially unreliable. --SamuelFalvo
      </p>
      <ul>
        <li>
           In years of heavy Git use, the only network-related issues I have had have involved git-svn. My experience suggests that although git-svn is not fault-tolerant when dealing with network problems, Git itself is. I wouldn't hesitate to use Git on a flaky network, as long as I didn't have to use git-svn. --<a href="MarnenLaibowKoser.html">MarnenLaibowKoser</a>, 12 Dec 2012
        </li>
      </ul>
      <hr/>
      <p>
        See also <a href="GitHub.html">GitHub</a>, <a href="GitWorkFlow.html">GitWorkFlow</a>
      </p>
      <hr/>
      <p>
        <a href="CategorySoftwareTool.html">CategorySoftwareTool</a> <a href="CategoryConfigurationManagement.html">CategoryConfigurationManagement</a>
      </p>
    </div>
  </body>
</html>