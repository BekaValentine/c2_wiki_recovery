<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Strict Typing Isa Test
      </h1>
      <code>
        From <a href="UnitTestsReconsidered.html">UnitTestsReconsidered</a>::	<em>"</em><a href="StrictTypingIsaTest.html">StrictTypingIsaTest</a> -- one that the compiler executes."<em></em><br/>
      </code>
      <p>
        <strong>There are other ways to test.</strong>
      </p>
      <p>
        In C++, the compiler is a big hunk of a <a href="UnitTest.html">UnitTest</a>s. Use it. It will help catch many really bad bugs. Moreover, good programming practices like <a href="SmartPointer.html">SmartPointer</a>s and assert()ions eliminate bugs that would otherwise require testing. In fact, blackbox testing should be the last line of defence to eliminate bugs. Better coding practices are superior because they are more maintainable.
      </p>
      <p>
        If your coding practices are really good--so good that your system remains simple enough to keep the bug count very low--then <a href="UnitTest.html">UnitTest</a>s may not be worth your time. It is possible. It just takes a lot of team maturity to pull it off. 
      </p>
      <p>
        Further, some domains aren't (easily) <a href="UnitTest.html">UnitTest</a>able. Graphics programming, concurrent programming and close-to-the-metal programming are very hard to <a href="UnitTest.html">UnitTest</a>. 
      </p>
      <hr/>
      <dl>
        <dt> </dt>
        <dd>The most bug free application I've ever written (after six months, 24 discovered bugs, mostly in the quickly written GUI) was entirely graphical, concurrent and close-to-the-metal, and it was 200 000 lines of C++ written in seven weeks, so I know it's possible to test those systems without <a href="UnitTest.html">UnitTest</a>s. A lot of <a href="AcceptanceTest.html">AcceptanceTest</a>s, a lot of <a href="TestingByPokingAround.html">TestingByPokingAround</a>, a lot of good coding practices, and a lot of (informal) proofs of correctness. -- <a href="SunirShah.html">SunirShah</a></dd>
      </dl>
      <p>
        <em>Anyone who can write a concurrent 200KLOC program in 49 days with that low a defect density is not being paid enough.  It doesn't even matter what their salary is :-).  I couldn't type 4000 lines in a day, even if I knew exactly what to type.  And keeping it up for 49 straight days would give me a severe case of </em><a href="CarpalTunnelSyndrome.html">CarpalTunnelSyndrome</a>.<em></em>
      </p>
      <p>
        <em>I think I may agree with the conclusion, but the math seems off.  6 months is approximately 26 weeks.  Working 5 days a week, this is 130 days.  This gives slightly over 1500 lines per day, and slightly less than 200 lines per hour, assuming an 8 hour day.  This all comes down to about 3.2 lines per minute.  If I assume approximately 6 words per line (pretty verbose programming), then this can be done by someone who can type 20 words per minute.  Of course, all compilation, testing, etc., has to be done after hours or on the weekends.  I conclude the initial case is vastly overstated, and this whole section should be deleted.</em>
      </p>
      <p>
        I suspect that the critical part is <em>...a lot of (informal) proofs of correctness.</em>
      </p>
      <hr/>
      <p>
        See:
      </p>
      <ul>
        <li>
           <a href="DesignByContractAssertionsVsUnitTestsVsTypes.html">DesignByContractAssertionsVsUnitTestsVsTypes</a>, which says that strict typing is a way of testing.
        </li>
        <li>
           And <a href="UnificationOfStaticTypesAndUnitTests.html">UnificationOfStaticTypesAndUnitTests</a>, which explains which parts of <a href="UnitTest.html">UnitTest</a>s can be replaced by <a href="StaticTypeSafety.html">StaticTypeSafety</a>.
        </li>
      </ul>
      <p>
        <em>Actually, strict typing isn't testing. Testing is a means of </em>externally<em> verifying the system. The type system of the compiler is internal to the system. In dynamic typed environments, you need to explicitly test what in other environments is given a priori. That's not to say that strict typing is good or bad, but it is to say that one should use the environment to its best advantage. The compiler is your friend. I'm amazed people fight </em><a href="ConstCorrectness.html">ConstCorrectness</a>. Also, it's also to say people who claim that testing is needed because in <em>their</em> environments it's useful aren't interesting unless they keep in mind <em>your</em> environment. Context is important.<em></em>
      </p>
      <p>
        Hmm: are <a href="UnitTest.html">UnitTest</a>s external to the system?
      </p>
      <hr/>
      <p>
        Some say <a href="StrictTypingIsaTest.html">StrictTypingIsaTest</a>.  Others say StrictTypingIsAnOptimization.  And we all know about premature optimization. 
      </p>
      <hr/>
      <p>
        As a long time C/C++ programmer, I feel calling Strict Typing a "Test" is vastly overstating the case.  Data typing is largely a product of the language you use and its use is best covered in a <a href="CodingStandard.html">CodingStandard</a>.  Strict Typing is, at best, a trivial test.  I find it does help, however, in the clarity of the code; put it in your coding standard.  -- <a href="WayneMack.html">WayneMack</a>
      </p>
      <p>
        As another experienced C++ programmer, I really don't think this is overstated. Strict typing performs numerous testa that are executed when the compiler examines your code. It catches discrepancies between what you intended to write, and what you did write -- which is ultimately one of the main goals of testing. (Another goal is testing whether what you intended is what's really wanted!) Think about how often you get type errors of one sort or another when compiling new code, and think about what the code might have tried to do at run time if they hadn't been caught. The only question is whether the time spent designing new classes (types), which can be a large portion of your programming time in languages like C++, is offset by time saved in run-time debugging. -- <a href="DanMuller.html">DanMuller</a>
      </p>
      <p>
        with templates and strict typing you can write your own compile time tests (usually by only specialising the template correctly for cases that should work). these sort of compile time template checks are certainly proper tests -- <a href="JamesKeogh.html">JamesKeogh</a>
      </p>
      <hr/>
      <p>
        See <a href="DoesUnitTestingMakeStaticTypingLessUseful.html">DoesUnitTestingMakeStaticTypingLessUseful</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryTesting.html">CategoryTesting</a>
      </p>
    </div>
  </body>
</html>