<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Gee Language
      </h1>
      <p>
        "G" is the <a href="GraphicalProgrammingLanguage.html">GraphicalProgrammingLanguage</a> used in <a href="LabView.html">LabView</a>. It is based on <a href="DataflowProgramming.html">DataflowProgramming</a> (or <a href="FlowBasedProgramming.html">FlowBasedProgramming</a>, although invented independently).
      </p>
      <p>
        <em>Really? The 2003 Labview User Manual </em><a href="http://www.ni.com/pdf/manuals/320999e.pdf">http://www.ni.com/pdf/manuals/320999e.pdf</a> says, in Chapter 1,<em></em>
      </p>
      <dl>
        <dt> </dt>
        <dd>LabVIEW is a graphical programming language that uses icons instead of lines of text to create applications. In contrast to text-based programming languages, where instructions determine program execution, LabVIEW uses dataflow programming, where the flow of data determines execution.</dd>
      </dl>
      <p>
        <em>There is no mention of a "G" language anywhere in the Glossary or Index.</em>
      </p>
      <p>
        Yes, really. See <<a href="http://zone.ni.com/devzone/nidzgloss.nsf/webmain/1097CE3D8B53FBA98625686A00794011">http://zone.ni.com/devzone/nidzgloss.nsf/webmain/1097CE3D8B53FBA98625686A00794011</a>>
        and <<a href="http://www.openg.org">http://www.openg.org</a>>. Also, it's useful to distinguish the <a href="LabView.html">LabView</a> environment and the G language.
      </p>
      <hr/>
      <p>
        Moved from <a href="PrographLanguage.html">PrographLanguage</a>:
      </p>
      <p>
        <em>I've been a fan of </em><a href="GraphicalProgrammingLanguage.html">GraphicalProgrammingLanguage</a>s since the 1970s. On the other hand, none of them so far has been a <a href="SilverBullet.html">SilverBullet</a>. <a href="GeeLanguage.html">GeeLanguage</a>/<a href="LabView.html">LabView</a> is one of the most famous successful ones, but it is a <a href="DomainSpecificLanguage.html">DomainSpecificLanguage</a>.<em></em>
      </p>
      <p>
        Actually there's nothing about the G language itself that is domain-specific. The <a href="LabView.html">LabView</a> components are domain-specific (mainly data acquisition and control), of course, but the programming model isn't.
      </p>
      <p>
        <em>Hmm. But that's the only domain where it's been successfully and nontrivially used, I believe. I've never heard of a single person raving about how great it is for general use. Correct me if I'm wrong.</em> 
      </p>
      <p>
        <a href="GeeLanguage.html">GeeLanguage</a> has been my primary programming language for eight years.  I began using it in grad school as a physics lab teaching assistant, and for the past seven years, I have been employed as an engineer using <a href="LabView.html">LabView</a> in industry.  I have recently used <a href="LabView.html">LabView</a> to create a program that builds icon files from bitmap images, a program that creates and verifies MD5 hashes, a program that creates images for a web page, and a program that translates the InternationalPhoneticAlphabet into other phonetic code forms.  The G language isnt domain specific, but <a href="LabView.html">LabView</a> is limited by the narrow mindedness (maybe stupidity) of National Instruments.  A few examples of this should suffice:
      </p>
      <ul>
        <li>
           <a href="GeeLanguage.html">GeeLanguage</a> has native support for global variables, but not for user defined global constants. (Bad programming style)
        </li>
        <li>
           <a href="LabView.html">LabView</a> doesn't have native object support.  The virtual instrument encapsulates data structures into a front panel, but each front panel can only have a single block diagram associated with it.  Therefore, the virtual instrument is analogous to an object with multiple properties and a single method. (Unthinkable by todays standards)
        </li>
        <li>
           <a href="LabView.html">LabView</a> executables require the <a href="LabView.html">LabView</a> run-time engine to function.  The runtime engine is analogous to the <a href="JavaVirtualMachine.html">JavaVirtualMachine</a>, but unlike the virtual machine, the <a href="LabView.html">LabView</a> runtime engine isn't cross platform.  Therefore, a <a href="LabView.html">LabView</a> executable must be recompiled for each <a href="OperatingSystem.html">OperatingSystem</a>. (Inferior to Java.)
        </li>
        <li>
           The <a href="LabView.html">LabView</a> runtime engine only supports the most recent versions of <a href="MicrosoftWindows.html">MicrosoftWindows</a>, <a href="MacOs.html">MacOs</a>, <a href="MacOsx.html">MacOsx</a>, and <a href="LinuxOs.html">LinuxOs</a>.  There is no support for the vast multitude of other operating systems, including <a href="OpenSource.html">OpenSource</a> and <a href="RealTimeOperatingSystem.html">RealTimeOperatingSystem</a> options available today. (Inferior to <a href="JavaVirtualMachine.html">JavaVirtualMachine</a>.)
        </li>
      </ul>
      <p>
        In my opinion, <a href="LabView.html">LabView</a> was developed by engineers to mimic the schematic diagrams that engineers are most comfortable with.  Unfortunately, the developers at National Instruments never got beyond the engineer mind set to create a true programming language.  The G language isn't domain specific, but National Instruments is.
      </p>
      <hr/>
      <p>
        I agree with the above points. 'G' is quick and easy for general programming. But it is geared towards instrument IO and control. If it didn't require a gigantic runtime, was cross-platform, and was free, I would use it for everything. As you know, after using labview, programming in C++, or Java, is like taking a step backwards, It's like using punch cards to write a GUI.
      </p>
      <hr/>
      <p>
        I'm currently recovering from having programmed in <a href="LabView.html">LabView</a> for about half a year. Though the concepts behind <a href="LabView.html">LabView</a> are fairly interesting (<a href="DataflowProgramming.html">DataflowProgramming</a>, <a href="ConcurrentProgramming.html">ConcurrentProgramming</a>), its execution is so mediocre it makes <a href="CobolLanguage.html">CobolLanguage</a> blush. For example, there is no support for recursion (unless you count reopening the current VI for re-entrant excution, but that's not exactly clear is it?).
      </p>
      <p>
        For the people interested in how it "looks", here is a small program that calculates a Fibonacci-sequence:
      </p>
      <p>
        <img src="http://web.archive.org/web/20070222082851/web.irdc.nl/wouter/2005/labview_fibonacci%2epng" />
      </p>
      <p>
        [ Translation of the Dutch labels: "Iteraties" = iterations, "Resultaat" = result ]
      </p>
      <p>
        -- <a href="WouterCoene.html">WouterCoene</a> <a href="DeleteWhenCooked.html">DeleteWhenCooked</a>
      </p>
      <hr/>
      <p>
        I used Labview to implement a massive suffix array indexer and various other things. It's not unusable for general programming, but I had some complaints about it:
      </p>
      <ul>
        <li>
           Clicking through menus to get a block for "add" is slower than typing +.
        </li>
        <li>
           The block icons are often less clear than a short string.
        </li>
        <li>
           Labview works really badly with other programming languages.
        </li>
        <li>
           SubVIs (the equivalent of function calls) are really cumbersome, each requiring a new file among other things.
        </li>
        <li>
           Being 2 dimensional means you end up spending time moving things around and adjusting connections. If you don't (and some don't!) you can take "spaghetti code" to a new level - actually looking like spaghetti!
        </li>
        <li>
           Sometimes, icons just don't work the way everything you can see says they should, and you have to rebuild something another way.
        </li>
        <li>
           The interface, while convenient for quick things, is very fixed.
        </li>
      </ul>
      <p>
        Think that's harsh? Better keep me away from the Java and C++ pages...
      </p>
      <hr/>
      <p>
        <a href="CategoryProgrammingLanguage.html">CategoryProgrammingLanguage</a> <a href="CategoryControlSystemsSoftware.html">CategoryControlSystemsSoftware</a>
      </p>
    </div>
  </body>
</html>