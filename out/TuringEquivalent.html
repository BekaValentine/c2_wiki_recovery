<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Turing Equivalent
      </h1>
      <p>
        A computing device is <a href="TuringEquivalent.html">TuringEquivalent</a> if, through some single-step transformation function, it can be transformed into a <a href="TuringMachine.html">TuringMachine</a>. If it can't be done by a single-step process, it can simply be called "Turing Capable".
      </p>
      <p>
        <em>What is a "single-step transformation function" and how is it distinguished from a transformation function that involves more steps? How does one measure the number of steps in the first place? Surely the number of steps involved is an implementation issue independent of the transformation's functional specification?</em>
      </p>
      <p>
        Some people use the term "<a href="TuringComplete.html">TuringComplete</a>" to describe this, but I thought that "<a href="TuringComplete.html">TuringComplete</a>" described a <em>problem</em> which can only be solved using a <a href="TuringMachine.html">TuringMachine</a> (i.e., a problem which cannot be solved by a simpler machine such as a <a href="FiniteStateMachine.html">FiniteStateMachine</a> or a PushDownAutomaton).
      </p>
      <p>
        Those people might argue that <a href="TuringEquivalent.html">TuringEquivalent</a> suggests a machine whose behavior is equivalent to that proposed by Alan Turing. But then I would argue that <a href="TuringEquivalent.html">TuringEquivalent</a> is just a shortening of TuringMachineEquivalent.
      </p>
      <p>
        <em>Or "complete" in the sense that such a device is capable of anything a Turing machine is capable - emulate a "complete" Turing machine, in other words.</em>
      </p>
      <p>
        It may be a category error from an analogy with NP-Complete problems. "Is TSP NP Complete?" is an instance of the NP-completeness problem; while "is SQL Turing Complete?" is an instance of the Turing Completeness problem. The fact that TSP is itself a problem doesn't mean that every "Foo-complete" predicate requires its domain of definition to be limited to "problems".
      </p>
      <hr/>
      <p>
        This generally means that one language or tool can theoretically <strong>emulate</strong> the other. This allows say Smalltalk to be able to solve any algorithm that LISP or Java can, and vice versa.
      </p>
      <p>
        Note, however, that <a href="TuringEquivalent.html">TuringEquivalent</a> says nothing about the convenience, speed, maintainability, or coding effort to achieve emulation or equivalence. It only considers whether it is possible. Losing track of this important difference between theory and practice can lead the unwary into the <a href="TuringTarpit.html">TuringTarpit</a>.
      </p>
      <hr/>
      <p>
        "Is SQL Turing Complete?" can be interpreted as asking a question of a <em>class</em> of systems - namely, SQL statements. The question becomes "For any possible computation, does there exist an instance of SQL which performs that computation?"
      </p>
      <p>
        A <em>different</em> question can be asked about whether a given <em>instance</em> of SQL is capable of anything a Turing machine is capable - i.e., that this instance is itself capable of performing any given computation.
      </p>
      <p>
        "Are Turing machines capable of performing any computation?" is true, but is a different question from asking "is <em>this</em> Turing machine: [insert description here] capable of performing any given computation?"
      </p>
    </div>
  </body>
</html>