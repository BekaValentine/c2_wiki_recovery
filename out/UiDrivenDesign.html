<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Ui Driven Design
      </h1>
      <p>
        Related articles:
      </p>
      <ul>
        <li>
           <a href="ModelFirst.html">ModelFirst</a>
        </li>
        <li>
           Adopt a UI-driven architecture by Ash Rofail, jun 1999 at <a href="http://www.devx.com/upload/free/features/entdev/1999/06jun99/fe0699/fe0699.asp">http://www.devx.com/upload/free/features/entdev/1999/06jun99/fe0699/fe0699.asp</a> (October 2004: This link no longer works, and I couldn't find an alternative.)
        </li>
      </ul>
      <p>
        My main questions are:
      </p>
      <ol>
        <li>
           Do <a href="UnitTest.html">UnitTest</a>s favour stateful clients?
        </li>
        <li>
           Could we treat the GUI as a functional test?
        </li>
        <li>
           Should <a href="UserStory.html">UserStory</a> cover the GUI so it is apparent how to code <a href="UnitTest.html">UnitTest</a>s?
        </li>
        <li>
           If <a href="UiDrivenDesign.html">UiDrivenDesign</a> is a dead end, where did I go wrong?
        </li>
      </ol>
      <p>
        In <a href="ModelFirst.html">ModelFirst</a>, the discussions seem to forget that creating the GUI is not an easy task. The conclusion is mainly that if you have well written code, then the GUI is easy to attach on top.
      </p>
      <p>
        I do not agree with that. What is considered well written code depends on the context. How do we know what well written code is to the GUI if we leave it out? The GUI will finally have code which has needs. It is somewhat too late to let it tell us what those are after the unit tests are done, isn't it?
      </p>
      <p>
        Also stateful and stateless clients will need different kinds of code.
      </p>
      <p>
        The other day I was programming a shopping basket and did the regular test-first approach. I ended up with good looking code suiting the stateful very well, but was equally clumsy to my stateless application. My basket object ended up with keeping state when it needed not to, and retrieving persisted state just to do a stateless operation. My tests did not reflect the GUI's needs.
      </p>
      <p>
        -- <a href="ThomasEyde.html">ThomasEyde</a>
      </p>
      <p>
        IMHO you'd avoid this kind of problem by concentrating on developing user stories, rather than back-end code.  The user doesn't care about back-end processing, stateless vs. stateful servers etc.  They only care about how they can interact with the shopping basket through the user interface.
      </p>
      <p>
        Therefore, start with the first story and only develop the code to meet that requirement.  This will result in a simple system with a small amount of UI code and a small amount of back-end code.  Then extend the system to implement the next story, refactoring as necessary.  Develop like this and you will notice any design mismatch between the UI and the backend earlier on in development and probably avoid it altogether.
      </p>
      <p>
        <em>Thank's for the feedback. Agreed, I could develop my stories better. I never saw the </em><a href="UserStories.html">UserStories</a> as a description on how the user reach his goal using the UI (enter text in this field, push that button...), and I am not quite at ease with this approach. You are correct in that the story doesn't care about statefullness and so on, but the UI certainly does. I am not ready to give up this <a href="UiDrivenDesign.html">UiDrivenDesign</a> idea. Perhaps I should do user story, then ui (spike), <a href="UnitTest.html">UnitTest</a>, back-end code, then finish up the ui code.<em></em>
      </p>
      <hr/>
      <p>
        On personal projects I use a quick GUI (see <a href="EarlyPrototyping.html">EarlyPrototyping</a>) <em>as</em> a user story.  There are problems inherent in tacking on a GUI at the last minute, and at the same time there are often technical issues which arise due to the need to support the desired work flow for the user.  I try to strike a balance between building what I might not need (<a href="ModelFirst.html">ModelFirst</a>), and overselling the app/wasting tome on GUI features which are uneeded at the end of the day (<a href="UiDrivenDesign.html">UiDrivenDesign</a>), by making a very early mock version of the program.  I get to check out how the application 'feels', explore possible error states/conflicts due to user interaction, and define the direction of the project.  From there I can do my modeling with a clear eye to the needs of the GUI and look for improvements in the apps  work flow, without being bound to having lots of GUI code slowing me down.  -- AaronCumming
      </p>
    </div>
  </body>
</html>