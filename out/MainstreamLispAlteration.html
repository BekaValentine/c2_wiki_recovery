<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Mainstream Lisp Alteration
      </h1>
      <p>
        I have been kicking around the idea of reworking Lisp or variations of it in order to make it more "palatable to the masses". The motivation is sort of the based on the way that <a href="SmallTalk.html">SmallTalk</a> concepts can be found in Python, but Python is more popular outside of diehard <a href="SmallTalk.html">SmallTalk</a> fan circles. Sure, Smalltalk fans would prefer <a href="SmallTalk.html">SmallTalk</a>, but if there is not a large enough user base, it will be hard to find companies that use it. Thus, a popular language like Python that has <a href="SmallTalk.html">SmallTalk</a> concepts in it may be better for even <a href="SmallTalk.html">SmallTalk</a> fans because it provides a large enough user-base to make finding projects that use a "close enough" language possible. In other words, it is better to be paid to use a language fairly close to <a href="SmallTalk.html">SmallTalk</a> than having to settle for Java and C++ because there are hardly any <a href="SmallTalk.html">SmallTalk</a> projects. One has to "sell-out" a bit to get concepts into the commercial world.
      </p>
      <p>
        Thus, I propose a Lisp-like language with the following bastardizations of Lisp:
      </p>
      <p>
        <strong>Command on the left of parenthesis</strong>
      </p>
      <code>
        foo(a b c d)<br/>
      </code>
      <p>
        instead of 
      </p>
      <code>
        (foo a b c d)<br/>
      </code>
      <p>
        Yes, I know it may reduce some of the meta-power of Lisp. That is a cost of compromise. One may have to have things like 
      </p>
      <code>
        list(q r s t)<br/>
      </code>
      <p>
        Instead of just
      </p>
      <code>
        (q r s t)<br/>
      </code>
      <p>
        Each list (and commands) essentially has one "tag name". If you don't need it, then simply ignore it. It might take up space, but its existence does not prevent anything significant that regular Lisp couldn't do.
      </p>
      <p>
        <em>The interaction style above has a history in the Lisp commnunity.  Search for "Evalquote" or "eval quote" for descriptions of this Lisp top level. --</em>
      </p>
      <p>
        <strong>Have Algo-based control structures (if, while, case) in the standard library</strong>
      </p>
      <code>
        while(condition statement1 statement2 statement3 .... )<br/>
      </code>
      <p>
        Usually written as:
      </p>
      <code>
        while (condition<br/>
        statement1<br/>
        statement2<br/>
        statement3<br/>
        )<br/>
      </code>
      <p>
        If examples
      </p>
      <code>
        if(condition dothis)<br/>
      </code>
      <code>
        if(condition <br/>
        statement1<br/>
        statement2<br/>
        elseif condition<br/>
        statement3<br/>
        else<br/>
        statment4<br/>
        )<br/>
      </code>
      <p>
        "else" and "elseif" are library-defined constants that the IF function/macro knows what to do with. (A macro will be defined simply as a function that has been designated to evaluates its own contents.) 
      </p>
      <p>
        Note that we are abandoning the right-side ending convention of parenthesis.
      </p>
      <p>
        This is just wild <a href="MentalMasturbation.html">MentalMasturbation</a> as this point, so please go easy on the idea.
      </p>
      <p>
        - top
      </p>
      <hr/>
      <p>
        It's not necessarily a bad idea, but you should be aware that it has been done by at least two (relatively) well-known languages: <a href="DylanLanguage.html">DylanLanguage</a> at Apple and CgolLanguage by Vaughn Pratt. And also that <a href="JohnMcCarthy.html">JohnMcCarthy</a> himself originally assumed that eventually there would be a higher level syntax, called M-notation (which is well-defined enough, actually, to approximately implement as a language, except that it used font changes).
      </p>
      <p>
        <em>See also Draft SRFI 49 (Indentation-sensitive syntax) for a proposed Python-like alternative syntax for </em><a href="SchemeLanguage.html">SchemeLanguage</a>, called I-Expressions - <a href="http://srfi.schemers.org/srfi-49/">http://srfi.schemers.org/srfi-49/</a> . Two interesting qualities of I-expressions are that they can be  freely combined with traditional <a href="EssExpressions.html">EssExpressions</a>, and that they can be implemented for any R5RS-compliant Scheme interpreter in only about 50 lines of code.<em></em>
      </p>
      <p>
        The proposal allows mixing I and S-expressions producing a format that is both compact and noise free. Here are samples from the proposal ...
      </p>
      <code>
        define (fac x)<br/>
        if (= x 0) 1<br/>
      </code>
      <ul>
        <li>
           x
        </li>
      </ul>
      <code>
        fac (- x 1)<br/>
      </code>
      <code>
        let<br/>
        group<br/>
        foo (+ 1 2)<br/>
        bar (+ 3 4)<br/>
        + foo bar<br/>
      </code>
      <hr/>
      <p>
        <em>Dylan looks a bit syntax-heavy. Not really a minimalist language.</em>
      </p>
      <p>
        Cgol at foldoc: <a href="http://foldoc.doc.ic.ac.uk/foldoc/foldoc.cgi?query=cgol">http://foldoc.doc.ic.ac.uk/foldoc/foldoc.cgi?query=cgol</a>
      </p>
      <p>
        Cgol source archive: <a href="http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/code/syntax/cgol/0.html">http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/code/syntax/cgol/0.html</a>
      </p>
      <p>
        Cgol probably isn't well-known outside the Lisp community, actually.
      </p>
      <p>
        There has been debate for decades, up to the current day (including on some pages here on wiki) about whether the failure of languages like that (Lisp semantics with roughly Algol-family syntax) to appeal to the masses is because this just isn't a good idea (that Lisp non-Algol-ish syntax isn't why the masses dislike it) -- or is it just that this idea has never been executed well enough?
      </p>
      <p>
        Hard to say. Opinions vary.
      </p>
      <p>
        Also, some people claim that certain modern languages, like Python or Ruby or Perl, have all of the power of Lisp and thus this has already been accomplished, but that is just factually incorrect. They mean that some of those languages now have <strong>some</strong> of the expressive power of Lisp. -- dm
      </p>
      <p>
        <em>Maybe just enough to avoid the </em><a href="SocialProblemsOfLisp.html">SocialProblemsOfLisp</a>? Too much power is sometimes a bad thing. Otherwise, every cop would carry an Uzi.<em></em>
      </p>
      <p>
        Yes, but that's a parallel that might or might not apply, since that's not, on the face of it, the same kind of power. (We could also digress about things like the military police on every street corner in Italy carrying machine guns, but let's not.)
      </p>
      <p>
        The question of when it's useful to limit expressive power of languages has been partially addressed on <a href="PrincipleOfLeastPower.html">PrincipleOfLeastPower</a> and on notes I wrote near the top of <a href="IssuesForLanguageDesigners.html">IssuesForLanguageDesigners</a>, among other places.
      </p>
      <p>
        Bottom line is that I disagree in this context, though. The primary argument against expressive power in a general purpose programming language seems to be "the average programmer just can't handle the power of things like higher order functions, bless their pointy little heads, so we must save them from themselves, just as we'd take an Uzi away from a baby and then spank them."
      </p>
      <p>
        Baloney. Anything along those lines is merely an argument that there are people who are called "programmers" who in fact are not "programmers", amounting to wishful thinking on the part of those who hope for cheap semi-skilled labor from an <a href="ArmyOfProgrammers.html">ArmyOfProgrammers</a> to save them money on the expensive process of software development. This is a sneaky way of claiming that there <strong>is</strong> a <a href="SilverBullet.html">SilverBullet</a>: dumb down programming languages enough so that even idiots can program, and then software development will be cheap, too cheap to meter!
      </p>
      <p>
        Unfortunately some supposedly-brilliant big names in the field actually believe this, but they're just kidding themselves. (An editorial rant by: -- <a href="DougMerritt.html">DougMerritt</a>)
      </p>
      <p>
        The type of supply reflects the type of demand. But the idea of this topic is to deal with reality rather than overhaul it. In other words, sneak Lisp in by making it more resemble what is favored.
      </p>
      <p>
        <em>If you believe a few trivial syntactic changes will do that, then you must think C++ / Java programmers are all exceedingly stupid. Nevermind.</em>
      </p>
      <hr/>
      <p>
        My first attempt at writing at this wiki, don't hit me hard: can anyone show a short program in Lisp, that would do something useful, and would be hard to write in any other language? There's no problem with throwaway programs in Perl or Ruby - which is why I love them. And my love affair with Java took off because it was easy to write small applets for the browser - a previously impossible task. Is there something equally convincing for Lisp?
      </p>
      <p>
        Lisp doesn't really need to resemble other languages. But Lisp has to be really good at some simple task. For example, if Lisp has lambda and is great for writing callback-based GUI stuff, why can't one grab a free implementation somewhere that would make native Windows GUI programming (i.e. making .exe files that show windows) really easy? (Somehow, the <a href="ObjectiveCaml.html">ObjectiveCaml</a> people managed this with LablGtk2.)
      </p>
      <ul>
        <li>
           Before we learn Lisp, we are required to sign a pledge never to use this great power for evil purposes. As part of that, section 23 clause 347 paragraph 5 specifically prohibits us from making native Windows GUI programming really easy. <em>Fantasy books tell us that the greatest power mustn't ever be used at all. Sounds a lot like Lisp, no?</em>
        </li>
        <li>
           Besides, every <a href="VisualBasic.html">VisualBasic</a> fan tells us that VB already makes every aspect of GUI programming really easy, so there must not be any problem. (They seem to be the only ones in the world, outside of GUI wizard companies, who claim this to be true of any technology, but who are we to argue?)
        </li>
      </ul>
      <p>
        I'm not a Lisp fan, convince me. -- VladimirSlepnev
      </p>
      <ul>
        <li>
           No. Never change; we love you just the way you are. Becoming a Lisp fan would just ruin you. We'd never be able to live with ourselves.
        </li>
      </ul>
      <ul>
        <li>
           <em>A few hours ago, I read a thread discussing how to make Prolog more popular. At one point a poster writes that "Of course, every language enthusiast wants to make their language more popular." Thank you for disproving that. Sigh.</em>
        </li>
      </ul>
      <ul>
        <li>
           paulgraham.com discusses possible reasons to keep Lisp as a private competitive advantage. However, in this case you seem to be missing the fact that the response is humor.
        </li>
      </ul>
      <ul>
        <li>
           <em>Perhaps. But humour is too often revealing of things we'd rather not speak of. However, in this case you seem to be missing the very ambiguous nature of my sigh. :)</em>
        </li>
      </ul>
      <ul>
        <li>
           :-) Indeed, on both counts. On the other hand, although I've been known to defend several languages, mostly I think all languages ever invented suck, so I'm not really the poster child for Lisp or any other language. Why else would I try to create a new one? The unrevealed mystery that my humor masks is probably just that I'm an irreverant smartass when I stray from straightforward debate. I could make a zen argument instead, but in this case, that too would just be a smartass thing to do. How recursive. Must be zen after all.
        </li>
      </ul>
      <p>
        Perhaps this request should be moved to <a href="LispShowOffExamples.html">LispShowOffExamples</a>.
      </p>
      <p>
        Yeah, this link feels right here. And feel free to delete my request if it doesn't fit here. --Vladimir Slepnev
      </p>
    </div>
  </body>
</html>