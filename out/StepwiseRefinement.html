<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Stepwise Refinement
      </h1>
      <p>
        Shame on you all that I had to add this page on 7th March 2003!
      </p>
      <ul>
        <li>
           <em>The </em><a href="WikiIsNotaDictionary.html">WikiIsNotaDictionary</a> crowd probably prevented it earlier.<em></em>
        </li>
      </ul>
      <p>
        <a href="StepwiseRefinement.html">StepwiseRefinement</a> is a relatively old technique of <a href="SoftwareDesign.html">SoftwareDesign</a> that has been successfully used in a wide range of <a href="StructuredProgramming.html">StructuredProgramming</a> and <a href="ModularProgramming.html">ModularProgramming</a> environments and languages. It is the procedural (step-by-step) form of <a href="SeparationOfConcerns.html">SeparationOfConcerns</a> and has what some may call a fractal nature of task division.
      </p>
      <p>
        The principle of <a href="StepwiseRefinement.html">StepwiseRefinement</a> kind of tries to roll-up <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a> and <a href="KeepItSimple.html">KeepItSimple</a> in one and most programmers (at least the <a href="GoodProgrammer.html">GoodProgrammer</a>s I've encountered) tend to use <a href="StepwiseRefinement.html">StepwiseRefinement</a> intuitively.
      </p>
      <p>
        The software design is approached as being a series of layers of modules of decreasing abstraction with call flows typically forming hierarchies through the modules. You start by identifying the top of the hierarchy (essentially main() or do_stuff()) and then apply <a href="TopDown.html">TopDown</a> design to work out the next set of modules that need to be built/written.
      </p>
      <p>
        <a href="StepwiseRefinement.html">StepwiseRefinement</a> can (and often is) also applied even down to the function level in languages such as <a href="CeeLanguage.html">CeeLanguage</a>.
      </p>
      <p>
        For example, the top level might be the function main(). The <a href="SoftwareEngineer.html">SoftwareEngineer</a> decides that main needs to call foo() and bar(), so she writes the function main() to call foo() and bar() but leaves foo() and bar() stubbed out with printf's. She then runs her <a href="UnitTest.html">UnitTest</a>s and confirms that foo() and bar() are called correctly i.e. we get printfs coming out where expected, so main() works. She then implements foo() which is straightforward, and runs the <a href="UnitTest.html">UnitTest</a>s once more to verify that both main() and foo() operate together correctly. She then goes back to look at bar() but realizes that bar() needs another lower level function, baz() to work. So, she implements bar() to call baz() but again just leaves baz() stubbed out. Once more the <a href="UnitTest.html">UnitTest</a>s are run to confirm that the software works correctly. The final stage is then to implement baz() and finished checking the software with the <a href="UnitTest.html">UnitTest</a>s.
      </p>
      <p>
        The advantage of <a href="StepwiseRefinement.html">StepwiseRefinement</a> is that it allows for <a href="IncrementalDevelopment.html">IncrementalDevelopment</a> but on a much finer level of granularity. A little bit like <a href="BarryBoehm.html">BarryBoehm</a>'s <a href="SpiralModel.html">SpiralModel</a>. It also uses <a href="UnitTest.html">UnitTest</a>s as an integral feature of the development process. The software is also rapidly built as <a href="StepwiseRefinement.html">StepwiseRefinement</a> lends itself naturally to producing working (and tested) prototypes of the software as it develops, and it is often possible to build prototypes in remarkably short periods of time as you can apply YAGNI pretty much down to the function level. <a href="StepwiseRefinement.html">StepwiseRefinement</a> is highly scalable, as large systems can be developed in a structured and predictable fashion from it. 
      </p>
      <p>
        The downside is that <a href="StepwiseRefinement.html">StepwiseRefinement</a> is open to interpretation of precisely what abstraction functions are required at the higher levels. This generates a tendency towards an architecture that has one larger high-level module with several smaller "worker" modules below it. That is, the hierarchy tends to grow across rather than down (which is the intention). 
      </p>
      <p>
        I'd be interested to hear anyone else's thoughts on this. Having been programming <a href="CeeLanguage.html">CeeLanguage</a> for a few years now (after being a <a href="JavaLanguage.html">JavaLanguage</a> and <a href="ObjectOriented.html">ObjectOriented</a> person for 2 years) I have become quite fond of <a href="StepwiseRefinement.html">StepwiseRefinement</a> and really do wonder how people program without it, especially when using <a href="StructuredProgramming.html">StructuredProgramming</a> languages.
      </p>
      <p>
        If you feel the need, <a href="PleaseComment.html">PleaseComment</a>.
      </p>
      <hr/>
      <p>
        Example:
      </p>
      <ul>
        <li>
           Brush Teeth
          <ul>
            <li>
               find toothbrush
            </li>
            <li>
               find toothpaste tube
            </li>
            <li>
               open toothpaste tube
              <ul>
                <li>
                   Put thumb and pointer finger on cap 
                </li>
                <li>
                   turn fingers counter-clockwise
                </li>
                <li>
                   repeat prior step until cap falls off
                </li>
              </ul>
            </li>
            <li>
               squeeze tube onto toothbrush
              <ul>
                <li>
                   (details omitted)
                </li>
              </ul>
            </li>
            <li>
               clean teeth 
              <ul>
                <li>
                   put brush on teeth
                </li>
                <li>
                   move back and fourth vigorously
                </li>
                <li>
                   repeat above step 100 times
                </li>
              </ul>
            </li>
            <li>
               clean up
              <ul>
                <li>
                   rinse brush
                  <ul>
                    <li>
                       turn on water
                    </li>
                    <li>
                       put head of brush under running water for 30 seconds
                    </li>
                    <li>
                       turn off water
                    </li>
                  </ul>
                </li>
                <li>
                   put cap back on toothpaste
                </li>
                <li>
                   put all items back in cabinet
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <p>
        Unfortunately, <a href="StepwiseRefinement.html">StepwiseRefinement</a> often leads to a solution where each module represents one part of the task in chronological terms, which can lead to multiple modules knowing the details of some data structures. See <a href="DavidParnas.html">DavidParnas</a>' wonderful paper <a href="OnDecomposingSystems.html">OnDecomposingSystems</a> for examples of different ways to decompose a system, some of which are more robust against changes in data representation.
      </p>
      <p>
        <em>I don't see wrapping data structures and </em><a href="StepwiseRefinement.html">StepwiseRefinement</a> to be mutually exclusive. <a href="DavidParnas.html">DavidParnas</a> paper is flawed in some ways.<em></em>
      </p>
      <p>
        They aren't, but it takes care to do both at the same time. The point is that it's very easy to think of the "steps" in <a href="StepwiseRefinement.html">StepwiseRefinement</a> as being "steps to solve the problem", which tend to be chronological. For example, if the above "brushing your teeth" system were implemented naively, it would be natural to have subroutines for each line, called by the next higher level and calling the ones at the next lower level, all of which have knowledge of the "toothbrush" and "toothpaste" data structures.
      </p>
      <p>
        <em>Please explain "which have knowledge"? Perhaps this is related to </em><a href="DatabaseNotMoreGlobalThanClasses.html">DatabaseNotMoreGlobalThanClasses</a>.<em></em>
      </p>
      <p>
        <em>As far as </em>'subroutines<em>', yes in practice one often does such. The above illustrates the design dividing process, not the coding and repetition factoring.</em>
      </p>
      <hr/>
      <p>
        <strong>Stepwise Refinement and Deviation Management</strong>
      </p>
      <p>
        "Dealing with Deviations from Framework" under <a href="HelpersInsteadOfWrappers.html">HelpersInsteadOfWrappers</a> illustrates how to use the levels to go lower into the <a href="StepwiseRefinement.html">StepwiseRefinement</a> tree to "override" behavior for custom exceptions-to-the-rule, but still potentially use some of the existing branches. -t
      </p>
      <hr/>
      <p>
        See also: <a href="ProceduralMethodologies.html">ProceduralMethodologies</a>, <a href="AbstractSyntaxTree.html">AbstractSyntaxTree</a>, <a href="WesternReductionism.html">WesternReductionism</a>. <a href="SecondEffort.html">SecondEffort</a>
      </p>
    </div>
  </body>
</html>