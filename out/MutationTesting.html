<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Mutation Testing
      </h1>
      <p>
        Mutation Testing involves running slightly corrupted versions of your target program through your test suite to see if any test cases flag the variations as defects.
      </p>
      <hr/>
      <p>
        <a href="MutationTesting.html">MutationTesting</a> turns the "testing" question upside-down:
        Instead of asking how if we've tested the program enough, we ask a more useful question:
        <strong>Are the tests sufficient to detect bugs in the program?</strong>
      </p>
      <p>
        So, we "test the tests" by introducing bugs in the code and running the tests.
        If the changed program passes all the tests, just like the original program, you have to ask "why doesn't it make any difference if this variable is off-by-one???
        Most likely, it's an area of the program that hasn't been tested sufficiently.
      </p>
      <hr/>
      <p>
        I'd be interested to know if anyone has used mutation testing in a practical way in industry. Very few tools support this technique and writing your own is not an option unless you are in the compiler business. But you could use a perl script to generate a few variations from a checklist of mutations. Can the technique be usefully adapted for industry?
      </p>
      <p>
        As I understand it, <a href="MutationTesting.html">MutationTesting</a> is intended as an iterative process. On each pass, you tighten up the tests to catch more mutant programs. In contrast to <a href="DefectSeeding.html">DefectSeeding</a>, <a href="MutationTesting.html">MutationTesting</a> seems to be targeted more to the test suite than to the testers or the review process. Also, the type of defects used in <a href="MutationTesting.html">MutationTesting</a> tend to be simple variations like a plus instead of a minus sign. The theory is that complicated bugs cluster around small bugs, so that if your suite catches simple defects, if will find both.
      </p>
      <p>
        <a href="http://www.isse.gmu.edu/faculty/ofut/rsrch/abstracts/practical.html">http://www.isse.gmu.edu/faculty/ofut/rsrch/abstracts/practical.html</a> contains some ideas for limiting the cost of mutation testing.
      </p>
      <p>
        Cayte
      </p>
      <p>
        <em>There's a very important application of </em><a href="MutationTesting.html">MutationTesting</a> (aka <a href="ActiveNonlinearTesting.html">ActiveNonlinearTesting</a>) in working with academic or other first-principles models. See <a href="http://www.santafe.edu/sfi/publications/Abstracts/96-03-011abs.html">http://www.santafe.edu/sfi/publications/Abstracts/96-03-011abs.html</a> for the first place I've ever encountered it. I'm not sure exactly how it can be used in a production coding setting, but it's a vital aspect of working with models, and anytime <a href="GeneticAlgorithm.html">GeneticAlgorithm</a>s are involved.<em> -- </em><a href="BillTozier.html">BillTozier</a>
      </p>
      <p>
        While we have not done production mutation testing, the DMS Software Reengineering Toolkit <a href="http://www.semanticdesigns.com/Products/DMS/DMSToolkit.html">http://www.semanticdesigns.com/Products/DMS/DMSToolkit.html</a> could be used to implement
        this pretty easily. DMS enables one to specify as set of arbitrary source to source transformation rules. This is much safer and easier than using PERL to do this, as the transformation rules operate on the abstract syntax of the program. By definining a set of mutation transforms, it would be easy to produce mutants. As a bonus, DMS works with virtually all the languages in common use. -- Ira Baxter, CTO Semantic Designs
      </p>
      <hr/>
      <p>
        If your <a href="UnitTest.html">UnitTest</a>s are automated (automated <a href="RegressionTesting.html">RegressionTesting</a>), an automated <a href="MutationTesting.html">MutationTesting</a> tool can tell you how well you've managed to <a href="TestEverythingThatCouldPossiblyBreak.html">TestEverythingThatCouldPossiblyBreak</a>.
      </p>
      <p>
        Tools:
      </p>
      <ul>
        <li>
           <a href="JesTer.html">JesTer</a> (described on the XPDeveloper site - follow the link)
        </li>
      </ul>
      <hr/>
      <p>
        See also <a href="DefectSeeding.html">DefectSeeding</a>, which is targeted at people, rather than being automated.
      </p>
      <hr/>
      <p>
        For <a href="JavaLanguage.html">JavaLanguage</a> programs, maybe something like BCEL (<a href="http://jakarta.apache.org/bcel/index.html)">http://jakarta.apache.org/bcel/index.html)</a> could be used to do "mutation automation". I have used it to do some simple code instrumentation work before, it could easily be used to make the code "always return null" or "always return without making any modifications" or "subtract instead of add", ...
      </p>
      <hr/>
      <p>
        PiTest (<a href="http://pitest.org/)">http://pitest.org/)</a> is actively developed as a <a href="JavaLanguage.html">JavaLanguage</a> mutation testing tool.
        It has a good integration with SonarQube.
      </p>
      <hr/>
      <p>
        <a href="CategoryTesting.html">CategoryTesting</a>
      </p>
    </div>
  </body>
</html>