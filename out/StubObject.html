<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Stub Object
      </h1>
      <p>
        See also <a href="ShuntPattern.html">ShuntPattern</a>, <a href="MockObject.html">MockObject</a>, <a href="MockStubShunt.html">MockStubShunt</a>
      </p>
      <p>
        The most simple implementation of an interface. In java, one might implement every method call with an empty (No-Op) body, returning null, or by throwing a runtime exception. This can be a useful Parent class to extend from to create Shunt and <a href="MockObject.html">MockObject</a>s. 
      </p>
      <hr/>
      <p>
        A Stub Object is one whose methods are stubs (or "mocks"?); that is, they do no useful work but prevent #doesNotUnderstand errors and return plausible values so that the computation can continue. They are used during testing or prototyping, where attention is focused on that other computation.
      </p>
      <p>
        Not to be confused with <a href="NullObject.html">NullObject</a>, although a Null Object can be used as a stub.
      </p>
      <hr/>
      <p>
        In Java, C++, it is useful to implement "actors" from your test cases as stub objects that derive from the interfaces on which a test depends. These stubs actually do a bit more than nothing: they can drive stimulus and check expected results. A <a href="TestCase.html">TestCase</a> may act as a mediator that coordinates/controls the behaviours of the actors.
      </p>
      <p>
        See also <a href="EncapsulateNewForTestability.html">EncapsulateNewForTestability</a>
      </p>
      <p>
        (Note: There's a set of pages to be refactored here: this one, <a href="TestingPatterns.html">TestingPatterns</a>, <a href="MockObject.html">MockObject</a>, <a href="ShuntPattern.html">ShuntPattern</a>, ...)
      </p>
      <p>
        --<a href="DaveWhipp.html">DaveWhipp</a>
      </p>
      <hr/>
      <p>
        one might implement a stub by extending an existing class and overriding every method.
      </p>
      <p>
        <em>but that's not as good as implementing an interface, since all of the base-class state will be initialized even when creating the stub; and in some cases (in for example some classes in the Java API) this initialization can have side-effects that might cause problems.--</em><a href="BrettNeumeier.html">BrettNeumeier</a><em></em>
      </p>
      <p>
        <em>Agreed; it also propagates dependencies - where the real class has members which must be initialized, their code must also be stubbed out, and this can build up quickly until there's more stubbing than testing. The easier solution is to create the minimal interface - essentially just the public functions excluding (con|de)structor - which is inherited by the real class, but can be instantiated as a stub in itself, or inherited instead by a mock class. -- </em>RobDesbois<em></em>
      </p>
      <hr/>
      <p>
        <a href="CategoryMockObjects.html">CategoryMockObjects</a> <a href="CategoryTesting.html">CategoryTesting</a>
      </p>
    </div>
  </body>
</html>