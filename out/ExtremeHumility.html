<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Extreme Humility
      </h1>
      <p>
        I think <a href="ExtremeProgramming.html">ExtremeProgramming</a> and several other similar approaches are based on humility about our abilities:
      </p>
      <ul>
        <li>
           we won't be able to work out all the requirements up front (so allow mid-course corrections).
        </li>
        <li>
           we won't get the design right first time. So don't try! Just <a href="DoTheSimplestThingThatCouldPossiblyWork.html">DoTheSimplestThingThatCouldPossiblyWork</a> and then <a href="RefactorMercilessly.html">RefactorMercilessly</a>.
        </li>
        <li>
           we don't know how implementable this design is. So implement it and see.
        </li>
        <li>
           we'll make mistakes in coding and interpreting designs. So test everything, run the tests every time you make a change.
        </li>
        <li>
           we don't understand the problem well enough to predict what we'll need later. So <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a>.
        </li>
        <li>
           we can't reliably write simple, understandable code on our own, so we work in pairs for constant feedback.
        </li>
      </ul>
      <p>
        <a href="DesignInXp.html">DesignInXp</a> makes some of the same points.
      </p>
      <p>
        In contrast, the (pure) <a href="WaterFall.html">WaterFall</a> method is arrogant in its confidence:
      </p>
      <ul>
        <li>
           in the requirements phase, we will identify all relevant requirements, and correctly
        </li>
        <li>
           in the analysis and design phases, we will interpret the requirements correctly, and produce an implementable architecture and design which will not need changes.
        </li>
        <li>
           in the coding phase, we will interpret the design correctly and make no significant mistakes (a waterfall plan almost by definition doesn't have a large "rework after testing" phase. <em>A plan may, and indeed should, have rework activity </em>'during<em>' testing and every other phase.  The model does not, however, because "rework" is just "work" iterated.</em>).
        </li>
        <li>
           in the testing phase, we will test correctly, and (sufficiently) exhaustively
        </li>
        <li>
           "We know how to design and you don't." That's why the designers "throw the design over the wall" to low pay "peon coders" to do the next phase.
        </li>
      </ul>
      <p>
        (You can have have WaterFallWithFlowback. You can then go back it becomes hard to know what you're actually doing, because you no longer know if you've finished (for example) design yet).
      </p>
      <p>
        See also <a href="CleanRoomHumility.html">CleanRoomHumility</a>, YouWillMakeMistakes
      </p>
      <hr/>
      <p>
        Even an XP cynic like myself (sorry, I've seen too many silver bullets whizzing by in the past 40 years to jump on even inviting band wagons) can see the wisdom of what you say. Nice job, Paul!
      </p>
      <p>
        <em>Does XP claim to be a silver bullet? Interesting question. I've attempted to answer it on </em><a href="XpIsNotaSilverBullet.html">XpIsNotaSilverBullet</a>.<em></em>
      </p>
      <p>
        "This is amazing!" -- RajWaghray
      </p>
      <hr/>
      <p>
        Humility about one's abilities need not lead you into doubting your abilities.
      </p>
      <p>
        The XP principles may arise out of humility but humility is certainly not the feeling I have when I practice these principles. On the contrary, I feel powerful, confident, and fearless. Perhaps even to the point of arrogance.
      </p>
      <p>
        Humility does not oppose power, confidence, or fearlessness; it is simply a state in which you have an awareness and acceptance of your flaws. I don't think it's very surprising at all that you feel much more secure in your capabilities when you are conscious of where you lack them - and XP, as a methodology that works well in the presence of human frailty, is going to further encourage your confidence.
      </p>
      <hr/>
      <p>
        This is getting philosophical, but then methodologies seem to tend toward philosophy or religion. :)
      </p>
      <p>
        But Seriously, don't you think the argument could be made that humility <em>is</em> empowering in a Zen like sort of way? 
      </p>
      <p>
        This quote sums up what I am trying to say:
      </p>
      <dl>
        <dt> </dt>
        <dd><em>"The more I learn, the more I realize I don't know."</em></dd>
      </dl>
      <dl>
        <dt>	 </dt>
        <dd><em>-- </em><a href="AlbertEinstein.html">AlbertEinstein</a><em></em></dd>
      </dl>
      <p>
        This is actually an indicator that XP is on the right track. Perhaps <em>because</em> it forces us to recognize our limitations, it makes it possible to overcome them, and thus succeed in our endeavors (in this context to finish the project on time, and in spec). The fact that a feeling of empowerment grows from this is very natural.
      </p>
      <hr/>
      <p>
        <strong>Re:</strong> <em>In contrast, the (pure) waterfall method is arrogant in its confidence...</em>
      </p>
      <p>
        Could you tell me where you found this "pure" waterfall method defined? A couple of years ago, I read the WinstonRoyce paper (dating from somewhere in the 1970's I think) that first captured the term "waterfall" to  describe this kind of progression in software projects. I was quite surprised to find that it was nothing like this stupid and rigid model we all like to poke fun at, and I saw no arrogance in his writing at all, only humility. Maybe, part of <a href="ExtremeHumility.html">ExtremeHumility</a> should include studying recent history, although that's not going to be "the simplest thing that could possibly work" for us.
      </p>
      <p>
        [The Winston W. Royce paper referred to may be "Managing the Development of Large Software Systems: Concepts and Techniques", WESCON technical papers, 14., published in 1970. Does anyone know of an online copy?]
      </p>
      <p>
        The above reference is correct. I just re-read the paper quickly. It seems the term "waterfall" does not even appear there, although a later paper by <a href="BarryBoehm.html">BarryBoehm</a> (<em>A Spiral Model of Software Development and Enhancement</em>, 1987 IEEE) credits Royce with the "original treatment of the <em>waterfall model</em>" in the same 1970 publication.  The "waterfall" we don't like seems not to have an author.
      </p>
      <hr/>
      <p>
        Waterfall methodology - as I was taught it, at least - includes the expectation that there will be regular cycles to the waterfall. Specify, design, implement and test what you currently know you need. Then specify, design, implement and test the changes to that. Rinse and repeat ad nauseum, until you have code which suits the requirements.
      </p>
      <p>
        <em>...and requirements that suit the sponsor.</em>
      </p>
      <p>
        I've yet to meet a developer who admits to ever having bought into a pure waterfall methodology. When I was taught the model back in 1987, it was constantly stressed that the so-called 'phases' naturally overlap and that iterating back through the 'phases' was inevitable. The dogma was that when a problem was identified during, say, 'build' or 'test' you should go back to the 'phase' that gave rise to the problem ('analysis' or 'program design', say), fix the problem there and 'fall' (quickly) back through the phases in between until you got back to the 'phase' where the problem was identified. Only then would the problem be 'fixed' (though you might have patched things up in the interim. In practice we often did this but I don't recall whether it was officially ok).
      </p>
      <p>
        The disaster (as so often in our business) was the <a href="ProjectManagement.html">ProjectManagement</a> take on it: 'the only way a waterfall flows is down', 'phase <strong>n</strong> shall complete on date <strong>t</strong> when phase <strong>n+1</strong> shall start', 'ok I'll build in a week for handover', 'why do I still have analysts on my project when I'm in test?'. I thought I was making progress when I secured the project manager's agreement to the principle that phase n could be declared to be 'complete' when the developer(s) for phase n+1 said so. That way, he could have his plan and we could get on with the development. Unfortunately, phase n+1 developers would never declare phase n complete because if they did the phase n developers would disappear without trace! -- <a href="AlanAshtonJeanes.html">AlanAshtonJeanes</a>
      </p>
      <p>
        <em>I don't think it requires a complete buy in. The key thing is what happens in response to a shortcoming in earlier phases. If the "fix" is always to make the earlier phase more strict/pedantic, you're in the trap. For instance, in my experience, when the requirements turn out not to be what the customer actually wants by the end of the project, if the constant response is "we need to write down the requirements more precisely/we need more requirements analysis", then I think you're in the waterfall trap. XP (and many other methodologies) accept that the quest for precise, unchanging requirements is unachievable, and deal with it</em> -- <a href="PaulHudson.html">PaulHudson</a>
      </p>
      <p>
        Fair enough.  But I don't know of anyone who believes in unchanging requirements either.  Or immutable design.  Or frozen code (...no, scrub that).  <strong><em>If</em></strong> the problem is that the requirement was wrong or has changed, either of which is highly likely, you <em>should</em>(according to the model) go back and see what difference that makes to everything that since has flown and fanned out from it.  If you don't, you will still, eventually, have to find and fix the problems, by which time more work will have flown and fanned out from the unfixed problem.  That's what I was taught, and I can still see the logic to it.
      </p>
      <p>
        As has been said elsewhere, it's mostly a question of scale.  Like XP, <a href="WaterFall.html">WaterFall</a> works on small scales, with short elapsed times.  Today, most people's approach to big development is to avoid it.  If you can't avoid it, chunk it until it's manageable.  How you proceed within any given chunk is, of course, with <a href="ExtremeHumility.html">ExtremeHumility</a>. -- <a href="AlanAshtonJeanes.html">AlanAshtonJeanes</a>
      </p>
      <p>
        <em>Agreed, within one project. What I meant was what happens on the next project, or at the post-project review. If the complaint is "Oh no, a requirement changed, we didn't try hard enough to nail the customer down at the beginning" or "the contract shouldn't allow the client to change the requirements", then you're trapped. But I think we largely agree on the overall point. </em>  Agreed, that would be the start of a very vicious circle.
      </p>
      <hr/>
      <p>
        Theories:
      </p>
      <ol>
        <li>
           XP Humility Embraces Many Little Mistakes to Avoid Catastrophic Failures
        </li>
        <li>
           To Embrace Many Little Mistakes, You Must be a Confident Person
        </li>
        <li>
           Arrogance is Actually Fear of All Failure, Large or Small
        </li>
      </ol>
      <p>
        XP does not merely embrace change, it embraces systematic (and collective) mistake-making and lesson-learning. By embracing lots of <a href="LittleMistakes.html">LittleMistakes</a>, XP reduces the risk of <a href="BigPublicFailure.html">BigPublicFailure</a>. Lots of little mistakes are like lots of naturally-occurring brushfires or controlled burns in a large forest. They constantly manage the risk of big forest fires by controlling the amount of fuel that such catastrophes require. 
      </p>
      <p>
        Confident people can easily choose to embrace lots of little mistakes because it does not feel like failure to them, it feels like incremental success. XP provides a collective and controlled means of keeping the mistakes small, and keeping them flowing at a constant rate. 
      </p>
      <p>
        But you can only be comfortable with a constant onslaught of little mistakes if your sense of self does not depend on continual mistake-free performance. If you know yourself to be fundamentally worthwhile, unplagued by fears of public failure, public humiliation, job loss, etc., then you have the luxury of gung-ho experimentation, mistake-making, and course-correction. If somebody points out an error in your code, and your reaction is positive and thankful ("Oh, cool, thanks. Good catch. Lemme fix that."), you are probably confident enough for the rough-and-tumble of XP. 
      </p>
      <p>
        If your reaction to someone pointing out an error your code is to deny, defend, and rationalize ("Oh, um, I did that for a reason. And I was gonna rewrite all of that soon anyway"), then you may prefer the illusion of mistake-free phases that waterfall provides.  
      </p>
      <p>
        To rephrase the Arrogance of waterfall list from the top of the page: 
      </p>
      <ul>
        <li>
           we will have a single closed-end requirements phase at the beginning, because we are afraid of getting them wrong and having to keep doing them forever.
        </li>
        <li>
           we will have only one analysis and design phase, because we are afraid of getting it wrong and having to throw away badly-conceived design
        </li>
        <li>
           we will have only one coding phase, because we are afraid of getting it wrong and having to throw-away badly-written code.
        </li>
        <li>
           we will have a single big testing phase, because we are afraid of bugs, and we wish to put off as long as possible the miserable experience of slogging through bug fixes.
        </li>
        <li>
           "We are afraid you might have good design ideas, which might make us look dumb or unnecessary. So we won't let you suggest any."
        </li>
      </ul>
      <p>
        And the list of XP humble assertions, rephrased in emotional terms:
      </p>
      <ul>
        <li>
           We don't mind that we won't be able to work out all the requirements up front. Making mid-course corrections will work out fine. In fact, it will be a gas.
        </li>
        <li>
           It's fine that we won't get the design right first time. The sooner we get it slightly wrong, the sooner we'll get it entirely right.
        </li>
        <li>
           We may not even be able to build this thing! Cool! 
        </li>
      </ul>
      <p>
        ... <em>etc</em>
      </p>
      <p>
        So it seems to me that XP's likeliest skeptics are those who are afraid of being "found out." Afraid that it will be discovered that they have occasionally designed, coded, and documented badly. And I mean actual fear: the kind that subverts  your life by secretly affecting your motivations, your actions, and your ability to enjoy life. 
      </p>
      <p>
        And I think that the arrogance of waterfall, and of traditional software "engineering" in general, is born of varieties of that fear. -- <a href="PatWelsh.html">PatWelsh</a>
      </p>
      <hr/>
      <p>
        Making another link here. XP (although by no means perfect) aligns the software development process mechanism with the way that the human brain works. XP seems to me an evolution of <a href="TomGilb.html">TomGilb</a> theories, and seems analogous to the TEFCAS theory of how the human brain learns described by <a href="TonyBuzan.html">TonyBuzan</a> in <a href="HeadStrong.html">HeadStrong</a>.
      </p>
      <p>
        It is time that we realized that we are flawed beings. If we were *really* smart, we would be able to take situations and immediately spit out the necessary binary code to instruct our machines. All the tools and techniques we have developed are to overcome human limitations.
      </p>
      <p>
        <em>Well, yes. That is what this page is all about, you know</em>
      </p>
      <hr/>
      <p>
        If you wanted another comparison, you could say that one underlying characteristic of an <a href="AgileMethodology.html">AgileMethodology</a> is that it tries to think of software development itself as a highly dynamic system - that is, more amenable to bottom-up, emergent order than to top-down order. This is how nature works, and although such systems aren't necessarily perfect or precise, it is usually quite resilient to outside shocks.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="YouKnowYouAreaRealProgrammerWhen.html">YouKnowYouAreaRealProgrammerWhen</a> ...<strong></strong>
      </p>
      <p>
        <em>The following views were expressed with </em><a href="ExtremeHumility.html">ExtremeHumility</a> sometime ago :)<em></em>
      </p>
      <p>
        I know this might seem inflammatory to some - but please consider that it's the opinion of many programmers who undeniably "Get it", myself included:
      </p>
      <p>
        Real programmers, who seem to just be able to code from birth, are too rare to build a society on.  Sure there's quite a few out there, but not the numbers that industry wants to be able to complete all of the tasks it needs done.  These real programmers never needed formal computer science, never needed software development lifecycle models.  They just Do It, and It Works.  Sure they may have dabbled in such things at times, hoping to better explain things to others, but they never needed them.  A whole lot of the greatest programmers who ever lived probably never cared about how to develop software by any model.
      </p>
      <p>
        So, we're left with this vacuum - society wants more of these "programmers", because they can do nifty things, but there just aren't enough to go around.  Salaries rise, demand rises.  So a bunch of people who aren't really the "real programmer", but might be a passable substitute if you down a quick shot of bourbon and squint your eyes, and a whole lot of other people who couldn't code their way out of a paper bag, step in to fill the vacuum.  They consistently fail to output the kind of results people are looking for, because they aren't the right tool for the job, and it's just really hard to "teach" someone who isn't a natural how to do this stuff.
      </p>
      <p>
        So lots of theories emerge, and books are written on the software development proccess, etc, etc.  Mostly these things offer some insight into the nature of the problem, but mostly these ideas are ultimately wrong.  Finally, at some point in the evolution of this whole system of subpar code jockeys trying to find their way in the dark, someone starts making this Extreme/Agile Programming idea popular, because it sure seems to make a whole lot of sense.
      </p>
      <p>
        As it turns out, Darwin wins again, and through stumbling in the dark and falling on their faces with ideas, this process eventually "evolved" a reasonably correct model.  It turns out that the basic tenets, ideas, and feelings behind the general area of Extreme/Agile-type software development methodology, are pretty much what the "real programmers" were doing in the beginning. It's almost as if someone built a database of real programmers and spied on them for a few years, and studied them and documented their methods as best they could. This accidental evolutionary system actually found what it was looking for in many senses. Deflate the hype and over-analysis, just mull over the key points of the extreme/agile way of doing things generally, and try to be rational and think like a "real programmer", and you're so much further along the enlightened path than anyone following any previous software development life-cycle hogwash. It's not perfect. It can't encapsulate the genius of the real programmers.  However, it's about as close a facsimile as you're going to get, so embrace it. Just don't go being too academic about it and over-thinking things.
      </p>
      <p>
        <em>Response from another, also in the distant past</em>
      </p>
      <p>
        Dear sweet merciful delicious Jesus-crackers.
      </p>
      <p>
        Please tell me that out of the hundreds of skilled professionals that read that entry, I am not the only one who read it and realized that it was a subtle jab at <a href="ExtremeProgramming.html">ExtremeProgramming</a>?
      </p>
      <p>
        <em>From the 4th word it starts with "might seem inflammatory", it talks about "</em><a href="RealProgrammer.html">RealProgrammer</a>s" versus idiot coders, and how "Extreme/Agile-type software development methodology" can help make up for the use of the latter instead of the former, etc. You call that subtle? How could it be more explicit; by throwing in obscenities?<em></em>
      </p>
      <p>
        Ironic to find it on a page called <a href="ExtremeHumility.html">ExtremeHumility</a>, no?
      </p>
      <hr/>
      <p>
        I seem to remember an article by <a href="EwDijkstra.html">EwDijkstra</a> called <em></em><a href="TheHumbleProgrammer.html">TheHumbleProgrammer</a><em> that addressed some of these ideas in 1972! </em>
      </p>
      <p>
        <em>Yes, that's been noted before. See </em><a href="ExtremeHumilityAndHowWeAchievedIt.html">ExtremeHumilityAndHowWeAchievedIt</a> <em></em>
      </p>
      <hr/>
      <p>
        Contributors: <a href="PaulHudson.html">PaulHudson</a>, <a href="JeffGrigg.html">JeffGrigg</a>, <a href="BradAppleton.html">BradAppleton</a>, <a href="AnonymousDonor.html">AnonymousDonor</a>, <a href="GlennVanderburg.html">GlennVanderburg</a>, <a href="BenAveling.html">BenAveling</a>, <a href="BillCaputo.html">BillCaputo</a>, <a href="JennVesperman.html">JennVesperman</a> ...
      </p>
      <hr/>
      <p>
        <a href="CategoryExtremeProgramming.html">CategoryExtremeProgramming</a>
      </p>
    </div>
  </body>
</html>