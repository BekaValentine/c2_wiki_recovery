<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Functional Programming Discussion
      </h1>
      <p>
        There are a lot of pages on <a href="FunctionalProgramming.html">FunctionalProgramming</a> on this wiki.  Some have challenged <a href="FunctionalProgramming.html">FunctionalProgramming</a>. 
      </p>
      <ul>
        <li>
           <em>Functional programming is pure nonsense.. the print("hello world") is still a procedure in any language (it affects the state and modifies the screen too). It's actually just a big </em><a href="SyntaxGame.html">SyntaxGame</a> and a form of different procedural programming. Eventually the program does something.<em> </em>
        </li>
      </ul>
      <p>
        Here is an example using the methods to be found on <a href="FunctoidsInCpp.html">FunctoidsInCpp</a> to show one way in which printing out <em>Hello World</em> can be made into an object which can be passed as a parameter to other functions. The various techniques employed are part of <strong>FC++</strong>, a library for C++.
      </p>
      <code>
        // helloexample.cpp<br/>
        // Example to show use of putting Hello World into a functional setting.<br/>
        #include <iostream><br/>
        #include <string><br/>
        // First a simple function.<br/>
        void printHelloWorld ()<br/>
        {<br/>
        std::cout << "Hello World" << std::endl;<br/>
        }<br/>
        void printString (std::string s)<br/>
        {<br/>
        std::cout << s << std::endl;<br/>
        }<br/>
        // Now some FC++ stuff<br/>
        #include "fcpp/prelude.h"<br/>
        template <typename T><br/>
        void do_it0(const T &t)<br/>
        {<br/>
        t();<br/>
        }<br/>
        template <typename T, typename S><br/>
        void do_it1(const T &t,const S &s)<br/>
        {<br/>
        t(s);<br/>
        }<br/>
        int main(int argc, char ** argv)<br/>
        {<br/>
        std::string hello_world("Hello World");<br/>
        printHelloWorld();<br/>
        // Turn in into a functoid by taking its address<br/>
        fcpp::Fun0<void> pHelloWorld = fcpp::ptr_to_fun(&printHelloWorld);<br/>
        // and then call that.<br/>
        pHelloWorld();<br/>
        // pass as an argument<br/>
        do_it0(pHelloWorld);<br/>
        printString(hello_world);<br/>
        // Turn in into a functoid by taking its address<br/>
        fcpp::Fun1<std::string,void> pString = fcpp::ptr_to_fun(&printString);<br/>
        // and then call that.<br/>
        pString(hello_world);<br/>
        // pass as an argument<br/>
        do_it1(pString,hello_world);<br/>
        }<br/>
      </code>
      <p>
        The output is multiple copies of <em>Hello World</em>.  -- <a href="JohnFletcher.html">JohnFletcher</a>
      </p>
      <hr/>
      <p>
        <strong>Right Tool for the Job</strong>
      </p>
      <p>
        It's my opinion that <a href="FunctionalProgramming.html">FunctionalProgramming</a> is of better use in <a href="SystemsSoftware.html">SystemsSoftware</a> than application software. While kicking around ideas for <a href="MaspBrainstorming.html">MaspBrainstorming</a>, I can find far more possible uses for FP in terms of using Masp to build domain-specific languages and idioms, such as building one's own control structure (loops, conditionals, etc.) Some have claimed that I simply don't have enough experience using FP for apps (<a href="ChallengeSixVersusFpDiscussion.html">ChallengeSixVersusFpDiscussion</a>), but the real problem is that engineers are far more willing to stick with and tolerate higher-level abstractions than most customers for applications; they want what they want when they want it, clean abstractions be damned. In a world where the "user" cares about and understands the value of abstractions and "buys into" them, it's easier to use, keep, and maintain abstractions in code. Procedural programming is less abstract for the most part, but it's also more flexible because of that. --top
      </p>
      <hr/>
      <p>
        <em>One must not forget also the phrase "right fool for the job." </em> i.e.: Right person/individual for the job.
      </p>
      <p>
        How, specifically, does this relate to the above?
      </p>
      <p>
        <em>I gave a name to this sort of thing a long time ago. I call it a </em><a href="ParkingTicket.html">ParkingTicket</a>.  It is a contribution to noise. I suggest ignoring it and moving on, which I know has its difficulties. There are one or more contributors who think <a href="FunctionalProgramming.html">FunctionalProgramming</a> a waste of time and those who use it foolish. That is their opinion.<em> -- </em><a href="JohnFletcher.html">JohnFletcher</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryFunctionalProgramming.html">CategoryFunctionalProgramming</a>
      </p>
    </div>
  </body>
</html>