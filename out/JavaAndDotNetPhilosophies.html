<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Java And Dot Net Philosophies
      </h1>
      <p>
        <strong>An account from the early days...</strong>
      </p>
      <p>
        I have spent the last ten years as an independent consultant, architecting and building systems on both the <a href="MicrosoftWindows.html">MicrosoftWindows</a> and <a href="UnixOs.html">UnixOs</a> platforms (with the occasional mainframe or midrange platform thrown in). I had primarily developed software with Microsoft tools and developed databases with Oracle or <a href="SqlServer.html">SqlServer</a>.
      </p>
      <p>
        Then Java caught my attention. As I investigated it, I realized that Java was where I wanted to be. I switched to Java when I became convinced of its enterprise maturity.
      </p>
      <p>
        However, the economy has driven me to take an IT staff job (as a Senior <a href="SoftwareEngineer.html">SoftwareEngineer</a>, supposedly). Now I am back in the Microsoft world developing an enterprise system using <a href="DotNet.html">DotNet</a> and <a href="CeeSharp.html">CeeSharp</a>. Now I am five months into that project, having started just after <a href="DotNet.html">DotNet</a> went final.
      </p>
      <p>
        What I have found is that the Windows and Unix platforms are more that just competing products - they represent competing philosophies.
      </p>
      <p>
        The Unix platform is founded on the premise that the user demands, and can handle, control of their systems. The platform provides a toolbox full of simple tools that are easy to configure and combine. The user has complete control to mix and match individual tools to create their own solution. The user also has complete responsibility to deal with all the issues that arise in the process. Most of the tools are free or nearly free, as is most of the help. The only real hindrance to the user achieving their desired results is their own competence, imagination, and resourcefulness. No obstacle has to be a show-stopper. However, most of the available tools and assistance require significant effort by the user to apply properly. Most of the user's resources are focused on design. [The Unix philosophy is nicely presented in <em></em><a href="TheArtOfUnixProgramming.html">TheArtOfUnixProgramming</a><em> by </em><a href="EricRaymond.html">EricRaymond</a>.]
      </p>
      <p>
        The Windows platform is founded on the opposite premise that the user does not want, and refuses to accept, control of their systems. The user chooses from a small set of off-the-shelf products, each of which provides a major piece of their desired results. Each product requires significant effort to install, configure, and coordinate with other products, but there are people available to handle those responsibilities. With minimal competence, imagination, and resourcefulness, the user can easily accomplish most of their desired results. Most of the issues that arise can be easily directed to the appropriate product manufacturer. Sometimes the manufacturer can provide no resolution, but that is uncommon. Most of the user's resources are focused on acquiring and managing a few crucial products.
      </p>
      <p>
        Although I definitely prefer the Unix philosophy, I believe that neither philosophy is inherently better to the degree that it can successfully exclude the other. There will always be sets of competing products, platforms, and approaches that reflect these two philosophies.
      </p>
      <p>
        Java arose from and reflects the Unix philosophy. <a href="DotNet.html">DotNet</a> obviously arose from Microsoft, but it begins to depart from the Windows philosophy. Unfortunately, the partial departure may be what kills it (more on that later). Since there will always be people who pursue each of the Unix or Windows philosophies, there will always be room for products, platforms, and approaches that reflect each one. <a href="DotNet.html">DotNet</a> will not kill Java because <a href="DotNet.html">DotNet</a> is irrelevant to those people who pursue the opposite philosophy, and vice-versa.
      </p>
      <p>
        As for <a href="DotNet.html">DotNet</a>'s departure from the Windows philosophy, I find that <a href="DotNet.html">DotNet</a> adopts many of the characteristics of the Unix philosophy as exemplified in the Java platform. <a href="DotNet.html">DotNet</a> is much more of the mix-and-match-lots-of-little-components than Microsoft's previous approaches. <a href="DotNet.html">DotNet</a> is less monolithic, less GUI-centric, more easily-configured-and-deployed-pieces, more tool-agnostic, etc. However, <a href="DotNet.html">DotNet</a> still keeps some critical footholds in the Windows worldview.
      </p>
      <p>
        <a href="DotNet.html">DotNet</a> claims multilanguage support, but actually doing it is a programmer's nightmare of constraints, incompatibilities, and partially documented gotchas. Likewise, it claims to preserve the legacy code investment, but even porting pre-<a href="DotNet.html">DotNet</a> <a href="VisualBasic.html">VisualBasic</a> is nontrivial.
      </p>
      <p>
        <a href="DotNet.html">DotNet</a> claims platform portability, but Windows-specific functionality is embedded in the core libraries. For example, System.Environment provides information regarding the OS, machine, and user, but it presumes a Windows platform. Other parts of the <a href="DotNet.html">DotNet</a> core libraries presume interaction with IIS or some other Windows product or subsystem. System.Data.SqlClient constitutes the <a href="SqlServer.html">SqlServer</a> database client; I have a problem with upgrading my core development platform just because I need to upgrade my database driver. Including the <a href="SqlServer.html">SqlServer</a> database driver in the core libraries seems inappropriate anyway.
      </p>
      <p>
        Microsoft does not require you to use <a href="VisualStudio.html">VisualStudio</a>, but it is not yet easy not to do so. The Java platform makes it easy to mix-and-match your <a href="JavaVirtualMachine.html">JavaVirtualMachine</a>, compiler, IDE, etc. Microsoft is only just beginning to get there. For a truly enterprise project, I have found that you will need to do so since <a href="VisualStudio.html">VisualStudio</a> is not up to the task.
      </p>
      <p>
        But the one thing that I find most distinguishes the two philosophies, and the two platforms, is the differences in their documentation. I have found that the Windows philosophy has always limited the documentation, both internal and external, to a tool-centricity. The Unix philosophy, especially as exemplified by the Java platform, has expanded the documentation to be design-centric. The <a href="DotNet.html">DotNet</a> documentation, and the third-party documentation available as web sites and books, have only begun to embrace the importance of design. Microsoft <em>et al.</em> now speak of architecture, tool choice, <a href="SeparationOfConcerns.html">SeparationOfConcerns</a>, and other such crucial design issues, but only minimally so and in a naive fog. When I first encountered documentation regarding Java, and especially today as I continue to explore such resources, I am inspired by the focus on design. Most Java-related documents start at a level of design sophistication that very few Microsoft-related documents ever achieve. Microsoft-related authors seem to hope that their readers may eventually become competent with their basic tools and then graduate into designers; Java-related authors seem to (properly) presume that their readers are already competent with their various tools and expect them to be designers already. I have said more about the underlying concepts at <a href="ProgrammingIsInTheMind.html">ProgrammingIsInTheMind</a> and <a href="MicrosoftProgrammerMentality.html">MicrosoftProgrammerMentality</a>.
      </p>
      <p>
        Beyond the philosophical issue, I have found many issues with the <a href="DotNet.html">DotNet</a> platform. Most of them can be attributed to its youth. Java has what I need and want, but <a href="DotNet.html">DotNet</a> has not matured yet. I need transaction management, but <a href="DotNet.html">DotNet</a> does not have it (Microsoft says to use <a href="ComPlus.html">ComPlus</a>, but then you are outside of <a href="DotNet.html">DotNet</a>). I need a distributed object solution, but I am left on my own to figure out <a href="DotNetRemoting.html">DotNetRemoting</a>. I need a clean approach to build a web site (comparable to <a href="JavaServlets.html">JavaServlets</a>), but Microsoft provides only <a href="AspDotNet.html">AspDotNet</a>. I want an <a href="EnterpriseApplication.html">EnterpriseApplication</a> server (comparable to an <a href="EnterpriseJavaBeans.html">EnterpriseJavaBeans</a> container), but nothing is on the horizon. Meanwhile, Microsoft constantly contradicts itself, such as in recommending that DataSets be used to carry data from the database all the way to the GUI, and then pointing out that such an approach violates the design principles of a multitier system.
      </p>
      <p>
        Overall, there are things that I very much like about <a href="DotNet.html">DotNet</a> that I see as improvements over the <a href="JavaPlatform.html">JavaPlatform</a>. However, they are minor compared to the immaturity of and the underlying philosophy of <a href="DotNet.html">DotNet</a>. Maybe <a href="DotNet.html">DotNet</a> will grow up to be a beautiful thing, but I would not promise it.
      </p>
      <p>
        -- <a href="RobWilliams.html">RobWilliams</a>
      </p>
      <hr/>
      <p>
        Re: "I need transaction management, but <a href="DotNet.html">DotNet</a> does not have it (Microsoft says to use <a href="ComPlus.html">ComPlus</a>, but then you are outside of <a href="DotNet.html">DotNet</a>). I need a distributed object solution, but I am left on my own to figure out <a href="DotNetRemoting.html">DotNetRemoting</a>."
      </p>
      <p>
        These are both sort of anti-RDBMS problem-solving approaches. And <a href="SeparationOfConcerns.html">SeparationOfConcerns</a> is an overused buzzword in my opinion and has its own downsides and alternatives. One of the few things I credit Microsoft for is only embracing fads partially, waiting for them to be proven, or at least not dangerous, before plunging all the way. --<a href="AnonymousDonor.html">AnonymousDonor</a>
      </p>
      <p>
        <em></em><a href="ItJustWorks.html">ItJustWorks</a> encapsulates <a href="MicrosoftWay.html">MicrosoftWay</a>.<em></em>
      </p>
      <hr/>
      <p>
        See also <a href="JavaAndDotNet.html">JavaAndDotNet</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryComparisons.html">CategoryComparisons</a> <a href="CategoryDotNet.html">CategoryDotNet</a> <a href="CategoryJava.html">CategoryJava</a>
      </p>
    </div>
  </body>
</html>