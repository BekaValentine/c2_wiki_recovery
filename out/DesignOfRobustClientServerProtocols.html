<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Design Of Robust Client Server Protocols
      </h1>
      <p>
        I found a bad bug where the loss of a reply caused a dead lock of
        of primary and secondary services during sync up. It happens very
        rarely, but i can happen.
      </p>
      <p>
        I was wondering of people could share their thoughts in designing
        robust client-server protocols.
      </p>
      <hr/>
      <p>
        Depends on what you mean by "robust". One definition is "any process that continues to run will halt with an output value in a fixed number of steps, regardless of delays or failures by other processes". This definition is discussed in: 
      </p>
      <ul>
        <li>
           M.P. Herlihy and N. Shavit. <em>The Topological Structure of Asynchronous Computability</em>. Journal of the ACM, November 1999. (<a href="http://www.cs.brown.edu/people/mph/HerlihyS99/p858-herlihy.pdf)">http://www.cs.brown.edu/people/mph/HerlihyS99/p858-herlihy.pdf)</a>
        </li>
      </ul>
      <p>
        which proves that for a large set of practical problems, this kind of robustness is an impossibility (mathematically).
      </p>
      <p>
        Another paper:
      </p>
      <ul>
        <li>
           M. Herlihy and E. Ruppert. <em>On the Existence of Booster Types</em>. In Thirty-Second IEEE Symposium on Foundations of Computer Science (FOCS), November 12-14, 2000 (<a href="http://www.cs.brown.edu/people/mph/HerlihyRu00/focs.pdf)">http://www.cs.brown.edu/people/mph/HerlihyRu00/focs.pdf)</a>
        </li>
      </ul>
      <p>
        discusses the different models of asynchronous concurrent computing, and builds a hierarchy of models that can be implemented on top of other models, losing a degree of robustness at each stage.
      </p>
      <p>
        However, there is also a positive paper that applies the same methods:
      </p>
      <ul>
        <li>
           M.P. Herlihy, V. Luchangco, M. Moir and W.M. Scherer. <em>Software Transactional Memory for Dynamic-sized Data Structures</em>, Proceedings of the Twenty-Second Annual ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing (PODC), July 2003 (<a href="http://www.cs.brown.edu/people/mph/HerlihyLM03b/main.pdf)">http://www.cs.brown.edu/people/mph/HerlihyLM03b/main.pdf)</a>
        </li>
      </ul>
      <p>
        It doesn't promise the same degree of robustness (called "wait-free") that has been proven impossible, but does promise a weaker form of robustness, called here "obstruction-free".
      </p>
      <p>
        <em>Is there something more concrete programmers can use in client-server messaging protocols. It's not clear how to turn those papers into systems.</em>
      </p>
      <p>
        SORRY! I had the wrong reference for the third one (corrected now). The right reference <strong>is</strong> directly applicable in programming!
      </p>
    </div>
  </body>
</html>