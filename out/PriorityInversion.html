<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Priority Inversion
      </h1>
      <p>
        One of the joys of working with <a href="RealTime.html">RealTime</a> systems. It happens when using <a href="LockBasedSynchronization.html">LockBasedSynchronization</a>.
      </p>
      <p>
        <a href="PriorityInversion.html">PriorityInversion</a> is a phenomenon commonly associated with shared resources and their management.
      </p>
      <p>
        High priority threads end up waiting for low priority threads to release resources because all get the same locks on the same resources. Since high priority threads leave few CPU resources to low priority threads, it takes time for low priority threads to release the resources that high priority threads are waiting for.
      </p>
      <p>
        <em>Especially harmful is when a high priority thread blocks on a resource held by a low-priority thread, and a medium priority thread gets the CPU and doesn't block.  In such a situation, the high-priority thread may be starved.</em>
      </p>
      <p>
        <em>A common solution to the problem (implemented by many </em><a href="RealTime.html">RealTime</a> <a href="OperatingSystem.html">OperatingSystem</a>s) is <a href="PriorityInheritance.html">PriorityInheritance</a>, but that technique has its own flaws.<em></em>
      </p>
      <hr/>
      <p>
        The description below is for <a href="ProcessStarvation.html">ProcessStarvation</a> or better named ThreadStarvation (when a thread can't continue because shared resources are never available for it, since other threads have more priority):
      </p>
      <p>
        Thread A has a higher priority than Thread B.  Thread B requests Resource C and blocks on that request, either because some medium priority Thread D delays it, or because some other condition forces it to wait.  Thread A also needs Resource C and tries to get control of it.  Because Thread B is continually interrupted by Thread A, it never finishes with Resource C, which leads to the higher priority Thread A failing because the lower priority Thread B *can't* release the resource because it never gets enough time to complete its task.
      </p>
      <p>
        (Although we don't make gadgets that crawl around on Mars, we do make gadgets that have to interact directly with people.  We have found that there's just nothing like actual people to discover latent inversions in production environments.)
      </p>
      <hr/>
      <p>
        Related: <a href="MarsPathfinder.html">MarsPathfinder</a> 
      </p>
      <hr/>
      <p>
        Links:
      </p>
      <ul>
        <li>
           <a href="http://marsrover.nasa.gov/home/index.html">http://marsrover.nasa.gov/home/index.html</a>
        </li>
      </ul>
      <hr/>
      <p>
        <a href="CategoryConcurrency.html">CategoryConcurrency</a>
      </p>
    </div>
  </body>
</html>