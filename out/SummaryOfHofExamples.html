<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Summary Of Hof Examples
      </h1>
      <p>
        Summary of <a href="HigherOrderFunctions.html">HigherOrderFunctions</a> examples and scenarios given on this wiki, most of which relates to the applicability of HOF's to custom business applications (CBA, see <a href="CustomBusinessApplicationDefinition.html">CustomBusinessApplicationDefinition</a>).
      </p>
      <hr/>
      <p>
        <a href="SummaryOfHofExamplesTwo.html">SummaryOfHofExamplesTwo</a> will try a different approach to summarizing.
      </p>
      <hr/>
      <p>
        <strong>Weather analysis system</strong> in <a href="ArrayDeletionExample.html">ArrayDeletionExample</a>.
      </p>
      <ul>
        <li>
           Cons:
          <ul>
            <li>
               Author says it's covered by a non-disclosure agreement, limiting questions and further probing into the business logic.
            </li>
            <li>
               May not be a CBA
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <strong>Multi-panel auto-refresh display</strong> (A.K.A. "Brady Bunch Intro") as found in <a href="ArrayDeletionExample.html">ArrayDeletionExample</a>:
      </p>
      <ul>
        <li>
           Pros:
        </li>
      </ul>
      <ul>
        <li>
           A runnable example of the display is available at <a href="http://shark.armchair.mb.ca/~dave/hofajax/">http://shark.armchair.mb.ca/~dave/hofajax/</a> complete with the <a href="JavaScript.html">JavaScript</a> source.  See <a href="HofPattern.html">HofPattern</a> for further discussion.
        </li>
      </ul>
      <ul>
        <li>
           Cons:
        </li>
      </ul>
      <ul>
        <li>
           Assumes one is stuck using JS/DOM, which only has one kind of built in "timer", and it requires HOF's as input unless one rolls their own timeer. Thus, the "benefits" of HOF's are only specific the particular client. It's comparable to saying it's easier to use the <a href="TutorialDee.html">TutorialDee</a> query language on the <a href="RelProject.html">RelProject</a> than on an SQL-based RDBMS. A UI "timer" does not have to inherently depend on HOF's in its interface. VB classic had one that did not "expose" or require HOF's, for example.
        </li>
      </ul>
      <ul>
        <li>
           <em>If you feel the environment unrealistically forces HOFs to be used -- and counter that with an imaginary environment that doesn't require HOFs -- then why not imagine your imaginary environment a step further, to wit:  "No matter what your requirement is, there is already an existing application that does it.  Therefore, HOFs are never needed."  (Indeed, by the same logic, we never need any programming!)  Obviously, this is absurd reasoning; we can't consider imaginary tools when examining real applications.  If we're going to consider real applications rather than abstractions, we have to accept the real requirements and real conditions that the real environments impose.</em>
        </li>
      </ul>
      <ul>
        <li>
           Discussion continued at <a href="HofExamplesDiscussionTwo.html">HofExamplesDiscussionTwo</a>.
        </li>
      </ul>
      <ul>
        <li>
           <a href="NodeJsAndHofDiscussionTwo.html">NodeJsAndHofDiscussionTwo</a> discusses an OOP pseudo-code version.
        </li>
      </ul>
      <p>
        <strong>App-side joins and unions from tables in different databases</strong> could benefit from the app querying both databases at the same time.
        (Example found in <a href="NodeJsAndHofDiscussion.html">NodeJsAndHofDiscussion</a>)
      </p>
      <ul>
        <li>
           Cons:
          <ul>
            <li>
               Ideally the language should have a "parallel" block construct in my opinion for that kind of need. (Such blocks are not common in most mainstream languages.) HOF's would be more useful if we needed to <em>dynamically</em> create parallel processes/threads (or at least variations of concurrency), but decent scenarios for that haven't appeared outside of GUI tools and could be done semi-declaratively in a GUI tool, which could roughly resemble HTML "frames" and "iframes" where each panel is treated like an independent mini browser window or mini-web-app, or done via OOP.
              <ul>
                <li>
                   It has been argued that a "parallel block" is limited and inflexible compared to HOF's or NodeJS and therefore HOF's or NodeJS should be used instead. Personally, I don't understand this "in for a penny, in for a pound" argument. Parallel blocks may not be the swiss-army-knife of concurrency management, but they are relatively simple and easy to grok by a wide variety of staff, and thus is the best tool for occasional usage. Spend conceptual complexity on common things, not rare things. -t
                </li>
                <li>
                   [Why spend effort and brainspace learning how to use a "parallel" block construct, which is only ever useful for implementing one specific pattern of concurrency, instead of learning how to use higher-order functions, which can be used both for that concurrency pattern, for dozens of others, and for completely separate uses such as <a href="InternalIterator.html">InternalIterator</a>s? Spend conceptual complexity on common things, not rare things. -DavidMcLean]
                </li>
                <li>
                   If that "one specific pattern" is almost all the app-code-side parallelism a given shop will need, then it's the more economical choice.  (Remember, the web server and RDBMS take care of most of such already.)
                </li>
                <li>
                   [Perhaps, <em>if</em> parallelism is all we need in the application. What happens when we find we can use an <a href="InternalIterator.html">InternalIterator</a> too? Maybe an <a href="EmbeddedDomainSpecificLanguage.html">EmbeddedDomainSpecificLanguage</a> or two? Event handlers? An algorithm we need to inject customisation into? What happens when we need all of those things, yet we only know about a "parallel" block construct? -DavidMcLean]
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           Continued at <a href="HofsAndEmbeddedDslDiscussion.html">HofsAndEmbeddedDslDiscussion</a>, since this is intended to be a summary.
        </li>
      </ul>
      <p>
        <strong></strong><a href="HofPattern.html">HofPattern</a><strong></strong>
      </p>
      <ul>
        <li>
           Pros:
          <ul>
            <li>
               Provides a generic, abstract illustration and justification for <a href="HigherOrderFunction.html">HigherOrderFunction</a>s.
            </li>
          </ul>
        </li>
        <li>
           Cons:
          <ul>
            <li>
               The illustration is abstract and generic rather than concrete and specific.
            </li>
            <li>
               Hasn't been shown applied to realistic custom business examples (disputed, as usual).
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <strong></strong><a href="BlocksInRuby.html">BlocksInRuby</a> including Enumerable as described in <a href="TopOnAbstraction.html">TopOnAbstraction</a><strong></strong>
      </p>
      <ul>
        <li>
           Pros:
          <ul>
            <li>
               Enumerable provides a generic interface to all collections, including database recordsets.
            </li>
          </ul>
        </li>
        <li>
           Cons:
          <ul>
            <li>
               May be better served with objects instead of introducing yet another language construct.
            </li>
            <li>
               May encourage non-standard or bastardized collection handling. It may be best to hard-wire them into the language to prevent unnecessary creativity as described in <a href="StandardToolDependancy.html">StandardToolDependancy</a>.
              <ul>
                <li>
                   [Counter-con: Doesn't do that, for reasons already described in <a href="TopOnAbstraction.html">TopOnAbstraction</a>. -DavidMcLean]
                </li>
                <li>
                   I disagreed with the claims made
                </li>
                <li>
                   [Yes. You raised a couple of concerns; you didn't make any response to my addressing those concerns, though.]
                </li>
                <li>
                   I have to disagree with that.
                </li>
                <li>
                   [Why? Do you have further concerns arising from my responses? Feel free to voice them.]
                </li>
                <li>
                   I'm satisfied with my responses as-is. I feel you are just re-inventing the dead Lisp War.
                </li>
                <li>
                   [I see you have gone on to add further responses. Thank you.]
                </li>
                <li>
                   (Eventually expanded into <a href="DatabaseAbstractInterfaceDiscussion.html">DatabaseAbstractInterfaceDiscussion</a>)
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <strong></strong><a href="ChallengeSixVersusFpDiscussion.html">ChallengeSixVersusFpDiscussion</a> - Reporting system with downloadable source code.<strong></strong>
      </p>
      <ul>
        <li>
           Cons: FP proponents couldn't find a way to improve it with FP or HOF's.
        </li>
        <li>
           Counter-cons: Endless quarrels make it impossible to tell if it's actually the case that FP proponents couldn't find a way to improve it with FP or HOFs, or if Top simply refused to acknowledge their success.
          <ul>
            <li>
               I don't understand, I gave runnable code for it. I don't see anything remotely close on the other side. Any "success" is purely anecdotal. If you find such, please do link to it. I want to see the metrics and how they were scored. --top
            </li>
            <li>
               Update: See <a href="ChallengeSixLispVersionDiscussion.html">ChallengeSixLispVersionDiscussion</a>. The usual disputes about staffing economics and reader <a href="WetWare.html">WetWare</a> came into play.
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <strong></strong><a href="PayrollExample.html">PayrollExample</a> - A basic payroll system with downloadable source code.<strong></strong>
      </p>
      <ul>
        <li>
           Cons: FP proponents couldn't find a way to improve it with FP or HOF's.
        </li>
        <li>
           Counter-cons: Endless quarrels make it impossible to tell if it's actually the case that FP proponents couldn't find a way to improve it with FP or HOFs, or if Top simply refused to acknowledge their success.
          <ul>
            <li>
               (This is not the place to complain about "endless quarrels". Evaluate topical arguments, not writing style here please.)
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <strong>Employee shift scheduling</strong>
      </p>
      <ul>
        <li>
           (Illustration still under construction)
        </li>
        <li>
           Con: May not be CBA because 13 off-the-shelf products were found that already exist to do it. 
          <ul>
            <li>
               Counter-con: It may not make a difference in terms of code design
              <ul>
                <li>
                   Counter: Commoditization ability may imply certain patterns in the app that affects HOF's differently
                </li>
                <li>
                   Counter-counter: The evidence for that is speculative
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
           Con: Claimer admitted that those products didn't exist at the time, and if they did, it may have affected the build-versus-buy decision, meaning it may not currently be CBA.
          <ul>
            <li>
               Counter: Eventually, <em>everything</em> that is currently "CBA" will either be already written or available off-the-shelf, so it's not clear why that's raised as a concern here.
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <strong>Custom Collating</strong> (typically for sorting)
      </p>
      <ul>
        <li>
           See <a href="FunctorVsClosure.html">FunctorVsClosure</a> and <a href="CustomCollationOrder.html">CustomCollationOrder</a>
        </li>
        <li>
           Discussion at <a href="PageAnchor.html">PageAnchor</a> customized-collation-01 on <a href="EvidenceDiscussion.html">EvidenceDiscussion</a>
        </li>
      </ul>
      <p>
        <strong>Query-Language-Like Interface to In-Memory Structures</strong>
      </p>
      <ul>
        <li>
           See <a href="PageAnchor.html">PageAnchor</a> RAM-Structure-Query in <a href="CustomCollationOrder.html">CustomCollationOrder</a>
        </li>
        <li>
           Suggestions considered but not yet fully explored: Use an RDBMS, built-in language TOP capability, OOP "override" interface, and EVAL'd expression passing.
        </li>
      </ul>
      <hr/>
      <p>
        <strong>Techniques competitive with HOF's</strong> (Depending on situation)
      </p>
      <p>
        <a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a> (presumably <a href="FunctorObject.html">FunctorObject</a>s? [1])
      </p>
      <ul>
        <li>
           Pro: 
          <ul>
            <li>
               Can attach attributes to context without changing existing calls.
            </li>
            <li>
               Cleaner "block" syntax. HOF's make for syntactically and visually sloppy blocks because they are often nested in function calls, which is reverse of the typical nesting structure. However, both depend on language design and it's difficult to compare without considering language features and syntax, often leading the debate into language and syntax design.
              <ul>
                <li>
                   Counter: Regarding nested functions as "syntactically and visually sloppy" is either personal preference or due to lack of familiarity with such constructs.
                  <ul>
                    <li>
                       <em>Counter-counter: Re: "lack of familiarity". The fact that it's unfamiliar should count against it. I suggest the industry focus on making OOP syntax and constructs more flexible and/or powerful so that developers can leverage what they already know rather than have to deal with 2 different kinds of syntax/idioms. -t</em>
                    </li>
                    <li>
                       Counter-counter-counter: If we'd treated "lack of familiarity" as a justification for avoiding constructs throughout the history of computing, we'd have no <a href="ObjectOriented.html">ObjectOriented</a> programming, no <a href="StructuredProgramming.html">StructuredProgramming</a>, no <a href="HighLevel.html">HighLevel</a> languages, no <a href="AssemblyLanguage.html">AssemblyLanguage</a>, no <a href="MachineCode.html">MachineCode</a>, no computers, and probably no electricity.
                    </li>
                    <li>
                       <em>Typically research labs, pilot projects, or intentionally high-risk/high-reward start-ups test new ideas and tools, not mainstream production shops. That's not their job nor their forte. This topic is </em>not<em> about research or new-tool testing, at least that's my working assumption. -t</em>
                    </li>
                    <li>
                       Of course, but every "new idea" I listed in "counter-counter-counter" is a mainstream tool used by mainstream production shops.  New ideas become mainstream ideas, or at least generally-recognised or generally-recognisable ideas.  Given that <a href="HigherOrderFunction.html">HigherOrderFunction</a>s have been available in at least one programming language since the late 1950s, and are found in a lot of languages since the 1990s, and are now available in all the top mainstream general-purpose programming languages like Python, PHP, C#, Java and C++, they can hardly be called a <em>new</em> idea.
                    </li>
                    <li>
                       <em>I think we're getting off track here. The "lack of familiarity" was considered from a local scope: what a given typical shop can expect, at least in typical shops I have encountered over the years. From a training/hiring economic perspective of a given shop, it's my judgement that leveraging and maximizing OOP would often be the better option than introducing lambda's and HOF's. (Unfortunately, OO-limited languages may not provide enough options such that L/H's may indeed appear to be the least evil of short-term choices.) Whether typical developers "should" know X is a different scope and different debate.</em>
                    </li>
                    <li>
                       It's not a question of what developers "should" know, but what they will <em>inevitably</em> know -- if not now, certainly in a few years when the latest crop of tech school programming and university <a href="ComputerScience.html">ComputerScience</a> graduates hit the job market in force.  Programming practice evolves.  Not that long ago, OO was unknown in "typical shops"; now it's ubiquitous.  Before that, it was <a href="StructuredProgramming.html">StructuredProgramming</a>.  Of course, OO (and <a href="StructuredProgramming.html">StructuredProgramming</a>, to a lesser degree) was a whole new paradigm, requiring significant changes to programming practice.  For many, it meant re-learning programming.  <a href="HigherOrderFunction.html">HigherOrderFunction</a>s and <a href="LambdaExpression.html">LambdaExpression</a>s are just variants on already-familiar functions.  They require no paradigm shift, no significant change in programming practice, no re-learning programming.  For programmers unfamiliar with them, an hour or two of minimal effort -- at most -- makes them familiar.
                    </li>
                    <li>
                       <em>My Chrystal ball gives a different answer than yours. OO wasn't easy for the industry to swallow (and it's still being being evaluated and absorbed), but since it's "installed" already, the industry may just figure out it's better to leverage it for "code-block indirection" more than by throwing FP into the mix.</em>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           The above is moving to <a href="OopVersusFpDiscussion.html">OopVersusFpDiscussion</a> in order to keep this summary a summary.
        </li>
      </ul>
      <ul>
        <li>
           Cons: 
          <ul>
            <li>
               Generally more verbose, although this may depend on the language and/or API design. It's difficult to compare without considering language features and syntax.
            </li>
            <li>
               HOF's may be better as work-arounds or band-aids to poorly-designed languages and/or API's. See <a href="NodeJsAndHofGuiDiscussion.html">NodeJsAndHofGuiDiscussion</a> for more.
            </li>
          </ul>
        </li>
        <li>
           Examples of comparison: Button-click GUI events: <a href="NodeJsAndHofGuiDiscussion.html">NodeJsAndHofGuiDiscussion</a> (Example 8462 in particular) and a timer interface: <a href="NodeJsAndHofDiscussionTwo.html">NodeJsAndHofDiscussionTwo</a>
        </li>
        <li>
           See also: <a href="FunctorVsClosure.html">FunctorVsClosure</a>
        </li>
      </ul>
      <p>
        EVAL: Strings of functions/expressions that use an Eval() operation when needed
      </p>
      <ul>
        <li>
           Pros:
          <ul>
            <li>
               Their string nature means they can be changed on and stored in databases, text files, etc.
            </li>
          </ul>
        </li>
        <li>
           Cons:
          <ul>
            <li>
               Slower run-time due to parsing step
            </li>
            <li>
               Subject to injection attacks. (Related: <a href="PowerfulCodeEvalDiscussion.html">PowerfulCodeEvalDiscussion</a>)
            </li>
            <li>
               No compile-time checking (if using a compiled language)
            </li>
            <li>
               Scoping of parameters or the equivalent potentially more difficult to manage (although may depend on language features).
            </li>
          </ul>
        </li>
      </ul>
      <p>
        SQL expressions
      </p>
      <ul>
        <li>
           Pro: Complex solutions can be expressed declaratively.
        </li>
        <li>
           Con: Not as full-featured as HOF's or the above.
        </li>
        <li>
           Con: More subject to injection attacks
        </li>
        <li>
           Con: Requires a SQL parser, typically a DBMS.
        </li>
        <li>
           See also: <a href="CustomCollationOrder.html">CustomCollationOrder</a>
        </li>
      </ul>
      <p>
        CASE statements or conditionals
      </p>
      <ul>
        <li>
           Pros:
          <ul>
            <li>
               Uses wide-spread and common language features, making it easy for beginners to understand
            </li>
            <li>
               Can see adjacent expressions to help identify similarities for potential refactoring
            </li>
          </ul>
        </li>
        <li>
           Cons:
          <ul>
            <li>
               May result in more components needing a recompile in compiled languages
            </li>
            <li>
               The grouping may not be appropriate for some applications.
            </li>
            <li>
               Only addresses a limited subset of HOF functionality
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <em>It's not clear how these techniques represent alternatives to HOFs. I presume "objects" means </em><a href="FunctorObject.html">FunctorObject</a>s, but that's just a guess.  It would be useful to see code examples for each alternative that demonstrates how the alternative compares to an equivalent use of a <a href="HigherOrderFunction.html">HigherOrderFunction</a> and/or <a href="LambdaExpression.html">LambdaExpression</a>.  <a href="FunctorVsClosure.html">FunctorVsClosure</a> demonstrates the difference between <a href="FunctorObject.html">FunctorObject</a>s and <a href="LambdaExpression.html">LambdaExpression</a>s in Java.  It would be good to see similar comparisons for EVAL, SQL expressions, and CASE statements or conditionals.<em></em>
      </p>
      <p>
        They are not necessarily all replacements for all HOF's in all circumstances. <a href="ItDepends.html">ItDepends</a> on the design etc.
      </p>
      <hr/>
      <p>
        <strong>Footnotes</strong>
      </p>
      <p>
        [1] I'm not prepared to subscribe to further OOP or OOP-related classification here. I'd rather move the suggestion below. -t
      </p>
      <hr/>
      <p>
        <a href="CategoryFunctionalProgramming.html">CategoryFunctionalProgramming</a>, <a href="CategoryExample.html">CategoryExample</a>
      </p>
      <hr/>
      <p>
        <a href="FebruaryThirteen.html">FebruaryThirteen</a>
      </p>
    </div>
  </body>
</html>