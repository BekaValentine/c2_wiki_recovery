<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Template Metaprogramming
      </h1>
      <p>
        Use of <a href="CeePlusPlus.html">CeePlusPlus</a> templates to execute code at <a href="CompileTime.html">CompileTime</a>.
      </p>
      <p>
        <a href="SmugLispWeenie.html">SmugLispWeenie</a>s will no doubt view this as an inefficient reinvention of <a href="LispMacro.html">LispMacro</a>s.  <em>They are correct of course, templates aren't nearly as powerful as macros, and I'm not a </em>LispWeenie.<em></em>
      </p>
      <ul>
        <li>
           Before this leads to later confused responses: they are both <a href="TuringEquivalent.html">TuringEquivalent</a>, but Lisp macros are exactly as expressive as regular Lisp functions, whereas C++ templates are much less expressive than the rest of C++; they must be used in strange and kludgy ways in order to achieve general computations beyond what they were nominally designed for. This is partly because C++ is not a <a href="HomoiconicLanguage.html">HomoiconicLanguage</a>.
        </li>
        <li>
           See also <a href="CeePlusPlusTemplatesCommonLispMacrosComparison.html">CeePlusPlusTemplatesCommonLispMacrosComparison</a>.
        </li>
      </ul>
      <ul>
        <li>
           As another non-LispWeenie, I have to say that Templates were a very nice try by some hard working people, but the fact that people have fallen into the <a href="TuringTarpit.html">TuringTarpit</a> with them has proven that they were insufficient.  Anything less than a fully expressive macro language will inevitably have shortcomings.  Fundamentally, the problem is that there are so many problems that can be solved in OOP metaprogramming by, on being given type T1,
          <ul>
            <li>
               Define type T2
            </li>
            <li>
               Iterate across the members of T1, create wrappers of them and add them to type T2
            </li>
            <li>
               all at compile time.
            </li>
          </ul>
        </li>
      </ul>
      <p>
        Consider how much can happen once you can iterate across the members/methods.  Implementing garbage-collected classes becomes possible.  Forwarding access to methods becomes simple.  C++ is a very nice language, why can't I just code my macros and templates in it?  If so, classes could simply be objects at compile time - a class would contain an array of method-describing structs, an array of member-describing-structs, etc.  You could iterate across this and use the information for the glorified mess of string parsing that is the actual process of creating the templated class.  If the "class" object included some way to be converted into an aggregate, then implementing reflection becomes simply taking each given class and adding a static "type" member and a dynamic "getType" operation.  Why should Lisp be the only language where macros and code are written in the same (or similar) dialects?  Even if it was just a modified version (like allowing easier emission of code and forcing class-defining operations to be functional) of C++ for macros, it would be better than anything else.  You can do all of this in C#, but it's at run-time so you lose the speed advantage and the static type-checking, making calling operations on your generated classes a massive pain.  Simply put: if your language isn't good enough to define your own programs in, why is it good enough for the logic itself?
        --<a href="MartinZarate.html">MartinZarate</a>
      </p>
      <p>
        See <a href="http://osl.iu.edu/~tveldhui/papers/Template-Metaprograms/meta-art.html">http://osl.iu.edu/~tveldhui/papers/Template-Metaprograms/meta-art.html</a>
      </p>
      <p>
        KrzysztofCzarnecki and UlrichEisenecker's <a href="GenerativeProgrammingBook.html">GenerativeProgrammingBook</a> is a wonderful tour of the world of generative programming.
        Much of it is devoted to demonstrating the
        power of the <a href="CeePlusPlus.html">CeePlusPlus</a> template mechanism. They observe that it is a <a href="TuringComplete.html">TuringComplete</a> language that allows a C++ program to manipulate itself at compile
        time. They go on to show how to build the elements of structured programming (if, switch, while, for) and a lisp processor (cons, car, cdr, ...).
      </p>
      <p>
        The C++ <a href="StandardTemplateLibrary.html">StandardTemplateLibrary</a> makes only very primitive use of the template mechanism. Programmers
        must specify their desires by explicitly choosing an implementation, rather
        than by describing their intent. Czarnecki and Eisenecker show how you can
        use templates to implement a <a href="DomainSpecificLanguage.html">DomainSpecificLanguage</a> for a client's
        use: the template meta-program then constructs the appropriate implementation
        classes based on the preferences.
      </p>
      <p>
        Another area they explore is optimization. They have been involved
        in the development of the <a href="MatrixTemplateLibrary.html">MatrixTemplateLibrary</a> (MTL). Using templates
        to define <a href="LazyEvaluation.html">LazyEvaluation</a> at compile time, they show how a matrix expression
        such as (a+b)*(c+d) can be optimized at compile-time by a suitable
        Template Metaprogram: the expression is compiled into expression objects
        which are optimized (re-structured) by the templates. The restructured
        expression objects are evaluated when the result is assigned. (See <a href="ExpressionTemplate.html">ExpressionTemplate</a>.)
      </p>
      <p>
        There's much more to the book than C++ templates: they discuss a range of
        methods and languages for generative software (I found the first couple
        of chapters a bit tedious). They make a strong case for the limitations
        of today's component technologies. They give a thorough review of
        Microsoft's <a href="IntentionalProgramming.html">IntentionalProgramming</a> research <a href="http://www.research.microsoft.com/IP).">http://www.research.microsoft.com/IP).</a> But their practical examples are
        written in C++. I had thought I understood templates: now I know how much
        I had missed.
      </p>
      <p>
        --<a href="DaveWhipp.html">DaveWhipp</a>.
      </p>
      <hr/>
      <p>
        <a href="BlitzPlusPlus.html">BlitzPlusPlus</a> uses a lot of template metaprograms. The PatternTemplateLibrary also has some interesting, though convoluted, use of parameterization.
      </p>
      <hr/>
      <p>
        <a href="DaixtroseLib.html">DaixtroseLib</a> is a <a href="CeePlusPlus.html">CeePlusPlus</a> header library that retakes ideas developed by ToddVeldhuizen and GeoffreyFurnish. <a href="DaixtroseLib.html">DaixtroseLib</a> is <a href="ExpressionTemplate.html">ExpressionTemplate</a>s for everyone.
        With the help of this library the <a href="ExpressionTemplate.html">ExpressionTemplate</a> technique now is available for everyone.
        <a href="DaixtroseLib.html">DaixtroseLib</a> takes the task of delaying the evaluation and building the expressions, such that users only have to provide the appropriate evaluation methods and by this can plug any existing class into the <a href="ExpressionTemplate.html">ExpressionTemplate</a> context. The library offers fine-grained control over disambiguation rules and copy/reference semantics and was designed to have other libraries built on top of it. --<a href="MarkusWerle.html">MarkusWerle</a>
      </p>
      <hr/>
      <p>
        See <a href="http://arxiv.org/html/cs.CL/0104010">http://arxiv.org/html/cs.CL/0104010</a>
      </p>
      <hr/>
      <p>
        Other books: <em></em><a href="CppTemplatesTheCompleteGuide.html">CppTemplatesTheCompleteGuide</a><em> by </em>DavidVandevoorde and NicolaiJosuttis, <a href="ModernCeePlusPlusDesign.html">ModernCeePlusPlusDesign</a>, <a href="CppTemplateMetaprogramming.html">CppTemplateMetaprogramming</a>, which describes <a href="BoostMpl.html">BoostMpl</a> (MPL).
      </p>
      <hr/>
      <p>
        <a href="CategoryCpp.html">CategoryCpp</a> <a href="CategoryCppTemplates.html">CategoryCppTemplates</a> <a href="CategoryMetaprogramming.html">CategoryMetaprogramming</a> <a href="CategoryLanguageFeature.html">CategoryLanguageFeature</a> <a href="TemplateMetaprogrammingTechniques.html">TemplateMetaprogrammingTechniques</a>
      </p>
    </div>
  </body>
</html>