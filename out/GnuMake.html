<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Gnu Make
      </h1>
      <p>
        Make [<a href="http://www.gnu.org/software/make/make.html]">http://www.gnu.org/software/make/make.html]</a> is a tool invented by <a href="StuFeldman.html">StuFeldman</a> which controls the generation of executables and other non-source files of a program from the program's source files. It first appeared in Version 7 Unix from <a href="BellLabs.html">BellLabs</a> in 1979.
      </p>
      <p>
        Make gets its knowledge of how to build your program from a file called the makefile, which lists each of the non-source files and how to compute it from other files. When you write a program, you should write a makefile for it, so that it is possible to use Make to build and install the program. 
      </p>
      <p>
        So <a href="GnuMake.html">GnuMake</a> is an example of a <a href="MakeTool.html">MakeTool</a>.
      </p>
      <hr/>
      <p>
        More generally, make uses rules to determine how to achieve goals (over a limited domain). Make is the most successful and widely used <a href="ArtificialIntelligence.html">ArtificialIntelligence</a> program around.  It is in essence a <a href="LogicProgramming.html">LogicProgramming</a> language, although for unknown reasons nearly all of the additional features added to versions of Make since 1979 have ignored this.
      </p>
      <hr/>
      <p>
        I love it, I hate it. It now automatically manages all my dependencies for me thanks to <a href="RecursiveMakeConsideredHarmful.html">RecursiveMakeConsideredHarmful</a>, but it can only manage to do this for .c files because patsubst and pattern rules use the same wildcard syntax and there is no way to use the outer wildcard in the inner context. It also has to rebuild all the dependency files in order to clean up the working directory (make clean). It is the best Make I have ever used, and I still hate it. -- <a href="AlastairBridgewater.html">AlastairBridgewater</a>
      </p>
      <hr/>
      <p>
        I have found make to be the most powerful tool in my arsenal. That, and cron are my allies. Make isn't just for programs, it is for data flow, <a href="UnitTest.html">UnitTest</a>s, web pages, database queries, and more. I find that the script that make writes for me is ALWAYS (Shout for joy) better than one I could write myself. I really appreciated the reference to <a href="RecursiveMakeConsideredHarmful.html">RecursiveMakeConsideredHarmful</a> and have begun looking into how to consolidate a small handful of thousand line Makefiles (Which are easy to <a href="RefactorMercilessly.html">RefactorMercilessly</a>) into one with symbolic links to it. -- <a href="ChrisGarrod.html">ChrisGarrod</a>
      </p>
      <hr/>
      <p>
        Q: <em>If God had not given us Makefiles, it would have been necessary to invent them.</em>
      </p>
      <p>
        A: I guess that is what DNA is.
      </p>
      <hr/>
      <p>
        I have a small Makefile for my Objective Caml programs, and another one for my C++ programs. I copy them around wherever I go; I only have to edit the list of source files, the rest happens automatically. Once you have the initial Makefile which does what you want, using make is really a joy; however, writing that first Makefile can be a bit painful if you have no prior experience with make. One tip: make sure you put a tab in the right place, rather than spaces!
        -- <a href="StephanHouben.html">StephanHouben</a>
      </p>
      <hr/>
      <p>
        To stop <a href="GnuMake.html">GnuMake</a> building dependencies when you 'make clean', check for 'clean' in $(MAKECMDGOALS). Only fairly recent versions have $(MAKECMDGOALS) though.
      </p>
      <hr/>
      <p>
        Most modifications to <a href="StuFeldman.html">StuFeldman</a>'s program try to provide a way to include information from other places in makefiles. The include syntax is highly variable. Hmmm, I seem to be talking about a variety of make programs, not just <a href="GnuMake.html">GnuMake</a>. Maybe I too can figure out how to <a href="RefactorMercilessly.html">RefactorMercilessly</a> on <a href="WardsWiki.html">WardsWiki</a>. -- Chris Garrod 
      </p>
      <hr/>
      <p>
        Make is <em>so</em> useful, the only question one could have about it is <em>why</em> has no one invented a replacement which uses a syntax humans can grok?
      </p>
      <p>
        <em>but make syntax is very simple. I don't understand this comment. If we were talking about hand-rolling sendmail.cf files (like the bad old days), I would agree! If you find make inscrutable then perhaps you would enjoy </em><a href="PerforceJam.html">PerforceJam</a> <a href="http://freetype.sourceforge.net/jam/.">http://freetype.sourceforge.net/jam/.</a> I have recently tried it on a few cross-platform projects, with pretty good results. I am not sure how well it scales to really large projects - I know I can do that with make, but I also know it will be a real pita.<em></em>
      </p>
      <hr/>
      <p>
        I've found myself trying to write a real build system for over 25,000 source files. Currently, my company uses Maven, and it's a POS. Builds take over 3 hours without maven tests, 6-7 with, and the build is far from incremental, and it is almost entirely single threaded due to Maven. (Not to be a bash Maven post, but to give perspective.) Trying to work on it is abysmal. Either you take hours to build from root, or you pick and choose what to build, hoping you don't miss a dependency. 
      </p>
      <p>
        I'd like to know if there's a build system out there which
      </p>
      <ol>
        <li>
          - is perfectly incremental or supports easily making the build be perfectly incremental (A naive GNU Make system would not trigger a rebuild when a source file is removed; no prereqs are newer than targets, so no rebuild, even though you almost certainly want to rebuild that dll when a cpp file no longer goes into it.),
        </li>
      </ol>
      <ol>
        <li>
          - parallelizes a build (and possibly distributed builds as GNU Make can be "hacked" to do in various ways), 
        </li>
      </ol>
      <ol>
        <li>
          - is Java / C++ / code generation / Lisp / etc. agnostic like GNU Make (My company uses a dozen custom build tools which is painful in Maven, and Maven doesn't like C++ code all that much 
        </li>
      </ol>
      <p>
        either.),
      </p>
      <ol>
        <li>
          - is very very fast, (With my GNU Make system, have it parsing all of the makefiles and stating all the files for a 25,000 source file build in under 25 seconds [No recursive make].)
        </li>
      </ol>
      <ol>
        <li>
          - and only then easy to work with? 
        </li>
      </ol>
      <p>
        I've almost gotten there with GNU Make 3.81, but it was somewhat painful and tedious to do. I've abstracted away all the really hard stuff so that users of the build system use a simple declarative structure, like define your source folder, your output folder, and your dll name, then say "include build_dll.mk", and voila, make and my build system written in makefiles handles the rest.
      </p>
      <p>
        Also, what would be an appropriate venue, do you think, to post what I've done thus far looking for comments? 
      </p>
      <hr/>
      <p>
        <a href="CategorySoftwareTool.html">CategorySoftwareTool</a>
      </p>
    </div>
  </body>
</html>