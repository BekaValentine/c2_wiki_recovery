<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Py Unit Test Browser
      </h1>
      <p>
        This is <a href="PyUnitTestBrowser.html">PyUnitTestBrowser</a> testing itself:
      </p>
      <code>
        <img src="http://flea.sourceforge.net/TestBrowserScreenShot.gif" /><br/>
      </code>
      <p>
        "Intwiguing!" -- Baby Bear
      </p>
      <p>
        <em>We are testing that the test runner can test a failing test and turn the green bar orange. This self-referential sentence compares to the mental difficulties testing testors with self-referential tests. And this sentence advises you to send mail to </em><a href="DouglasHofstadter.html">DouglasHofstadter</a> that discusses testing testors with themselves by referring to itself, which he'd enjoy.<em></em>
      </p>
      <p>
        This test rig automatically triggers a test of the currently selected item when you save your source. Hence it provides <a href="OneButtonTesting.html">OneButtonTesting</a> for any editor.
      </p>
      <p>
        If your editors are Vim or Idle, you can navigate to any test, any correctly-named source, or any file and line in the error list with a click. This provides One Button Error Navigation.
      </p>
      <p>
        Until I invite Steve Purcell to add this as a Contrib to <a href="PythonUnit.html">PythonUnit</a>, it lurks here:
      </p>
      <code>
        <a href="http://flea.sourceforge.net/browser006.zip">http://flea.sourceforge.net/browser006.zip</a><br/>
      </code>
      <p>
        Version 004 included >all< of the command line suggestions received so far.
      </p>
      <p>
        Version 005 bonds with <a href="PyChecker.html">PyChecker</a>.
      </p>
      <p>
        Version 006 bonds with grep.
      </p>
      <p>
        The documentation is here:
      </p>
      <code>
        <a href="http://flea.sourceforge.net/BrowseMe.html">http://flea.sourceforge.net/BrowseMe.html</a><br/>
      </code>
      <p>
        If you run it with Vim, add an imap and a map under a function key that saves all. This way you don't need to type <esc>:w as your muscle memory demands. (You may not have noticed that's <em>not one button!</em>)
      </p>
      <p>
        <a href="PyChecker.html">PyChecker</a> is a "lint" for python. Click on a file in the tree, tap <F7> or <F8>, and <a href="PyChecker.html">PyChecker</a> (if installed) will lint your test source or production source, respectively. Errors appear in the output list, and of course if you select them an editor will pop up with the cursor on the suspicious line.
      </p>
      <p>
        Have fun! Bio-patches & suggestions with technical backing preferred, at <a href="mailto:phlip_cpp@yahoo.com">mailto:phlip_cpp@yahoo.com</a>
      </p>
      <p>
        --<a href="PhlIp.html">PhlIp</a>
      </p>
      <hr/>
      <p>
        <strong>Tested on:</strong>
      </p>
      <ul>
        <li>
           Mandrake Linux 8+
        </li>
        <li>
           Python 2.2 and 2.1
        </li>
        <li>
           Windows NT with Python2.2
        </li>
        <li>
           PythonMegawidgets 0.8.5 (<em>how modest of them to give such a fine package a version number <1</em>). Grab it from <a href="http://pmw.sourceforge.net/.">http://pmw.sourceforge.net/.</a>
        </li>
      </ul>
      <p>
        <strong>Do List:</strong>
      </p>
      <ul>
        <li>
           Permit browser.py to be on the python path instead of in the current directory. The very aggressive module re-import system breaks relocatability.
        </li>
        <li>
           make the Grep field a "MemoryEntry" - where it remembers previous commands in a drop down
        </li>
        <li>
           put import syntax errors into the output list - not a Tkinter crash window
        </li>
        <li>
           small time delay before import so we know the file flushed out
        </li>
        <li>
           Preserve and restore the screen geometry
        </li>
        <li>
           Bond with Python's debugging systems
        </li>
        <li>
           Make the ditzy trace list box accept a DoubleClick to raise an error
        </li>
        <li>
           Publish how the maybeMainloop system works
        </li>
        <li>
           Port to pygtk
        </li>
        <li>
           Port to wxPython
        </li>
        <li>
           Port to Ruby
        </li>
      </ul>
      <p>
        <strong>Done List:</strong>
      </p>
      <ul>
        <li>
           Specify the pattern to match test files, test_\*.py, on the command line
        </li>
        <li>
           Specify individual test files, with paths, on the command line
        </li>
        <li>
           Specify test folders on the command line
        </li>
        <li>
           db() routes into the error list
        </li>
        <li>
           Find <a href="TestCase.html">TestCase</a>s by any means necessary
        </li>
        <li>
           Test under MsWindows. One dumb os.sep bug fixed!
        </li>
        <li>
           Added (a very untested) link to Python's Idle editor
        </li>
        <li>
           Test under Python2.1 and clean up hyperactive assertions
        </li>
      </ul>
      <hr/>
      <p>
        <em>A truly beautiful piece of work by Phlip. Highly recommended.</em> -- <a href="PeterMerel.html">PeterMerel</a>
      </p>
      <p>
        <a href="PhlIp.html">PhlIp</a>, I've been refactoring stuff for the last couple hours. A friend suggested that refactoring code that you don't understand is a great way to understand it. It doesn't matter if you make the code
        worse as you go. What the hey, just change it back once you understand better.
      </p>
      <p>
        I set up my screen as follows. A shell window on the left, with a little space underneath the window near the bottom of the screen. In that space, pytest's green bar. (The shell window is on top of the pytest window, and the bottom of the pytest window is off the bottom of the screen, so only the green bar is visible.) A vi window on the right.
      </p>
      <p>
        <em>Ben only used the </em><a href="GreenBar.html">GreenBar</a>, and kept the tree and error list out of the way. Because PUB routes errors to both the console and the error list, he watched both program output and errors flow in the "shell window" console. In other words, Ben built an IDE out of Vim (imagine that!), a shell window, and a green bar. <a href="PlugAndPlay.html">PlugAndPlay</a>.<em></em>
      </p>
      <p>
        I just plowed through the test code, changing anything I didn't like, and immediately hitting :w as I always do. The bar went to cyan and back to green. Occasionally when I'd introduce a syntax error, the bar would go orange, and I'd fix it. I got going to an amazingly fast pace, making lots of tiny changes and constantly verifying that they were right. I could zip along and start the next tiny change with only the corner of my eye on the bar.
      </p>
      <p>
        Excellent. Beautiful. Efficient. Pleasant, even. Addictive.
      </p>
      <p>
        -- <a href="BenKovitz.html">BenKovitz</a>
      </p>
      <hr/>
      <p>
        <em>Now if only it got notified by the editor on file write instead of constantly polling and chewing up CPU ... probably a more civilized way to launch the thing in most editors anyway ...</em>
      </p>
      <p>
        The "TestOnSave" meme should infest all test runners. However...
      </p>
      <p>
        ...if you can find a platform- language- and editor-neutral way to either...
      </p>
      <ul>
        <li>
           send a ping from any editor to a test runner
        </li>
        <li>
           sample the local folder's file list as a semaphore
        </li>
      </ul>
      <p>
        ...then I'd love to hear of it.
      </p>
      <p>
        The sticky point is no <a href="TestRunner.html">TestRunner</a> author wants to force users to use a particular editor. So all <a href="TestRunner.html">TestRunner</a> authors invite users to solve the LastMile problem by hand, most users then devolve to a save-mouse-click-click cycle just to test.
      </p>
      <p>
        Further, the test runner should persist in a window during edits. Hence it's always in the same configuration, and one can edit while testing (if one thinks that's wise), and one can test without directly interacting with the testor. This provides overwhelming flow benefits. Keyboard and mental focus remain in the editor until a difficult error occurs. The more one tests, the less often one will.
      </p>
      <p>
        Until a real solution to all these conflicting requirements emerges, we poll. If you actually experience CPU slowdown due a timer which is currently set to a 1/2 second interval, either upgrade something or reduce something else.
      </p>
      <p>
        As of the 2.6 linux kernel, linux supports iNotify, which allows programs to be notified upon filesystem events such as writing to a file.  Perhaps this would be a good way to implement this kind of thing... See: <a href="http://www-128.ibm.com/developerworks/linux/library/l-inotify.html">http://www-128.ibm.com/developerworks/linux/library/l-inotify.html</a> for more info.  The only problem with this is that it's not cross platform.
      </p>
      <p>
        <em>I believe the right thing then is for the testrunner to listen on a public pipe. If you want a file or routine tested, you just throw its name down the pipe. Maybe acquire names from CVS too ... then all it wants is to define levels of diagnostic a la </em><a href="StarTrek.html">StarTrek</a>. Seriously, TestRunnerIsToCodeAsBrowserIsToText ... isn't that what the <a href="SmallTalk.html">SmallTalk</a>ers have been trying to tell us all these years?<em></em>
      </p>
      <p>
        I implemented something like this in <a href="RubyTk.html">RubyTk</a> and <a href="DistributedRuby.html">DistributedRuby</a> -- I split it into two processes so the GUI only listened to the results from the fresh clean interpreter each time it was invoked, didn't have to worry about the slate not being clean. Didn't have <a href="PhlIp.html">PhlIp</a>'s extra touches, though, for sure. But it'd be a short step to make such a beast language-independent -- care to specify a TestResultXmlSchema so xUnits can talk the same language to their GUIs? (which would simplify running PHP tests a <em>lot</em>!) -- <a href="RyanPlatte.html">RyanPlatte</a>
      </p>
    </div>
  </body>
</html>