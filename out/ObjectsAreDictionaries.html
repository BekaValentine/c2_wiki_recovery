<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Objects Are Dictionaries
      </h1>
      <p>
        One definition of "objects" or "object oriented programming" is that objects are "glorified maps" (dictionary structures). Note that no distinction between class and object is made here, as it is assumed to be a language-specific feature rather than part of the definition of <a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a>. (A class is a static dictionary or pre-compiled dictionary in this view.)
      </p>
      <p>
        This "dictionary" (map) comparison roughly comes about as a combination of <a href="RobertMartin.html">RobertMartin</a>'s "jump table" definition of OOP, and an observation that in dynamic OOP languages, objects and classes are basically dictionaries (AKA, associative arrays, hash tables, maps) where the method name is the key, and the result (value cell) is one of:
      </p>
      <ul>
        <li>
           An attribute value
        </li>
        <li>
           Algorithm (method code)
        </li>
        <li>
           Pointer to an algorithm
        </li>
        <li>
           Pointer to another dictionary
        </li>
      </ul>
      <p>
        In statically-typed languages, you simply have a more complex or compound key (method name plus parameter signature) and some access limitations or rules. Aside from "prototype" languages or techniques (which are still considered "inheritance" by most, but use a kind of mitosis {clone} approach), the one extra thing besides the dictionary is the "search path" to the parent(s). If the item is not found in the current dictionary (object), then the search path is checked for other dictionaries that contain the method/attribute (or message) name. However, I am not sure that such a search path is necessary to be considered "OO" because of the above-mentioned clone approach. However, it is popular among languages considered OO. But it can simply be considered a "parent pointer" entry in the dictionary, a reserved attribute.
      </p>
      <p>
        With this view, an object or class is the dictionary, and <a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a> is the process of creating software using *combinations* of these dictionaries (with an inheritance path). 
      </p>
      <hr/>
      <p>
        So you are saying that a class is a list of methods?
      </p>
      <p>
        <em>It is not a list, because it's not ordered.</em>
      </p>
      <p>
        What's the big news and why introduce a new term, i.e., dictionary?
      </p>
      <p>
        <em>It is to establish a "working terminology" for use in certain discussions, such as </em><a href="ArgumentsAgainstOop.html">ArgumentsAgainstOop</a> and <a href="TableOrientedProgramming.html">TableOrientedProgramming</a>. I did not invent the term Dictionary (<a href="DictionaryDataStructure.html">DictionaryDataStructure</a>). It is one of the common <a href="DataStructures.html">DataStructures</a>. They are also known as "maps".<em></em>
      </p>
      <p>
        The fundamental flaw here is that if you put everything in terms of data structures, then of course a data structure oriented approach such as TOP will fit best. 
      </p>
      <p>
        <em>Seeing everything as a data structure is just a way of looking at things. It does not necessarily change the nature of what is being observed or implemented. Besides, how is seeing everything as data structures worse than seeing everything as objects or everything as syntax?</em>
      </p>
      <p>
        Why must we see everything as X?  I doubt you could find many OOP developer insist that we see everything as objects.  
      </p>
      <p>
        <em>I thought I remember some OO proponents claiming they do. However, your question begs the issue of how things *should* be seen. That is outside the scope of finding a definition for OO.</em>
      </p>
      <p>
        I agree there are OO proponents who claimed such a thing, but what's the point even if you could convince them not everything is an object?  Where's the benefit? OO means "Object Oriented", not "Objects Only".  As for how things should be seen, it smacks of <a href="BigDesignUpFront.html">BigDesignUpFront</a>.  Even though I do practice XP complete, I find that by doing the simplest thing possible and refactor properly, I only need to think about how things should be done, never caring about how things should be seen.  How about you start with telling us how seeing everything as a data structure help us develop systems better?
      </p>
      <p>
        <em>Such a discussion is for </em><a href="TableOrientedProgramming.html">TableOrientedProgramming</a>, not here. This topic is about a definition, not benefits.<em></em>
      </p>
      <p>
        <em>As far as what such a view does "help", data structures are relatively well defined. Thus, it gives one a common framework in which to compare things if using it in a definition. I will consider other alternative definitions, but usually I find them vague. I am just trying to climb out of vagueness by using something we (hopefully) all agree on: </em><a href="DataStructure.html">DataStructure</a> definitions. Whether I succeed or not is topic 2.<em></em>
      </p>
      <p>
        I have never met any developer who thinks that a DB table is an object, it is just that it is very convenient to access the table through objects, though.
      </p>
      <p>
        <em>I *have* heard OO proponents say that their objects "hide" (encapsulate) the table so that they can still think in terms of objects. No survey has been presented here for how developers actually think, let alone how they should think.</em>
      </p>
      <p>
        Encapsulating the DB table is what I meant by convenient, as I don't have worry about what DB I am using, 
      </p>
      <p>
        <em>In practice this does not work unless you are only using the DB for bare-bones persistence, which some OO practitioners do.</em>
      </p>
      <p>
        and something I don't even care what datatype I am using for a particular column.
      </p>
      <p>
        <em>I can do that without objects, but this is not the proper topic.</em>
      </p>
      <p>
        I think the question is why cast everything in terms of data structures?  There are already existing of definitions of objects or class you can use, such as <a href="AclassIsNothingButaCyclicDependency.html">AclassIsNothingButaCyclicDependency</a>.
      </p>
      <p>
        <em>I smell more battles over whose OO definition is better. This topic once ranged for about 4 months on comp.object. A dictionary-like viewpoint ("jump-tables") received as many votes as any other presented. (By the way, I criticize </em><a href="AclassIsNothingButaCyclicDependency.html">AclassIsNothingButaCyclicDependency</a> as being too static a definition in there.)<em></em>
      </p>
      <p>
        So what?  Who cares?  We build systems using languages based on OOP paradigm, we don't build anything based on popularity contests of OO definition.  
      </p>
      <p>
        <em>I find it easier to discuss things if the definitions are agreed to by both parties, even if all that can be mustered is a working definition for the scope of the discussion.</em>
      </p>
      <p>
        If OOP paradigm leads to languages that make us more productive, great.  If you can show us how any X-oriented paradigm will make us even more productive, even better! <em>[Another topic]</em> But why must that start with the definition of OO?  When I learn the OO paradigm, no book ever starts with a definition on structure/procedural programming.
      </p>
      <p>
        <em>I thought I have seen some such definitions offered, but don't have any references for you at the moment. Again, definitions are important for coherent discussions in my experience.</em>
      </p>
      <p>
        From my experience, arguing about definitions usually bring more heat than light.  Perhaps you can show us how a concise definition helps us solve problems or develop systems.
      </p>
      <p>
        <em>This topic is about definitions, not about getting benefits. If you think settling on definitions to improve communications is not important, then we cannot go any further.</em>
      </p>
      <p>
        {Perhaps some of the above discussion can be moved to WhyBotherHavingClearDefinitions or the like. I have seen some debate about whether it is worth it or not.}
      </p>
      <p>
        (See e.g. <a href="StandardDefinitions.html">StandardDefinitions</a>.)
      </p>
      <p>
        {Under <a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a>, this definition is listed as one of many, which is what is being suggested, isn't it?}
      </p>
      <hr/>
      <p>
        "Objects have very similar properties to maps (dictionaries)" - It's not quite the same statement, but leans the same way.
      </p>
      <hr/>
      <p>
        (Moved Python dictionary-to-class discussion to <a href="PythonLanguage.html">PythonLanguage</a>)
      </p>
      <hr/>
      <p>
        I am moving "benefit" issues to <a href="DataStructureCentricViewDiscussion.html">DataStructureCentricViewDiscussion</a> 
      </p>
      <hr/>
      <p>
        Another way of putting it is: objects are data structures with methods (procedures) attached to them.  Shouldn't the word dictionary be reserved for the book dictionary?
      </p>
      <p>
        <em>"Map" is probably a more common term than "dictionary", though they are used interchangeably in the wild. Your description doesn't tell us which data structure.</em>
      </p>
      <p>
        Or objects are records with methods (oberon calls them advanced records, or extended records).
      </p>
      <p>
        <em>"Record" is not a formal data structure. It means different things in different language/tools.</em>
      </p>
      <p>
        Classes in C++ are like Cee Structs with methods.  Structs are equivalent (or very close to) records in oberon/delphi/modula. A struct in Cee can directly be compared to a record in delphi.  Even a php associative array could have methods if you extended the php language. Instead of adding methods to structs, you could add methods to the associative array.  
      </p>
      <code>
        array['something'].callMethod() <br/>
      </code>
      <p>
        instead of the more procedural 
      </p>
      <code>
        callProc(array['something']) <br/>
      </code>
      <p>
        Object orientation can also be considered a terse syntax sugar that wraps or abstracts structured programming and procedural programming underneath the hood - it's a bit higher level than procedural and is a syntax sugar over top of it. Object purists would disagree and they see it as a whole new technology, or a new snake oil entirely different than procedural programming. I don't see it this way at all - I see it as an extension of structured procedural programming. Once you understand it is just an extension to procedural structured programming, you cannot hate OOP if you enjoy procedural programming, because OOP is procedural programming!
      </p>
      <p>
        <em>I tend to agree (see </em><a href="MergingMapsAndObjects.html">MergingMapsAndObjects</a>). However, I'm bothered by "extension of procedural". I'd probably classify it as a functional concept in that functions (behavioral units) are or can be manipulated just like any other "kind" of programming "object". Actually, raw machine language allowed such, but a separation began to form around the Fortran era, probably to prevent errors. Ways to have dynamic references without the rawness of machine language took a while to sink in to mainstream languages. -t<em></em>
      </p>
      <hr/>
      <p>
        One advantage of the map-based definition over many of the others is that it considers objects merely as a coding convenience (code packaging) and does NOT assume objects are intended to be used for a specific purpose, such as fitting the "real world" or wrapping "data structures" behind behavioral interfaces. It's a wider view of OO; and if one <strong>dispenses with such "purpose" views</strong>, then map-ism naturally follows. Think about it. --top
      </p>
      <hr/>
      <p>
        See Also: <a href="DictionaryDataStructure.html">DictionaryDataStructure</a>, <a href="SparseColumns.html">SparseColumns</a>, <a href="NetworkDatabase.html">NetworkDatabase</a>, <a href="DefinitionsForOo.html">DefinitionsForOo</a>, <a href="MergingMapsAndObjects.html">MergingMapsAndObjects</a>, <a href="ObjectOrientedLandscape.html">ObjectOrientedLandscape</a>, <a href="AvoidDirectAccessOfMembers.html">AvoidDirectAccessOfMembers</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryDefinition.html">CategoryDefinition</a>
      </p>
    </div>
  </body>
</html>