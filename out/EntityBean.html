<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Entity Bean
      </h1>
      <p>
        <a href="EntityBean.html">EntityBean</a>: One form taken by <a href="EnterpriseJavaBeans.html">EnterpriseJavaBeans</a>. Represents actual data in a database.
      </p>
      <hr/>
      <p>
        Or, to put it another way, they represent business objects that happen to require persistent data. As opposed to <a href="SessionBean.html">SessionBean</a>s, which provide services (business logic) without representing a persistent entity. A 1:1 correspondence with tables in an RDBMS is neither required nor very desirable.
      </p>
      <hr/>
      <p>
        I think the EJB spec writers had something more elaborate in mind. Yes, many EJB servers and CMP implementations assume 1 bean == 1 RDBMS table, but I think the designers had something more like domain objects in mind. It's just that persistence, life cycle and domain object state have been jammed into a single idiom.
      </p>
      <p>
        -<a href="ChrisRaber.html">ChrisRaber</a>
      </p>
      <p>
        On good days, I think the writers were simply inexperienced in dealing with OO-RDBMS issues. I can imagine them finishing <a href="SessionBean.html">SessionBean</a> part and thinking 'RDBMSes are used much in the real world, so we need something to work with them in our spec'.
        On bad days, I think some joker just slipped them into the specification and they became one of the largest practical jokes in the history.
      </p>
      <hr/>
      <p>
        The mapping of the domain objects (or some say it the wrapping of the domain objects with entity beans) to entity bean is typical. Not all domain objects can be represented using the <a href="EntityBean.html">EntityBean</a>s. Like for example if I have a Address table and a Customer table at first I would map both of them to <a href="EntityBean.html">EntityBean</a>s. But as we know, the <a href="EntityBean.html">EntityBean</a>s are bulk components and we don't want to make them fine grained. It would be a better idea to make Address just a normal
        java object (probably a <a href="JavaBean.html">JavaBean</a>) and Customer an <a href="EntityBean.html">EntityBean</a>. The main idea here is wrap the independent domain objects into <a href="EntityBean.html">EntityBean</a>s and the dependent objects as normal <a href="JavaBean.html">JavaBean</a>s. As you said, the other things that we should consider when selecting the appropriate <a href="EntityBean.html">EntityBean</a>s is the life time. 
        -<a href="SeshKumar.html">SeshKumar</a> 
      </p>
      <hr/>
      <p>
        Something that's bothering me about entity beans are all the different criteria by which I may need to locate collections of entity beans. Do I write a custom finder for each (perhaps parameterized) set of criteria? This can get quickly out of control. I've seen persistence layers that allowed you to create a collection of objects from a SQL statement, but that kind of punches through the whole "abstraction" thing, doesn't it?
      </p>
      <p>
        -Paul Busch
      </p>
      <hr/>
      <p>
        <a href="CategoryEjb.html">CategoryEjb</a>
      </p>
    </div>
  </body>
</html>