<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Active Object Model
      </h1>
      <p>
        See also <a href="AdaptiveObjectModel.html">AdaptiveObjectModel</a>, which seems to be the preferred term.
      </p>
      <p>
        One of the things about OOPSLA'97 that impressed
        me the most was that half of the demos had an
        explicit representation of their object model that
        they would interpret.  Each system used a different
        name for this idea, often including "meta" as part of
        the name.  But the name that I liked best was  <a href="ActiveObjectModel.html">ActiveObjectModel</a>.
      </p>
      <p>
        <em>[See </em><a href="MetaData.html">MetaData</a>, <a href="MetaLevel.html">MetaLevel</a> for more about "meta"]<em></em>
      </p>
      <p>
        You can easily get yourself in trouble with an 
        <a href="ActiveObjectModel.html">ActiveObjectModel</a>.  It can make your application
        more abstract and harder for newcomers to understand.
        However, it can also drastically simplify an application,
        can make programs become much more extensible without
        recompiling them, and can make an expert extremely productive.
      </p>
      <p>
        A system with an <a href="ActiveObjectModel.html">ActiveObjectModel</a> has an explicit object
        model that it interprets at run-time.  If you change the
        object model, the system changes its behavior.  For example,
        a lot of workflow systems have an <a href="ActiveObjectModel.html">ActiveObjectModel</a>.
        Objects have states and respond to events by changing state.
        The <a href="ActiveObjectModel.html">ActiveObjectModel</a> defines the objects, their states,
        the events, and the conditions under which an object
        changes state.  Suitably privileged people can change 
        this object model "without programming".  Or are they
        programming after all?
      </p>
      <p>
        One of the systems at OOPSLA was used for defining
        potential products.  The products were complex
        telecommunications equipment.  Each product had hundreds
        of options, and only certainly combination of options
        were legal. The system had an object model that described
        the different components of a product and which 
        configurations were legal.  The whole system used only
        four or five classes, but these classes were things
        like Object and Relation.  The thousands of kinds of
        products were all just instances of Object.  They would
        configure a system for sale by making a clone of one of
        the existing Objects and customizing it.  So, this
        system not only had an <a href="ActiveObjectModel.html">ActiveObjectModel</a>, it used the
        Prototype pattern.  The authors claimed they could
        build a system in .01% of the time that others took to
        build it.
      </p>
      <p>
        The Hartford has an <a href="ActiveObjectModel.html">ActiveObjectModel</a> for representing
        insurance policies.  A policy is a tree of objects,
        each of which is an instance of Component.  Each Component
        has a type, which is an instance of ComponentType.  
        Each instance of ComponentType has a name and defines
        a set of attributes.  For example, the ComponentType
        named "Auto" defines attributes like "Make" and "Year",
        while the ComponentType named "Property" defines attributes like "Address" and "Construction".  The
        component representing the policy on a house has the
        type "Property", and gives values to all the attributes
        defined by the "Property" ComponentType.
      </p>
      <p>
        -<a href="RalphJohnson.html">RalphJohnson</a>
      </p>
      <hr/>
      <p>
        This is similar to <a href="CustomizationViaProgramming.html">CustomizationViaProgramming</a>.
      </p>
      <hr/>
      <p>
        Ralph, you mention attributes above, but what about methods?  Moreover, is AOM really different from, say, a pure prototype system like Self? 
      </p>
      <p>
        It is very interesting to me that here the object model is made explicit and over in <a href="MultiCaster.html">MultiCaster</a>, the connection and notification models are made explicit.  -- <a href="MichaelFeathers.html">MichaelFeathers</a>
      </p>
      <hr/>
      <p>
        This seems a bit related to <a href="BusinessRules.html">BusinessRules</a>, where the rules are made explicit.
      </p>
      <hr/>
      <p>
        I've seen systems that let you define rules and associate them with types.
        The Hartford system is one.  But some of the systems don't do this, so it
        seems to be an optional part of the pattern.
      </p>
      <p>
        Self is a language.  These systems are not billed as languages, though of
        course you can think of them as languages.  Self is prototype based, while
        these are based on the <a href="TypeObject.html">TypeObject</a> pattern.  <a href="JamesNoble.html">JamesNoble</a> has apparently seen
        quite a few prototype-based systems that are similar to this.  I haven't.
      </p>
      <p>
        A lot of patterns make something explicit that is usually implicit.
        I think that is a common trick in OO design.
      </p>
      <p>
        -- <a href="RalphJohnson.html">RalphJohnson</a>
      </p>
      <hr/>
      <p>
        Good insight. See also <a href="AspectOrientedProgramming.html">AspectOrientedProgramming</a>.
        -- <a href="DaveHarris.html">DaveHarris</a>
      </p>
      <hr/>
      <p>
        I would have called it an <a href="AbstractMachine.html">AbstractMachine</a>: you are building a custom set of entities and an instruction set to go along with it. All your domain problems are expressed as combinations of these things. I like these types of designs -- must be my Operating System bias. If you take this seriously, and take into account language-design issues like naming and scope and so on, the designs become super-flexible with little effort. A closely related idea is the Bell Labs' <a href="LittleLanguage.html">LittleLanguage</a> school of design. Although I think the labs people were mistaken to build so many little languages, a single common language like lisp or smalltalk is much better. (Yes, I know they were working on resource-starved machines).  -- <a href="AamodSane.html">AamodSane</a>
      </p>
      <hr/>
      <p>
        Manufacturing systems (MRP, ERP) usually have more than one level of active models:  one level often called Masters, e.g. Product Master, BillOfMaterial Master, Routing Master, defines products and their associated processes generally.  The Master level sometimes also has something corresponding to a <a href="TypeObject.html">TypeObject</a>.  In process industries, the Master level might be called Recipes or Formulas for products.
      </p>
      <p>
        The next level is Planning or Specification, where people plan specific quantities of specific products to manufacture at specific times. This level is the <a href="ActiveObjectModel.html">ActiveObjectModel</a> for the real-time event level. --Bob Haugen
      </p>
      <hr/>
      <p>
        See these pattern languages:
      </p>
      <p>
        <a href="BrianFoote.html">BrianFoote</a> and <a href="JosephYoder.html">JosephYoder</a>, <em>Metadata and Active Object-Models</em>,
        <a href="http://www.joeyoder.com/papers/patterns/patterns.html">http://www.joeyoder.com/papers/patterns/patterns.html</a>
      </p>
      <p>
        <a href="MartinFowler.html">MartinFowler</a>, <em>Dealing with Properties</em>, Copyright year 1997 <a href="http://www.martinfowler.com/apsupp/properties.pdf">http://www.martinfowler.com/apsupp/properties.pdf</a>
      </p>
      <hr/>
      <p>
        In my experience, there is one element that makes an <a href="ActiveObjectModel.html">ActiveObjectModel</a> work or break: If you can come up with a complete interpreter or not. The interpreter is actually the place where your domain knowledge goes in. It contains the invariants of the "<a href="BusinessRules.html">BusinessRules</a>", the fundamental rules the system has to play by. The system can not operate outside this invariants (unless someone comes up with a hack here and there).  The variant parts (<a href="HotSpot.html">HotSpot</a><strong>'s) have been factored out to the object model it interprets.</strong>
      </p>
      <p>
        It is interesting that the systems mentioned on this page are all dealing with a relative small and well defined <a href="ProblemDomain.html">ProblemDomain</a> (Configuration: Combination allowed or not. Insurance: Case Insured or not). All problem domains where it seems to be possible to come up with a closed <a href="MetaModel.html">MetaModel</a> of what is going on in the real word. So one prerequisite for succesfull applying the pattern might be to have
      </p>
      <ul>
        <li>
           a relative small, well defined problem domain,
        </li>
      </ul>
      <ul>
        <li>
           where all principal interactions and relations in the problem domain are known,
        </li>
      </ul>
      <ul>
        <li>
           and where these can be abstracted into some kind of interpreter,
        </li>
      </ul>
      <ul>
        <li>
           forming a <a href="FrameWork.html">FrameWork</a> on a <a href="MetaLevel.html">MetaLevel</a>.
        </li>
      </ul>
      <p>
        Regarding the last point: In my view, <a href="ActiveObjectModel.html">ActiveObjectModel</a> is about creating a <a href="FrameWork.html">FrameWork</a>, which is based on a higher problem domain abstration than usual (on the <a href="MetaLevel.html">MetaLevel</a>). Consequently, the flexible part of such a framework (the object model) operates on the problem domain level.
      </p>
      <p>
        -- <a href="ThomasWeidenfeller.html">ThomasWeidenfeller</a>
      </p>
      <hr/>
      <p>
        A note about the pattern's name. <a href="ActiveObject.html">ActiveObject</a> is a well known OO term, where it denotes that an object executes in its own thread of control. Maybe <a href="ActiveObjectModel.html">ActiveObjectModel</a> is a misleading name?
      </p>
      <p>
        Seconded!  --<a href="PaulMorrison.html">PaulMorrison</a>
      </p>
      <hr/>
      <p>
        See also: <a href="http://www.adaptiveobjectmodel.com/">http://www.adaptiveobjectmodel.com/</a> 
      </p>
      <hr/>
      <p>
        <a href="CategoryPattern.html">CategoryPattern</a> <a href="CategoryModels.html">CategoryModels</a>
      </p>
    </div>
  </body>
</html>