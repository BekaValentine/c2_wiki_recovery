<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Why People Use Bad Languages
      </h1>
      <p>
        Dumping stuff trimmed from other pages here.
      </p>
      <p>
        Any language could be considered bad. The most common ones that seem to be referred to as bad are <a href="MainstreamLanguage.html">MainstreamLanguage</a>s such as <a href="CobolLanguage.html">CobolLanguage</a>, <a href="FortranLanguage.html">FortranLanguage</a>, <a href="CeeLanguage.html">CeeLanguage</a>, <a href="CeePlusPlus.html">CeePlusPlus</a>, and <a href="BasicLanguage.html">BasicLanguage</a>. Sometimes people also call <a href="PerlLanguage.html">PerlLanguage</a> and <a href="PythonLanguage.html">PythonLanguage</a> pretty bad.
      </p>
      <p>
        I suspect that the main reasons people use bad languages are either situation pressure, or it is the best of what they know and they don't want to learn better (or they disagree that better exists).
      </p>
      <p>
        Don't discount that the "bad language" may simply be what they were taught and what they see everyone else using.  To illustrate: you could also ask why do so many people speak <a href="EnglishLanguage.html">EnglishLanguage</a>?  
      </p>
      <hr/>
      <p>
        Why does anyone use <a href="CeePlusPlus.html">CeePlusPlus</a> if it's so bad?
      </p>
      <p>
        <em>People use </em><a href="CeePlusPlus.html">CeePlusPlus</a> for a number of reasons:<em></em>
      </p>
      <ul>
        <li>
           <em>They're working within the </em><a href="MicroSoft.html">MicroSoft</a> toolset, which is set up to encourage work in either C++ or <shudder> <a href="VisualBasic.html">VisualBasic</a>. Apart from the maintenance horrors of the language itself, VB presents a number of serious architectural limitations that prevent it scaling - no object pooling & only single apartment threading (<a href="SingleThreadedApartment.html">SingleThreadedApartment</a>) - so in MS-land C++ is almost universally accepted as the basis for building larger apps.<em></em>
        </li>
      </ul>
      <ul>
        <li>
           <em>They're working with </em><a href="RealTime.html">RealTime</a> / embedded systems. Manufacturers of these systems usually offer <a href="ApplicationProgrammingInterface.html">ApplicationProgrammingInterface</a>s in <a href="CeeLanguage.html">CeeLanguage</a> or <a href="CeePlusPlus.html">CeePlusPlus</a>, and the maintenance and performance costs of shoe-horning a <a href="JavaVirtualMachine.html">JavaVirtualMachine</a> into the picture aren't acceptable.<em></em>
        </li>
      </ul>
      <ul>
        <li>
           <em>Their team's experience base is mainly </em><a href="CeePlusPlus.html">CeePlusPlus</a>. It's easy (and fun!) for C++ folk to make the transition to the <a href="JavaLanguage.html">JavaLanguage</a>, but a conservative manager may see this as an unacceptable risk.<em></em>
        </li>
      </ul>
      <ul>
        <li>
           <em>They've never tried serious development in any other language, so they succumb to the </em><a href="BlubParadox.html">BlubParadox</a>.<em></em>
        </li>
      </ul>
      <ul>
        <li>
           (Or they've never heard of <a href="ObjectiveCee.html">ObjectiveCee</a>.)
        </li>
      </ul>
      <p>
        Or is it not bad, in some way I don't understand?
      </p>
      <p>
        <em>Although I've rubbished </em><a href="CeePlusPlus.html">CeePlusPlus</a> here a couple of times (especially on <a href="AllPanaceasBecomePoison.html">AllPanaceasBecomePoison</a>), I maintain a grudging affection for the language. Given the right team, I can build big systems fast in C++, applying all the <a href="ExtremeProgramming.html">ExtremeProgramming</a> techniques without getting tripped in any particular way. Nothing about the language is a development showstopper; it just requires higher development discipline to do things right in C++ than to do things wrong.<em></em>
      </p>
      <ul>
        <li>
           If a team is doing some IS kind of project in <a href="CeePlusPlus.html">CeePlusPlus</a>, they are tagged with one of the two danger signs in Alistair's book. What alternative implementation language[s] could/should they consider?
          <ul>
            <li>
               <em>They should consider </em><a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a> with the most appropriate of <a href="PythonLanguage.html">PythonLanguage</a>, <a href="HaskellLanguage.html">HaskellLanguage</a>, <a href="PerlLanguage.html">PerlLanguage</a> or <shudder> <a href="VisualBasic.html">VisualBasic</a> for the soft layer. Better to write most of your system in a soft language that's easier to maintain, then profile and rewrite the hard bits in C++. But you may find strong management resistance to this notion - management sees extra languages as extra risks, not risk reducers.<em></em>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <a href="ObjectiveCee.html">ObjectiveCee</a>. It's a direct superset of C, unlike C++ (you can assign void pointers to non-void pointers, for example), with a message-oriented Smalltalk-like object system. It's not really an obscure language either. Most <a href="MacOs.html">MacOs</a> development is done in the <a href="CocoaFramework.html">CocoaFramework</a>, Apple's <a href="ObjectiveCee.html">ObjectiveCee</a> class library. I'm really surprised people keep forcing themselves to choose between C++ and Java, meanwhile a beautiful, very simple OO superset of C is right there waiting to be used. <a href="ObjectiveCee.html">ObjectiveCee</a> isn't perfect, but it's unbelievably better than C++. And C++ keeps getting farther and farther from the metal; templates, <a href="RunTimeTypeInformation.html">RunTimeTypeInformation</a>, and so much more have slowed this beast down, and the ISO committee just keeps adding more and more to it. C++ gets slower and slower and uglier and uglier. I'm really shocked people keep forcing themselves to use it even when they really don't have to. (<a href="GnuCee.html">GnuCee</a>, by the way, comes with an <a href="ObjectiveCee.html">ObjectiveCee</a> compiler too, since the language is just a small, simple wrapper around C.  <a href="GnuCee.html">GnuCee</a> is the compiler Apple uses in their <a href="ExCode.html">ExCode</a> IDE.)
          <ul>
            <li>
               You got to love the irony of a paragraph that in the same breath, a) praises <a href="ObjectiveCee.html">ObjectiveCee</a> for it's "Smalltalk-like" object system, and b) condemns C++ for RTTI for "slowing this beast down". For one thing, RTTI doesn't cost you any CPU cycles unless you explicitly use it (with <a href="DynamicCast.html">DynamicCast</a>, etc.) - and even then RTTI is comparatively cheap. For another, <a href="ObjectiveCee.html">ObjectiveCee</a> (and all languages with <a href="DynamicTyping.html">DynamicTyping</a>) perform the equivalent of RTTI on <strong>every single message send!</strong>. The cost of a selector lookup in <a href="ObjectiveCee.html">ObjectiveCee</a> is (depending on how closely it mirrors Smalltalk semantics) quite a bit more than a <a href="VeeTable.html">VeeTable</a> lookup in C++. Which isn't itself a bad thing; greater <a href="LateBinding.html">LateBinding</a> gives the programmer more flexibility, which is the selling point of higher-level languages. But when such arguments are used to promote the <a href="MythOfCppBloat.html">MythOfCppBloat</a>, that's another story altogether.
              <ul>
                <li>
                   <em>Indeed. I wonder if many of the C++ criticizers have actually done much development in C++, or if they just buy into the "C++ = big bloated code" stereotype. Also many people confuse nice clean portable C++ with the horrible COM/MFC ridden monstrosities that some Windows programmers created</em>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           I wasn't saying C++ is slower than Objective C, but the fact is, <strong>C++ has gotten slower</strong>, and <strong>continues to get slower</strong>. What about the .NET runtime? (Or Mono?) What about the managed code that comes with it? I know, those things - like dynamic casting, exceptions, templates, etc. - are all optional. If a C++ programmer wants to, they can just use C++ as a "better" C. Well, for better or for worse, many developers <em>are</em> going to take advantage of all of those features, and at that point the efficiency arguments start to go out the window, and in my opinion, Objective C starts to look like a really, really nice alternative.
        </li>
      </ul>
      <ul>
        <li>
           <em>Uh, </em><a href="DotNet.html">DotNet</a> really has almost nothing to do with <a href="CeePlusPlus.html">CeePlusPlus</a>. Or any particular language. A dialect of C++, called <a href="ManagedCeePlusPlus.html">ManagedCeePlusPlus</a>, is supported by <a href="DotNet.html">DotNet</a> - but Managed C++ is sufficiently different under the hood that observations about it don't apply to C++. When you speak of "many" developers, an important question to ask is "developing what?" Much custom business software isn't being written in C, C++, or <a href="ObjectiveCee.html">ObjectiveCee</a>; instead, it's being written in VB, C#, Java, etc. All of which are probably more appropriate for that sort of software than either C++ or Obj-C is. C++ and Obj-C both are more suited to shrinkwrap and/or widely-distributed <a href="OpenSource.html">OpenSource</a> software, where the additional testing/development required to support a more low-level language can be amortized across many more installations/sales/downloads, and users are more likely to have greater demands on performance. In that domain, ObjC is nice, but C++ has long surpassed it. The one thing that ObjC has that C++ doesn't is <a href="DynamicTyping.html">DynamicTyping</a> (of objects), and numerous dynamic object models have been greenspunned on top of C++. I shudder at the amount of work that would be required to add many of the C++ semantics to ObjC.<em></em>
        </li>
      </ul>
      <ul>
        <li>
           <em>Remember that C++ programmers can choose which features to use (we don't use templates, RTTI is a checkbox in the project settings). Just because the feature exists and is arguably bloated doesn't mean it has to be used</em>
        </li>
      </ul>
      <ul>
        <li>
           How can a team or company wean themselves from <a href="CeePlusPlus.html">CeePlusPlus</a>?
          <ul>
            <li>
               <em>If they don't actually have a good reason for C++, then as Kyle says above they ought to go to </em><a href="JavaLanguage.html">JavaLanguage</a>. It has some warts, but it's really such a much better choice for most applications.<em></em>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           Using <a href="CeePlusPlus.html">CeePlusPlus</a>, how can maximum flexibility be maintained?
          <ul>
            <li>
               <em>Apart from </em><a href="ExtremeProgramming.html">ExtremeProgramming</a> and <a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a>, get used to the idea that <a href="MultipleInheritanceIsNotEvil.html">MultipleInheritanceIsNotEvil</a> and then scrupulously apply the <a href="AcyclicDependenciesPrinciple.html">AcyclicDependenciesPrinciple</a> when refactoring. Also don't let <a href="CeeLanguage.html">CeeLanguage</a> atavisms creep into your code; keep everything strictly within <a href="StlStyle.html">StlStyle</a>. Also use a really good cross-platform generics library - <a href="ObjectSpace.html">ObjectSpace</a> is my favourite. And, if in MS-land, use the <a href="ActiveTemplateLibrary.html">ActiveTemplateLibrary</a> and never ever use <a href="MicrosoftFoundationClasses.html">MicrosoftFoundationClasses</a>.<em></em>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           Why does <a href="CeePlusPlus.html">CeePlusPlus</a> exist?
          <ul>
            <li>
               <em>So that we can have an OO language that's close to the metal.</em>
            </li>
          </ul>
        </li>
      </ul>
      <p>
        -- <a href="PeterMerel.html">PeterMerel</a>
      </p>
      <hr/>
      <p>
        See <a href="WhyFunctionalProgrammingLanguagesArentMainstream.html">WhyFunctionalProgrammingLanguagesArentMainstream</a>
      </p>
    </div>
  </body>
</html>