<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        The Real Definition Of Agile
      </h1>
      <p>
        In <a href="AgileSoftwareDevelopment.html">AgileSoftwareDevelopment</a>, <a href="AlistairCockburn.html">AlistairCockburn</a> describes an agile process as being both light and sufficient, where lightness means maneuverability, and sufficiency means facilitating future development.  He then identifies five "sweet spots" that characterize agilility, having to do with team size and composition, frequency of feedback on the product and process, etc.  I've found his conception more helpful, in gauging whether a project is "agile", than a checklist of practices from a particular agile method.
      </p>
      <p>
        That sentiment was echoed by a group of participants in the "Executive Summit" of the 2003 <a href="AgileDevelopmentConference.html">AgileDevelopmentConference</a>, who concluded that they have come to value the principles of agile development over the practices of agile development (that is, while there is value in the item on the right, they value the item on the left more).
      </p>
      <hr/>
      <p>
        <em>de-paraphrased by </em><a href="PhlIp.html">PhlIp</a>:<em></em>
      </p>
      <p>
        While developing software, the time between test runs matters.
      </p>
      <p>
        The most difficult but important increments to test are the end-users? productivity gains.
      </p>
      <p>
        At one scale, some projects manually test every few weeks, or less often. That impedes improving end users? productivity; inner cycle delays compound outer cycles? delays.
      </p>
      <p>
        <a href="AgileSoftwareDevelopment.html">AgileSoftwareDevelopment</a> exploits the other end of the scale. We automatically test everything relevant to a module after the fewest possible edits; say 10 at the most. So we only perform the kinds of edits that immediately return the project to a testable state.
      </p>
      <p>
        Make testing, including manual testing in the hands of real end-users, as cheap as possible. Bugs delay feedback, so write simple code and lots of tests. Time spent ?perfecting? the object model delays getting to that feedback, so use a ?good enough? object model. Harness feedback to defeat process waste.
      </p>
      <p>
        Testing the act of changing code fundamentally shifts how our industry specifies good design. Books like <em></em><a href="DesignPatterns.html">DesignPatterns</a><em> show good solution instances, frozen in time. Books about Agility describe dynamically seeking good designs.</em>
      </p>
      <p>
        Test coverage makes inspiration and intuition safe. Tight & automated feedback increases the odds we catch errors as soon as we make them, not weeks or months later when memories are stale. Unnoticed errors lead, later on, to long bug hunts in code that may since have grown more complex.
      </p>
      <p>
        Incremental changes and relentless testing permit Agile projects to reach for these goals:
      </p>
      <ul>
        <li>
           accept feature requests in any order, at any time
        </li>
        <li>
           release any Integration to <a href="QualityControl.html">QualityControl</a> and beyond
        </li>
        <li>
           minimize the time between specifying a feature and using it (<a href="SoftwareInProcess.html">SoftwareInProcess</a>, LeanDevelopment)
        </li>
      </ul>
      <p>
        A project?s client steers with feature requests, getting the most important ones first. The sooner these features help end-users add value, the sooner our project lifts off the runway and sustains itself.
      </p>
      <p>
        <em>note that while </em><a href="PhlIp.html">PhlIp</a> formerly inspired others to write a page called "<a href="TheRealDefinitionOfAgile.html">TheRealDefinitionOfAgile</a>", <a href="PhlIp.html">PhlIp</a> himself knows better than to present <strong>goals</strong> as definitions or diagnoses.<em></em>
      </p>
      <hr/>
      <p>
        So what if you were to define what it meant to be Agile and you didn't have to worry about satisfying the hopes and fears of all the 17 founding members of the <a href="AgileAlliance.html">AgileAlliance</a>?  I think you'd come up with something like the above.
      </p>
      <p>
        It's simple and it's got the same HardCore and honest feel as:
      </p>
      <p>
        <em>Listening, Testing, Coding, Designing. That's all there is to software. Anyone who tells you different is selling something.</em>
      </p>
      <hr/>
      <p>
        I can do those things and release poodles, not software.
      </p>
      <p>
        <em>If you did, then I don't think you understand what Listening means</em>
      </p>
      <hr/>
      <p>
        To me the essence of Agile is expressed in a Zen poem I read some time ago:
        "With but rod and sandals I traverse the ten thousand worlds"
      </p>
      <p>
        <em>I would guess that only one guy actually got through the ten thousand world with just a rod and sandals, and I'm thinking he may have had a towel he's not telling us about.</em>
      </p>
      <hr/>
      <p>
        <em>I can do those things and release poodles, not software.</em>
      </p>
      <p>
        <em>If you did, then I don't think you understand what Listening means</em>
      </p>
      <p>
        Why would a process working for making good software not work for "manufacturing" good poodles?
      </p>
      <p>
        <em>Because software is not hardware, nor a living thing.  Not everything that applies to manufacturing or biological processes applies directly to software development, and vice-versa.  To think otherwise is naive - there is no "one process to rule them all." </em> -- <a href="JamesTwine.html">JamesTwine</a>
      </p>
      <hr/>
      <p>
        What do you mean he wouldn't understand what Listening means?  Maybe I don't understand either?  To me, listening is requirements gathering.  If the requirements are that they need poodles, and I produce poodles, where have I misunderstood what is meant by listening?
      </p>
      <hr/>
      <p>
        See also <a href="SoftwareManagementManifesto.html">SoftwareManagementManifesto</a>
      </p>
      <hr/>
      <p>
        Category Agile Methodology
      </p>
    </div>
  </body>
</html>