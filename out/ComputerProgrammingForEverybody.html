<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Computer Programming For Everybody
      </h1>
      <p>
        CP4E: Computer Programming for Everybody
        <a href="http://www.python.org/doc/essays/cp4e.html">http://www.python.org/doc/essays/cp4e.html</a>
      </p>
      <p>
        A proposed research effort "to improve the state of the art of computer use, not by introducing new hardware, nor even (primarily) through new software, but simply by empowering all users to be computer programmers."
      </p>
      <hr/>
      <p>
        <strong>Summary of Where it Succeeds</strong>
      </p>
      <ul>
        <li>
           For political or social reasons, no professional programmers are available
        </li>
        <li>
           Time-saving shortcut intended to be used only by the originating user
        </li>
        <li>
           Prototyping - has the advantage of a domain expert behind it
        </li>
      </ul>
      <p>
        <strong>Summary of Where it Fails</strong>
      </p>
      <ul>
        <li>
           When the user takes 4 times longer to make the same program as a programmer, it's not economical.
        </li>
        <li>
           Newbies have no experience with maintenance and techniques for improving maintenance. While some users pick up programming quickly, maintainability usually requires experience. (Maintenance is often more expensive than first roll-out in the long-run.)
        </li>
        <li>
           Difficult to hand-off because most users of the tool don't program in it also, and it's not a standard "IT shop" programming language. (If you hire a domain tool expert who also knows its programming language/interface, then you are essentially hiring a programmer, not a domain program user. Thus, they don't qualify as "everybody".)
        </li>
      </ul>
      <hr/>
      <p>
        <strong>CP4E with Python</strong>
      </p>
      <p>
        Though the proposal starts with a reference to <a href="XeroxParc.html">XeroxParc</a>, it uses <a href="PythonLanguage.html">PythonLanguage</a>, not <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>. (Maybe not so odd; the proposal is made by <a href="GuidoVanRossum.html">GuidoVanRossum</a>, the creator of <a href="PythonLanguage.html">PythonLanguage</a>.) One could argue for other languages, but <a href="PythonLanguage.html">PythonLanguage</a> is not the worst possible choice.
      </p>
      <hr/>
      <p>
        Here is an interesting (but short) interview with <a href="GuidoVanRossum.html">GuidoVanRossum</a> about using Python to teach programming to non-computer science people: <a href="http://www.linuxjournal.com/article.php?sid=5028">http://www.linuxjournal.com/article.php?sid=5028</a>
      </p>
      <hr/>
      <p>
        <strong>CP4E: meta</strong>
      </p>
      <p>
        <em></em><a href="EditHint.html">EditHint</a>: This page contains much that is interesting, but is hopelessly <a href="ThreadMess.html">ThreadMess</a>ed. Perhaps it's time to start distilling the information from it.<em></em>
      </p>
      <p>
        One obvious place to start editing: leave all the Python-specific stuff here, and move all the more general, is-computer-programming-for-everybody? stuff to a new page (IsComputerProgrammingForEverybody, perhaps).  <em>Or vise versa: </em>PythonForEverybody and general stuff here.<em></em>
      </p>
      <hr/>
      <p>
        <strong>CP4E with Python</strong>
      </p>
      <p>
        <em> Where does Python need improvement for beginners? </em>
      </p>
      <p>
        How about a list of PythonProgrammingProjects which are graded according to difficulty?
      </p>
      <p>
        In the end, programming is much more about problem solving than syntax. What newbie programmers need are programming problems which are neither too easy nor too difficult, Projects which will challenge but not overwhelm the new programmer. Ideally, I think, a good programming project (for a beginner) should be solvable within the time-span of a single afternoon-- for relatively instant gratification.
      </p>
      <hr/>
      <p>
        Python doesn't come with a simple GUI builder. A beginner should be able to make a nice dialog box with minimal effort. This is the obvious thing to fix.
      </p>
      <p>
        <em></em><a href="PythonCard.html">PythonCard</a>, a <a href="HyperCard.html">HyperCard</a>-like Python environment, seems like the solution to this. <a href="HyperCard.html">HyperCard</a> was very easy to teach to people familiar with GUIs, but not programming. -- <a href="GeorgePaci.html">GeorgePaci</a><em></em>
      </p>
      <p>
        And the syntax is tricky. Case sensitivity is a big problem. An editor which forces valid syntax would help.
      </p>
      <p>
        A big issue is that programming requires clear and logical thinking. This is hard. A GUI which manipulates semantics could help. As in "Do you want me to make sure this array is sorted?"
      </p>
      <p>
        -- <a href="EricUlevik.html">EricUlevik</a>
      </p>
      <hr/>
      <p>
        <strong>CP4E in general</strong>
      </p>
      <p>
        I don't think beginning programmers necessarily need to be developing dialog boxes that early in their careers.  Event-driven programming is kind of subtle.  I'd rather have them learn with procedural console I/O driven programs.  Ask the user for some data, process it, then output some data.  
      </p>
      <p>
        On the other hand, I agree that incorporating some sort of GUI into the learning process can help beginners who are intimidated by the debugging process.  See <a href="KarelTheRobot.html">KarelTheRobot</a>. -- <a href="SteveHowell.html">SteveHowell</a>
      </p>
      <p>
        <em>I disagree with the console I/O approach, simply because beginners get bogged down with reading text line-by-line (or record-by-record), parsing it into words/commands/data, checking for invalid input formats, and so on.  Many would-be programmers give up at this stage, because it is just too frustrating, and they are left with the impression that all programming is like this.  The benefit of a GUI approach is that it generally simplifies the I/O model, allowing beginners to think more about overall program logic. --</em><a href="KrisJohnson.html">KrisJohnson</a><em></em>
      </p>
      <p>
        I would just start them with output only.  The compute something, and then they output it with output().  If that's too frustrating for them, they don't have much of a future in it, anyway.  For input, make sure they have a real simple API like readString, readNumber, and have your API strip off the carriage returns for them automatically.  -- <a href="SteveHowell.html">SteveHowell</a>
      </p>
      <p>
        <em>Another drawback of console-based teaching is that, well, students have to use the console.  Assuming that most students are accustomed to Windows and other GUI interfaces, using a command-line is one more hurdle they have to jump before they can get to the good stuff.  -- </em><a href="KrisJohnson.html">KrisJohnson</a><em></em>
      </p>
      <p>
        Well, I guess I should clarify that I like the idea of learning stream I/O before graphical I/O, but I have no objection to starting the students from within an IDE.  I actually like the idea of learning the command line before learning to program, though.  Giving instructions to the computer one line at a time is just a simple form of programming, after all.  A beginner can go a long way with a few commands like ls/dir, cd, and perl/cc/javac/python.  Python has a nice, friendly interpreter mode too.  Getting hello-world up and running in a command-line environment is a great warmup for more sophisticated detail-oriented tasks.  -- <a href="SteveHowell.html">SteveHowell</a>
      </p>
      <hr/>
      <p>
        You like the command line because it's rudimentary programming. But why do we have to go back to the ancient technology of the console to be able to program our own machine? Just why is it that the GUI doesn't allow for rudimentary programming? As a simple example, why is it that one can't set up scripts and pipes using a few mouse clicks and gestures? Why is it that every GUI application is fat and bloated so that X-Window programs resemble DOS programs more than Unix? Why is it that the GUI doesn't have a sign language (UML diagrams maybe?) the same way that Unix has "lots of little programs"? Why is it that the GUI doesn't have a viewable history to see what was executed? If you want to teach <a href="ComputerProgrammingForEverybody.html">ComputerProgrammingForEverybody</a>, then invent the GUI equivalent of the modern programmable shell. The killer app for it might be non-linear pipelines. -- Anonymous
      </p>
      <ul>
        <li>
           Many operating systems and applications have a recordable scripting system, which lets you record a series of actions into a script.  Examples: Unix command line and the 'script' utility, <a href="MacOs.html">MacOs</a> and <a href="AppleScript.html">AppleScript</a>, many editors (Emacs, vi), some Microsoft applications and <a href="VisualBasicForApplications.html">VisualBasicForApplications</a>.  The nice thing about this is you are left with a program you can tweak without having to start from scratch; a kind of template based programming.
        </li>
      </ul>
      <p>
        As much as we humans despise certain poorly designed text interfaces, we still like text.  A picture might say a thousand words, but try to translate your paragraph above into a picture, and you'll see the converse is true as well.  Anyone who has ever driven himself mad trying to build a Visio document will tell you it's a relief sometimes to just express relationships with text.  (See <a href="GraphViz.html">GraphViz</a>, for example.)
      </p>
      <p>
        I have seen at least one tool that let you build programs by combining some sort of graphical primitives, but I forget its name.  I don't think any one ever built serious programs with it.  -- <a href="SteveHowell.html">SteveHowell</a>   <em>Could you be thinking of </em><a href="SanScript.html">SanScript</a>? (See <a href="http://www.nwoods.com/sanscript)''">http://www.nwoods.com/sanscript)''</a>
      </p>
      <p>
        <strong>There are a few such programming languages: some </strong>DataFlow languages, and tree-rewriting languages such as <a href="WouterVanOortmerssen.html">WouterVanOortmerssen</a>'s Aardappel language.<strong></strong>
      </p>
      <p>
        I agree with Anonymous that the console is archaic, and should not be used in the teaching of new programmers.  I don't understand why so many people think that a teletype emulator is the best way to interact with a computer.  However, I still think programs should be written using textual programming languages until someone can create a useful <a href="GraphicalProgrammingLanguage.html">GraphicalProgrammingLanguage</a>. -- <a href="KrisJohnson.html">KrisJohnson</a>
      </p>
      <p>
        This subject is very flamebait.  For example, the console being "ancient", I'm still of the opinion that GUI never contributed anything to usability -- quite on the contrary.  The reason the C64 was easy to program was that (1) you didn't have to know about the file system to write programs, (2) you didn't have to learn an editor, (3) you could try out code snippets while coding and (4) it was easy to see the <em>state</em> of the computer, because there was no multitasking, windowing and such.  Ease of programming lies in what you <strong>don't</strong> have to learn, and GUI (as I/O in general) is one of those things. -- <a href="PanuKalliokoski.html">PanuKalliokoski</a>
      </p>
      <p>
        See also <a href="InTheBeginningWasTheCommandLine.html">InTheBeginningWasTheCommandLine</a>
      </p>
      <hr/>
      <p>
        I will defend the console interface, although I don't think it's the <em>best</em> or only way to talk to the computer.  The console interface has a simple metaphor--normal human conversation.  I say something, the computer says something. Repeat.  Not very complicated.  It's great for simple tasks like "compile this program" or "show me what folder you try to run files from."  It's not so great for more complicated things, like heavy duty file maintenance, although it can do that from the command line if you're patient.  Since programming demands patience anyway, I don't see the fact that the console also demands patience as a drawback.  
      </p>
      <p>
        Finally, the "teletype" aspect of consoles--<em>i.e.</em> you send commands to a remote processor--still makes sense in certain academic environments where students share computing resources.  This makes less sense, though, as PCs get more powerful.  
      </p>
      <p>
        -- <a href="SteveHowell.html">SteveHowell</a>
      </p>
      <p>
        Why are console and GUI an either/or issue? Why can't one program one's GUI, no matter how rudimentarily, as well as program one's console? Perhaps it's the either/or attitude of skilled programmers that prevents them from creating a programmable GUI? Why can't all the advantages of the console not be seamlessly integrated into a GUI? Instead of dealing with a monolithic X terminal, why not have a mouse gesture open a single-line input stream? Why not extend the transparency of X terminals to a single blinking cursor in the GUI that accepts console input? Why not integrate GUI and CLI history so that one can see "<double click>program" at the same level as "program<enter>"?
      </p>
      <p>
        Why should people be content with GUIs no more sophisticated nor programmable than DOS? Is this an example of the <a href="WorseIsBetter.html">WorseIsBetter</a> philosophy? Something alone the lines of "If you want a history of mouse double-clicks, why don't you drop to bash?" Perhaps people should learn to stop tolerating the worse and start demanding the better. Only when people stop defending the past will they unleash the creative energies needed to imagine a better future. (<a href="BurnTheDiskpacks.html">BurnTheDiskpacks</a>, perhaps?)
      </p>
      <p>
        <em>There are plenty of programmable GUIs out there.  </em><a href="MicrosoftOffice.html">MicrosoftOffice</a> comes to mind.  But I think this is moving away from the topic of the page. -- <a href="KrisJohnson.html">KrisJohnson</a><em></em>
      </p>
      <p>
        Yep, and there are also GUI programs that incorporate CLI features.  A lot of editors let you map a keystroke to an OS command, and they redirect the output from the command to a streamed window within the GUI. GUIs and CLIs can obviously coexist and overlap.  
      </p>
      <p>
        Back to the earlier debate--I use GUIs all the time, but I like stream I/O for writing the types of small, interesting programs that are often enriching for newbies.  Newbies can write GUI programs quickly given the right environment, but I'm not sure they'd be focusing on the most interesting parts of constructing software. -- <a href="SteveHowell.html">SteveHowell</a>
      </p>
      <hr/>
      <p>
        <strong>CP4E in general</strong>
      </p>
      <p>
        One of the best things about learning programming with BASIC (20 years ago, now!) was that it was very interactive: if I wanted to try out the "print" command, I didn't need to write a program and run it--I could just type "print $a, $b" at the command interpreter prompt and see what happened.
      </p>
      <p>
        <a href="LogoLanguage.html">LogoLanguage</a> (which all us little hackers hated because we had to pre-declare our variables) had the same feature: you can try things out, fixing them as you go, then commit them to a program when you're confident you're on the right track.  Ditto for <a href="ForthLanguage.html">ForthLanguage</a> (which I encountered in the form of GraForth)--<a href="ChuckMoore.html">ChuckMoore</a> is very adamant about the importance of interactivity.  And ditto for Lisp, and practically any other language with interpreted roots.
      </p>
      <p>
        When I work with languages that aren't interactive (in this sense)--<em>e.g.</em> Pascal, C, Java -- I miss the little command interpreter prompt.  The closest thing was usually the debugger, which isn't really the same.  Other people obviously missed it, too: someone has written a Java console that lets you type a line or two, then compiles it into a throwaway class and executes it.
      </p>
      <p>
        When I'm working with web development, I use the unit tests to provide interaction and quick feedback: change a form, run its <a href="UnitTest.html">UnitTest</a> in echo mode, see how it looks.
      </p>
      <p>
        So, given that we're going to be programming with text for the foreseeable future, why wouldn't you want a way to feed lines of text--tiny little bits of programs--to your language environment to see what they do? -- <a href="GeorgePaci.html">GeorgePaci</a>
      </p>
      <p>
        Very true.  <a href="PythonLanguage.html">PythonLanguage</a> and <a href="PerlLanguage.html">PerlLanguage</a> would be other good examples of interpreted languages that have nice interactive modes for testing out simple concepts. -- <a href="SteveHowell.html">SteveHowell</a>
      </p>
      <p>
        There are two needs here. One is the need for an interactive environment, which makes exploratory programming so much easier; python has this. The other is the need for a graphical interface, which makes learning programming so much more comfortable (in that the interface is something the user is familiar with, rather than that writing it is easy); python does not have this.
      </p>
      <p>
        Perhaps the way to provide an easy graphical interface is through HTML, with <a href="JavaScript.html">JavaScript</a>-style event handlers. The user could write their program logic in python and their GUI in HTML, then plug them together with onClick attributes etc. This would require a python-friendly browser-like thing to be built into the environment - essentially, a stripped-down version of <a href="FireFox.html">FireFox</a>, or just Gecko with some bits added on. Perhaps you could use it like this:
      </p>
      <code>
        import gui<br/>
      </code>
      <code>
        def sayHello():<br/>
        name = window.main.user_name<br/>
        gui.tell("Hello " + name + "!")<br/>
      </code>
      <code>
        windowHtml = """<html><br/>
        <body><br/>
        <form name=main><br/>
        <input type=text name=user_name><br/>
        <input type=submit onClick="sayHello()"><br/>
        </form><br/>
        </body><br/>
        </html><br/>
        """<br/>
        window = gui.show(windowHtml)<br/>
      </code>
      <p>
        Don't ask me how the namespaces work here - i'm <a href="BrainStorming.html">BrainStorming</a>! Oh, and gui.tell is a convenience method which pops up a dialogue box (or a little ordinary window) with some text in - inspired by <a href="HyperCard.html">HyperCard</a>'s AskAndAnswer.
      </p>
      <p>
        This does require that users learn HTML before they learn python, but i don't think this is a huge problem - indeed, it might be good to get them to learn HTML first, as a 'zeroth language', since it's very simple, gives immediate positive feedback (web pages!), and is of quite a lot of practical value.
      </p>
      <p>
        -- <a href="TomAnderson.html">TomAnderson</a>
      </p>
      <p>
        <em>Learn HTML before learning Python? Learn HTML before </em>any<em> programming language? Do you know how many people mislearn HTML? Do you know how many people write invalid HTML? Do you know how many people get the hang of separating content from presentation? HTML is not all that simple, and I do believe the world would be a slightly better place if people wrote better HTML. Besides, if you really want people using web pages for their </em><a href="UserInterface.html">UserInterface</a>, you might as well start out teaching them <a href="JavaScript.html">JavaScript</a>, not <a href="PythonLanguage.html">PythonLanguage</a>. <a href="JavaScript.html">JavaScript</a> isn't nearly as much fun or powerful as Python, but it is relatively easy and it automatically comes with the student's browser. No complicated installation or special libraries required. -- <a href="ElizabethWiethoff.html">ElizabethWiethoff</a><em></em>
      </p>
      <p>
        I am not sure what you are proposing and why learning HMTL first is a bad idea just because it may be hard. It is more practical if you ask me. As far as <a href="SeparateDomainFromPresentation.html">SeparateDomainFromPresentation</a>, a lot of that mantra is malarky in my opinion. --top
      </p>
      <hr/>
      <p>
        See also:  <a href="DamianConway.html">DamianConway</a>'s paper <em>Seven Deadly Sins of Introductory Programming Language Design</em> (available from his home page)
      </p>
      <p>
        Summary of the seven major "sins":
      </p>
      <ul>
        <li>
           <strong>1. </strong><a href="LessIsMore.html">LessIsMore</a>:<strong> paradigm purity can get in the way of practical problem solving...</strong>
        </li>
        <li>
           <strong>2. More is more:</strong> ...but you can also have too much semantics to learn
        </li>
        <li>
           <strong>3. Grammatical traps:</strong>
          <ul>
            <li>
               <em>Syntactic synonym</em> - multiple ways to do the same thing (i.e. array[i] == *(array+i) in C)
            </li>
            <li>
               <em>Syntactic homonym</em> - same syntax has different semantics in different contexts ("static" keyword in C)
            </li>
            <li>
               <em>elision</em> - allowed omission of a syntactic component (Lisp superbrackets)
            </li>
          </ul>
        </li>
        <li>
           <strong>4. Hardware dependence:</strong> i.e. different length of "int" in C
        </li>
        <li>
           <strong>5. Backwards compatibility:</strong> language elements included for familiarity with prior languages have no benefit for a first-time student (i.e. Java's and C++'s C-like syntax and Scheme's retention of assembly mnemonics "car" and "cdr")
        </li>
        <li>
           <strong>6. Excessive cleverness:</strong> obvious to an expert but not to a novice (i.e. C/C++ declaration syntax)
        </li>
        <li>
           <strong>7. Violation of expectations:</strong> such as syntax traps ( "if (c=1) ..." in C ), strange precedence rules, and integer overflow
        </li>
      </ul>
      <p>
        and seven recommended introductory language design principles:
      </p>
      <ul>
        <li>
           Start where the novice is
        </li>
        <li>
           Differentiate semantics with syntax
        </li>
        <li>
           Make the syntax readable and consistent
        </li>
        <li>
           Provide a small and orthogonal set of features
        </li>
        <li>
           Be especially careful with I/O
        </li>
        <li>
           Provide better error diagnosis
        </li>
        <li>
           Choose a suitable level of abstraction
        </li>
      </ul>
      <p>
        One of the authors, <a href="DamianConway.html">DamianConway</a>, also wrote a nice book about object-oriented Perl, if you're into that kind of thing.
      </p>
      <p>
        -- <a href="SteveHowell.html">SteveHowell</a> (expanded by <a href="IanOsgood.html">IanOsgood</a>)
      </p>
      <p>
        I think these "sins" are questionable.  For example, I've never seen someone learning programming to be bothered by sin #4. -- <a href="PanuKalliokoski.html">PanuKalliokoski</a>
      </p>
      <hr/>
      <hr/>
      <p>
        <a href="VisualBasic.html">VisualBasic</a> certainly qualifies as <a href="ComputerProgrammingForEverybody.html">ComputerProgrammingForEverybody</a> (who has something they need the computer to do) And experts in their own fields certainly know what that is more than the expert computer programmer who doesn't know the field. It is part of the reason that productivity has been increasing for many years. It was the non-programming specialist who saw in microcomputers a way of accomplishing automatically what had to be done manually because of the Main Frame mindset that said that their computing concerns were not economically feasible or important enough. The computer for everyone has been the result.  
      </p>
      <hr/>
      <p>
        The real challenge is not the language, it is sharing programs safely. Such is the design goal of <a href="WikiTalk.html">WikiTalk</a>. The design is still in its infancy, please participate. <a href="WikiTalk.html">WikiTalk</a> is language neutral in that Python, SQL, shell, Java, SOAP etc. code can be used at the will of the writer rather than forcing a particular language. At the same time it is becoming a language on its own based on natural language, semistructured text, RELAX NG, and XSLT. The boundaries between program and code are obliterated. -- <a href="JimScarver.html">JimScarver</a> of <a href="http://WikiWorld.com">http://WikiWorld.com</a>
      </p>
      <hr/>
      <p>
        <strong>CP4E: fundamental problems</strong>
      </p>
      <p>
        I have a problem with this idea--it smacks of both a denigration of software development as a profession and seems to imply that everyone should be able to tell a machine what they want it to do. Look at the tax system--everyone with an engineering degree can do the math necessary to calculate their taxes, but many choose to have someone else do their taxes.  Why?  Because some things are better left to the specialists.  A similar trend exists in auto maintenance--why should I buy and store a set of tools to change my engine oil, filters, brakes, etc, when for less that half the cost in materials, and much less in my time, I can drive the car to the shop, wait 30 minutes, and have it done for me? Software development is <strong>not</strong> trivial, and the average person without training in the field will produce poor solutions. -- <a href="PeteHardie.html">PeteHardie</a>
      </p>
      <p>
        <strong>CP4E with Python</strong>
      </p>
      <p>
        Inspired by CP4E, Yorktown High School is now in its 4th year using Python in an intro CS course.  My goal is to get as many students from as broad a range of interests and backgrounds as possible into the course.  I do not aspire to make computer programmers out of everyone.  I do want to empower all my students with a greater understanding of what a computing machine is and what it is capable of doing.  I want to "demystify" computer programming for all students in the class.  Given how important these machines are becoming in the production of our world, such an understanding has important implications for democracy. It has been both fun and challenging working successfully with a very heterogeneous population of students.  Using Python has played a big part in making the course as successful as it has been.  Most students in the course are very successful, yet having very varied levels of understanding has in no way held back the most advanced students from becoming computer programmers. -- <a href="JeffElkner.html">JeffElkner</a>
      </p>
      <p>
        <strong>CP4E: fundamental problems</strong>
      </p>
      <p>
        You can hire a CPA to do your taxes, but is it really worth it if you're using the short form and can get it done in a half hour?  In the same way, I've found many uses for just firing up Python and typing a few lines to get a job done, or writing a little one-like Perl or Awk program to do a job for me.  Who's to say that others wouldn't benefit?  And even if the average person doesn't need to program, learning how to do so might make the computer itself seem like a less mysterious and cryptic device. -- <a href="NickBensema.html">NickBensema</a>
      </p>
      <p>
        So maybe it's ComputerUseForEverybody, instead.  Programming is more than 30 minutes of toss-together.  Sure, lots of small companies have their personnel database handled in <a href="FoxPro.html">FoxPro</a> by the receptionist, but when the CEO says "Develop our enterprise-wide production DB system, and by the way, you can use this database code that my secretary has written to get started", you've got an entirely different kettle of fish.  Would you call using the short form for your taxes TaxAccountingForEverybody? -- <a href="PeteHardie.html">PeteHardie</a>
      </p>
      <p>
        I like the analogy to writing.  Folks with serious talent do it as their primary profession--maybe compare a novelist to a compiler hacker.  Folks with other types of talent use writing as a tool--compare lawyers who write briefs to web designers who develop <a href="JavaScript.html">JavaScript</a>.  Almost every one else writes on an amateur basis, but can we say the same thing about programming?  There seems to be discontinuity in the spectrum with programming.  -- <a href="SteveHowell.html">SteveHowell</a>
      </p>
      <p>
        I think that the valuable thing about there being programming tools for everybody is simply to maintain a pool of quality programmers for the future.  Part of the reason that I attribute my ability to grasp computing concepts is that I have been programming, on a limited basis, since I was 5 or 6.
      </p>
      <p>
        Who buys their kid a full copy of VC++?  It's way too much. I think that Python is ideal for this sort of thing because it's already free and it seems to be quite simple.  -- <a href="KenWronkiewicz.html">KenWronkiewicz</a>
      </p>
      <p>
        <em>My parents did--not VC++; it didn't exist then; but an equivalent product--for which I am eternally grateful to them. -- </em><a href="DanielKnapp.html">DanielKnapp</a><em></em>
      </p>
      <p>
        Yes, but ideally, this should exist without parental interaction.  I'm glad that my parents purchased me plenty of different software packages over the years, but, at the same time, my parents appreciated what could happen if I learned computing.  But both minimal parental appreciation of the potential of learning to code and lack of finances can make it hard for a parent to purchase VC++ for their kid. -- <a href="KenWronkiewicz.html">KenWronkiewicz</a>
      </p>
      <p>
        I think that programming -- at least at the basic level -- is an important thing to learn for any budding computer user.
        Simple shell or batch scripts make it a lot easier to do repetitive and/or time consuming tasks.  I think that learning a couple languages (even just at a superficial level) would give a user a better understanding of how their comnputer works, and also it would cut the fear most people have about using electronics and computers.  I am somewhat pessimistic about the average person's ability to understand computer logic.  I have memories of many people in math classes having problems understanding how to solve "word problems" because they weren't able to quantify what was being asked.  Most often, the problems one encounters in writing programs are more complex than simply plugging numbers into a formula.  Maybe I am wrong, but I'd like to hear other's opinions on this issue. -- <a href="TimothySeguine.html">TimothySeguine</a>
      </p>
      <hr/>
      <p>
        <strong>CP4E in general</strong>
      </p>
      <p>
        A mere understanding of what's involved in programming is helpful for the computer users of the future.  They will be able to understand that you can't write a big complex program in a day or a week. -- <a href="KenWronkiewicz.html">KenWronkiewicz</a>
      </p>
      <hr/>
      <p>
        <strong>Case Study: Lotus 1-2-3</strong>
      </p>
      <p>
        Re: "Keep in mind that programming is a basic skill that will soon be required of everyone"
      </p>
      <p>
        [Unlikely, most internet users can barely figure out how to use email and browse the web, programming isn't in their future.  When they learn to not open up executables from people they don't know, and figure out that america online isn't the internet, then maybe... maybe... nah... it'll never happen.]
      </p>
      <p>
        Butlers are too expensive even if immigrants are cheap. Similarly, having a programmer at your beck and call is simply too expensive. The same logic eliminated typists as a profession.
      </p>
      <p>
        <em>But I find self-programming as likely as self-auto-repair.</em>
      </p>
      <p>
        The closest thing I ever saw to programming-for-the-masses was when <strong>Lotus-123</strong> allowed one to save keystrokes into "macros". It was an incremental way to learn because it built on something users already knew: the keystroke commands. The Lotus menus were closely tied to keyboard sequences. There was even a "recorder" tool to save keystrokes. Just throw in IFs and LOOPs and it was then <a href="TuringComplete.html">TuringComplete</a>. Boatloads of accountants became programmers. I've seen some fairly sophisticated stuff. It ended when MS-Excel was forced down their throat after Lotus fell from corporate grace. MS-Excel programming is about as easy-to-learn and intuitive as an Apollo lander. Plus mousing reduced the reliance on keyboard-based commands. The lesson for CP4E is to:
      </p>
      <ul>
        <li>
           Build on something a user already knows rather than throw them in the deep-end of the pool. 
        </li>
        <li>
           Base it on a domain-specific tool set.
        </li>
        <li>
           Text commands (such as menu letters) are perhaps easier to convert into programs than mousing (<a href="MouseScriptDisconnect.html">MouseScriptDisconnect</a>).
        </li>
      </ul>
      <p>
        However, in general, newbie code is hard to maintain because the newbie is so focused on just getting stuff to run that maintainability and abstraction are something they are not yet ready for. And guess who they call after they've made a <a href="BigBallOfMud.html">BigBallOfMud</a>? Making maintainable, readable code is a skill difficult to pick up quickly. But the keyboard macro style was great for minor personal automation.
      </p>
      <hr/>
      <p>
        Some software engineers regard <a href="VisualBasic.html">VisualBasic</a> and <a href="PhpLanguage.html">PhpLanguage</a> to be programming-for-the-masses, as these languages allow you with little experience quickly to write unmaintainable code.
      </p>
      <p>
        <em>Hmmmm. Does easy-to-learn equal "bad"? Note that </em>LispWeenies consider Java in that category also.<em></em>
      </p>
      <p>
        Yes, I've noticed most people think easy-to-learn-or-user is "bad" / "lame". Try looking at all the linux "gurus" that look down on the other linux users because they don't use the command line as much.
      </p>
      <p>
        <em>This page is ripe full of </em><a href="LanguagePissingMatch.html">LanguagePissingMatch</a>es and <a href="HolyWar.html">HolyWar</a> fodder.<em></em>
      </p>
      <p>
        I caught myself doing the same thing yesterday -- sneering at someone who declared some variable as "long", when <em>obviously</em> declaring it as <em>char</em> would be ever so much more "efficient".
        When will I stop worshipping the false god of <a href="PrematureOptimization.html">PrematureOptimization</a> ?
      </p>
      <hr/>
      <p>
        <strong>CP4E in general</strong>
      </p>
      <p>
        Not everybody wants to be a programmer. Users would benefit from being programmers (but do not know it). Users are also the easiest to teach, since the program they want to change is the one they use. As we all know, users are expert testers - they must be to find bugs that the programming discipline has missed. Training users to modify their own programs has many benefits and few drawbacks. The obvious drawback is that sometimes they break the system. So you need to provide a test and release environment with the released application. 
      </p>
      <p>
        If this is done, users will evolve their own systems. Not all of them. Just some of them. Not all of them will improve it in all senses, but they all satisfy their needs.
      </p>
      <hr/>
      <p>
        There seems to be a spectrum of ideas here:
      </p>
      <ul>
        <li>
           Everyone should be required to learn to program maintainable, readable code, and write their own text editor from scratch.
        </li>
        <li>
           It would be a Good Thing if someone were to develop a programming environment that made it so easy to program, that vast masses of people could use it that are currently too intimidated by current tools to even try.
        </li>
        <li>
           Sometimes a user has an idea for a tiny little program that he will use once or twice, saving him an hour of doing something manually. Multiply this by thousands of users, and it's better to let the users do the simple things on their own (such as putting the gas in the car), and save scarce professional programming time for the complex tasks (adjusting the engine timing).
        </li>
        <li>
           It would be a Good Thing if people understood how complex programming really is. Rather than struggling for months to build a rickety, insecure BallOfMud, perhaps it would be better all around to hand it off to a specialist who could bolt together a high-quality piece of machinery in a few days for a pittance.
        </li>
        <li>
           Only professionally certified programmers should be allowed to touch compilers and similar highly dangerous tools, which shall be kept under lock and key from 5pm until 8am the next day.
        </li>
      </ul>
      <p>
        The ends of the spectrum are straw men (I think).
      </p>
      <hr/>
      <p>
        Web Links:
      </p>
      <p>
        <a href="http://klangworks.org/blog/archives/2005/09/28/the_myth_of_non_programmer_languages/">http://klangworks.org/blog/archives/2005/09/28/the_myth_of_non_programmer_languages/</a>
      </p>
      <hr/>
      <p>
        See Also: <a href="CompilingVersusMetaDataAid.html">CompilingVersusMetaDataAid</a>, <a href="EveryoneShouldBeaDeveloper.html">EveryoneShouldBeaDeveloper</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryPaper.html">CategoryPaper</a> <a href="CategoryComputerEducation.html">CategoryComputerEducation</a>
      </p>
    </div>
  </body>
</html>