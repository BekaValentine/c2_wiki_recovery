<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Counter In Many Programming Languages
      </h1>
      <p>
        The Problem (Originally from <a href="PythonVsRuby.html">PythonVsRuby</a>):
      </p>
      <ul>
        <li>
           A counter may be initialised with a value or defaults to an initial value of 1.  When called, it:
          <ul>
            <li>
               returns its current value; and
            </li>
            <li>
               increments its current value
            </li>
          </ul>
        </li>
        <li>
           The exact internal implementation is less important than the output behaviour - feel free to set current value to 1 less than the value given if you feel that pre-incrementing gives a cleaner implementation in your language.
        </li>
        <li>
           The counter should be such that any number of individual counters can be instantiated.
        </li>
        <li>
           If the counter is unable to handle integers of arbitrary size, this should be stated.
        </li>
      </ul>
      <p>
        Of particular interest, of course, is the counter's behavior when an overflow condition exists.  Some languages mentioned below do not provide fixed-precision numeric types; thus overflow doesn't happen (until you run out of memory--shortly after the universe collapses in on itself).  Others provide only fixed-precision types (and thus risk overflow); though in many cases the amount of precision provided ShouldBe more than adequate for most applications.  (But if it isn't...)  None seems to handle an overflow condition gracefully, except <a href="LispLanguage.html">LispLanguage</a>, <a href="PythonLanguage.html">PythonLanguage</a>, and <a href="RubyLanguage.html">RubyLanguage</a>, whose integers will be automatically (UnderTheHood) upgraded to bignums when fixnum range is exceeded.  The <a href="SmlLanguage.html">SmlLanguage</a> (Basis Library) supports fixed width integers with overflow causing an exception (e.g. the Int32 module), fixed width unsigned integers with modular arithmetic (e.g. the Word32 module), and arbitrary precision integers (the IntInf module).   (See <a href="TypeMigration.html">TypeMigration</a>)
      </p>
      <p>
        See also: <a href="AccumulatorGenerator.html">AccumulatorGenerator</a>
      </p>
      <hr/>
      <p>
        Intel 80X86/Pentium <strong></strong><a href="AssemblyLanguage.html">AssemblyLanguage</a><strong>:</strong>
      </p>
      <code>
        ;;; counter.asm<br/>
      </code>
      <code>
        %assign SYS_EXIT	1<br/>
      </code>
      <code>
        ;; -------------------------<br/>
        ;; data segment<br/>
        ;; -------------------------<br/>
      </code>
      <code>
        section	.data<br/>
        counter      dw  1<br/>
        countstring  dd  0<br/>
      </code>
      <code>
        ;; -------------------------<br/>
        ;; code area<br/>
        ;; -------------------------<br/>
      </code>
      <code>
        section	.text<br/>
        global	_start<br/>
      </code>
      <code>
        _start: call  incCounter<br/>
      </code>
      <code>
        ;; exit()<br/>
      </code>
      <code>
        mov	eax,SYS_EXIT<br/>
        mov	ebx,0<br/>
        int	0x80		; final system call<br/>
      </code>
      <code>
        ;-----------------------------------<br/>
        ;incCounter: prints current value<br/>
        ;and increments counter<br/>
        ;Registers modified:EAX,EBX,ECX,EDX<br/>
        ;-----------------------------------<br/>
      </code>
      <code>
        incCounter:<br/>
      </code>
      <code>
        ;;calculate ascii string to print<br/>
        mov             edx,0                 ; keep track of number of digits<br/>
        mov             ax,[counter]          ; get the current value of the counter<br/>
        lea             ecx,[countstring + 3] ; load location to store string in, starting at last byte<br/>
        mov             dl,10                 ; print a base ten number <br/>
        ; of no more than four digits by finding<br/>
        nextdig: div             dl                    ; the ascii code of the LSD, storing it<br/>
        add             ah,48<br/>
        mov             [ecx],ah<br/>
        inc             edx<br/>
        cmp             al,0<br/>
        je              icprint               ; if this is the last digit, print it<br/>
        cmp             edx,4<br/>
        je              icprint               ; if this is the fourth digit, print it<br/>
        dec             ecx<br/>
        xor             ah,ah<br/>
        jmp             nextdig<br/>
      </code>
      <code>
        icprint: <br/>
        mov             eax,SYs_WRITE<br/>
        mov             ebx,STDOUT<br/>
        int             0x80<br/>
      </code>
      <code>
        ;; increment the counter<br/>
        add             word [counter],1<br/>
      </code>
      <code>
        ret<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="CeeLanguage.html">CeeLanguage</a><strong> (C9x):</strong>
      </p>
      <p>
        Overflows when the type long long overflows; as long long int is guaranteed to be at least 64 bits, this won't be for a while.
      </p>
      <p>
        Pseudo-OO; to the extent that you can do OO in C.  
      </p>
      <p>
        Doesn't do any error checking.
      </p>
      <code>
        struct Counter {<br/>
        long long int value_;<br/>
        };<br/>
      </code>
      <code>
        void counterInit (struct Counter *ctr) {<br/>
        ctr->value_ = 1;<br/>
        }<br/>
      </code>
      <code>
        void counterInitToValue (struct Counter *ctr, long long int value) {<br/>
        ctr->value_ = value;<br/>
        }<br/>
      </code>
      <code>
        long long int counterNext (struct Counter *ctr) {<br/>
        return ctr->value_++;<br/>
        }<br/>
      </code>
      <code>
        int main (void) <br/>
        {<br/>
        struct Counter *ctr1 = malloc(sizeof (struct Counter));<br/>
        struct Counter *ctr2 = malloc(sizeof (struct Counter));<br/>
      </code>
      <code>
        counterInit (ctr1);<br/>
        counterInitToValue (ctr2,5000);<br/>
        printf ("Ctr 1: %d\n", counterNext(ctr1));<br/>
        printf ("Ctr 1: %d\n", counterNext(ctr1));<br/>
        printf ("Ctr 2: %d\n", counterNext(ctr2));<br/>
        printf ("Ctr 1: %d\n", counterNext(ctr1));<br/>
        printf ("Ctr 2: %d\n", counterNext(ctr2));<br/>
        printf ("Ctr 2: %d\n", counterNext(ctr2));<br/>
      </code>
      <code>
        return 0;<br/>
        }<br/>
      </code>
      <code>
        >>> Ctr 1: 1<br/>
        >>> Ctr 1: 2<br/>
        >>> Ctr 2: 5000<br/>
        >>> Ctr 1: 3<br/>
        >>> Ctr 2: 5001<br/>
        >>> Ctr 2: 5002<br/>
      </code>
      <p>
        Not very interesting; but does kinda show why OO is cool, and exposes lots of the dirty work that the programmer needs to do in a low-level language like C.
      </p>
      <p>
        <em>How does this show how OO is cool? This does not smell like an idiomatic C example. -- </em><a href="AnonymousDonor.html">AnonymousDonor</a>
      </p>
      <p>
        I think he's trying to say that this would be a lot more impressive if it <em>was</em> OO, but it just looks hackish in C.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="CeePlusPlus.html">CeePlusPlus</a><strong>:</strong>
      </p>
      <p>
        just plain C++; not an example of TemplatesGoneMad.  We'll use just plain old ints:
      </p>
      <code>
        // Each counter will be an instantiation of the Counter class<br/>
        class Counter <br/>
        {<br/>
        private:<br/>
        int val_;<br/>
        public:<br/>
        Counter (int val = 1) : val_(val) {}<br/>
        int next () {<br/>
        return val_++;<br/>
        } <br/>
        };<br/>
      </code>
      <p>
        Or, if you prefer the type of the counter to be a parameter,
      </p>
      <code>
        // Each counter will be an instantiation of the Counter template class,<br/>
        // specialized on a numeric type (typically int or some bignum class)<br/>
        template <class T><br/>
        class Counter <br/>
        {<br/>
        private:<br/>
        T val_;<br/>
        public:<br/>
        Counter (T val = 1) : val_(val) {}<br/>
        T next () {<br/>
        return val_++;<br/>
        } <br/>
        };<br/>
      </code>
      <p>
        <a href="CeePlusPlusEleven.html">CeePlusPlusEleven</a> version using lambdas:
      </p>
      <code>
        #include <functional><br/>
      </code>
      <code>
        template <class T><br/>
        auto Counter(T val = 1) -> std::function<T()> {<br/>
        return [=]() mutable { return val++; };<br/>
        }<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="CommonLisp.html">CommonLisp</a><strong>:</strong>
      </p>
      <p>
        one simple possibility: 
      </p>
      <code>
        ;; Each counter is a lambda closure<br/>
        (setf counter1 (let ((n 2)) (lambda () (incf n))))<br/>
        (setf counter2 (let ((n 0)) (lambda () (incf n))))<br/>
        CL-USER> (funcall counter1)<br/>
        3<br/>
        CL-USER> (funcall counter2)<br/>
        1<br/>
        CL-USER> (funcall counter1)<br/>
        4<br/>
        CL-USER> (funcall counter2)<br/>
        2<br/>
      </code>
      <p>
        This may look a little odd to people used to thinking about 'factories' or objects to abstract this sort of thing.  Due to first-class functions and the properties of closure, a simple form produces a function object which behaves like the above counters.
      </p>
      <p>
        Another possibility (there are others as well, of course).  Wrapped up as a counter-factory function:
      </p>
      <code>
        ;; Counters are created by a wrapper around a lambda closure<br/>
        (defun make-counter (&optional (n 1))<br/>
        (lambda ()<br/>
        (prog1 n (incf n))))<br/>
      </code>
      <code>
        (setf counter (make-counter 3))<br/>
        (setf counter2 (make-counter))<br/>
      </code>
      <code>
        CL-USER> (funcall counter)<br/>
        3<br/>
        CL-USER> (funcall counter2)<br/>
        1<br/>
        CL-USER> (funcall counter)<br/>
        4<br/>
        CL-USER> (funcall counter2)<br/>
        2<br/>
      </code>
      <p>
        There is a trade-off here.  The second approach abstracts the 'counter' idea behind a 'factory' function to use the analogy of this page.  However, you may need to look at the definition of make-counter to remember what the semantics are (this is true of all the factory approaches on this page).  The simple lambda form is more verbose, but still concise and has the advantage that you know exactly what is happening by looking at a single line of code.  The choice of what is better depends on the context in which it is used.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="CsharpLanguage.html">CsharpLanguage</a><strong> </strong>
      </p>
      <code>
        using System;<br/>
      </code>
      <code>
        class Test<br/>
        {<br/>
        static Func<int> F()<br/>
        {<br/>
        int x = 0;<br/>
        return delegate { return ++x; };<br/>
        }<br/>
      </code>
      <code>
        static void Main()<br/>
        {<br/>
        var d = F();<br/>
        Console.WriteLine(d());<br/>
        Console.WriteLine(d());<br/>
        Console.WriteLine(d());<br/>
        }<br/>
        }<br/>
      </code>
      <hr/>
      <p>
        Dodo <a href="http://dodo.sourceforge.net">http://dodo.sourceforge.net</a>
      </p>
      <code>
        yield int counter(int n)<br/>
        {<br/>
        loop:<br/>
        return n<br/>
        ++.n.<br/>
        }<br/>
        def c() = counter(5)<br/>
      </code>
      <p>
        Or equivalently
      </p>
      <code>
        def c() = for (n in 5...).value<br/>
      </code>
      <p>
        Io-style
      </p>
      <code>
        def c = new struct()<br/>
        {<br/>
        int counter = 1<br/>
        method Next: Next()<br/>
        {<br/>
        .value = counter<br/>
        ++.counter<br/>
        } -> value int.<br/>
        }<br/>
        c.Next()    # 1<br/>
        c.Next()    # 2<br/>
        def k = new c(counter: 400)<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="ForthLanguage.html">ForthLanguage</a><strong>:</strong>
      </p>
      <code>
        ( This is similar in the underlying implementation to the C++ example.<br/>
        The defining word init-counter is like a constructor, where the create<br/>
        part sets up an object's data and the does> part defines a class method.<br/>
        The individual counters are like objects; multiple data, single method. )<br/>
      </code>
      <code>
        : init-counter ( n "name" -- )   create ,<br/>
        does> ( -- n++ )   dup >r  @  dup 1+  r> ! ;<br/>
        \ or: does>  dup @  dup 1+ rot ! ;<br/>
        \ or: does>  dup @  1 rot +! ;<br/>
        \ or: does>  1 over +!  @ 1- ;  \ omit '1-' for ( ++n )<br/>
      </code>
      <code>
        : counter ( "name" -- )   1 init-counter ;<br/>
      </code>
      <code>
        counter counter1<br/>
        counter counter2<br/>
      </code>
      <ol>
        <li>
           init-counter counter3
        </li>
      </ol>
      <code>
        counter1 .<br/>
        >>> 1<br/>
        counter1 .<br/>
        >>> 2<br/>
        counter1 .<br/>
        >>> 3<br/>
        counter2 .  counter2 .  counter2 .<br/>
        >>> 1 2 3<br/>
        counter3 .  counter3 .  counter3 .<br/>
        >>> 10 11 12<br/>
      </code>
      <p>
        Note that <a href="ForthLanguage.html">ForthLanguage</a> doesn't support default argument values, so this implementation provides two words: <em>init-counter</em> which accepts an argument and <em>counter</em> which calls <em>init-counter</em> with an argument of 1.  Also, this suffers overflow problems similar to C++ and Java.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="HaskellLanguage.html">HaskellLanguage</a><strong>:</strong>
      </p>
      <code>
        import Data.IORef -- Haskell Hierarchical Libraries (GHC 5.04 and later & new versions of Hugs)<br/>
        -- "import IOExts" under the ancient hslibs<br/>
      </code>
      <code>
        makeCounter  :: (Num n) => n -> IO (n -> IO n)<br/>
        makeCounter  n = do r <- newIORef n<br/>
        return (counter r)<br/>
        where counter r i = do modifyIORef r (+i)<br/>
        readIORef r<br/>
      </code>
      <code>
        Main> counter <- makeCounter 10<br/>
        Main> counter 33<br/>
      </code>
      <ol>
        <li>
          3
        </li>
      </ol>
      <code>
        Main> counter 10<br/>
      </code>
      <ol>
        <li>
          3
        </li>
      </ol>
      <hr/>
      <p>
        HQ9++
      </p>
      <code>
        +<br/>
      </code>
      <p>
        <em>This fails the definition of the test, since HQ9++ has only one counter, like its predecessor. (The object instantiated by ++ also should not be confused with the concurrent increment operations.)</em>
      </p>
      <hr/>
      <p>
        <strong></strong><a href="IconLanguage.html">IconLanguage</a><strong>:</strong>
      </p>
      <code>
        # Each counter is a co-expression (coroutine-expression<br/>
        local counter1, counter2<br/>
        counter1 := create (1 to 1000)   # create co-expressions<br/>
        counter2 := create (1 to 1000)<br/>
      </code>
      <code>
        # Each activation with "@" returns old value and steps to next value<br/>
        write(@counter1)<br/>
        write(@counter1)<br/>
        write(@counter1)<br/>
        write(@counter2)<br/>
      </code>
      <p>
        produces
      </p>
      <code>
        1<br/>
        2<br/>
        3<br/>
        1<br/>
      </code>
      <p>
        Icon is particularly good at coroutines (and what it calls "co-expressions", as here). It's hard to see getting any simpler and more direct than this.
      </p>
      <p>
        Note that if you want it to start at something other than 1, you just say so, since this doesn't need to be wrapped in a function:
      </p>
      <code>
        counter1 := create (n to 1000)<br/>
      </code>
      <p>
        Wrapping it in a function definition would make it <strong>more</strong> complicated rather than less. 
      </p>
      <p>
        However, it should still be encapsulated in real code that used it more than once:
      </p>
      <code>
        procedure makecounter(n)<br/>
        /n := 1                      # supply default value if missing<br/>
        return create (n to 1000)<br/>
        end<br/>
        procedure main()<br/>
        local counter1, counter2<br/>
        counter1 := makecounter()<br/>
        counter2 := makecounter(1)<br/>
        write(@counter1)<br/>
        write(@counter1)<br/>
        write(@counter1)<br/>
        write(@counter2)<br/>
        end<br/>
      </code>
      <p>
        <em>How would an Icon version look with no upper bound (or do I misunderstand the role of 1000 in above)? I mean a counter that does not overflow (i.e. will increment until memory is exhausted, if needed.)  Do you have to give an upper bound in Icon?  Do you have arbitrary precision types?  If not, what happens when you overflow?  I'm not bashing Icon here, I don't know anything about it --- so I am curious.</em>
      </p>
      <p>
        Icon supports bignums, but not seamlessly the way that Scheme and some Lisps do, and the "n to m" mechanism unfortunately in particular does not seem to allow bignums to be used. I don't know why, since that seems stupid and easy to rectify in the design. There may be an alternate sequence mechanisms for bignums, I'm not sure.
      </p>
      <p>
        You do not have to specify an upper bound, e.g. there is a "seq()" call that means "1,2,3..." without limit. I don't believe that it allows you to use the "to" mechanism without an upper bound; e.g. it would be sensible to allow "(1 to)" and assume the close paren meant "no upper bound", but that's not what it does, so you need to switch to "seq()". (Which itself optionally allows a lower and upper bound.)
      </p>
      <p>
        The language is built around "success" and "failure" events in places where most languages use boolean values, so e.g. loops continue until something inside the loop conditional <strong>or</strong> body <strong>fails</strong>, and then the loop stops. This supports goal-directed evaluation (backtracking) fairly seamlessly.
      </p>
      <p>
        I mention this because that is what I would expect to happen instead of overflow: the sequence generator should <strong>fail</strong>, and so would any enclosing conditional or loop or whatever; it would not be a silent failure as happens in e.g. C.
      </p>
      <p>
        <em>Interesting.  One of these days I will have to look at Icon properly.  Do you have a feel for how these 'events' relate to the common lisp condition system?</em>
      </p>
      <p>
        It's a bit similar in feel, but the important difference is that Icon <strong>fail</strong> is a normal failure, not an error failure. For instance, one would loop searching for a character in a string, doing something with each match, and when the <strong>find</strong> finally failed, the search would terminate, and so would the loop. No error involved.
      </p>
      <p>
        Icon doesn't have a boolean type at all; this kind of normal failure is used everywhere in the language that you'd ordinarily expect to see boolean #f/NIL/false, resulting in a powerful approach to pattern matching.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="JavaLanguage.html">JavaLanguage</a><strong>:</strong>
      </p>
      <code>
        // Each counter is an object instantiation of a class wrapping an int<br/>
        public class Counter <br/>
        {<br/>
        private int value;<br/>
        public Counter () { <br/>
        this(1);<br/>
        }<br/>
        public Counter (int initialValue)  {<br/>
        value = initialValue;<br/>
        }<br/>
        public int next () {<br/>
        return value++;<br/>
        } <br/>
        }<br/>
      </code>
      <p>
        Both the C++ and Java variants have a potential <a href="FixedQuantityOverflowBug.html">FixedQuantityOverflowBug</a>. The counter below, however, is only limited by the available memory.
      </p>
      <code>
        import java.math.BigInteger;<br/>
      </code>
      <code>
        public class BigCounter <br/>
        {<br/>
        private BigInteger value;<br/>
        public BigCounter () { <br/>
        this(BigInteger.ONE);<br/>
        }<br/>
        public BigCounter (BigInteger initialValue)  {<br/>
        value = initialValue;<br/>
        }<br/>
        public BigInteger next () {<br/>
        BigInteger returnValue = value;<br/>
        value = value.add(BigInteger.ONE);<br/>
        return returnValue;<br/>
        } <br/>
        }<br/>
      </code>
      <p>
        What do you guys think of <a href="MikeCowlishaw.html">MikeCowlishaw</a>'s <a href="BigDecimal.html">BigDecimal</a> proposal (JSR 13) - <a href="http://www.jcp.org/en/jsr/detail?id=13">http://www.jcp.org/en/jsr/detail?id=13</a> ? We used an early implementation of this on a project, and it seemed to work very well. --<a href="PaulMorrison.html">PaulMorrison</a> 
      </p>
      <hr/>
      <p>
        <strong></strong><a href="JavaScript.html">JavaScript</a><strong>:</strong>
      </p>
      <code>
        function counter(x) {<br/>
        var c = x==undefined ? 1 : x;<br/>
        return function () { return c++ }<br/>
        }<br/>
      </code>
      <p>
        <em>Note: you can't use </em>c = x || 1<em> because it won't let you initialize a counter starting at zero.</em>
      </p>
      <p>
        The count overflows when it exceeds the precision of a double-precision floating point mantissa.
      </p>
      <hr/>
      <p>
        <a href="LispOnePointFive.html">LispOnePointFive</a>:
      </p>
      <code>
        define ((<br/>
        (make-counter (lambda (x) (function (lambda () (setq x (+ x 1)) x))))<br/>
        ))<br/>
      </code>
      <p>
        The initial value of the counter must be specified.  The integers could not get arbitrarily large.  The 7090 was a 36 bit machine, so I'm guessing this would break when the counter got past 2^35-1.  I don't know what would happen in this case.
      </p>
      <hr/>
      <p>
        <strong>m4</strong>:
      </p>
      <code>
        define(`defcounter',<br/>
        `define(`@counter_$1',ifelse(`$2',,0,`$2'))'dnl<br/>
        `define(`$1',<br/>
        `define(`@counter_$1',incr(defn(`@counter_$1')))defn(`@counter_$1')')')<br/>
      </code>
      <p>
        usage:
      </p>
      <code>
        defcounter(c1)dnl<br/>
        defcounter(c2, 5000)dnl<br/>
        c1 c1 c2 c1 c2 c2     dnl Output: 1 2 5001 3 5002 5003<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="NemerleLanguage.html">NemerleLanguage</a><strong>:</strong>
      </p>
      <code>
        using System.Console;<br/>
      </code>
      <code>
        module Counter {<br/>
        makeCounter(from: long): void -> long {<br/>
        mutable n = from -1l;<br/>
        fun() {++n; n}<br/>
        }<br/>
      </code>
      <code>
        // parameterless overload to provide default behaviour<br/>
        makeCounter(): void -> long {<br/>
        makeCounter(1l)<br/>
        }<br/>
      </code>
      <code>
        Main(): void {<br/>
        def counter = makeCounter();<br/>
        def counter5 = makeCounter(5l);<br/>
      </code>
      <code>
        WriteLine(counter());<br/>
        WriteLine(counter5());<br/>
        WriteLine(counter());<br/>
        WriteLine(counter5());<br/>
        WriteLine(counter());<br/>
        WriteLine(counter5());<br/>
        }<br/>
        }<br/>
      </code>
      <p>
        output:
      </p>
      <code>
        $ ./counter.exe<br/>
        1<br/>
        5<br/>
        2<br/>
        6<br/>
        3<br/>
        7<br/>
      </code>
      <p>
        the long type is a 64bit integer, so it will overflow, but it'll at least take a while to do so...
      </p>
      <p>
        or, i've just discovered that mono provides a <a href="BigInteger.html">BigInteger</a> class, in the Mono.Math namespace (which is inexplicably contained in the Mono.Security assembly), which lets you write a counter that won't overflow, with the usual memory/cpu usage tradeoffs that bignums involve. --<a href="MikeRoome.html">MikeRoome</a>
      </p>
      <p>
        You can also use an approach similar to the first lisp version, and just create it directly with a lambda:
      </p>
      <code>
        using System.Console;<br/>
        module M {<br/>
        Main(): void {<br/>
        def counter1 = {mutable n = 2; fun() {++n; n}}<br/>
        def counter2 = {mutable n = 0; fun() {++n; n}}<br/>
        WriteLine(counter1());<br/>
        WriteLine(counter2());<br/>
        WriteLine(counter1());<br/>
        WriteLine(counter2());<br/>
        WriteLine(counter1());<br/>
        WriteLine(counter2())<br/>
        }<br/>
        }<br/>
      </code>
      <p>
        output:
      </p>
      <code>
        $ ./ncounter.exe<br/>
        3<br/>
        1<br/>
        4<br/>
        2<br/>
        5<br/>
        3<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="OcamlLanguage.html">OcamlLanguage</a><strong>:</strong>
      </p>
      <code>
        (* OCaml's partial application semantics prevent purely optional<br/>
        arguments from appearing at the end, so we have to put an extra<br/>
        "unit" argument at the end. *)<br/>
        let counter ?(n = 1) () =<br/>
        let r = ref (n-1) in<br/>
        fun () -> begin<br/>
        incr r; !r<br/>
        end<br/>
      </code>
      <p>
        Then:
      </p>
      <code>
        # let x = counter ();;<br/>
        val x : unit -> int = <fun><br/>
        # let y = counter ();;<br/>
        val y : unit -> int = <fun><br/>
        # let z = counter ~n:5 ();;<br/>
        val z : unit -> int = <fun><br/>
        # x ();;<br/>
        - : int = 1<br/>
        # x ();;<br/>
        - : int = 2<br/>
        # y ();;<br/>
        - : int = 1<br/>
        # z ();;<br/>
        - : int = 5<br/>
        # x ();;<br/>
        - : int = 3<br/>
        # y ();;<br/>
        - : int = 2<br/>
        # z ();;<br/>
        - : int = 6<br/>
      </code>
      <p>
        This overflows at the same time OCaml's integers do.  If you want arbitrary-precision arithmetic, you can use the Num module:
      </p>
      <code>
        let counter ?(n = num_of_int 1) () =<br/>
        let r = ref (pred_num n) in<br/>
        fun () -> begin<br/>
        incr_num r; !r<br/>
        end<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="PerlLanguage.html">PerlLanguage</a><strong>:</strong>
      </p>
      <p>
        There is more than one way to do it (of course), this one uses closures.
      </p>
      <code>
        sub Counter { my $n = @_ ? shift() : 1; sub { $n++ } }<br/>
        $counter = Counter;<br/>
        $counter5 = Counter 5;<br/>
      </code>
      <code>
        print $counter->();   # prints 1<br/>
        print $counter->();   # prints 2<br/>
        print $counter5->();  # prints 5<br/>
        print $counter5->();  # prints 6<br/>
        print $counter->();   # prints 3<br/>
      </code>
      <p>
        <em>But wait! If you call now, we'll throw in the following absolutely free! ...</em>
      </p>
      <code>
        $leadingzeros = Counter '000000000100';  #generates 000000000100, 000000000101, ...<br/>
      </code>
      <code>
        $letters = Counter 'a';  # generates a, b, ... z, aa, ab, ...<br/>
      </code>
      <code>
        $reallylongnumber = Counter '1'; # will generate count to as many digits as needed (till long after the sun burns out...)<br/>
      </code>
      <p>
        You can even start with a really long number:
      </p>
      <code>
        $anotherlongnumber = Counter '1000000000000000000000000000000';<br/>
      </code>
      <p>
        Or you can generate something like serial numbers.
      </p>
      <code>
        $serialnumber = Counter 'ITEM000100';  # will produce ITEM000100, ITEM000101, ...<br/>
      </code>
      <p>
        (The magic auto-increment is documented in perlop.)
      </p>
      <p>
        Also, in the best traditions of modularity and bloat, here is the subclassable OO version.
      </p>
      <code>
        sub Counter::new { my ($c, $n) = @_; bless(\$n, $c) }<br/>
        sub Counter::inc { my $self = shift; $$self++ }<br/>
      </code>
      <code>
        $c = Counter->new("ITEM000");<br/>
        print $c->inc, "\n";<br/>
        print $c->inc, "\n";<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="PythonLanguage.html">PythonLanguage</a><strong>: </strong>
      </p>
      <code>
        # Each counter is a coroutine counting with an int or long<br/>
        def Counter(n=1):<br/>
        while 1:<br/>
        yield n<br/>
        n += 1<br/>
      </code>
      <code>
        counter1 = Counter(3).next<br/>
        counter2 = Counter().next<br/>
        print counter1()<br/>
        >>> 3<br/>
        print counter2()<br/>
        >>> 1<br/>
        print counter1()<br/>
        >>> 4<br/>
        print counter2()<br/>
        >>> 2<br/>
        >>> clong1 = Counter(sys.maxint).next<br/>
        >>> clong1()<br/>
      </code>
      <ol>
        <li>
          7
        </li>
      </ol>
      <code>
        >>> clong1()<br/>
      </code>
      <ol>
        <li>
          L
        </li>
      </ol>
      <code>
        >>> clong2 = Counter(sys.maxint**8).next<br/>
        >>> clong2()<br/>
      </code>
      <ol>
        <li>
          L
        </li>
      </ol>
      <p>
        The value of <em>n</em> automatically becomes an arbitrarily <em>long</em> integer beyond <em>sys.maxint</em>.  
      </p>
      <p>
        An older solution:
      </p>
      <code>
        class Counter:<br/>
        def __init__(self, n=0):<br/>
        self.n = n<br/>
        def __call__(self):<br/>
        self.n += 1<br/>
        return self.n<br/>
      </code>
      <code>
        >>> clong = Counter(sys.maxint-1)<br/>
        >>> print clong() # 2147483647<br/>
        >>> print clong() # 2147483648<br/>
        >>> print clong() # 2147483649<br/>
      </code>
      <p>
        The short solution (requires a recent Python):
      </p>
      <code>
        >>> import itertools<br/>
        >>> counter = itertools.count(1).next<br/>
        >>> counter()<br/>
        1<br/>
        >>> counter()<br/>
        2<br/>
      </code>
      <p>
        Alas the count wraps-around at sys.maxint.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="RubyLanguage.html">RubyLanguage</a><strong>:</strong>
      </p>
      <code>
        def Counter(n=1)<br/>
        proc do<br/>
        result = n<br/>
        n = n + 1<br/>
        result<br/>
        end<br/>
        end<br/>
      </code>
      <code>
        counter = Counter(3)<br/>
        counter2 = Counter()<br/>
        print counter.call()<br/>
        >>> 3<br/>
        print counter2.call()<br/>
        >>> 1<br/>
        print counter.call()<br/>
        >>> 4<br/>
        print counter2.call()<br/>
        >>> 2<br/>
      </code>
      <p>
        Or if you don't mind incrementing the counter before rather than after (like that Lisp version up above):
      </p>
      <code>
        def counter(n=0)  lambda {n += 1};  end<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="RubyLanguage.html">RubyLanguage</a><strong>, more traditional OO style:</strong>
      </p>
      <code>
        class Counter<br/>
        def initialize(n = 1) @value = n-1 end<br/>
        def incr!() @value += 1; @value end<br/>
        def value() @value+1 end<br/>
        end<br/>
      </code>
      <p>
        This also lets you get the current value of the counter without incrementing it.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="SchemeLanguage.html">SchemeLanguage</a><strong>:</strong>
      </p>
      <code>
        (define (make-counter . x)<br/>
        ; validate argument<br/>
        (let ((count (if (and<br/>
        (not (null? x))<br/>
        (integer? (car x)))<br/>
        (car x)<br/>
      </code>
      <ol>
        <li>
          )))
        </li>
      </ol>
      <code>
        ; return counter closure  <br/>
        (lambda ()<br/>
        (let ((current-count count))<br/>
        (set! count (+ 1 count))<br/>
        current-count))))<br/>
      </code>
      <p>
        Usage:
      </p>
      <code>
        > (define counter (make-counter))<br/>
        > (counter)<br/>
        1<br/>
        > (counter)<br/>
        2<br/>
        > (counter)<br/>
        3<br/>
        > (define counter2 (make-counter 10))<br/>
        > (counter2)<br/>
      </code>
      <ol>
        <li>
          0
        </li>
      </ol>
      <code>
        > (counter2)<br/>
      </code>
      <ol>
        <li>
          1
        </li>
      </ol>
      <code>
        > (counter2)<br/>
      </code>
      <ol>
        <li>
          2
        </li>
      </ol>
      <code>
        > (define counter3 (make-counter 10.1))<br/>
        > (counter3)<br/>
        1<br/>
        > (counter3)<br/>
        2<br/>
        > (counter3)<br/>
        3<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="SmlLanguage.html">SmlLanguage</a><strong>:</strong>
      </p>
      <p>
        Below is an interactive session with the SML/NJ compiler.  The
        lines starting with a dash contain the code.  The other lines
        have been printed by the compiler.
      </p>
      <code>
        Standard ML of New Jersey v110.57 [built: Fri Feb 10 21:37:49 2006]<br/>
        - val newCounter = (fn c => fn () => !c before c := !c + (1:IntInf.int)) o ref ;<br/>
        [autoloading]<br/>
        [library $SMLNJ-LIB/Util/smlnj-lib.cm is stable]<br/>
        [library $basis.cm(=$SMLNJ-BASIS)/basis.cm is stable]<br/>
        [autoloading done]<br/>
        val newCounter = fn : IntInf.int -> unit -> IntInf.int<br/>
        - val counterA = newCounter 1 ;<br/>
        val counterA = fn : unit -> IntInf.int<br/>
        - val counterB = newCounter 10000000000000000000 ;<br/>
        val counterB = fn : unit -> IntInf.int<br/>
        - counterA () ;<br/>
        val it = 1 : IntInf.int<br/>
        - counterB () ;<br/>
        val it = 10000000000000000000 : IntInf.int<br/>
        - counterA () ;<br/>
        val it = 2 : IntInf.int<br/>
        - counterB () ;<br/>
        val it = 10000000000000000001 : IntInf.int<br/>
        - counterB () ;<br/>
        val it = 10000000000000000002 : IntInf.int<br/>
        - counterA () ;<br/>
        val it = 3 : IntInf.int<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="VerilogHdl.html">VerilogHdl</a><strong>:</strong>
      </p>
      <code>
        // 7 bit up counter synchronous active high reset and initial value<br/>
        // overflow output<br/>
        // positive edge triggered clock<br/>
        module Counter(clk,reset,load,init_value,count,overflow);<br/>
        parameter WIDTH=7; // number of bits<br/>
      </code>
      <code>
        input clk, reset, load;<br/>
        input [WIDTH-1:0] init_value;<br/>
        output [WIDTH-1:0] count;<br/>
        output overflow;<br/>
      </code>
      <code>
        reg [WIDTH-1:0] count;<br/>
        reg overflow;<br/>
      </code>
      <code>
        always @(posedge clk) begin<br/>
        if (reset) begin<br/>
        count <= 1;<br/>
        overflow <= 0;<br/>
        end else if (load) begin<br/>
        count <= init_value;<br/>
        overflow <= 0;<br/>
        end else begin     <br/>
        if (&(count))<br/>
        overflow <= 1;<br/>
        count <= count + 1;<br/>
        end<br/>
      </code>
      <code>
        endmodule<br/>
      </code>
      <code>
        Counter       count1(...); // 7-bit counter (default)<br/>
        Counter #(23) count2(...); // 23-bit counter<br/>
        Counter #(531) count3(...); // 531-bit counter (might cause timing problems ...)<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="VhdlLanguage.html">VhdlLanguage</a><strong>:</strong>
      </p>
      <code>
        -- 7-bit synchronous up-counter with asynchronous active-high reset<br/>
        library ieee;<br/>
        use ieee.std_logic_1164.all;<br/>
        use ieee.std_logic_arith.all;<br/>
        use ieee.std_logic_unsigned.all;<br/>
      </code>
      <code>
        -- the interface of the counter<br/>
        entity counter is<br/>
        port(<br/>
        CLK		: in std_logic;<br/>
        RST		: in std_logic;<br/>
      </code>
      <code>
        O		: out std_logic_vector(6 downto 0));<br/>
        end entity;<br/>
      </code>
      <code>
        -- the rtl architecture of the entity. One entity can have multiple<br/>
        -- architectures, the appropriate architecture being selected at<br/>
        -- instantation.<br/>
        architecture rtl of counter is<br/>
        signal value		: std_logic_vector(6 downto 0);<br/>
        begin<br/>
        -- sequential process<br/>
        process (CLK,RST)<br/>
        begin<br/>
        -- reset logic<br/>
        if (RST = '1') then<br/>
        value <= (others => '0');<br/>
      </code>
      <code>
        -- increment counter on the rising edge of the clock<br/>
        elsif (rising_edge(CLK)) then<br/>
        value <= value + 1;<br/>
        end if;<br/>
        end process;<br/>
      </code>
      <code>
        -- concurrent statement to output the counter value<br/>
        O <= value;<br/>
        end rtl;<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="ExtendedObjectTcl.html">ExtendedObjectTcl</a><strong></strong>
      </p>
      <p>
        Someone else can provide an interesting version for the pure <a href="ToolCommandLanguage.html">ToolCommandLanguage</a>.
      </p>
      <code>
        Class Counter -parameter {count 1}<br/>
      </code>
      <code>
        Counter instproc next {} {<br/>
        my instvar count<br/>
      </code>
      <code>
        set result $count<br/>
        incr count<br/>
        return $result<br/>
        }<br/>
      </code>
      <p>
        How to use it:
      </p>
      <code>
        Counter basicCounter<br/>
        puts [basicCounter next]<br/>
      </code>
      <code>
        ==> 1<br/>
      </code>
      <code>
        Counter basicCounter -count 5<br/>
        puts [basicCounter next]<br/>
      </code>
      <code>
        ==> 5 <br/>
      </code>
      <hr/>
      <p>
        MyFutureLanguage
      </p>
      <code>
        counter :=<br/>
        | n | \ n...Infinity<br/>
      </code>
      <code>
        #counter is defined as<br/>
        #      if given one argument (pattern-matching <em>a l�</em> <a href="MlLanguage.html">MlLanguage</a>, also <a href="RubyLanguage.html">RubyLanguage</a> syntax lookalike ;))<br/>
        #         , the function (\ = lambda)<br/>
        #            which returns the value that n...Infinity generates<br/>
        #             (where x...y is a generator <em>a l�</em> <a href="IconLanguage.html">IconLanguage</a>)<br/>
        #(Usage is:<br/>
        # myVar := counter(1)<br/>
        # print myVar<br/>
        # print myVar<br/>
      </code>
      <hr/>
      <p>
        <a href="IoLanguage.html">IoLanguage</a>:
      </p>
      <code>
        counter := Object clone do(<br/>
        count := 1<br/>
        withValue := method(n, count := n)<br/>
        count := method(<br/>
        count = count + 1<br/>
        count - 1<br/>
        )<br/>
        )<br/>
      </code>
      <code>
        c1 := counter clone<br/>
        c1 count print<br/>
        c1 count print<br/>
      </code>
      <code>
        c2 := counter clone withValue(100)<br/>
        c2 count print<br/>
        c2 count print<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="PhpLanguage.html">PhpLanguage</a><strong> 5.3+</strong>
      </p>
      <code>
        function Counter($val = 1) {<br/>
        return function() use (&$val) { return $val++; };<br/>
        }<br/>
      </code>
      <p>
        <a href="PhpLanguage.html">PhpLanguage</a> pre-5.3 version ;)
      </p>
      <code>
        function Counter($val = 1) {<br/>
        return create_function(<em>, 'static $val = '.$val.'; return $val++;');</em><br/>
        }<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="ObjectiveCee.html">ObjectiveCee</a><strong></strong>
        using Blocks on MacOSX 10.6+
      </p>
      <code>
        typedef int (^IntGenerator)();<br/>
        IntGenerator Counter(int val) {<br/>
        __block int _val = val;<br/>
        return [[^() { return _val++; } copy] autorelease];<br/>
        }<br/>
      </code>
      <hr/>
      <p>
        <a href="GoLanguage.html">GoLanguage</a>
      </p>
      <code>
        func Counter(val int) func() int {<br/>
        return func() int {<br/>
        val++<br/>
        return val<br/>
        }<br/>
        }<br/>
      </code>
      <hr/>
      <p>
        <a href="SwiftLanguage.html">SwiftLanguage</a>
      </p>
      <p>
        func Counter(var val: Int) -> () -> Int {
      </p>
      <code>
        return {<br/>
        val++<br/>
        return val<br/>
        }<br/>
      </code>
      <p>
        }
      </p>
      <hr/>
      <p>
        See <a href="ArraySumInManyProgrammingLanguages.html">ArraySumInManyProgrammingLanguages</a>, <a href="DotProductInManyProgrammingLanguages.html">DotProductInManyProgrammingLanguages</a>, <a href="WardNumberInManyProgrammingLanguages.html">WardNumberInManyProgrammingLanguages</a>, <a href="HelloWorldInManyProgrammingLanguages.html">HelloWorldInManyProgrammingLanguages</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryInManyProgrammingLanguages.html">CategoryInManyProgrammingLanguages</a>
      </p>
    </div>
  </body>
</html>