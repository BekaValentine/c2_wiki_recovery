<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Social Problems Of Lisp
      </h1>
      <p>
        See <a href="WhyWeHateLisp.html">WhyWeHateLisp</a> (problem), <a href="XpInCommonLisp.html">XpInCommonLisp</a> (ultimate solution).
      </p>
      <hr/>
      <p>
        It is often suggested that one of the <a href="SocialProblemsOfLisp.html">SocialProblemsOfLisp</a> is that <a href="LispUsersAreArrogant.html">LispUsersAreArrogant</a>.
      </p>
      <p>
        <em>No, they're just perceived as arrogant by lesser beings.</em>
      </p>
      <p>
        ("Lesser beings" being those who bathe regularly.)
      </p>
      <p>
        <em>The authors of these last two comments have disqualified themselves from criticism regarding social problems. Do they consider this an acceptable way to behave? Is this how they would behave in a face-to-face situation? It is truly appalling and taints both the Lisp community and its detractors.</em>
      </p>
      <p>
        No, it serves the practical purpose of providing clear evidence that Lisp is associated with social problems :-)
      </p>
      <p>
        <em>The exchange above was also a great example of the dry ironies the real world manifests, thus serving the true </em><a href="PrimeDirective.html">PrimeDirective</a>: making me chuckle. --CraigEverett<em></em>
      </p>
      <hr/>
      <p>
        <a href="SocialProblemsOfLisp.html">SocialProblemsOfLisp</a> are a pet topic of LispHaters.
      </p>
      <hr/>
      <p>
        Like many things in Lisp, the <a href="SocialProblemsOfLisp.html">SocialProblemsOfLisp</a> is recursive. People mostly complain about the <a href="SocialProblemsOfLisp.html">SocialProblemsOfLisp</a> because they hear other people complain about the <a href="SocialProblemsOfLisp.html">SocialProblemsOfLisp</a>.
      </p>
      <p>
        <em>Many of us have run into various </em><a href="SocialProblemsOfLisp.html">SocialProblemsOfLisp</a> head-on. The likely source of unfairness is that other languages have boorish twits advocating them as well; but the <a href="SmugJavaWeenie.html">SmugJavaWeenie</a>s seem to be a much smaller subset of the Java community.<em> I can't really agree with that from reading Slashdot, talking to fellow programmers, or even the news I hear from Java conferences.</em>
      </p>
      <p>
        <em>ANY subset of the Java community is likely to be larger than the Lisp community in its entirety.</em>
      </p>
      <p>
        In all seriousness, I think the <a href="SocialProblemsOfLisp.html">SocialProblemsOfLisp</a> originate mostly on the other (non-Lisp) side of the fence. 
      </p>
      <p>
        <em>Where they "originate" is hard to pinpoint - but it should be obvious that the whole topic arises as a result of interactions between the Lisp community and the non-Lisp community.</em>
      </p>
      <p>
        I've been reading Ellen Rose's <em>User Error: Resisting Computer Culture</em> (ISBN: 1896357792), and besides being a razor-sharp culmination of criticisms of modern computer culture (I recommend it to anyone who makes software, free or not), it largely confirms the irrational basis of much of the criticism leveled against Lisp, Emacs, and user-programmable systems in general. It all comes down to a pathological struggle of developer vs. user control, with a good dash of conservative white geek thrown in. Incidentally, it also nicely explains the complex world of Free Software politics and business adoption (even though the book makes no mention at all of free or open source software). - Vladimir Sedach
      </p>
      <p>
        <em>Developer vs user control? "Conservative white geek"? Any supposedly-scientific treatise that depends on words (or concepts) like </em>that<em> definitely smells bad to me.</em> I'm sorry, but where did you see the quotes around my statement? It's a conclusion I drew partly from the book, but mostly from my own experience. Please attack my thesis and not my sources. <em>At any rate, while "control" may be part of the equation, it certainly doesn't explain everything. Numerous other programming communities use/advocate "free-form" programming languages, but don't have the bad reputation that the Lisp community, er, enjoys. Python is a notable example; the Python community is refreshingly free of zealotry.</em> The Python community is also refreshingly free of history. It can honestly be said to have begun forming only 8 or so years ago. Pathologies (and reputations) take time to develop, even today.
      </p>
      <p>
        When you see how the absolute worst <a href="LispStrawMen.html">LispStrawMen</a> are thrown about on the c2 wiki, ones that even the <a href="SlashDot.html">SlashDot</a> community has high enough standards not to repeat, you have to ask what's going on. <a href="WhyWeHateLisp.html">WhyWeHateLisp</a> and <a href="SocialProblemsOfLisp.html">SocialProblemsOfLisp</a> are full of simple, verifiable lies.
      </p>
      <ul>
        <li>
           But the LispStrawMan arguments <em>aren't</em> advocated much on Wiki - that page appears to be created by Lispers in order to refute admittedly weak anti-Lisp arguments. Unsubstaited claims of "Lisp is slow, duh" are easy to refute; car/cdr is widely considered a non-issue by many of us here; etc. <a href="EssExpression.html">EssExpression</a>s are an issue for some - but that's a syntactic issue. The <a href="IssuesAndProblemsWithLisp.html">IssuesAndProblemsWithLisp</a> page contains more substantial arguments. And the argument heard from the anti-Lisp crowd here is not one of "Lisp sucks"; instead it's a reaction to the Lisp crowd's often-repeated claim that "everything but Lisp sucks". For the record, I think Lisp is a fine language; but there are many legitimate reasons to choose something else. In many application areas.
        </li>
      </ul>
      <ul>
        <li>
           When I wrote <a href="LispStrawMen.html">LispStrawMen</a>, I took all the strawmen from this wiki. (I didn't write the lisp-is-slow one, but the rest I did.) You claim they're weak - that's why they're <a href="StrawMen.html">StrawMen</a>. If it's not a <a href="StrawMan.html">StrawMan</a>, then it's not weak, is it? <a href="IssuesAndProblemsWithLisp.html">IssuesAndProblemsWithLisp</a> looks like a fine page. But this page (<a href="SocialProblemsOfLisp.html">SocialProblemsOfLisp</a>) doesn't, until it is changed to reflect real social problems, not fake stories.
        </li>
      </ul>
      <ul>
        <li>
           A <a href="StrawMan.html">StrawMan</a> isn't the same as a weak argument - a better title for the page might be DumbArgumentsAgainstLisp. A <a href="StrawMan.html">StrawMan</a> is when a weak argument is attributed to the opposition, and then (easily) refuted - in order to make it appear that you've refuted the opponent's entire position.
        </li>
      </ul>
      <ul>
        <li>
           In the context of <a href="LispStrawMen.html">LispStrawMen</a>, a straw man is a easily-criticised caricature of Lisp which the Lisp detractor presents as the reality of Lisp. "Lisp's only data-type is the list" and "Lisp programs are full of names like <em>car</em> and <em>cdr</em>" are straw men because they are used as arguments against Lisp, even though those statements are not generally true of Lisp. "Lisp uses lots of parantheses" is not a straw man, because Lisp does.
        </li>
      </ul>
      <p>
        There's a little fictional dialogue below that's supposed to be between lispers, and when someone pointed out it made no sense, the author replied, "The story is just intended as an illustration; it's not a direct quotation." A made up story. Just like the criticism on <a href="WhyWeHateLisp.html">WhyWeHateLisp</a> that lispers refuse to "learn from other communities," because lisp doesn't have a <em>for</em> loop - BS, lisp has something that's kind of like all <em>for</em> loops in all languages rolled into one.
      </p>
      <ul>
        <li>
           Anyone who says Lisp doesn't have loops is an ill-informed twit; probably one who received undergraduate exposure to Lisp as an example of a <a href="FunctionalProgrammingLanguage.html">FunctionalProgrammingLanguage</a>, and thus got the mistaken impression that Lisp uses recursion exclusively. Much anti-Lisp stuff is of that sort. But there are lots of legitimate criticisms of the language which aren't so easily dismissed.
        </li>
      </ul>
      <ul>
        <li>
           Well, that falsehood's still the first claim on <a href="WhyWeHateLisp.html">WhyWeHateLisp</a>. I agree he's greatly misinformed, but that's the standard on this wiki, and that's all I'm arguing about. <a href="IssuesAndProblemsWithLisp.html">IssuesAndProblemsWithLisp</a> looks like a bold and intelligent page. I recall some things were wrong there, but honestly wrong and perhaps close to the truth anyhow.
          <ul>
            <li>
               If I read <a href="WhyWeHateLisp.html">WhyWeHateLisp</a> correctly - the claim isn't that Lisp has no do loop; the claim is that a query on how to <em>implement</em> a loop produced all sorts of unexpected advice. Some of it may be good advice (use "span" rather than iterating over a variable), some of it may be questionable (use of recursion - while theoretically elegant, recursion has an implementation cost in many <a href="CommonLisp.html">CommonLisp</a> implementations), and some of it specious (references to the PeanoAxioms and so forth).
            </li>
            <li>
               And besides - <a href="WhyWeHateLisp.html">WhyWeHateLisp</a> is largely a <em>joke</em> page anyway.
            </li>
          </ul>
        </li>
      </ul>
      <p>
        Anyone who has ever visited Slashdot knows that the troll community is a tiny percentage with a lot of time on their hands. They love focussing on the "human side" because it's the easiest to make up stories about, and the hardest to disprove.
      </p>
      <ul>
        <li>
           I'm not terribly concerned with <a href="SlashDot.html">SlashDot</a>.
        </li>
      </ul>
      <ul>
        <li>
           On the whole I'm happier with <a href="SlashDot.html">SlashDot</a> right now. Then again, I browse comments at 3+.
        </li>
      </ul>
      <p>
        Visit usenet and tell us who's a bad meanie, and we'll discuss it rationally. Pick out something real. In case someone sends a troll, I'm posting this on Sept. 8, 2004, probably a couple hours before midnight GMT.
        <a href="http://groups.google.com/groups?hl=en&lr=&ie=UTF-8&group=comp.lang.lisp">http://groups.google.com/groups?hl=en&lr=&ie=UTF-8&group=comp.lang.lisp</a>
      </p>
      <ul>
        <li>
           <a href="ErikNaggum.html">ErikNaggum</a>. Granted, he seems to have slunk into retirement - which is a good thing.
        </li>
      </ul>
      <ul>
        <li>
           (Actually, Erik Naggum is dead.)
        </li>
      </ul>
      <ul>
        <li>
           If that's your only example, a blast from the past, I'd say we're done here. I'm always ready to hear a real problem of lispers, because I (and others) can try doing something about that. I scan this wiki fairly often; you have the usenet link, and we can talk about <strong>real</strong> problems. But all I see now are friendly lispers and newbies walking away happy.
        </li>
      </ul>
      <hr/>
      <p>
        Perhaps the social problems of lisp are noticeable simply because it has so few technical problems?
      </p>
      <p>
        [Now there is a well-reasoned response. You sure showed us why the above question couldn't be true.]
      </p>
      <ul>
        <li>
           But there are relevant <a href="IssuesAndProblemsWithLisp.html">IssuesAndProblemsWithLisp</a>; particularly in the domains (business application) where the vast majority of programmers are employed. And, there are some social issues - one doesn't run into SmugVisualBasicWeenies very often. (Granted, any VB weenies that <em>do</em> exist have little to be smug about, but VB is more appropriate than even Lisp for some tasks).
        </li>
      </ul>
      <p>
        <em>That's because most of the </em>SmugVisualBasicWeenies are managers, whether they know it or not ('it' refers to the former - of course they know they're managers!). Market share and availability of programmer monkeys are things that are worth being smug about. No-one I know got fired for buying IBM or Microsoft. -- Vladimir Sedach<em></em>
      </p>
      <ul>
        <li>
           Blaming everything on managerial incompetence is usually an inadequate explanation. For some things, VB or Java is probably a better solution to the problem - you don't need an 18-wheeler to deliver pizzas, and you probably don't <em>want</em> one either.
        </li>
      </ul>
      <ul>
        <li>
           Way to put words in the horse's mouth! If you didn't notice the first time you read (or not) what I wrote above, what I was explaining is where all the SmugVisualBasicWeenies were hiding (I do have to ask - what did you think I explained inadequately?). I certainly didn't blame anybody (what's there to blame them for?), and if you insist that choosing VB or Java based on availability of cheap programmers and popularity is "managerial incompetence," then you're just contradicting yourself. -- Vladimir
        </li>
      </ul>
      <hr/>
      <p>
        One problem is a very anti-newbie attitude. It's not so much that <a href="SmugLispWeenie.html">SmugLispWeenie</a>s don't try to encourage newcomers to get involved with Lisp - it's that they cannot agree with each other for five seconds on (loop) vs (do), <a href="CommonLisp.html">CommonLisp</a> vs <a href="SchemeLanguage.html">SchemeLanguage</a>, whether metamacros are horrible style or occasionally justifiable,... they fight over everything except indenting style, since the language makes that one a null issue. So when somebody comes to a group of two or more SLWs asking for advice, it goes something like this:
      </p>
      <p>
        <em>Just to be clear since this has confused some people: The following is a dramatization; not a transcript of any actual conversation that occurred. Take the following with a grain of salt.</em>
      </p>
      <p>
        Newbie: Hi. I've been using Lisp for about half a year now, programming for three years. I discovered this group and wondered if you could help me out with a problem I'm having?
      </p>
      <p>
        Smug: Hi! Always glad to have new blood. Sure thing, just ask.
      </p>
      <p>
        Snide: Heya New! You bet, ask anything and we'll try to help.
      </p>
      <p>
        Newbie: Okay, I'm trying to filter a list, something like Perl's grep. I want to set up a predicate and have the new list be only those elements from the old list that satisfy it. I know there's some standard idiom for doing this, I just can't find it anywhere...
      </p>
      <p>
        Smug: Perl's grep was inspired by Lisp's higher-order functions, you know. :)
      </p>
      <p>
        Newbie: Oh, cool. :)
      </p>
      <p>
        Smug: But it's inferior since it has balky syntax.
      </p>
      <p>
        Snide: You can do it with (mapcan (lambda (item) (when (predicate item) (list item))) list).
      </p>
      <p>
        Newbie: Sounds good, where can I look up how to use mapcan?
      </p>
      <p>
        Smug: You could do it that way, if you were brain-damaged and didn't care about readability. It would be better to write the macro (collecting) and then do (collecting (mapc (lambda (item) (when (predicate item) (collect item))) list)
      </p>
      <p>
        Snide: Collecting is for wimps.
      </p>
      <p>
        Snoozer: Newbie, you're trying to use (collecting)? That's a mistake, it's non-standard. Yes it is portable, but it's hard to read because new people don't know it.
      </p>
      <p>
        Newbie: What does (collecting) do?
      </p>
      <p>
        Snoozer: If you don't know, why are you trying to use it?
      </p>
      <p>
        Snide: You know, I had to do something like this last month, for my commercial Lisp program which I was paid to do. I did it with (mapcan).
      </p>
      <p>
        Smug: Well I guess some of us just aren't that lucky then.
      </p>
      <p>
        Newbie: And can anyone tell me please, where do I look up documentation for how to use (mapcan) or (collecting) or whatever it is?
      </p>
      <p>
        Snoozer: You're a lamer, Newbie, go away.
      </p>
      <p>
        Smug: Snoozer, don't be rude. Snide, both ways are perfectly good.
      </p>
      <p>
        Newbie: So....?
      </p>
      <p>
        Smug: So, you should use (collecting), because it's a helpful macro and will make your code more readable.
      </p>
      <p>
        Snide: No, you shouldn't.
      </p>
      <p>
        Smug: This whole debate is only happening because you accept the Kantian metaphysics.
      </p>
      <ul>
        <li>
          Newbie has left the channel (Quit: Error: User's head has exploded.)
        </li>
      </ul>
      <p>
        <em>I would have just told the guy to use:</em>
      </p>
      <code>
        <em>(defun collection (pred lat)</em><br/>
        <em>(cond ((null lat) '())</em><br/>
        <em>((funcall pred (car lat)</em><br/>
        <em>(cons (car lat) (collection pred (cdr lat))))</em><br/>
        <em>(t (collection pred (cdr lat)))))</em><br/>
      </code>
      <p>
        One of the <a href="SmugLispWeenie.html">SmugLispWeenie</a>s would have pointed out that your function isn't <a href="TailRecursive.html">TailRecursive</a>, then pointed out how to transform it to a <a href="TailRecursive.html">TailRecursive</a> style with an accumulator, then someone would have said to use the LOOP macro, and then the permanent LOOP macro <a href="FlameWar.html">FlameWar</a> brigade would have swooped down to duke it out, and then there would be a fight between the people who favor recursion and those who prefer the DO form, and the newbie would have some nice learning experience prior to the head explosion. I'll give <a href="SmugLispWeenie.html">SmugLispWeenie</a>s one thing: if you can stand them, they can be pretty informative when they bicker over the best way to answer a newbie's question.
      </p>
      <p>
        <em>But above code does not even work. Now what?</em> <em>Converting it to use an accumulator is useless, since Common Lisp does not support tail call removal. The best hint would be (as said below) to use REMOVE-IF-NOT, which is a standard function in Common Lisp. LOOP is fine: (loop for element in lat when (funcall pred element) collect element).</em>
      </p>
      <ul>
        <li>
          Interestingly, (remove-if-not (lambda (x) (zerop (mod x 2))) '(23 34 45 56 67 12)) is only slightly shorter than (loop for x in '(23 34 45 56 67 12) when (zerop (mod x 2)) collect x).  Probably actual Lisp hackers (which I am not) would have come up with those fairly quickly.
        </li>
      </ul>
      <ul>
        <li>
          What the hell are you talking about? I don't know of any CL implementation that isn't tail-recursive.
        </li>
      </ul>
      <ul>
        <li>
          So, which do you know then? How would you write portable code such that all those CL implementations compile code using tail code removal? How do these implementations do tail call removal in the presence of dynamic bindings (LET, ...) or CATCH or :AROUND METHOD-COMBINATIONS? And where can I read about it in the ANSI CL spec? What's a tail call in CL anyway?
          <ul>
            <li>
              I'm familiar with CMUCL, CLISP, and Corman Lisp. Try something like (defun foo (x) (print x)(foo (+ 1 x))) for a tail-recursive function. Guess what: It's tail recursive because the recursive call is guaranteed to be the last executed.
              <ul>
                <li>
                   Only if you set some switches in the Lisp right (typically some low DEBUG level), so the compiler optimizes it. But now try something like the above with a LET and a dynamic variable. (defvar *bar* 1) (defun bar () (let ((*bar* (1+ *bar*))) (bar))) Guess what? It's not tail recursive, even though the recursive call looks like it is the last executed. Oh, oh... See CMUCL docs for an explanation of the limits of tail call merging (as it is called there).
                </li>
                <li>
                   You've proved that if you try to defeat your compiler, by writing code in a completely non-functional style, you can write inefficient code. What is your point? You can defeat your compiler in any language, with any implementation, if you wish. Do you have any real examples of code that defeats CMUCL tail-call elimination (but appears tail-recursive), which is in any way preferable to a natural tail-recursive implementation?
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <p>
        Amusing story but at least one of the <a href="SmugLispWeenie.html">SmugLispWeenie</a>s would have mentioned REMOVE-IF-NOT, which is the built-in higher-order function to do what the Newbie wanted. <em>(Good point. The story is just intended as an illustration; it's not a direct quotation.)</em>
      </p>
      <p>
        For a genuine (non-fiction) story of a newbie to <a href="CeePlusPlus.html">CeePlusPlus</a> facing "experts" who natter on and duke it out, see <a href="CeeProgramsForBeginnersDiscussion.html">CeeProgramsForBeginnersDiscussion</a>. There it's not the newbie's head that explodes but the newbie's computer!
      </p>
      <hr/>
      <p>
        Rather than complaining about experienced lisp users with different opinions on a subject i would be quiet happy watching once more the perfect adaptability of lisp to one's tastes. The newbie should just RTF(awesome)M. Programming in lisp for a long time, consists mostly in making a language that is as close as possible to your native way of thinking.I prefer that to absolute formality even if it's not newbie-friendly. -- SteliosKokkalis
      </p>
      <hr/>
      <p>
        Amusing story, but I observe exactly the same behaviour on every IRC channel I've used and most of the newsgroups I read too. Is it really so much worse for Lisp?
      </p>
      <dl>
        <dt> </dt>
        <dd>Go not unto the Usenet for advice, for you will be told both yea and nay (and quite a few things that just have nothing at all to do with the question).</dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd>(author unknown)</dd>
      </dl>
      <p>
        [No, it isn't notably worse for lisp. There is a skew towards experts in the community, relative to some others - which may have some effect.]
      </p>
      <hr/>
      <p>
        Whether the above is a problem or not is questionable. People are learning Lisp all the time (I only started two years ago, by accident, in my spare time) and enjoying it quite well. Personally, I pay close attention to Usenet threads with scenarios with the premise as shown above - I've never been disappointed. I always find that I either learn to do a new thing, an old thing in a new way, or a new thing in many new ways, but most importantly I learn all about their applications and trade-offs. I've never found a community quite so expert and detail-oriented in any other field. - Vladimir Sedach
      </p>
      <hr/>
      <p>
        Another problem is a tendency to reinvent the wheel. It grates on Lispers that they have to link with other languages to be competitive nowadays. They try to avoid this by rewriting absolutely everything in Lisp, even if they can't possibly hope to compare with existing C software. They never seem to get around to debugging the FFIs of their Lisp implementations, either.
      </p>
      <p>
        <em>Java has this problem too. It just doesn't matter for Java because the industry is so big that somebody out there has probably already done the rewrite in question.</em>
      </p>
      <p>
        The rewrites generally have technical reasons. Code linked in from other languages doesn't support the superior debugging and error-handling Common Lisp users are used to. Multi-methods and multiple inheritance are also a problem with many object-centered languages. <em>That could be viewed as an FFI deficiency.</em> <em>FFI deficiency? I don't see how an FFI is supposed to add multi-methods to C++, a condition system to C, or higher-order functions to Pascal.</em>
      </p>
      <p>
        The scope of the rewrites is just not worth it, though. Rewriting a parser generator, or make, sure. Those make sense. An X11 window manager? Nope. There are already a sufficient supply of good window managers, and maintaining one of those is hard and constant work.
      </p>
      <p>
        <em>Window managers are an interesting example: the Sawfish window manager, written in a Lisp dialect called rep, has been an absolute smash-hit in recent years. I'm sure this is in large part due to its convenient extensibility through Lisp, which appeals directly to Emacs-loving lisp hackers, and indirectly to other people who can use the resulting new features. -- </em><a href="LukeGorrie.html">LukeGorrie</a><em></em>
      </p>
      <p>
        <em>Ok, let's go through all of the Lisp-based and scriptable X11 window managers I know about. Luke Gorrie already mentioned Sawfish, which is quite popular on it's own merits. There's GWM, which was written in the early 90s, when there wasn't much of a wheel to re-invent. Both of those only use Lisp as a scripting language. Of the window managers written natively in Lisp, two are academic projects: Eclipse (Common Lisp - undergrad term project at U of Bordeaux), Scheme Constraint Window Manager (Scheme - graduate project at MIT). The third one (I just found out about it), is the Stump Window Manager - it's a lot like Ratpoison, only extendable at run-time, so it does have it's own niche (it's a single-author project, and I don't think he did it just to reinvent the wheel). And if you haven't noticed, there are dozens C-based window managers around, with new ones popping up every few months. So, where is this sinister Lisp wheel-building conspiracy again? - Vladimir Sedach</em>
      </p>
      <hr/>
      <p>
        It's amazing (and sad) that Lisp attracts these feelings. My experience with the Scheme community has been much more pleasant so I really wonder how objective the above protestations are.
      </p>
      <p>
        As the author of much of the above, I can assure you that I do not intend to besmirch the language itself; I am an avid user of it, and sometime advocate. I also recognize that it is impossible to make statements like this which will apply to all individuals in a group the size of the greater Lisp/Scheme community. This page is called <a href="SocialProblemsOfLisp.html">SocialProblemsOfLisp</a>, and I view the page as a tool for describing these problems and discussing their causes, relationships, and solutions. Because these problems exist in SOME subcommunities, they are worth discussing. I really don't view the negative comments I wrote as protestations at all. Does that help your assessment of them any?
      </p>
      <p>
        It is indeed sad.
      </p>
      <hr/>
      <p>
        I may have been the (unwitting) cause of this page, with this line
        which I wrote in <a href="XpInCommonLisp.html">XpInCommonLisp</a>:
      </p>
      <p>
        <em>Dunno. I think Lisp and XP are orthogonal. Lisp has many problems, but every one of them is social, not technical.</em>
      </p>
      <p>
        But the social problems were <strong>not</strong> those referred above (i.e. of newbies finding a hostile community). Rather I think Lisp suffers from
      </p>
      <ul>
        <li>
           hangover from the <a href="AiWinter.html">AiWinter</a>
        </li>
        <li>
           a community which largely disdains "easy" problems 
        </li>
        <li>
           lack of critical mass necessary to accumulate the momentum to "go forward". The ANSI CL spec is one of the great specs ever created, but it's now nearly 20 years old. The standardization of threading issues, FFI (to more than just C, if possible) would sure be nice. '(Also, a larger spec index section would be nice, so that they can add more features to Scheme. :) )'
          <ul>
            <li>
               Scheme R6RS is moving onward, with the draft at 142 pages. Maybe the next <a href="CommonLisp.html">CommonLisp</a> standard could include an Oracle-compatible database to catch up...
            </li>
          </ul>
        </li>
        <li>
           eternal confusion with the Scheme community (as demonstrated, yet again, on this page). Lisp, in real life, has very little to do with Scheme. Much less than, say, Java has to do with C. To outsiders, both languages look the same (lots of parentheses) but the goals of the communities are almost completely at odds.
        </li>
        <li>
           lack of new blood. This one is being addressed by a new generation of Lispers, who have brought us CLOCC and CCLAN. It is unclear if this effort will fizz out, or achieve critical mass.
        </li>
      </ul>
      <p>
        -- <a href="AlainPicard.html">AlainPicard</a>
      </p>
      <hr/>
      <p>
        Stuff moved to <a href="IsSchemeLisp.html">IsSchemeLisp</a>
      </p>
      <hr/>
      <p>
        If I could throw in my two cents, the "new" Lisp community is starting to develop one more problem - a growing association with <a href="DebianGnuLinux.html">DebianGnuLinux</a> and the Debian way of doing things. I still can't figure out how to use asdf or asdf-based software. Why can't I just shove all the dependencies together in the same directory and have it work? I don't know. <em>What does that have to do with Debian?</em>
      </p>
      <p>
        <em>This threw me for a minute too (I'm new to lisp, and don't use debian). Turns out all you have to do is load "asdf.lisp" from wherever, and you are good to go. For example, here is how I set up for loading uffi: in my .cmucl or whatever:</em>
      </p>
      <code>
        (load "/home/foo/lisp/asdf")<br/>
        (push "/home/foo/lisp/uffi/" asdf:*central-registry*)<br/>
      </code>
      <p>
        <em>Then when I need to use uffi:</em>
      </p>
      <code>
        (asdf:oos 'asdf:load-op :uffi)<br/>
      </code>
      <p>
        <em>It will (re)-build uffi automagically if needed.</em>
      </p>
      <p>
        <em>As a relatively new common lisper I've found the asdf stuff to be great. Dump the source for packages wherever you like and symlink the .asd files into a directory somewhere. Push the directory into asdf:*central-registry* as above and then it all just works - asdf works out where it's supposed to build and load the packages from through the symlinks. Defining your own systems with asdf is a little tricky at first [ the (:module foo :components ("filename")) stuff], but then you can drop a :depends-on into the definition and have the dependencies for your app loaded automatically. Then you only need to (asdf:oos 'asdf:load-op 'my-program) and you're good to go.</em>
      </p>
      <p>
        What has that to do with translating from a lisp source file to a native code file? (The equivalent of "cc file.c" for C)
      </p>
      <hr/>
      <p>
        <em>Lisp is so bendable as a language that a particular Lisp developer(s) will tend to create a style/library that fits the way they think. A different Lisp person may come along and be really annoyed by the techniques and styles employed. Personal preferences are magnified under Lisp. This is perhaps why it is called a "hacker language". Corporations like consistent standards and conventions because they want easily-exchangeable developers. A "creative" language makes this harder.</em>
      </p>
      <p>
        It doesn't seem that a good lisp program written using idioms that are somewhat unfamiliar to some random lisp hacker would make that program all that much harder to read for said hacker. If the idioms are appropriate for the problem at hand, it should be straightforward to learn them, and the resulting succinctness of the rest of the program will make up for the time spent learning them. Does this really impact developer exchangeability, except in the messed up logic of a bad, misinformed manager? Unless, of course, you mean exchanging expert hackers for naive, incapable hackers, (say, as a project is switching into "maintenance mode" - riiiiight,) which won't work in any case.
      </p>
      <p>
        The situation is worse in languages like C, where it takes a much more close and careful reading of a program to grok it. It's easier to write spaghetti code in C, C#, or Java than in lisp, if <strong>only</strong> because the programs in those languages generally use more lines of code.
      </p>
      <p>
        Give me a choice between maintaining a 1,000,000 line lisp program and a 1,000,000 line C/C++/Java program (not the same program; pick any two) and I won't hesitate to choose the lisp program.
      </p>
      <p>
        Speaking from personal experience, I've always been kind of bad a reading others' code. Of course, the code I've had to read has been in VB6, which is a terrible language, aesthetically. Then again, I've had trouble with C++ and C# programs, too. When I learned lisp, on the other hand, I found I could suddenly read others' code. ("Like magic appears...") I can only attribute this to the malleability of the language: when it starts to get in the way of you expressing an idea clearly and naturally, you can push it out of the way instead of having to add lots of comments to explain some weird hack you had to make because there's no better way to put the concept you were trying to express. It seems the malleability of the language, far from making code more tied to the hacker that created it, is what allows it to attain heights of readability mostly unknown to the programming world. -- Chris Capel
      </p>
      <p>
        On the other hand, if you were simply talking about small idioms such as indention style, variable naming, using loop instead of one of the do's, I'd say that the differences between various C programmers w.r.t. brace style is just as much of a problem. Consistent standards and conventions of this sort are just as easy to impose in lisp (and indeed, are already more standard across the users of the language) as in any language.
      </p>
      <p>
        <em>Consider the issue of a consultant walking into a company to work on some existing code. At least you know how the control structures of most Algol- or C-derived languages work. However, if every shop and/or developer reinvents their own variations of control structures, then the consultants will consume several hours and maybe days just learning and getting used to the custom ones.</em>
      </p>
      <p>
        [Every shop does this already with libraries. Learning a new control structure is no different from learning a new object in a library. Consultants have to spend time either learning the local controls structures or learning the local library, there is no difference.]
      </p>
      <ul>
        <li>
           Have you used Common Lisp yet, with an open mind? You will find these fears are illusory. New control structures are not "scary things," to be feared. Common Lisp is a good multiparadigm tool, and as a programmer, I carry good tools with me.
        </li>
      </ul>
      <ul>
        <li>
           Further, almost every programmer has some story of finding horrible code. Common Lisp's philosophy is to give you more tools to dig yourself out, when you find yourself in this pit.
        </li>
      </ul>
      <p>
        The first <em>any</em> consultant should do is learn the problem domain. I don't see how you can even think about control structures until you understand just what it is you're supposed to build.
      </p>
      <p>
        <em>Ideally you are right, but we don't live in an ideal world. People are put into less-than-ideal situations all the time and have to make the best of what they have.</em>
      </p>
      <ul>
        <li>
           OK, but at least have the best tools to aid you. <a href="MacGyver.html">MacGyver</a> would.
        </li>
      </ul>
      <p>
        And a Lisp program is likely to be framed in the terms of the problem domain; that's the whole point of macros.
      </p>
      <p>
        <em>Sometimes stuff is "invented" because the programmer is bored, not because they are looking for the ideal abstraction. I guess what I am saying is that Lisp makes </em><a href="MentalMasturbation.html">MentalMasturbation</a> perhaps too easy.<em></em>
      </p>
      <ul>
        <li>
           Please don't say a programmer's first instinct is to perform mental masturbation, because that is so untrusting. In fact, if you follow that <a href="MentalMasturbation.html">MentalMasturbation</a> link, you'll find people debating whether Unix or Windows is the best example of <a href="MentalMasturbation.html">MentalMasturbation</a>.
        </li>
      </ul>
      <ul>
        <li>
           <em>Some do and some don't. But, people who like to experiment will tend more towards Lisp than say C.NET or Java. Lisp's tendency to attract "experimenters" is one of its social problems. Different languages tend to attract different kinds of personality flaws.</em>
        </li>
      </ul>
      <ul>
        <li>
           That is deeply true. Lisp has an OpenDoorPolicy - you can tinker with its insides. Much like an ideal machine; a "programmer" is someone who knows the system so deeply enough you're willing to trust them to develop software.
        </li>
      </ul>
      <ul>
        <li>
           One example is the reader, the part of lisp which reads in text and can turn it into a program. (It's called the lexer or tokenizer in other systems.) If you look at lisp, there's already a few built-in languages: "this is string syntax", 394932 is an integer, #*001011101 is a bit string, ' quotes data so it's not executed as code. Those aren't lispy-looking languages. And you can create your own.
        </li>
      </ul>
      <ul>
        <li>
           If you think this is scary, consider today's "Cambrian" explosion of languages. To be a competent programmer, you need to know things like Java, XML, SQL, various little languages like AWK, and productivity languages like Ruby and Python. Not all of these tools are great; many of them have bitter expert users who wish they could mold them into something great. Programmers program, and we try to master this skill over years. But there are programs we are not competent enough to be trusted with?
        </li>
      </ul>
      <ul>
        <li>
           If you look at any good algorithm book using C or Java, you will often find language extensions to make the algorithms more lucid. All we do are algorithms, and those responsible for teaching them need to come up with their own language extensions to make algorithms bearable! (I'm thinking of Aho/Hopcroft/Ullman's algorithm book and Andrews' multiprocessing book. Others use pseudocode and invented languages to sidestep the issue, like Knuth and CLR.)
        </li>
      </ul>
      <ul>
        <li>
           I believe Common Lisp fails when people can't change things like GC strategies. (The older lisps apparently let you really interact with it, but Common Lisp was a minimal standard in some ways, which you could feasibly implement on commodity hardware.)
        </li>
      </ul>
      <p>
        Control structures are the least important part of the problem; you've got to learn all the existing APIs and libraries and components and data structures anyway. <a href="WhyIsDomainKnowledgeNotValued.html">WhyIsDomainKnowledgeNotValued</a>?
      </p>
      <p>
        Aside from that, <a href="CommonLisp.html">CommonLisp</a> already has a pretty rich set of control structures. It matches everything in C/Algol, at least. If a Lisp program is inventing a new control structure, it's because there's duplicated code that can be abstracted away. Think of how many times you write "for(int i = 0; i < array.length; ++i) { ... }" or "while(e.hasMoreElements()) { ...e.nextElement() }", both of which are abstracted under mapcar in Lisp. This makes things <em>more</em> uniform, not less, as there's a standard mechanism to iterate over elements of the container. -- <a href="JonathanTang.html">JonathanTang</a>
      </p>
      <hr/>
      <p>
        <strong>Algol Syndrome</strong>
      </p>
      <p>
        It is hard to break away from the Algol-family control structures (while, for, if) and conventions. One has to overhaul the way they think about control blocks and blocks in general under Lisp. Yes, it is probably good for us, like green leafy vegetables, but many are just not in the mood for a brain overhaul. Most algorithms and literature are designed around the Algol-style. Yes, it is probably <a href="QwertySyndrome.html">QwertySyndrome</a>, but hey, it just goes that way. I wish Lisp was forced on me in school so that I could mentally convert early and be over with it. But now I am old and lazy and would rather play with other equal or more interesting concepts instead. If API's are designed right, the Algol style is not that much more bloated anyhow. The Lisp improvement is relatively minor, just like the Dvorak keyboard. But you are welcome to prove me wrong. Show me consistent simplification and coding savings that approach 50% instead of just 5% or 10%, and I might change my mind. How about show up <a href="QueryAndLoop.html">QueryAndLoop</a>. The body of the loop is usually where the code bulk is anyhow, not the loop setup. Until then, have a QWERTY day.
      </p>
      <ul>
        <li>
           Well, you could use Sweet expressions <a href="http://www.dwheeler.com/readable/">http://www.dwheeler.com/readable/</a> -- Eduardo Bellani
        </li>
      </ul>
      <hr/>
      <p>
        I'm not sure how seriously to take the diatribe at the start of this page, but let's take one of the concrete statements it contains: "You have to literally describe files using a form of Chinese Calculus just to open a damned file! I'm not making this up either!" It's unclear to me what "literally" means there - certainly not literally "literally" - but:
      </p>
      <code>
        (with-open-file (f "foo.txt")<br/>
        ... do something with the open file f ...)<br/>
      </code>
      <p>
        doesn't seem to me like "a form of Chinese Calculus". <a href="CommonLisp.html">CommonLisp</a> has some hairy facilities for manipulating names of files and directories as structured objects, and those facilities don't happen to match the present-day world of Windows and Unix very well, but you can get by quite well without using them and working with strings like you do in other languages. -- <a href="GarethMcCaughan.html">GarethMcCaughan</a>
      </p>
      <hr/>
      <p>
        <em>Cet animal est tres mechant: quand on l'attaque, il se defend.</em> Trolling produces some responses. Big surprise. If you think it proves anything about Lisp users that when you say "Lisp users are arrogant know-it-alls, and their language sucks", backing your claims up with blatant falsehoods, and some people are offended or correct the falsehoods ... well, then I'm afraid you're a twit as well as a troll. You'd get the same results from users of C++, or Java, or Visual Basic, or Perl.
      </p>
      <p>
        But, yes: Something about Lisp is really weird sociologically. So many people have a bizarre and irrational love or hatred of the language and of (other) people who use it. I'm sure there must be reasons for this, but it's far from clear to me what they are. Does it <em>really</em> all go back to the AI Winter thing?
        -- <a href="GarethMcCaughan.html">GarethMcCaughan</a>
      </p>
      <p>
        It occurs to me that whoever has used lisp loves it and whoever just sees lisp code just hates it. It has to do with those "alien" concepts behind lisp which are so damn simple and beautiful though. As for the lisp "veteran"'s attitude one assumption would be that there is such a powerful language in his hands but so few big lisp projects that could give him the world's respect (cyc, emacs or the viaweb case coming first into my mind).This behaviour from your environment tends to make you quiet unsocial.Anyway that was only as a probable answer to your question which hasn't been true for myself. After having read the great Hyperspec from Xanalysis and all the free online books on lisp any question i made in #lisp was immediately answered by guys that i never thought i could speak with. It's insolent to demand ready food anyway.
        -- Stelios Kokkalis
      </p>
      <p>
        <em>That's the </em><a href="IfYouDontLikeItYouDontUnderstandIt.html">IfYouDontLikeItYouDontUnderstandIt</a> fallacy rearing its ugly head again.<em></em>
      </p>
      <ul>
        <li>
           It may be a fallacy, but do you know of any people who stuck with Lisp long enough to really get it but nevertheless don't like it?
        </li>
        <li>
           <em>The same question should probably be asked regarding any alleged </em><a href="GoldenHammer.html">GoldenHammer</a>. The vast majority of people are not going to live with something that rubs them wrong for years unless their employer dictates it to them and they stay on anyhow. That is not going to happen very often. <a href="UshapedGetItCurves.html">UshapedGetItCurves</a>.<em></em>
        </li>
      </ul>
      <p>
        While dislike of Lisp does not imply unfamiliarity with Lisp, perhaps it is the case that familiarity [or coding experience] with Lisp is a prerequisite for liking Lisp?  That is, If you don't understand it, you probably won't like it.
      </p>
      <hr/>
      <p>
        Lisp is for experimentation, expression and it's also powerful enough to use for the hard problems. Obviously it could do the grunt work better than the rest of the mob but who wants the kludges needed to facilitate that? Main-streaming lisp will box it. The constant yells to do so is a Lisp social problem.
      </p>
      <hr/>
      <p>
        I disagree with the above- Cl is certainly good for hard problems. It is also good for easy problems (which sometimes turn out to be not _that_ easy). What CL lacks is one of the following:
      </p>
      <ol>
        <li>
           a huge user community writing open source packages, like Perl or
        </li>
        <li>
           the backing of a huge company like Sun.
        </li>
      </ol>
      <p>
        All that's needed to do the grunt work are some good libraries, and they have been turning up a lot lately- see clsql, for instance...
      </p>
      <p>
        I'm not sure what you mean when you say above that kludges are needed to facilitate grunt work. Care to expand on that?
      </p>
      <p>
        It's also clear that CL is in fact being used for more and more grunt work all the time. For an amusing but trivial example see the source of <a href="http://www.booble.com">http://www.booble.com</a> (NotSafeForWork - it's a search engine for pornography, and it may create pop-up porn ads). Booble's meta tags list the following technologies:
      </p>
      <code>
        cmucl-19a<br/>
        cl-html-template<br/>
        CL <-> Postgres<br/>
        Emacs<br/>
      </code>
      <hr/>
      <p>
        An interesting article on a relatively well-known blog:  <a href="http://www.troutworks.com/Timlog/timlog.php?y=2002&m=11&d=12">http://www.troutworks.com/Timlog/timlog.php?y=2002&m=11&d=12</a>
      </p>
      <hr/>
      <p>
        And another, referencing this page, on the Lisp blog LemonOdor:  <a href="http://lemonodor.com/archives/000902.html#comments.">http://lemonodor.com/archives/000902.html#comments.</a> It ain't too friendly to the content of this page. :)
      </p>
      <hr/>
      <p>
        Just had to share this from comp.lang.lisp. A Lisp novice asked for advice on writing a simple function, and got several answers showing different ways to do it, some very extensively describing the reasoning process. Also, the usual complement of commentary on the solutions offered. The original poster then wrote this:
      </p>
      <code>
        Thanks a lot for your hints and explanations. They were way more than<br/>
        I was hoping for! I haven't quite gotten a firm grasp of what you<br/>
        wrote, but I'm going to study up on them this weekend. I'm guessing<br/>
        you'll be hearing more from me in the immediate future since this is<br/>
        such a good resource for beginners like myself. Thanks again!<br/>
      </code>
      <p>
        Obviously, the poor fellow hasn't read this page. If only he knew...
      </p>
      <p>
        And that gave me an idea...
      </p>
      <p>
        According to Google, the phrases "thanks a lot" or "thank you very much" appeared in about 360 messages from beginning of the year 2000 to now (mid-September 2004). The words "twit", "idiot", or "jerk" appeared in about 310 messages in the same period. These numbers are provided for amusement only.
      </p>
      <hr/>
      <p>
        <a href="NewLisp.html">NewLisp</a> users have some social problems, too: <a href="http://www.alh.net/newlisp/phpbb/viewtopic.php?t=1630">http://www.alh.net/newlisp/phpbb/viewtopic.php?t=1630</a>
      </p>
      <p>
        Not very smug, but very psycho-weenie.
      </p>
      <hr/>
      <p>
        A good index of the <a href="SocialProblemsOfLisp.html">SocialProblemsOfLisp</a> actually is to compare the Lisp communities with the <a href="HaskellLanguage.html">HaskellLanguage</a> community, which, IMHO, has managed to dodge the biggest social problems dogging Lisp and Scheme.  
      </p>
      <hr/>
      <p>
        I am the developer of a language that looks a lot like pseudo code. It compiles to byte code which looks very similar to the source code of Lisp. This statement on the surface seems to validate the claim that Lisp is the universal language but I think it suggests the opposite. The simple syntax of Lisp makes writing a compiler (not the libraries) for Lisp extremely easy. If fact a simple Lisp compiler was printed on a single page in some early Lisp publication. It is absolutely correct that Lisp syntax is easily translated for the computer but is it great for humans? I believe that source code should be good for the programmer and produce exacting code for the computer. If some people want to use their mind to compile their program, good for them, but I would prefer that the compiling was done by the compiler, rather than me.
      </p>
      <p>
        A great thing about Lisp is that it has great extensibility but Lisp's biggest problem is that it can be easily extended! When a group of people learn a language, they can communicate using commonly known constructs. They can also make custom code but that code uses "sets" of commonly known constructs. There is nothing wrong with extending the functionality of a language but it should be done in a way that shows a programmer what is the "commonly known" code and what they have created themselves. In Lisp, it is difficult to even see the "structure" of the program. Where is the "looping", "conditions" etc? I know that Lisp has all these things (structure) but they aren't obvious to me. I love the idea of Lisp's "compile time" macros and I am implementing them in my language as well. This is a great mechanism for creating small DSL modules inside your code.
      </p>
      <p>
        Some people, smart or otherwise, might have trained their brain to overcome the intrinsic deficiencies of Lisp syntax but calling Lisp a good language or the "mother of all languages" flies in the face of reality.
      </p>
      <p>
        The mother of all languages is assembler, not Lisp. Who would say that after the invention of Assembler, all other languages have no merit?  -- <a href="DavidClarkd.html">DavidClarkd</a>
      </p>
      <hr/>
      <p>
        The Bipolar Aspects of Lisp:
      </p>
      <p>
        <a href="http://www.lambdassociates.org/blog/bipolar.htm">http://www.lambdassociates.org/blog/bipolar.htm</a>
      </p>
      <hr/>
      <p>
        See: <a href="LispIsTooPowerful.html">LispIsTooPowerful</a>
      </p>
      <p>
        <a href="CategoryLisp.html">CategoryLisp</a>
      </p>
    </div>
  </body>
</html>