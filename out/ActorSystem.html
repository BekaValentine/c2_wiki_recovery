<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Actor System
      </h1>
      <code>
        <strong><em>Description</em></strong><br/>
      </code>
      <p>
        Actor systems are a line of research by <a href="CarlHewitt.html">CarlHewitt</a> (a professor in the AI laboratory at MIT) in the seventies. There is an alternative <a href="ThreadMode.html">ThreadMode</a> page on this Wiki using the (historically perhaps less accurate) <a href="ActorsModel.html">ActorsModel</a> moniker.
      </p>
      <p>
        Actor systems are based on a <a href="ModelOfComputation.html">ModelOfComputation</a> involving collections of self contained <em>actors</em>, which are entities with the following characteristics:
      </p>
      <ul>
        <li>
           A unique identity for each actor.
        </li>
      </ul>
      <ul>
        <li>
           A list of identities of other actors it can interact with, called its <em>acquaintances</em>.
        </li>
      </ul>
      <ul>
        <li>
           A <em>script</em> that drives the behaviour of the actor, which involves constructing and sending <em>messages</em> (themselves actors) to its acquaintances, and receiving, examining and processing messages received from other actors.
        </li>
      </ul>
      <p>
        Computation then proceeds as a pattern of message exchanges among actors.
      </p>
      <code>
        <strong><em>Motivation</em></strong><br/>
      </code>
      <p>
        This model of computation maps well onto <strong>fine grained</strong> massively parallel, distributed computer systems, because there is no shared state, and maximum concurrently is allowed in the message passing patterns.
      </p>
      <p>
        Hewitt envisaged that a possible evolutionary path of computer systems was indeed as chips and boxes containing very large numbers of simple general purpose processors.
      </p>
      <p>
        Part of the research involved for example concept like greedy, speculative execution, and the consequent need to garbage collection of processes.
      </p>
      <code>
        <strong><em>Evolution</em></strong><br/>
      </code>
      <p>
        However, so far the dominant evolutionary path of computer systems has been towards even more complex and faster single processor systems for which the more conventional procedural <a href="ModelOfComputation.html">ModelOfComputation</a> is more suitable.
      </p>
      <p>
        Therefore <a href="ActorSystem.html">ActorSystem</a> research is somewhat obscure, and mainly of historical interest except that early variants of <a href="SmallTalk.html">SmallTalk</a> were strongly influenced by it, as <a href="AlanKay.html">AlanKay</a> worked with Carl Hewitt, and from there <a href="ActorSystem.html">ActorSystem</a> terminology, in particular <a href="MessagePassing.html">MessagePassing</a>, entered the OO mainstream in a somewhat pervasive way.  This is why Smalltalk refers to message calls as <em>sending messages</em>, even though Smalltalk-80 "messages" have synchronous (blocking-the-caller) semantics similar to function/method calls in most other maintstream procedural and OO languages.  
      </p>
      <p>
        While it is very natural to write programs for <a href="ActorSystem.html">ActorSystem</a> computational engines using <a href="ObjectOriented.html">ObjectOriented</a> decomposition, in particular its prototype oriented variant, almost all <a href="ObjectOriented.html">ObjectOriented</a> languages and programs are based on the procedural model of computation, and also are class oriented rather than prototype oriented, and the conflation of <a href="ActorSystem.html">ActorSystem</a> terminology and concepts with those of <a href="ObjectOriented.html">ObjectOriented</a> programming has lead to much confusion.
      </p>
      <p>
        There is some speculation that the growth of single processor performance has hit some limits and that fine grained, massively parallel distributed systems  are therefore the way of the future, and this may lead to a resurgence of interest in the <a href="ActorSystem.html">ActorSystem</a> model of computation.
      </p>
      <code>
        <strong><em>Pointers</em></strong><br/>
      </code>
      <ul>
        <li>
           Alternate <a href="ThreadMode.html">ThreadMode</a> page: <a href="ActorsModel.html">ActorsModel</a>
        </li>
        <li>
           <a href="ActorLanguages.html">ActorLanguages</a>
        </li>
        <li>
           A site dedicated to actor systems: <a href="http://www.dekorte.com/docs/actors/">http://www.dekorte.com/docs/actors/</a>
        </li>
        <li>
           History of actor research up to 1993: <a href="ftp://sail.stanford.edu/pub/MT/93actors.ps.Z">ftp://sail.stanford.edu/pub/MT/93actors.ps.Z</a>
        </li>
        <li>
           Page about the main original actor languages: <a href="http://hopl.murdoch.edu.au/showlanguage.prx?exp=3346">http://hopl.murdoch.edu.au/showlanguage.prx?exp=3346</a>
        </li>
        <li>
           Advocacy of ACT-1, a later actor language: <a href="http://agents.www.media.mit.edu/people/lieber/Lieberary/OOP/Act-1/Concurrent-OOP-in-Act-1.html">http://agents.www.media.mit.edu/people/lieber/Lieberary/OOP/Act-1/Concurrent-OOP-in-Act-1.html</a>
        </li>
        <li>
           A very recent (2004) actor language and system simulator: <a href="http://www.ncc.up.pt/tyco/">http://www.ncc.up.pt/tyco/</a>
        </li>
        <li>
           The Free Lunch Is Over (why no 10GHz today): <a href="http://www.gotw.ca/publications/concurrency-ddj.htm">http://www.gotw.ca/publications/concurrency-ddj.htm</a>
        </li>
      </ul>
      <p>
        -- Blissex 040505
      </p>
    </div>
  </body>
</html>