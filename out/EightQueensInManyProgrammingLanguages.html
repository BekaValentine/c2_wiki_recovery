<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Eight Queens In Many Programming Languages
      </h1>
      <p>
        From <a href="EightQueensProblem.html">EightQueensProblem</a>.
      </p>
      <p>
        Another fun toy problem for quickly showing off language features. Summary: how may ways can you place eight queens on a chessboard such that no queens are attacking each other?
      </p>
      <ul>
        <li>
           <em>Extra credit: solve for arbitrary square board sizes.</em>
        </li>
        <li>
           <em>Extra credit: log the solutions found.</em>
        </li>
        <li>
           <em>Extra credit: only count solutions unique through reflection, transposition, and rotation.</em>
        </li>
        <li>
           <em>Triple credit: solve for 3-D Chessboard </em><a href="http://www.chessvariants.com/3d.dir/startrek.html''">http://www.chessvariants.com/3d.dir/startrek.html''</a>
        </li>
        <li>
           <em>Extra credit: Make a queen program in </em><a href="InterCal.html">InterCal</a>.<em></em>
        </li>
      </ul>
      <p>
        Someone pointed to an analysis and <a href="CeeLanguage.html">CeeLanguage</a> solution for this on the main <a href="EightQueensProblem.html">EightQueensProblem</a> page.
      </p>
      <hr/>
      <p>
        The name of this page is misleading. The solutions here shown solve the N-queens problem, not just the <a href="EightQueensProblem.html">EightQueensProblem</a>. However:
      </p>
      <ul>
        <li>
           that's because everyone was going for extra credit
        </li>
        <li>
           "eight queens" is the more widely used phrase (seen any non-8x8 chess boards lately?),
        </li>
        <li>
           there's no essential difference between 8 and N, so it doesn't matter,
        </li>
        <li>
           there was no N-queens problem page at the time this page was created.
          <ul>
            <li>
               Plus it's (paradoxically) sometimes easier to solve a slightly more general problem than the one you are focused on. 
            </li>
            <li>
               ... although the C bitboard entry <em>would</em> be hard to extend to more than 8x8 boards.
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <ul>
        <li>
           <a href="EightQueensProblemInRuby.html">EightQueensProblemInRuby</a>
        </li>
        <li>
           <a href="EightQueensProblemInSmalltalk.html">EightQueensProblemInSmalltalk</a>
        </li>
      </ul>
      <hr/>
      <p>
        <strong></strong><a href="SmlLanguage.html">SmlLanguage</a><strong></strong>
      </p>
      <code>
        (*<br/>
      </code>
      <ul>
        <li>
           This was mainly written to show that efficient bit manipulation isn't
        </li>
        <li>
           the exclusive right of C. There are more concise ways to count
        </li>
        <li>
           n-queens in SML.
        </li>
      </ul>
      <code>
        *<br/>
      </code>
      <ul>
        <li>
           To compile and run:
        </li>
        <li>
           1. Install MLton (see <a href="http://mlton.org/)">http://mlton.org/)</a>
        </li>
        <li>
           2. Save this code as "numQueens.sml".
        </li>
        <li>
           3. Go to the directory where you saved "numQueens.sml".
        </li>
        <li>
           3. Compile: mlton numQueens.sml
        </li>
        <li>
           4. Run: ./numQueens 16
        </li>
        <li>
          )
        </li>
      </ul>
      <code>
        open Word infix 2 andb infix 1 orb infix 0 << >><br/>
      </code>
      <code>
        val (w2s, s2w) = (Int.toString o toIntX, fromInt o valOf o Int.fromString)<br/>
      </code>
      <code>
        fun nQs m =<br/>
        let fun search (lb, cb, rb, cnt) =<br/>
        if ~ 0w1 = cb then cnt+0w1<br/>
        else let fun lp (bs, cnt) =<br/>
        if ~ 0w1 = bs then cnt<br/>
        else case notb bs andb bs+0w1 of<br/>
        b => lp (bs orb b,<br/>
        search (lb orb b << 0w1, cb orb b,<br/>
        rb orb b >> 0w1, cnt))<br/>
        in lp (lb orb cb orb rb, cnt)<br/>
        end<br/>
        in search (0w0, ~ 0w1 >> m, 0w0, 0w0)<br/>
        end<br/>
      </code>
      <code>
        val m = min (fromInt wordSize, s2w (hd (<a href="CommandLine.html">CommandLine</a>.arguments ()))<br/>
        handle _ => ~ 0w1)<br/>
        fun lp n = if m < n then ()<br/>
        else (app print [w2s n, ": ", w2s (nQs n), " total solutions\n"]<br/>
        ; lp (n+0w1))<br/>
        val () = lp 0w1<br/>
      </code>
      <p>
        Below run was done on my 1.6GHz Pentium M laptop:
      </p>
      <code>
        $ time ./numQueens 16<br/>
      </code>
      <ol>
        <li>
          : 1 total solutions
        </li>
        <li>
          : 0 total solutions
        </li>
        <li>
          : 0 total solutions
        </li>
        <li>
          : 2 total solutions
        </li>
        <li>
          : 10 total solutions
        </li>
        <li>
          : 4 total solutions
        </li>
        <li>
          : 40 total solutions
        </li>
        <li>
          : 92 total solutions
        </li>
        <li>
          : 352 total solutions
        </li>
        <li>
          : 724 total solutions
        </li>
        <li>
          : 2680 total solutions
        </li>
        <li>
          : 14200 total solutions
        </li>
        <li>
          : 73712 total solutions
        </li>
        <li>
          : 365596 total solutions
        </li>
        <li>
          : 2279184 total solutions
        </li>
        <li>
          : 14772512 total solutions
        </li>
      </ol>
      <code>
        real    0m26.547s<br/>
        user    0m26.491s<br/>
        sys     0m0.003s<br/>
      </code>
      <p>
        It is <a href="FasterThanCee.html">FasterThanCee</a> (at least until the C folks get their act together).
      </p>
      <p>
        <em>Nope. You used a faster algorithm than anyone else on this page did. It is well-known that there's a big difference between the obvious algorithms and the fastest known algorithms. You're comparing apples and oranges, and the result just tells us what we already knew, which is that the fast algorithms are faster than the obvious algorithms. Try again with the obvious algorithm.</em>
      </p>
      <p>
        Actually there are several programs (in various languages) on this page that use essential the same algorithm (as my SML version). To me, this algorithm was obvious. Why implement a slow algorithm in C when you can just as easily implement faster algorithms in higher level languages?
      </p>
      <p>
        <em>In my case, because I had a personal interest in the smallest number of lines of code, but that's fine, use whatever algorithm you like -- but the conclusion is that it is the </em>'algorithm<em>' that is faster, not the language.</em>
      </p>
      <p>
        The C version already uses a very different representation of search state (bit vector), as well as a different search algorithm (DFS), compared to some of the other solutions (e.g. Haskell uses lists and the order of evaluation order of Haskell code isn't fixed). You've been comparing apples and oranges long before I came along.
      </p>
      <p>
        <em>SML and some other languages are in fact sometimes faster than C, using the same algorithm, but you'll never know without a head-to-head comparison.</em>
      </p>
      <p>
        Why don't you just rewrite the C version instead of bitching and moaning?  The better algorithm will, most likely, be even shorter than the current one (speaking of the C version). And I would be surprised if it wasn't AsFastAsSml.
      </p>
      <p>
        Also, it is a category mistake to say that a language is faster/slower than some other language.
      </p>
      <p>
        <em>True.</em>
      </p>
      <p>
        <em>I don't see how to use a better algorithm </em>'and<em>' be even shorter; why do you think that's possible?</em>
      </p>
      <p>
        There is no fundamental reason why a better algorithm would need to be longer. However, the reason why I think that it is possible, in this case, is that I can visualize how the code will roughly look like (I've written hundreds of thousands of lines of C and C++ code over the years). Geez, do I really have to do everything?
      </p>
      <code>
        #include <stdio.h><br/>
        #include <stdlib.h><br/>
        #include <limits.h><br/>
      </code>
      <code>
        typedef unsigned long ulong;<br/>
      </code>
      <code>
        static const ulong ulong_bit = sizeof(ulong) * CHAR_BIT;<br/>
      </code>
      <code>
        static inline ulong search(ulong lb, ulong cb, ulong rb, ulong cnt) {<br/>
        if (~0ul == cb)<br/>
        cnt += 1;<br/>
        else<br/>
        for (ulong bs = lb | cb | rb; ~0ul != bs;) {<br/>
        ulong b = ~bs & (bs+1);<br/>
        bs |= b;<br/>
        cnt = search((lb | b) << 1, cb | b, (rb | b) >> 1, cnt);<br/>
        }<br/>
        return cnt;<br/>
        }<br/>
      </code>
      <code>
        static inline ulong nQs(ulong m) { return search(0, ~0ul >> m, 0, 0); }<br/>
      </code>
      <code>
        int main(int argc, char* argv[]) {<br/>
        ulong a = argc < 2 ? ulong_bit : atol(argv[1]);<br/>
        ulong n = a < ulong_bit ? a : ulong_bit;<br/>
        for (ulong i=1; i<=n; ++i)<br/>
        printf("%li: %li total solutions\n", i, nQs(i));<br/>
        return 0;<br/>
        }<br/>
      </code>
      <p>
        Unsurprisingly, it is faster on my laptop (at least when compiled on gcc 4.0.3 with -O2 or -O3) than the MLton compiled SML version. Happy now? ;-)
      </p>
      <hr/>
      <p>
        <strong></strong><a href="CeeLanguage.html">CeeLanguage</a> -- tiny<strong></strong>
      </p>
      <p>
        This version attempts very short source code (for C, that is), and is just about the same length as the Lisp version below, which I will call a moral victory for a C program :-) It uses bit vectors for simplicity and speed -- valid up to the bit word length of the machine (e.g. 32x32 on a 32 bit machine).
      </p>
      <p>
        It cranked out the solution to all boards up to 14x14 in 3.3 seconds, and to 15x15 in 21 seconds, whereas other language solutions went up to only 12x12 or 13x13 (presumably due to speed issues) so that seems reasonably fast. 2Ghz Athlon cpu. See <a href="AsFastAsCee.html">AsFastAsCee</a> ;-) -- <a href="DougMerritt.html">DougMerritt</a>
      </p>
      <code>
        inline int calcDiag1Bit(int max, int row, int col) { return 1 << (max-col-row); }<br/>
        inline int calcDiag2Bit(int max, int row, int col) { return calcDiag1Bit(max, row, max-col); }<br/>
        int solve(int max, int solutions, int *rowsUsed, int row, int col, int allCols,<br/>
        int diag1, int diag2) {<br/>
        int rowBit, colBit, diag1bit, diag2bit;<br/>
        for (col=0; col<max; col++) {<br/>
        if (allCols & (colBit=(1 << col))) continue;<br/>
        if (diag1 & (diag1bit=calcDiag1Bit(max, row, col))) continue;<br/>
        if (diag2 & (diag2bit=calcDiag2Bit(max, row, col))) continue;<br/>
        rowsUsed[row] = col;<br/>
        if (row >= (max-1))<br/>
        ++solutions;<br/>
        else<br/>
        solutions = solve(max, solutions, rowsUsed, row+1, col,<br/>
        allCols|colBit, diag1|diag1bit, diag2|diag2bit);<br/>
        }<br/>
        rowsUsed[row] = -1;<br/>
        return solutions;<br/>
        }<br/>
        int main() {<br/>
        int     i, solutions, rowsUsed[32];<br/>
        for (i=0; i<32; i++)<br/>
        rowsUsed[i] = -1;<br/>
        for (i=1; i<15; i++) {<br/>
        solutions = solve(i, 0, rowsUsed, 0, 0, 0, 0, 0);<br/>
        printf("%d: %d total solutions\n", i, solutions);<br/>
        }<br/>
        }<br/>
      </code>
      <p>
        Output:
      </p>
      <ol>
        <li>
          : 1 total solutions
        </li>
        <li>
          : 0 total solutions
        </li>
        <li>
          : 0 total solutions
        </li>
        <li>
          : 2 total solutions
        </li>
        <li>
          : 10 total solutions
        </li>
        <li>
          : 4 total solutions
        </li>
        <li>
          : 40 total solutions
        </li>
        <li>
          : 92 total solutions
        </li>
        <li>
          : 352 total solutions
        </li>
        <li>
          : 724 total solutions
        </li>
        <li>
          : 2680 total solutions
        </li>
        <li>
          : 14200 total solutions
        </li>
        <li>
          : 73712 total solutions
        </li>
        <li>
          : 365596 total solutions
        </li>
      </ol>
      <p>
        A later run revealed 2279184 solutions for a 15x15 board in 21 seconds, 14772512 solutions for a 16x16 board in 3 min 13 sec.
      </p>
      <p>
        <em>While I agree that this is a *concise* solution for the C language, it has a flaw: premature optimization. By concentrating on bit-fiddling instead of algorithms, you can fall into the classic trap; The result here is that this code is actually quite slow because it uses a somewhat poor algorithm. By comparison, I have some optimized C code that will do the 15x15 case in 8 seconds on a 500Mhz P3, so more than an order of magnitude gain (I will try and dig up a link for this, it isn't my code). So I guess if your goal is to write the shortest C version you can, you are part way there --- but if you want the fastest there is a lot of room for improvement.</em>
      </p>
      <p>
        Disagree; the primary motivation for everything was to be concise, including the bit twiddling: it allows testing of many values in parallel, which makes the code significantly shorter than if those values were in an array. 
      </p>
      <p>
        Secondarily I tried to avoid slowing it down unnecessarily, so there were various small things I did, such as throwing in "inline" declarations. This isn't premature optimization, because I was already committed to the algorithm at that point. To my mind, there's a big difference between avoiding pessimizing and actual optimization, because a tiny amount of pessimization avoidance isn't subject to the same critique that premature optimization is.
      </p>
      <p>
        I wasn't attempting the absolute fastest possible C solution, just a reasonably fast one, but I would be interested in seeing yours.
      </p>
      <p>
        However, note that your arithemetic is off...that would be 3.5 times faster than my second claim of 28 seconds, not "an order of magnitude". That was a typo; my first claim further up above is correct: 21 seconds, so that's 2.6 times faster. (I've now fixed both figures to be "21".)
      </p>
      <ul>
        <li>
           Oops...you said 500Mhz. Well, post it and I'll see what it's like on my Athlon, which may or may not actually be 4 times faster for this application.
        </li>
      </ul>
      <p>
        I would think that a very small algorithm that's within a factor of 2 in speed of the (let's assume) fastest possible but much longer algorithm is not bad at all.
      </p>
      <p>
        <em>You also need to account for the order of growth of each algorithm. For instance, comparing the number of inner loops of the first two </em><a href="ForthLanguage.html">ForthLanguage</a> entries as N goes from 8 to 12, the first method does 4.3x, 4.4x, 4.8x, and 5.2x times more work for successive N, but the second method (like the Haskell entry) does 5.2x, 5.3x, 5.7x, and 6.1x more work as N increases. No matter how much more optimized the second program is, there will be an N where the first method eventually surpasses it.<em></em>
      </p>
      <p>
        Anyway, those are all side issues; a concise expression was my primary goal, and I'm fairly happy with the result. I know bit twiddling has a bad reputation, but personally I think it is quite elegant in this particular solution.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="LispLanguage.html">LispLanguage</a><strong></strong>
        There are several variants of this problem. Here is some Lisp code to generate a list of all solutions for a given board size (i.e. and n-Queens problem). Solutions are represented by lists of (row . col) pairs. This can probably be improved quite a bit.
      </p>
      <code>
        (defun n-queens (dimension)<br/>
        (macrolet ((row (x) `(car ,x))<br/>
        (col (x) `(cdr ,x)))<br/>
        (labels ((in-threat (pos1 pos2)<br/>
        (or (= (row pos1) (row pos2)) (= (col pos1) (col pos2))<br/>
        (= (- (row pos1) (col pos1)) (- (row pos2) (col pos2)))<br/>
        (= (+ (row pos1) (col pos1)) (+ (row pos2) (col pos2)))))<br/>
        (test-pos (pos1 partial-soln)<br/>
        (dolist (pos2 partial-soln t)<br/>
        (when (in-threat pos1 pos2)<br/>
        (return nil))))<br/>
        (all-cols (row) (loop for col below dimension collecting (cons row col))))<br/>
        (do ((row 1 (1+ row))<br/>
        (candidates (all-cols 1)) <br/>
        (solns (mapcar #'list (all-cols 0))))          <br/>
        ((>= row dimension) (mapcar #'nreverse solns))<br/>
        (setf candidates  (all-cols row)<br/>
        solns (loop for soln in solns<br/>
        for res = (loop for pos in candidates<br/>
        when (test-pos pos soln)<br/>
        collect (cons pos soln))<br/>
        unless (null res)<br/>
        append res))))))<br/>
      </code>
      <p>
        Mirroring the below table:
      </p>
      <code>
        CL-USER> (dotimes (n 14) (format t "The ~A-queens problem has ~A solutions.~%" n (length (n-queens n))))<br/>
        The 0-queens problem has 0 solutions.<br/>
        The 1-queens problem has 1 solutions.<br/>
        The 2-queens problem has 0 solutions.<br/>
        The 3-queens problem has 0 solutions.<br/>
        The 4-queens problem has 2 solutions.<br/>
        The 5-queens problem has 10 solutions.<br/>
        The 6-queens problem has 4 solutions.<br/>
        The 7-queens problem has 40 solutions.<br/>
        The 8-queens problem has 92 solutions.<br/>
        The 9-queens problem has 352 solutions.<br/>
        The 10-queens problem has 724 solutions.<br/>
        The 11-queens problem has 2680 solutions.<br/>
        The 12-queens problem has 14200 solutions.<br/>
        The 13-queens problem has 73712 solutions.<br/>
      </code>
      <p>
        Interpreted (not compiled) in GNU Clisp, it took 70 seconds to solve up to 11x11 on a 2Ghz Athlon.
      </p>
      <p>
        <em>This is pretty unfair to lisp, since uncompiled is very unusual, and the above code is (intentionally) not optimized. It is much easier to follow that the bit-fiddling approach (which could also be done in lisp, of course). Furthermore, the lisp actually constructs and reports each solution in an easily readable form. I haven't done it, but from experience with similar things, i expect within a factor of 2x the above c shoudln't be difficult. Probably while maintaining the much more readable/maintainable structure of the lisp code. By the way of somewhat useless comparison, the above code is more than 10x faster by merely compiling it with cmucl, no optimizations (or declarations) at all.</em>
      </p>
      <p>
        There's nothing unfair about it; I was very careful to say "Interpreted (not compiled)", so that no one would be mislead.
      </p>
      <p>
        The rest of your bitching and moaning should simply be replaced with a report on how fast it runs when compiled -- obviously it will be much faster. I would have compiled it myself, except I misplaced my cmucl executable when doing rebuilds from source recently.
      </p>
      <p>
        As for the tradeoff between one algorithm and another in terms of readability and speed, yes, that's always an issue, in every language. I think that bit twiddling is overly maligned, though, because sometimes its compactness improves readability over a longer non-twiddling algorithm. Sometimes.
      </p>
      <p>
        <em>I think `bitching and moaning' is a bit much. I was trying to make two points: First, that this was an apples and oranges comparison (the algorithms don't do the same thing, and only one of them has been optimized). And second, there is (for whatever reason) a common misconception in the programming world that Lisp is interpreted or byte-compiled. With another language, I probably would have just left your comment as it stands --- however, many people seem to be quite surprised by the fact that the normal case for lisp is to generate native machine code (and pretty efficient code at that). You are quite right about the tradeoffs, sometimes bit fiddling is the thing to do (I did mention that you could do this in lisp as well), but this isn't a good example. In this case, it certainly has reduced the readability/maintainability without approaching optimal performance. If our goal is to write the fastesd n-queens routine we can, then it may be the proper approach to use low-level techniques (although at that point, asm might be the way to go also) but only *after* algorithm analysis. See comments above.</em>
      </p>
      <p>
        Agreed -- largely. But do note that all I was doing was running the existing language samples to add timings; clearly this is not a scientific way to thoroughly compare the speeds of the languages concerned (which is difficult to do), but it isn't a meaningless thing to do either. It adds information that the original authors left out, that's all. 
      </p>
      <p>
        <em>I think it was left out because it wasn't particularly interesting. Now we seem to have started a conversation about "opimizing n-queens".</em>
      </p>
      <ul>
        <li>
           Well...I have to admit that the many comments that "my favorite language will be faster than C reall soon now" irritate me, and that was in the back of my mind when I started timing. The thing about C is that although it's not very modern, it is missing many features, it is bug prone, hard to write highly readable programs, etc, on the other hand, it does tend to be fast. :-) Often that doesn't matter, but sometimes it does, and 8 queens actually is an instance where it does matter, because it is infeasible to find solutions for N > threshold, partly just depending on the language.
        </li>
      </ul>
      <p>
        Oh, wait...you're saying my bit twiddling reduced readability/maintainability? No, I disagree. Bit manipulation is idiomatic in C, you can't just condemn it outright. Any experienced C programmer will have no troubles.
      </p>
      <p>
        I wouldn't do that in Smalltalk or Lisp, because they have different idioms. But idioms and idiom guidelines do not, in general, cross language boundaries.
      </p>
      <p>
        <em>I actually know C a lot better than Lisp; your C solution is not a particularly readable C. And note that nowhere did I condemn bit-twiddling outright; I often use it myself where it is appropriate. Your solution isn't terrible, and comments would address some of this (it certainly isn't heading into the domain of IOCC). The algorithm used in the lisp version is not at all optimal, but very easy to understand. Not true for your algorithm, whether in C or in Lisp. I understand what you did and why, but I can't take seriously a claim that the C code is equivalently readable (for someone versed in both languages, of course). So you see my point was not about idiomatic C vs. idiomatic Lisp, but more about simple algorithms clearly presented vs. speed hacks that are harder to understand and verify. There are places for both (but the second should *always* be avoided unless and until it has been shown to be necessary). You are right about the difficulty of comparing languages. In order to do that, we would have to compare the same algorithms, probably two of them: one for speed of execution (and then you are really comparing compilers) and one for generality (for example, implement the algorithm shown in lisp in C). One nice thing about the lisp version is that it took about 5 minutes to write and verify (the only 'error' was I hadn't thought to reverse the solutions at the end, but that was really aesthetic). I doubt I could have written the C version that fast.</em>
      </p>
      <p>
        Nor I. That's one of the nice things about Lisp. But although the Lisp version is more readable than my C version, that's apples to oranges. IMHO my C version is more readable than the original C version below; the only thing in mine that is difficult is the mapping from (row,column) to a bit vector -- but bit twiddling is normal in C, so there's tons of it in the original below. You're complaining about my bit twiddling? By C standards, I <strong>minimized</strong> the amount of it. ;-)
      </p>
      <p>
        ["Tastes great! ...Less filling!" ;) One person's inscrutible hack is another's idiom. As with all writing, code and comments should be targeted at the audience. In this case, probably the casual programmer who wants to see how different languages attack problems in different ways. Perhaps the person is shopping for a new language. But that audience is likely neither expert in the problem domain nor the languages involved, so the comments should be detailed in both regards. Personally, I don't think <em>any</em> of the code on this page (or the other language comparison pages) is commented anywhere near well enough for that audience. Personally (C: fluent, Lisp: literate), neither the Lisp nor the tiny C is transparent enough to stand without commentary. It seems that most contributors are more concerned with showing off how few lines/words/characters they can use to solve a problem than how readable their code ends up to the lay programmer. -- <a href="IanOsgood.html">IanOsgood</a>  (P.S. Of course my own Forth and C entries are perfectly transparent! *ahem* ;) Seriously, I gladly welcome constructive criticism of the clarity of my code.]
      </p>
      <p>
        <em>Ian, I find your comments interesting. I was not going for brevity with the Lisp solution, it was just a one-pass implementation of one fairly obvious algorithm for this. I would have thought that if you a) understand the problem and b) are Lisp literate, then that solution would pretty much stand on its own (although I could have/should have added a couple of comments about the candidates loop). It seems I was wrong! Certainly the code on  a page like this shouldn't duplicate comments about the problem itself...</em>
      </p>
      <p>
        [Well, perhaps Lisp semi-literate. I mostly learned through implementing the language in the eighties, and know little about macros, 'when', 'unless', and other new-fangled stuff. (All right, call me Lisp illiterate or archaic even. Maybe I should put <a href="LispMe.html">LispMe</a> on my toy next to <a href="QuartusForth.html">QuartusForth</a> so I can do some brushing up.)]
      </p>
      <p>
        <em>Ah, ok I see then. Lisp, without quantifiers, means </em><a href="CommonLisp.html">CommonLisp</a> these days and so the unfamiliar elements for you are actually standard and idiomatic. LispME is, in fact a scheme implemementation, so while it would be fun to play with it won't help you get used to standard lisp :)<em></em>
      </p>
      <hr/>
      <p>
        Speaking of Scheme... <strong></strong><a href="SchemeLanguage.html">SchemeLanguage</a><strong></strong>
      </p>
      <p>
        <em>I wrote this to help me learn Scheme. It's entirely unoptimized, and I focused on readability instead of terseness. If you can make it better, please do.</em>
      </p>
      <code>
        (define (make-queen row col) (list row col))<br/>
        (define (get-row queen) (car queen))<br/>
        (define (get-col queen) (cadr queen))<br/>
      </code>
      <code>
        (define (same-row? nq oq) (= (get-row nq) (get-row oq)))<br/>
        (define (same-col? nq oq) (= (get-col nq) (get-col oq)))<br/>
        (define (same-diag? nq oq)<br/>
        (= (abs (- (get-row nq) (get-row oq)))<br/>
        (abs (- (get-col nq) (get-col oq)))))<br/>
      </code>
      <code>
        (define (attacks? nq oq)<br/>
        (or (same-row? nq oq) (same-col? nq oq) (same-diag? nq oq)))<br/>
      </code>
      <code>
        (define (safe? target queens)<br/>
        (cond ((null? queens) #t)<br/>
        ((attacks? target (car queens)) #f)<br/>
        (else (safe? target (cdr queens)))))<br/>
      </code>
      <code>
        ; Solve for a board size of sz.<br/>
        (define (solve sz)<br/>
        (define (s-rec sz x y pos sols)<br/>
        (cond <br/>
        ; If we've advanced past the last column, we have a solution.<br/>
        ; (By the way, the reverse is because pos is built up backward.)<br/>
        ((> x sz) (cons (reverse pos) sols))<br/>
        ; If we've advanced past the last row, we have a failure.<br/>
        ((> y sz) sols)<br/>
        ; If the queen is safe, the fun begins.<br/>
        ((safe? (make-queen x y) pos)<br/>
        ; This is the backtracking call. This is executed once<br/>
        ; the inner call is complete.<br/>
        (s-rec sz x (+ y 1) pos<br/>
        ; Run the next column first; if any solutions<br/>
        ; result, they need to be passed to the backtracked<br/>
        ; call.<br/>
        (s-rec sz (+ x 1) 1<br/>
        ; Add this queen when considering the next<br/>
        ; column's placement.<br/>
        (cons (make-queen x y) pos)<br/>
        sols)))<br/>
        ; If this queen isn't safe, move on to the next row.<br/>
        (else (s-rec sz x (+ y 1) pos sols))))<br/>
        ; Start the recursion.<br/>
        (s-rec sz 1 1 '() '()))<br/>
      </code>
      <code>
        (define (show-queens n)<br/>
        (display (list "The" n "queens problem has"<br/>
        (length (solve n))<br/>
        "solutions."))<br/>
        (newline))<br/>
      </code>
      <p>
        Results:
      </p>
      <code>
        > (for-each show-queens '(1 2 3 4 5 6 7 8 9 10 11))<br/>
        (The 1 queens problem has 1 solutions.)<br/>
        (The 2 queens problem has 0 solutions.)<br/>
        (The 3 queens problem has 0 solutions.)<br/>
        (The 4 queens problem has 2 solutions.)<br/>
        (The 5 queens problem has 10 solutions.)<br/>
        (The 6 queens problem has 4 solutions.)<br/>
        (The 7 queens problem has 40 solutions.)<br/>
        (The 8 queens problem has 92 solutions.)<br/>
        (The 9 queens problem has 352 solutions.)<br/>
        (The 10 queens problem has 724 solutions.)<br/>
        (The 11 queens problem has 2680 solutions.)<br/>
      </code>
      <hr/>
      <p>
        <strong></strong><a href="CeeLanguage.html">CeeLanguage</a><strong></strong>
      </p>
      <code>
        /* 8 Queens problem, bitboard approach */<br/>
        #include <stdio.h><br/>
      </code>
      <code>
        typedef unsigned long long BitBoard;  // 64 bits for an 8x8 chess board<br/>
      </code>
      <code>
        void print_board(BitBoard b)  // top left is rank 0, file 0<br/>
        {<br/>
        int r,f;<br/>
        for (r=0; r<8; r++) {<br/>
        for (f=0; f<8; f++, b>>=1) {<br/>
        putchar( ' ' );<br/>
        putchar( (b&1) ? 'Q' : '.' );<br/>
        }<br/>
        putchar('\n');<br/>
        }<br/>
        putchar('\n');<br/>
        }<br/>
      </code>
      <code>
        /* masks for eliminating possible queen positions from future tries */<br/>
        /* they are indexed by rank (then shifted by file) */<br/>
      </code>
      <code>
        BitBoard attacks[8] = {<br/>
        ~0x81412111090503ffLL,   // 00000000  (bit pattern for attacks[0]<br/>
        ~0x412111090503ff03LL,   // 00111111   in the order shown by print_board)<br/>
        ~0x2111090503ff0305LL,   // 01011111<br/>
        ~0x11090503ff030509LL,   // 01101111<br/>
        ~0x090503ff03050911LL,   // 01110111<br/>
        ~0x0503ff0305091121LL,   // 01111011<br/>
        ~0x03ff030509112141LL,   // 01111101<br/>
        ~0xff03050911214181LL    // 01111110<br/>
        };<br/>
      </code>
      <code>
        /* code to calculate attacks at runtime:<br/>
      </code>
      <code>
        BitBoard attacksForRank(int r0)<br/>
        {<br/>
        BitBoard b = 0;<br/>
        int r = 0;<br/>
        while (r < r0) {  // diagonal attack<br/>
        b <<= 8; b |= 1 | 1<<(r0-r); r++;<br/>
        }<br/>
        b <<= 8; b |= 0xff; r++;  // horizontal attack<br/>
        while (r < 8) {   // diagonal attack<br/>
        b <<= 8; b |= 1 | 1<<(r-r0); r++;<br/>
        }<br/>
        return b;<br/>
        }<br/>
      </code>
      <code>
        void init_attacks()<br/>
        {<br/>
        int r;<br/>
        for (r=0; r<8; r++) {<br/>
        attacks[r] = ~attacksForRank(7-r);<br/>
        }<br/>
        }<br/>
      </code>
      <ul>
        <li>
          /
        </li>
      </ul>
      <code>
        int count = 0;	// should be 92<br/>
        int nodes = 0;	// should be 1965<br/>
      </code>
      <code>
        /* try placing queens (q) along file f and recurse to subsequent files */<br/>
        /* BitBoard b accumulates a solution, and left tracks possible */<br/>
        /*  future queen positions */<br/>
      </code>
      <code>
        BitBoard b = 0;<br/>
      </code>
      <code>
        void try_file(int f, BitBoard left)<br/>
        {<br/>
        BitBoard q = 1<<f;<br/>
        int r = 0;<br/>
        nodes++;<br/>
        while (r < 8) {<br/>
        if (left & q) {<br/>
        b ^= q;<br/>
        if (f < 7) {<br/>
        try_file(f+1, left & (attacks[r]<<f));<br/>
        } else {<br/>
        print_board(b); count++;<br/>
        }<br/>
        b ^= q;<br/>
        }<br/>
        r++; q <<= 8;	// next rank<br/>
        }<br/>
        }<br/>
      </code>
      <code>
        main()<br/>
        {	// init_attacks();<br/>
        try_file(0, ~0);	           // ~0: all bits set<br/>
        printf("%d solutions, %d nodes\n", count, nodes);<br/>
        }<br/>
      </code>
      <ol>
        <li>
          000 seconds to solve 8x8 on 2Ghz Athlon (does not generalize to NxN)
        </li>
      </ol>
      <hr/>
      <p>
        <strong></strong><a href="ForthLanguage.html">ForthLanguage</a><strong></strong>
      </p>
      <code>
        \ constants and utilities shared by the various approaches<br/>
      </code>
      <ol>
        <li>
           constant maxN
        </li>
        <li>
           value N
        </li>
      </ol>
      <code>
        : Nbits ( -- mask ) 1 N lshift 1- ;<br/>
        : lowBit  ( mask -- bit ) dup negate and ;<br/>
        : lowBit- ( mask -- bits ) dup 1- and ;<br/>
      </code>
      <code>
        variable solutions  variable nodes  variable inner<br/>
        \  first approach N=8: 92 1073 4380<br/>
        \ second approach N=8: 92 1964 46752<br/>
        \  third approach N=8: 92 1965<br/>
      </code>
      <p>
        First approach: track attacks on upcoming ranks.
      </p>
      <code>
        \ Triangular array of bitmasks, one bit per square<br/>
        \  recursion depth 0, ranks 0..N-1 are at offsets 0..N-1<br/>
        \  recursion depth 1, ranks 1..N-1 are at offsets N..N+(N-1)-1<br/>
        \  etc.<br/>
        create ranks maxN dup 1+ * 2/ cells allot<br/>
        : init-ranks<br/>
        Nbits  N 0 do dup ranks I cells + ! loop drop ;<br/>
        : .sq   1 and if [char] Q else [char] . then space emit ;<br/>
        : .rank ( mask -- ) N 0 do dup .sq 2/ loop drop cr ;<br/>
        : .solution	\ a solution is encoded in ranks<br/>
        N ranks begin<br/>
        dup @ lowBit .rank<br/>
        over cells +  swap 1- swap<br/>
        over 0= until 2drop cr ;<br/>
      </code>
      <code>
        \ Copy the square availability from the current ranks<br/>
        \ to the next ranks, excluding attacks by the new queen<br/>
        \ at nextBit of ^rank.<br/>
        \ Aborts if there is no possible solution from here.<br/>
        : exclude ( ranksLeft ^rank -- tf )<br/>
        over 1- cells over + swap rot ( dest src ranksLeft )<br/>
      </code>
      <ol>
        <li>
           do   1 inner +!
          <ol>
            <li>
              dup dup @ lowBit ( dest src mask ) \ file
            </li>
          </ol>
        </li>
      </ol>
      <code>
        dup I lshift or		\ left diagonal<br/>
        dup I rshift or invert	\ right diagonal<br/>
        swap I cells + @ and        ( dest masked )<br/>
        dup 0= if 2drop 2drop unloop false exit then<br/>
        swap I cells + !<br/>
        loop 2drop true ;<br/>
        : tryRank ( ranksLeft ^rank -- ) 1 nodes +!<br/>
        begin<br/>
        over 1- if<br/>
      </code>
      <ol>
        <li>
          dup exclude if
        </li>
      </ol>
      <code>
        over 1- 2dup 1+ cells + recurse<br/>
        then<br/>
        else ( .solution)  1 solutions +! then<br/>
        dup @ lowBit-  dup<br/>
        while  over !<br/>
        repeat drop 2drop ;<br/>
        : queens   init-ranks   N ranks tryRank ;<br/>
      </code>
      <p>
        A smaller but less efficient approach, similar to the Haskell entry below.
      </p>
      <code>
        create files maxN allot  \ Q file per rank<br/>
        : .sol2  cr N 0 do I files + c@ . loop ;<br/>
        : safe? ( file rank -- ? )<br/>
        dup 0 do  1 inner +!<br/>
        over I files + c@ -<br/>
        dup 0= if nip nip ( false ) unloop exit then<br/>
        abs I + over = if 2drop false unloop exit then<br/>
        loop 2drop true ;<br/>
        : tryRank2 ( rank -- rank )<br/>
        dup N = if ( .sol2) 1 solutions +! exit then  1 nodes +!<br/>
        N 0 do I over safe? if<br/>
        I over files + c!  1+ recurse 1-<br/>
        then loop ;<br/>
        : queens2   1  N 0 do I files c! tryRank2 loop drop ;<br/>
      </code>
      <p>
        This is fastest so far, the elegant approach used by the MCPL entry. Instead of tracking attacks on all future ranks in memory, the attacks of placed queens along files and both diagonals relative to the current rank are carried forward on the stack through the recursion.
      </p>
      <code>
        : .sol3 ( fn ... f1 x x f0 -- unchanged )<br/>
        dup N 0 do<br/>
        I 3 * 4 + pick ( fi fi+1 )<br/>
      </code>
      <ol>
        <li>
          dup xor .rank  nip
        </li>
      </ol>
      <code>
        loop drop cr ;<br/>
        : third ( a b c -- a b c a ) 2 pick ;    \ >r over r> swap ;<br/>
        : poss ( a b c -- a b c a&b&c ) dup 2over and and ;<br/>
        : next3 ( dl dr f Qfilebit -- dl dr f dl' dr' f' )<br/>
        invert >r third r@ and 2* 1+  third r@ and 2/  third r> and ;<br/>
        : try ( dl dr f -- )             \ bitmasks for unused diagonals and files<br/>
        dup if 1 nodes +!  poss<br/>
        begin ?dup while<br/>
        dup >r lowBit next3 recurse r> lowBit-<br/>
        repeat<br/>
        else ( .sol3) 1 solutions +! then drop 2drop ;<br/>
        : queens3  -1 dup Nbits try ;<br/>
      </code>
      <p>
        Test harness for all methods:
      </p>
      <code>
        : harness ( 'method -- ) 0 solutions ! 0 nodes ! 0 inner !  cr execute<br/>
        N . ." queens: " solutions @ . ." solutions, "<br/>
        nodes @ . ." nodes" inner @ ?dup if . ." , inner loops" then ;<br/>
        : test ( "method" -- ) '  maxN 0 do I 1+ to N  dup harness loop drop ;<br/>
        test queens<br/>
        test queens2  \ queens2 takes 10x longer to finish up to N=12, using 20x more inner loops<br/>
        test queens3  \ about 33% faster than the first approach<br/>
      </code>
      <p>
        Approach #1, "queens": 1.2 seconds to generate all NxN up to 12x12 using GNU Gforth on 2Ghz Athlon (12.5 sec with approach #2, "queens2"); 37.0 seconds to generate up to 14x14.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="PerlLanguage.html">PerlLanguage</a><strong></strong>
      </p>
      <code>
        #!/usr/bin/perl -l<br/>
      </code>
      <code>
        sub placequeen<br/>
        {<br/>
        $_[0]=~/^(.)(.*(.))(??{abs$1-$3!=length$2 && 'x'})/ ? () : <br/>
        length $_[0] == 8 ? @_ : map $_[0]=~$_?():placequeen("$_@_"), 0..7<br/>
        }<br/>
        print map '.'x$_.'Q'.'.'x(7-$_)."\n", /./g for placequeen;<br/>
      </code>
      <p>
        <em>Slightly generalized by another contributor...</em>
      </p>
      <code>
        #!/usr/bin/perl -l<br/>
        sub placequeen {<br/>
        $_[0]=~/^(.)(.*(.))(??{abs$1-$3!=length$2 && 'x'})/ ? () : <br/>
        length $_[0] == ($ARGV[0]-0) ? @_ : map $_[0]=~$_?():placequeen("$_@_"), 0..($ARGV[0]-1)<br/>
        }<br/>
        print map '.'x$_.'Q'.'.'x(($ARGV[0]-1)-$_)."\n", /./g for placequeen;<br/>
      </code>
      <p>
        <em>Just kidding (because some expect it of perl)...</em>
      </p>
      <code>
        #!/usr/bin/perl -l<br/>
      </code>
      <code>
        sub placequeen<br/>
        {<br/>
        return if $_[0] =~ /^((.).*\2|<br/>
      </code>
      <ol>
        <li>
          (1|.2|..3|...4|....5|.....6|......7)|
        </li>
        <li>
          (0|2|.3|..4|...5|....6|.....7)|
        </li>
        <li>
          (.0|1|3|.4|..5|...6|....7)|
        </li>
        <li>
          (..0|.1|2|4|.5|..6|...7)|
        </li>
        <li>
          (...0|..1|.2|3|5|.6|..7)|
        </li>
        <li>
          (....0|...1|..2|.3|4|6|.7)|
        </li>
        <li>
          (.....0|....1|...2|..3|.4|5|7)|
        </li>
        <li>
          (......0|.....1|....2|...3|..4|.5|6) )/x;
        </li>
      </ol>
      <code>
        if(length $_[0] < 8) # recurse for next queen<br/>
        {<br/>
        placequeen("$_@_") for 0..7;<br/>
        }<br/>
        else # found a solution, print it...<br/>
        {<br/>
        print map '.'x$_.'Q'.'.'x(7 - $_)."\n", $_[0] =~ /./g;<br/>
        }<br/>
        }<br/>
      </code>
      <code>
        placequeen;  # start with no rows placed<br/>
      </code>
      <p>
        using a digit from 0 to 7 inclusive for each row, where the digit
        represents the column number of the queen in that row.
      </p>
      <p>
        The second version reduces the problem to its five basic elements (statements),
        a validity test, a success test, a recursion to the next row,
        a printout of the board, and a starting point.
      </p>
      <ol>
        <li>
          04 seconds to generate 8x8 only (with board-printing code deleted) on 2Ghz Athlon.
        </li>
      </ol>
      <hr/>
      <p>
        <strong></strong><a href="McplLanguage.html">McplLanguage</a><strong>:</strong>
      </p>
      <code>
        GET "mcpl.h"<br/>
        STATIC count, all<br/>
        FUN try<br/>
        : ?, =all, ? => count++<br/>
        : ld, cols, rd => LET poss = ~(ld | cols | rd) & all<br/>
        WHILE poss DO<br/>
        { LET bit = poss & -poss<br/>
        poss -:= bit<br/>
        try( (ld|bit)<<1, cols|bit, (rd|bit)>>1 )<br/>
        }<br/>
        FUN start : =><br/>
        all := 1<br/>
        FOR n = 1 TO 12 DO<br/>
        { count := 0<br/>
        try(0, 0, 0)<br/>
        writef("There are %5d solutions to %2d-queens problem\n",<br/>
        count,             n )<br/>
        all := 2*all + 1<br/>
        }<br/>
        RETURN 0<br/>
      </code>
      <p>
        Output:
      </p>
      <code>
        There are 1 solutions to 1-queens problem<br/>
        There are 0 solutions to 2-queens problem<br/>
        There are 0 solutions to 3-queens problem <br/>
        There are 2 solutions to 4-queens problem <br/>
        There are 10 solutions to 5-queens problem<br/>
        There are 4 solutions to 6-queens problem<br/>
        There are 40 solutions to 7-queens problem <br/>
        There are 92 solutions to 8-queens problem <br/>
        There are 352 solutions to 9-queens problem <br/>
        There are 724 solutions to 10-queens problem <br/>
        There are 2680 solutions to 11-queens problem <br/>
        There are 14200 solutions to 12-queens problem<br/>
      </code>
      <hr/>
      <p>
        <a href="HaskellLanguage.html">HaskellLanguage</a>:
      </p>
      <code>
        queens 0 = [[]]<br/>
        queens (n+1) = [ q:b | b <- queens n; q <- [0..7]; safe q b ]<br/>
        safe q b = and [ not checks q b i | i <- [0..(b-1)] ]<br/>
        checks q b i = q=b!!i || abs(q - b!!i)=i+1<br/>
      </code>
      <p>
        <em>HUGS wouldn't run this, I must be making a newbie mistake.</em>
      </p>
      <p>
        Hmm... quite a few syntactic errors in the code above (where did it come from?).
        Try this (from <a href="http://www.haskell.org/pipermail/haskell-cafe/2004-March/005872.html):">http://www.haskell.org/pipermail/haskell-cafe/2004-March/005872.html):</a>
      </p>
      <code>
        boardSize = 8<br/>
        queens 0 = [[]]<br/>
        queens n = [ x : y | y <- queens (n-1), x <- [1..boardSize], safe x y 1]<br/>
        safe x [] n = True<br/>
        safe x (c:y) n = and [ x /= c , x /= c + n , x /= c - n , safe x y (n+1)]<br/>
      </code>
      <p>
        using a fold:
      </p>
      <code>
        import Control.Monad<br/>
        queens boardSize = foldM (\y _ -> [ x : y | x <- [1..boardSize], safe x y 1]) [] [1..boardSize]<br/>
        safe x [] n = True<br/>
        safe x (c:y) n = and [ x /= c , x /= c + n , x /= c - n , safe x y (n+1)]<br/>
      </code>
      <hr/>
      <p>
        <a href="RubyLanguage.html">RubyLanguage</a>:
      </p>
      <code>
        def safe?(col, others)<br/>
        others.each_with_index do |c, r|<br/>
        return false if col == c or (col - c).abs == (others.size - r).abs<br/>
        end<br/>
        end<br/>
      </code>
      <code>
        def solve(n, solutions = [], cols=[])<br/>
        return solutions.push(cols) unless cols.size < n<br/>
        n.times { |col| solve(n, solutions, cols + [col]) if safe?(col, cols) }<br/>
        return solutions<br/>
        end<br/>
      </code>
      <code>
        def show_solutions(n)<br/>
        solutions = solve(n)<br/>
        puts "There are #{solutions.size} solutions for n = #{n}."<br/>
        for cols in solutions<br/>
        puts <em>, cols.map { |c| (0...n).map { |i| i == c ? 'Q' : '.' }.join }</em><br/>
        end<br/>
        end<br/>
      </code>
      <p>
        -- <a href="JasonArhart.html">JasonArhart</a>
      </p>
      <hr/>
      <p>
        <a href="PythonLanguage.html">PythonLanguage</a>:
      </p>
      <code>
        NQUEENS = 8<br/>
        def attack((row1, col1), (row2, col2)):<br/>
        return (row1 == row2) or (col1 == col2) or abs(row1 - row2) == abs(col1 - col2)<br/>
        def safe(square, queens):<br/>
        for queen in queens:<br/>
        if attack(square, queen): return 0<br/>
        return 1<br/>
        def solve(n):<br/>
        if n == 0: return [[]]<br/>
        smaller_solutions = solve(n-1)<br/>
        return [solution+[(n,i+1)]<br/>
        for i in range(NQUEENS)<br/>
        for solution in smaller_solutions<br/>
        if safe((n,i+1), solution)]<br/>
        for answer in solve(NQUEENS): print answer<br/>
      </code>
      <p>
        Here is an animated version using the <a href="GuidoVanRobot.html">GuidoVanRobot</a> toolkit:
      </p>
      <code>
        from powerMode import *<br/>
      </code>
      <code>
        def main():<br/>
        world.positionRobot(1,1, 'E')<br/>
        world.setWall(1, 8, 'N', 8)<br/>
        world.setWall(8, 1, 'E', 8)<br/>
        setDelayAmount(0.002)<br/>
        beginDisplay(11, 11)<br/>
        placeQueens(1)<br/>
        turnoff()<br/>
      </code>
      <code>
        def placeQueens(x):<br/>
        if x > 8:<br/>
        printSolution()<br/>
        takeVictoryLap()<br/>
        # be greedy, return False<br/>
        # so we can find the next<br/>
        # solution<br/>
        return False<br/>
        y = 1<br/>
        while y <= 8:<br/>
        if placeQueen(x,y):<br/>
        if placeQueens(x+1):<br/>
        return True<br/>
        goto(x, y)<br/>
        pickbeeper()<br/>
        y += 1<br/>
        return False<br/>
      </code>
      <code>
        def placeQueen(x, y):<br/>
        goto(x,y)<br/>
        if underAttack(x,y):<br/>
        return False<br/>
        placeBeeper()<br/>
        return True<br/>
      </code>
      <code>
        def printSolution():<br/>
        positions = []<br/>
        for x in range(8):<br/>
        for y in range(8):<br/>
        if world.beepers.get((x,y), 0):<br/>
        positions.append((x,y))<br/>
        print positions<br/>
      </code>
      <code>
        def underAttack(x, y):<br/>
        for i in range(x):<br/>
        if world.beepers.get((x-i, y), 0):<br/>
        return True<br/>
        if world.beepers.get((x-i, y+i), 0):<br/>
        return True<br/>
        if world.beepers.get((x-i, y-i), 0):<br/>
        return True<br/>
        return False<br/>
      </code>
      <code>
        def goto(x,y):<br/>
        curX, curY = world.robot<br/>
        if curX < x:<br/>
        while curX < x:<br/>
        move()<br/>
        curX += 1<br/>
        elif curX > x:<br/>
        turnaround()<br/>
        while curX > x:<br/>
        move()<br/>
        curX -= 1<br/>
        turnaround()<br/>
        if curY < y:<br/>
        turnleft()<br/>
        while curY < y:<br/>
        move()<br/>
        curY += 1<br/>
        turnright()<br/>
        elif curY > y:<br/>
        turnright()<br/>
        while curY > y:<br/>
        move()<br/>
        curY -= 1<br/>
        turnleft()<br/>
        return True<br/>
      </code>
      <code>
        def takeVictoryLap():<br/>
        setDelayAmount(0.1)<br/>
        goto(8,8)<br/>
        goto(1,8)<br/>
        goto(1,1)<br/>
        goto(8,1)<br/>
        goto(8,8)<br/>
        goto(1,8)<br/>
        goto(1,1)<br/>
        setDelayAmount(0.002)<br/>
      </code>
      <code>
        def placeBeeper():<br/>
        world.robotBeepers += 1<br/>
        putbeeper()<br/>
      </code>
      <code>
        def turnaround():<br/>
        turnleft()<br/>
        turnleft()<br/>
      </code>
      <code>
        def turnright():<br/>
        turnaround()<br/>
        turnleft()<br/>
      </code>
      <code>
        main()<br/>
      </code>
      <p>
        -- <a href="SteveHowell.html">SteveHowell</a>
      </p>
      <hr/>
      <p>
        <strong>Sather</strong> See <a href="SatherLanguage.html">SatherLanguage</a>
      </p>
      <code>
        -- From: <a href="http://www.fleiner.com/claudio/benchmarks/data/queen.sa">http://www.fleiner.com/claudio/benchmarks/data/queen.sa</a><br/>
        -- Copyright (C) International Computer Science Institute, 1995. COPYRIGHT   --<br/>
        -- NOTICE: This code is provided "AS IS" WITHOUT ANY WARRANTY and is subject --<br/>
        -- to the terms of the SATHER LIBRARY GENERAL PUBLIC LICENSE contained in    --<br/>
        -- the file "Doc/License" of the Sather distribution.  The license is also   --<br/>
        -- available from ICSI, 1947 Center St., Suite 600, Berkeley CA 94704, USA.  --<br/>
        --<br/>
        -- solves the N queen problem<br/>
        -- Version 1.0, June 1996, by Claudio Fleiner<br/>
      </code>
      <code>
        class QUEEN is<br/>
        include AREF{CHAR};<br/>
        shared print_result:BOOL:=false;<br/>
      </code>
      <code>
        str:STR is <br/>
        res::="QUEENS: ";<br/>
        loop res:=res+aelt!.int+" "; end;<br/>
        res:=res+"\n";<br/>
        return res;<br/>
        end;<br/>
      </code>
      <code>
        print is #OUT+str; end;<br/>
      </code>
      <code>
        pos(x:INT):INT is<br/>
        count::=0;<br/>
        if x=asize then<br/>
        if print_result then print; end;<br/>
        return 1;<br/>
        else<br/>
        loop i::=asize.times!;<br/>
        if [i]=0.char then<br/>
        ok::=true;<br/>
        loop while!(ok);<br/>
        j::=asize.times!;<br/>
        ok:=[j].int=0 or (x+1-[j].int/=i-j and x+1-[j].int/=j-i);<br/>
        end;<br/>
        if ok then<br/>
        [i]:=(x+1).char;<br/>
        count:=count+pos(x+1);<br/>
        [i]:=0.char;<br/>
        end;<br/>
        end;<br/>
        end;<br/>
        end;<br/>
        return count;<br/>
        end;<br/>
      </code>
      <code>
        pos:INT is return pos(0); end;<br/>
        end;<br/>
      </code>
      <code>
        class MAIN is<br/>
        test is<br/>
        b::=#QUEEN(8);<br/>
        QUEEN::print_result:=true;<br/>
        #OUT+("found "+b.pos+" solutions for the 8 - queen problem\n");<br/>
        end;<br/>
      </code>
      <code>
        usage is<br/>
        #ERR+"USAGE: queen TEST | [-p] size\n";<br/>
        end;<br/>
      </code>
      <code>
        main(argv:ARRAY{STR}):INT is<br/>
        size::=0;<br/>
        if argv.size=2 and argv[1]="TEST" then test; return 0; end;<br/>
        if argv.size=3 then<br/>
        if argv[1]="-p" then QUEEN::print_result:=true;<br/>
        else usage; return 1; end;<br/>
        size:=#INT(argv[2]);<br/>
        elsif argv.size=2 then<br/>
        size:=#INT(argv[1]);<br/>
        else <br/>
        usage; return 1;<br/>
        end;<br/>
      </code>
      <code>
        if size<1 or size>99 then usage; return 1; end;<br/>
      </code>
      <code>
        b::=#QUEEN(size);<br/>
        t::=#TIMES;<br/>
        found::=b.pos;<br/>
        d::=t.elapsed;<br/>
        #OUT+"found "+found+" solutions for the "+size+" - queen problem\n";<br/>
        #OUT+d.str;<br/>
        return 0;<br/>
        end;<br/>
        end;<br/>
      </code>
      <hr/>
      <p>
        <strong>J</strong> see <a href="JayLanguage.html">JayLanguage</a>
      </p>
      <code>
        queens=: 3 : 0<br/>
        z=.i.n,*n=.y<br/>
        for. }.z do.<br/>
        b=. -. (i.n) e."1 ,. z +"1 _ ((-i.){:$z) */ _1 0 1<br/>
        z=. ((+/"1 b)#z),.(,b)#(*/$b)$i.n<br/>
        end.<br/>
        )<br/>
      </code>
      <p>
        from <a href="http://jsoftware.com/jwiki/Essays/N_Queens_Problem">http://jsoftware.com/jwiki/Essays/N_Queens_Problem</a>
      </p>
      <p>
        or shorter
      </p>
      <code>
        queens =: (](1&=@(>./@(+/,+//.,+//.@|.))"2#])@,/@:((],"_ _ 1=@i.@#@{.)"2)^:[(1 0&,$0:))<br/>
      </code>
      <hr/>
      <p>
        Contributors:  <a href="IanOsgood.html">IanOsgood</a>, <a href="DanielSheppard.html">DanielSheppard</a>, <a href="DougMerritt.html">DougMerritt</a>, <a href="BenjaminGeiger.html">BenjaminGeiger</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryInManyProgrammingLanguages.html">CategoryInManyProgrammingLanguages</a>
      </p>
    </div>
  </body>
</html>