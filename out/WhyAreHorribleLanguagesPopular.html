<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Why Are Horrible Languages Popular
      </h1>
      <p>
        Inspired by inverting <a href="HowCanSomethingBeSuperGreatWithoutProducingExternalEvidence.html">HowCanSomethingBeSuperGreatWithoutProducingExternalEvidence</a>. See WhyDoesEvilExist for political parallels.
      </p>
      <p>
        Why are <a href="BasicLanguage.html">BasicLanguage</a>, <a href="VisualBasic.html">VisualBasic</a>, <a href="CeePlusPlus.html">CeePlusPlus</a> and <a href="JavaLanguage.html">JavaLanguage</a> so popular considering that they are utter and unmitigated crap?
      </p>
      <ul>
        <li>
           <a href="JavaLanguage.html">JavaLanguage</a> disproved the "accident of history" theory.
        </li>
        <li>
           <a href="CeePlusPlus.html">CeePlusPlus</a> disproved the "ease of learning" theory.
        </li>
        <li>
           <a href="DylanLanguage.html">DylanLanguage</a> disproved the "algol syntax" theory.
        </li>
      </ul>
      <p>
        Some say it's know-nothing consultants and business hype.
      </p>
      <p>
        <em>Others say it's the observers viewpoint that is horrible, not the applications.</em>
      </p>
      <p>
        <em>I blame the shortage of </em><a href="InteractionDesigner.html">InteractionDesigner</a>s.<em> Especially the "foaming-at-the-mouth" variety.</em>
      </p>
      <p>
        I don't, since programming language design is possibly the only prosperous area of software design. There has never been a shortage of <a href="LanguageDesigner.html">LanguageDesigner</a>s. On the other issue, there certainly have been shall we say ... evangelical language designers, so I'm not sure what foaming at the mouth is supposed to add to it. I don't think it's such a problem that language designers have traditionally been wealthy enough to avoid getting rabies from some pet or stray animal.
      </p>
      <hr/>
      <p>
        I suspect that the fact that the above languages were developed and evangelized by companies who were (at the time, at least) major <a href="OperatingSystem.html">OperatingSystem</a> suppliers (<a href="MicrosoftCorporation.html">MicrosoftCorporation</a>, <a href="SunMicrosystems.html">SunMicrosystems</a>, and AT&T--even if AT&T wasn't really in the OS business) has something to do with the success of those languages. -- sj
      </p>
      <hr/>
      <p>
        One problem is that we choose languages at the beginning of projects before we face the kinds of problems that a powerful language addresses. This has us focus too much on the size of libraries and the quality of tools while we ignore the ability to make long-lived abstractions. I offer as evidence my own switch from Smalltalk-80 on workstations to Smalltalk-V on the DOS PC. I found much to dislike about this new environment the first week. But after that week passed I was living in a world of my own abstractions and found any complaints about Smalltalk-V unimportant. -- <a href="WardCunningham.html">WardCunningham</a>
      </p>
      <p>
        <em>Good point.  Of course, many projects--and many organizations--</em>'never<strong> face the kinds of problems that powerful languages address. </strong><a href="LispLanguage.html">LispLanguage</a> is wasted on <a href="CrudScreen.html">CrudScreen</a>s. <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> is excellent at them, but when it comes to algorithmically simple tasks such as this, the difference between Smalltalk and VB or Java vanishes (and given the plethora of tools for the latter languages which make crud screen generation easy, the "horrible" languages may have an advantage).<em></em>
      </p>
      <p>
        <em>Of course, one of the biggest problems in industrial computing is </em>not<em> the description of an algorithm or problem to the machine, it's the conversion of vague and ambiguous user requirements into a form that is unambiguous. In other words, the mental gymnastics which occur before you start typing. -- </em><a href="ScottJohnson.html">ScottJohnson</a><em></em>
      </p>
      <hr/>
      <p>
        Horrible languages are popular for the same reason horrible genes are popular:  they succeed.  You couldn't cram a useful Lisp or Smalltalk onto an Altair 8800 with 4K of RAM.  You <em>could</em> cram a useful BASIC onto it, so it became the first high level language for home computers.  Even when home computers grew big enough to run other languages, BASIC had an advantage because so many home computer designers and owners had already learned it.  C piggy-backed on the success of Unix.  C++ piggy-backed on the success of C.  Java piggy-backed on the success of C++.
      </p>
      <p>
        None of these languages will win awards for elegance or beauty.  All of them had just enough of what a plurality of programmers wanted at precisely the time the hardware they required was affordable to those programmers.  Like successful genes, they got the job done and no more.
      </p>
      <p>
        My own programming language history precisely reflects these horrible languages:
      </p>
      <ol>
        <li>
           BASIC - The first language I learned because it came with my computer.
        </li>
        <li>
           Assembly - More efficient than BASIC, but tiresome to read and write.
        </li>
        <li>
           C - Virtually as efficient as assembly, easier to read and write, more expressive than BASIC.
        </li>
        <li>
           Pascal - Much like C but slower.
        </li>
        <li>
           C++ - Because I already knew C and was already approaching an object oriented style of programming.
        </li>
        <li>
           Java - Because I already knew C++, was tired of managing memory by hand and wanted a standardized library.
        </li>
      </ol>
      <p>
        -- <a href="EricHodges.html">EricHodges</a>
      </p>
      <p>
        Your explanation is really a non-explanation that explains precisely nothing. What exactly dictates "what a plurality of programmers want" or when programmers "get tired" of a language's deficiencies?
      </p>
      <p>
        The only thing in your non-explanation that might turn it into an explanation is your implied supposition that programmers will eat up whatever's shoved in front of them, much like a mindless cow or pig has no thought to what exists beyond its immediate sight.
      </p>
      <p>
        Even that's only the beginning of an explanation since all it amounts to is the observation that programming language adoption is governed by Hype and Buzz. A real explanation would need to delineate the rules of Hype and Buzz. -- RK
      </p>
      <p>
        <em>C was not shoved in front of me. I read an article in Rainbow magazine that briefly described it as a procedural language like Pascal that could be compiled and I decided I wanted to learn it. C++ wasn't shoved in front of me. I sought it out because I saw that it would simplify my code. Same with Java. Your supposition should not be implied.</em>
      </p>
      <p>
        <em>I'm unfamiliar with any hype or buzz for BASIC, C or C++. Perhaps you can document that. -- EH</em>
      </p>
      <p>
        Java succeeded C++ but it had nothing to do with C++. Java had more to do with Smalltalk than it ever had C++. Your claim that Java piggy-backed on C++ is factually wrong.
      </p>
      <p>
        With the exception of being free and well-marketed, nothing you say about Java explains the success of Java. Smalltalk had automatic garbage collection and a large (and mature) standard library long, long before Java ever was an idea in anyone's head.
      </p>
      <p>
        C was most certainly shoved in front of you. Your reading an article in a trade magazine is exactly its being shoved under your nose. I suppose you would rather the phrase be restricted to meaning 'shipped free with the OS' or somesuch. And even that isn't far from the truth since C was shipped with Unix and Basic was shipped with DOS. If your particular experience conflicts with the vast majorities', it only invalidates the relevance of your experience. -- RK
      </p>
      <p>
        <em>C++ had a great deal to do with the success of Java.  Java's syntax was lifted from C++, not Smalltalk:</em>
      </p>
      <dl>
        <dt> </dt>
        <dd>"The syntax of Java was chosen to be familiar to C programmers, but direct compatibility with C was not maintained. Java also was specifically designed to be simpler than C++."</dd>
      </dl>
      <dl>
        <dt>	 </dt>
        <dd>-- <a href="http://en.wikipedia.org/wiki/Comparison_of_Java_to_C++#Design_aims:">http://en.wikipedia.org/wiki/Comparison_of_Java_to_C++#Design_aims:</a></dd>
      </dl>
      <p>
        <em>Hordes of C++ programmers took the path from C++ to Java despite the fact that Smalltalk is less horrible than Java, because Java was less horrible than C++ and the path was so short.</em>
      </p>
      <p>
        <em>"Rainbow" was hardly a trade journal. It was a hobbyist's magazine for the TRS-80 Color Computer. The C programming language was mentioned exactly once before I decided to learn it. It received a single paragraph in an article about an operating system that was likely to be ported to the Color Computer as part of a review of languages that might be available in the future.  The other languages were Basic09 and Pascal.  If anything was shoved in front of me, it was Pascal.  I'd already heard of it from other magazines and was later required to learn it in my first CS course at university.</em>
      </p>
      <p>
        <em>-- </em><a href="EricHodges.html">EricHodges</a><em></em>
      </p>
      <p>
        Granted. So in that case, what is it that determines language adoption? One thing you almost allude to is a cyclic "silver bullet -> pure crap" psycho-dynamic. Java was initially a <a href="SilverBullet.html">SilverBullet</a> to C++'s ills but nowadays it's a big yawn. You mention "frustration" with C++'s problems but you omit that this frustration, like all frustration everywhere, was mounting over time. Probably, language adoption follows <a href="TheStructureOfScientificRevolutions.html">TheStructureOfScientificRevolutions</a>, and a new language is adopted for no better reason than that it is new <em>at a propitious moment</em>.
      </p>
      <p>
        If languages are adopted because they are widely marketed (like Java) then one has to ask why they are widely marketed in the first place. Answer: because they are new. Additionally, Java's algol syntax wasn't the big deal you make it out to be since <a href="DylanLanguage.html">DylanLanguage</a> suffered some kind of ignominious death. Java's static type system and primitive types may have been a factor though.
      </p>
      <p>
        So far we've got:
      </p>
      <ul>
        <li>
           a programming language stays constant until frustration with it mounts to intolerable levels,
        </li>
        <li>
           at which point the next new language,
        </li>
        <li>
           that's sufficiently different,
        </li>
        <li>
           but comfortably similar
        </li>
        <li>
           will get adopted.
        </li>
      </ul>
      <p>
        Are we good so far? -- RK
      </p>
      <p>
        Sort of.  As I said above, timing is crucial.  The benefits of a new language must be within reach of a plurality of programmers for it to gain momentum.  That reach is constrained by:
      </p>
      <ul>
        <li>
           awareness (hype & buzz)
        </li>
        <li>
           learning curve (how close is it to known languages and concepts)
        </li>
        <li>
           hardware cost (at one time you had to buy a co-processor to run Ada on a PC) 
        </li>
        <li>
           existing software environment (does it play well with others)
        </li>
      </ul>
      <p>
        There has to be some motivation for change, and frustration is more motivating than curiosity.
      </p>
      <p>
        Java is the most heavily marketed language I've ever seen.  I don't attribute that to its novelty; all languages were new at some point.  Java was heavily marketed because Sun thought it could take business away from Microsoft by making the desktop irrelevant with applets.  The 90s were filled with that sort of thinking.
      </p>
      <p>
        Programmers seek local, not global, maxima.  Once they reach a local maxima all of the convenient options are worse.  Dylan is Algol-like, but not as C-like as Java.  C and C++ programmers gave Java early momentum.  It's the same pattern seen in evolution.  Each change has to offer immediate benefits over the current state or it will be swamped by the replication of changes that do offer immediate benefits.  There's no skipping across less fit states to reach a state more fit than the current one.  That's why there are so many "horrible" genes running about.
      </p>
      <p>
        -- <a href="EricHodges.html">EricHodges</a>
      </p>
      <hr/>
      <p>
        <a href="JanuaryZeroSix.html">JanuaryZeroSix</a>
      </p>
      <p>
        See also <a href="ReachableUtopia.html">ReachableUtopia</a>, <a href="InsanelyGreat.html">InsanelyGreat</a>
      </p>
      <p>
        <a href="CategoryDiscussion.html">CategoryDiscussion</a>
      </p>
    </div>
  </body>
</html>