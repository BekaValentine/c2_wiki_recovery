<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Languages Vs Environments
      </h1>
      <p>
        Most people view a <a href="ProgrammingLanguage.html">ProgrammingLanguage</a> as something that sits on an <a href="OperatingSystem.html">OperatingSystem</a>.  <a href="VisualBasic.html">VisualBasic</a>, <a href="CeePlusPlus.html">CeePlusPlus</a>, and <a href="PythonLanguage.html">PythonLanguage</a> are all examples of this.  However the <a href="SmugLispWeenie.html">SmugLispWeenie</a>s will tell you that having a whole environment dedicated to that language is better.  Think <a href="SymbolicsMachine.html">SymbolicsMachine</a> and <a href="DynaBook.html">DynaBook</a>.
      </p>
      <p>
        So, the question is, just use a language on an OS, or hold out for an operating environment for your language.  For CeeHackers, either every OS, or no OSs fit this description, depending how you look at it.
      </p>
      <p>
        An <a href="IntegratedDevelopmentEnvironment.html">IntegratedDevelopmentEnvironment</a>, especially as used for 'live' systems like <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> or <a href="MozartProgrammingSystem.html">MozartProgrammingSystem</a>, also fuzzy up the borderline between <a href="OperatingSystem.html">OperatingSystem</a> and language. Many OS developers think this is the right way to go; providing <a href="NakedObjects.html">NakedObjects</a> and supporting <a href="NoApplication.html">NoApplication</a> systems and so on. But to really have languages take over for the OS, we'll need both type-safety (even if dynamic) and a <a href="SecurityModel.html">SecurityModel</a> integrated into the language from the ground up, and probably some <a href="ProcessAccounting.html">ProcessAccounting</a> and effective resource management, all integrated into the language. <a href="ObjectCapabilityModel.html">ObjectCapabilityModel</a> is an especially promising basis for security and much work has been done to achieve market-based, cooperative, and competitive resource management atop it.
      </p>
      <hr/>
      <p>
        From <a href="ColorForth.html">ColorForth</a>:
      </p>
      <p>
        Would it be possible to have only the language, without the operating system.  I have some kind of bad experience when languages are combined with operating systems.  Why not only make the language?
      </p>
      <p>
        <em>Because you lose most of the advantages of the environment when you use a separate OS.</em>
      </p>
      <p>
        What advantages do you lose?  Stand-alone is not really an advantage, if you ask me.  It can still be compact, simple, fast, innovative and unique, if you need this.  What else?
      </p>
      <p>
        <em>I don't see how a system can be "compact" if it's strapped to a 2-megabyte OS kernel and megabytes upon megabytes of supplementary material. I don't see how a system can be "simple" if it has things like a user->supervisor transition for most/all basic operations. I don't see how a system can be "fast" if it's wasting most of its time copying buffers to and from user space to preserve POSIX semantics. I'm not going to touch "innovative" or "unique", those can easily be argued either way. On the other paw, I don't see myself switching to </em><a href="ColorForth.html">ColorForth</a> as my main system. I, too, have too much invested in my current (<a href="FreeBsd.html">FreeBsd</a>) setup to make such a drastic change.<em></em>
      </p>
      <p>
        While I too have much invested in my current Linux machine, I'm working on setting up a <a href="JavaStation.html">JavaStation</a> to host different environments.  One will be <a href="SqueakSmalltalk.html">SqueakSmalltalk</a> on Linux.  Another might be Squeak running on bare hardware.  A 3rd might be something lisp related, and a fourth might be forth, again running bare.  Plus, it will have a normal linux image for guest users.
      </p>
      <hr/>
      <p>
        A complete environment as opposed to a stand-alone language ties you to only those platforms for which the environment has been ported, and only those systems for which support has been added, while a stand-alone language does not(should not?) have those restrictions.
      </p>
      <p>
        If I wanted to use, for example <a href="ColorForth.html">ColorForth</a> on a Macintosh or over a network or with an external library or ..., I'd be out of luck, until the environment had these things added, while a stand-alone language would (hopefully) allow for just typing 'make'... -- <a href="MartinRudat.html">MartinRudat</a>
      </p>
      <p>
        Well, a stand-alone language ties you to only those platforms for which the language has been ported.  It's just (presumably) easier to port a stand-alone language than a full environment.  If I want to use <a href="GwydionDylan.html">GwydionDylan</a> on a non-<a href="CygWin.html">CygWin</a> Windows box, or <a href="RubyLanguage.html">RubyLanguage</a> on a <a href="LispMachine.html">LispMachine</a>, or CormanLisp or <a href="MalbolgeLanguage.html">MalbolgeLanguage</a> on my Linux laptop, I'm out of luck.  Not every platform has 'make' either; didn't that not exist for Macs until <a href="MacOsx.html">MacOsx</a>?  -- <a href="JonathanTang.html">JonathanTang</a>
      </p>
      <hr/>
      <p>
        See also <a href="LanguageIsAnOs.html">LanguageIsAnOs</a> <a href="LanguagesAreOperatingSystems.html">LanguagesAreOperatingSystems</a> <a href="PinkyAndTheBrainLanguage.html">PinkyAndTheBrainLanguage</a> <a href="SeparationOfConcerns.html">SeparationOfConcerns</a> <a href="SingleLanguageOperatingSystem.html">SingleLanguageOperatingSystem</a>
      </p>
    </div>
  </body>
</html>