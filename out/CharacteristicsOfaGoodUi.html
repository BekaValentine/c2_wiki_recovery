<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Characteristics Ofa Good Ui
      </h1>
      <p>
        Moved from <a href="UserManualIsAnAntiPattern.html">UserManualIsAnAntiPattern</a>
      </p>
      <p>
        This list is doubtless controversial:
      </p>
      <ul>
        <li>
           All operations [can be] guaranteed reversible.
          <ul>
            <li>
               No deletions of network files
            </li>
            <li>
               The <a href="SpikeSolution.html">SpikeSolution</a> for a feature might not be guaranteed reversible, but with some thought, it can be made reversible.
            </li>
            <li>
               <em>That is more of a general feature than a UI feature. The implimentation may require a lot of stuff not related to the UI.</em>
            </li>
          </ul>
        </li>
        <li>
           All operations [can be] guaranteed harmless.
          <ul>
            <li>
               Harmless is relative, and not always practical. For example, it is often not possible to undo a sales transaction or money withdrawal from an ATM machine (see <a href="BankMoneyTransfer.html">BankMoneyTransfer</a>).
            </li>
          </ul>
        </li>
        <li>
           The context of each command [can be] obvious within the application.
        </li>
        <li>
           There is enough room in the <a href="UserInterface.html">UserInterface</a>, that beginning users can see more explanatory buttons and menus, and advanced users can take shortcuts.
          <ul>
            <li>
               Some <a href="HumanComputerInteraction.html">HumanComputerInteraction</a> researchers suggest using 3-D views.
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <p>
        So. . . basically a CLI/console/xterm is a bad UI?
      </p>
      <ul>
        <li>
           Not all the commands can be reversed
        </li>
        <li>
           You can delete network files
        </li>
        <li>
           The operations are not harmless
        </li>
        <li>
           The context isn't obvious unless you check the path also
        </li>
        <li>
           There are no buttons, menus, or 3d views
        </li>
      </ul>
      <p>
        <em>To whoever put "disk defragmentation" in the above lists: disk defragmentation seems irrelevant to this. It's analogous to </em><a href="GarbageCollection.html">GarbageCollection</a> and HeapCompaction; these are background implementation details that should never even be seen by the user. Even on OSes that require the user to manually initiate disk defragmentation (and need it frequently because of the filesystem's design being unusually susceptible to fragmentation) there is no conceivable reason to want to <em>re</em>fragment the disk, as file contents are not altered.<em></em>
      </p>
      <p>
        Actually, you might want to undo the defragmentation.  Sometimes the defragmentation actually makes the fragmentation worse. For example, the paging file might wind up more fragmented after defragmentation than before.
      </p>
      <p>
        <em>That's why on an operating system like Microsoft Windows the default defragmentation tool will not touch the paging file. I think the list above applied to GUI not necessarily UI in general</em>
      </p>
      <p>
        I'm pretty sure the list above applied to UI in general. What it doesn't apply to is inherently broken systems like Windows filesystems. Ext2fs and Ext3fs don't have defragmentation tools, or if they do then they're never used. And logging filesystems have automatic compactors. So defragmentation is simply a non-issue.
      </p>
      <dl>
        <dt> </dt>
        <dd>Once upon a time, I was seriously pursuing a career in recording engineering, focusing on the digital recording. Hardware then not being quite what it is today, one was quite often pushing the limits of how many tracks could be recorded and played back at the same time (processing and bandwidth; the hardware to actually do multiple channel recording was another issue).  It was quite common to have a project with (say) 12 tracks playing back fine after they were recorded, but a few weeks later, they simply would not play. The culprit in most cases was that a defragment had occurred at some point, removing the necessary interleaving of the audio files.</dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd>You see, when you record 2 tracks at the same time, the data from the two tracks will be interleaved on the disk, even though the tracks are in separate files. This 'fragmentation' ends up making playback involving those two tracks much more efficient. When you have 12 tracks, many of those tracks will have been recorded at the same time as others, and so the load on the drive (mainly seek times) ends up equivalent to only 8 or 9 tracks.</dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd>There were many utilities (often built into the application; and this (may) still be common) for re-interleaving tracks after defragmentation or copying, in order to provide exactly that: a manner to <em>re</em>fragment the disk.</dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd>-- <a href="WilliamUnderwood.html">WilliamUnderwood</a></dd>
      </dl>
      <hr/>
      <p>
        <a href="CategoryUserInterface.html">CategoryUserInterface</a>
      </p>
    </div>
  </body>
</html>