<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Tuple Definition
      </h1>
      <p>
        A tuple is a fixed fixed-length list containing elements that need not have the same type. It can be, and often is, used as a key-value pair.
      </p>
      <p>
        Technically, the name tuple is overloaded and denotes several distinct but very closely related concepts. So depending on the context one of the following definitions apply.
      </p>
      <hr/>
      <p>
        (1)
      </p>
      <p>
        The most common used in general mathematics, database theory, etc.
      </p>
      <p>
        <strong>Intuitive</strong> : a n-tuple is a composite with n elements. t = (x1, x2, ..., xn)
      </p>
      <p>
        Formally a n-tuple is a function t: {1 .. n} -> U where U is a set (universe) of elements
      </p>
      <hr/>
      <p>
        (2)
        In axiomatic set theory the above definition is typically not used because students are introduced to function as a special kind of relation and relation is a set of tuples. So the following technical trick is used:
      </p>
      <code>
        An <strong>ordered pair</strong> (2-tuple) denoted (a,b) is defined as the following set {{a},{a,b}}<br/>
        The following theorem is easy to verify: (a,b)=(a',b') <=> (a=a') /\ (b=b')<br/>
        An n-tuple (n>2) is the ordered pair t_n= (t_(n-1), x_n) where t_(n-1) is a (n-1_ -tuple<br/>
      </code>
      <p>
        <em>Those of us who have been out of school for too long may not recognize what notations like "<=>" and "/\" mean. May I suggest a page called </em><a href="WikiAsciiMathSymbols.html">WikiAsciiMathSymbols</a>.<em></em>
      </p>
      <hr/>
      <p>
        (3)
      </p>
      <p>
        Database theory operates with two kinds of tuple (<a href="FoundationsOfDatabases.html">FoundationsOfDatabases</a> calls the two approaches the named versus unnamed perspective. The unnamed perspective uses the first definition as it provides a slightly more convenient notation to prove some theorems.
      </p>
      <p>
        In addition, <a href="DrCodd.html">DrCodd</a> decorated (just like in <a href="DecoratorPattern.html">DecoratorPattern</a>) the unnamed tuple with column names. So instead of referring to tuple components by their index, we refer them by names. Formally we can consider a tuple a function 
      </p>
      <code>
        t: Column_Names -> U <br/>
      </code>
      <p>
        where Column_Names is a set of names (strings) and U is the universe of simple (scalar) values. This can further be decorated with domains by associating a column_name with a domain of values, so that each column value belongs to a particular domain defined for that column.
      </p>
      <code>
        t(column) <strong>in</strong> domain_of(column)<br/>
      </code>
      <p>
        This later definition is particularly useful in programming, as information items are better access by their names as
        in employee.employee_id rather than an arbitrary index (employee[1]).
      </p>
      <p>
        <em>It should be pointed out that in relational theory, more than just decoration is going on. By the act of decoration, the order of elements within a tuple no longer matters -- tuples in the </em><a href="RelationalModel.html">RelationalModel</a> are held to be unordered.<em></em>
      </p>
      <p>
        Actually, functions are like that by definition. So even under the first definition tuples are unordered, it's only in the notation or possibly within an implementation inside a computer that tuples are thought to be ordered. In any case the same can be said about the named perspective: you can introduce an order of components defined by the lexicographical order of column names. 
      </p>
      <p>
        However this point is worth mentioning since SQL being what it is (not very faithful to <a href="RelationalModel.html">RelationalModel</a>) made the order of columns important, so if two tables do not have the same exact order of columns they are "type incompatible" in SQL so:
      </p>
      <code>
        (select id,name from x)<br/>
        union<br/>
        (select name,id from y)<br/>
      </code>
      <p>
        is illegal in SQL. 
      </p>
      <p>
        Which is particularly strange (they mix the named and unnamed perspective in the same ball of wax) and sometimes annoying in complex database schemas, where different views may have slightly different column orders and then when thy need to be put back together it breaks unless you explicitly re-order the columns.
      </p>
      <p>
        <em>It is a trade-off. Order-based is easier for some situations and name-based is easier for others. Perhaps if SQL had better intermediate (virtual) table abilities, then it may tilt the other way. -- top</em>
      </p>
      <hr/>
      <p>
        Discussion:
      </p>
      <p>
        Some old discussion is <a href="TupleDefinitionDiscussion.html">TupleDefinitionDiscussion</a>. In particular, <a href="TopMind.html">TopMind</a> is adamant that tuples can be equated with dictionary data structures (as in Perl for example) suggesting they are just different views of the same thing.
      </p>
    </div>
  </body>
</html>