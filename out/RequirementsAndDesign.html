<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Requirements And Design
      </h1>
      <p>
        From <a href="CritiqueOfUseCases.html">CritiqueOfUseCases</a>.
      </p>
      <hr/>
      <p>
        In a thought experiment, I came up with the idea that there are guaranteed to be two different, incompatible modes of expression on a software project.  It is no good trying to make just one.  And there is always going to be a translation jump between them.
      </p>
      <p>
        The first is a person's wishes for the behavior of a system.  The second is the program itself.  They are fundamentally incompatible because the first is necessarily imprecise and the second is necessarily precise.   At the moment of wishing for something, the person doesn't know / can't express all the ramifications, interrelationships and details.  Adding the extra precision, the person generates implications that either are not clearly understood or are not necessarily really requirements, or contain mistakes. Every new statement generates interrelationships between the previous statements.  This is inevitable.  But at some point, the person might back off and say, "Wait, all I really want is ..."  (my example is when I go to the barbershop  - all I want is for my hair to look nice.  Then they start asking if I want more cut here or there.  If I actually give the instructions, then my hair doesn't look nice).
      </p>
      <p>
        To me, this jump from imprecise to precise is unavoidable, and rife with errors.  It doesn't matter if you use OO or SA, or pseudocode, or drawings or text, at some point you make a jump.  At that point, it doesn't even matter if you change descriptive paradigms.  Traceability matrixes don't help.  There is a language of the user, there is a language of the programmer, and the programmer has to connect the two through a leap of imagination.  
      </p>
      <p>
        And there is necessarily duplicate maintenance involved, since both are busy changing (one of the items mentioned in <a href="CritiqueOfUseCases.html">CritiqueOfUseCases</a>).
      </p>
      <p>
        Use cases are not the only way to get the wishes out of the minds of the users - in former days, alert programmers created the user manual first.  The user manual is another place to get the customer to express "all and only" what they want. (where did I read that story recently about writing the user manual for 4 months, 2,000 LOC in the 5th month, and 20,000 LOC in the 6th month?).   --<a href="AlistairCockburn.html">AlistairCockburn</a>
      </p>
      <p>
        <a href="MichaelJackson.html">MichaelJackson</a> talks about this as the <em>informality</em> and <em>unboundedness</em> of the real world (and by implication the desires of human beings for computer systems to impact the real world) compared to the formality of software system descriptions.  See <a href="SoftwareRequirementsAndSpecifications.html">SoftwareRequirementsAndSpecifications</a>.
      </p>
      <p>
        As Michael shows, what you call the jump between the two is not just at design time.  It also occurs, inevitably, as we struggle to enter "real world data" into the running, formal system.  He uses a nice illustration from a Punch magazine cartoon many years ago where a railway porter is confronted by a "non-standard" animal a passenger wants to take on a train - a gerbil, say - and is looking at a rule book which only mentions dogs and cats.  The punchline: "your gerbil's a cat so you don't have to pay".
      </p>
      <p>
        <em>the actual text of the cartoon was</em>:
        Railway Porter (to Old Lady travelling with a Menagerie of Pets). "'STATION MASTER SAY, MUM, AS CATS IS 'DOGS,' AND RABBITS IS 'DOGS,' AND SO'S PARROTS; BUT THIS 'ERE 'TORTIS' IS A INSECT, SO THERE AIN'T NO CHARGE FOR IT!" [Punch, 1869, Vol. 57, p. 96]
      </p>
      <p>
        Which means that our systems always need to learn, to evolve, whatever level of abstration they have reached.  But I also entirely accept your point that the evolution will mean <em>duplicate maintenance</em> will always be required, looked at from this level.  OnceAndOnlyOnceDoesntScale in that sense.
      </p>
      <p>
        I also really like <em>there is a language of the user, there is a language of the programmer, and the programmer has to connect the two through a leap of imagination</em>.  This is indeed the designer's responsibility not the user's (which is why I prefer that term designer, although one day maybe I'll make the grade to <a href="JustaProgrammer.html">JustaProgrammer</a>) and simply cannot be reduced to rote or method in the conventional sense.
      </p>
      <p>
        --<a href="RichardDrake.html">RichardDrake</a> 
      </p>
      <hr/>
      <p>
        <em>This is so true and unobvious, Alistair, it needed to be said!</em>
      </p>
      <p>
        I disagree that traceability doesn't help. It does help when you fix a translation error and need to fix all the consequential mistakes generated downstream. I suppose that's why people do it.
      </p>
      <p>
        How do you deal with this problem? <a href="UseCases.html">UseCases</a> don't solve the problem because there is still the line to cross between Human and Computer. -- <a href="SunirShah.html">SunirShah</a>
      </p>
      <hr/>
      <p>
        When I wrote that traceability doesn't help, I was referring to the wish of some people that simply marking that requirementA lives in designElementX suddenly confers on the two the ability to stay in sync.  The two change, and the connecting lines change also (that makes three).
      </p>
      <p>
        I rely on that PeopleAreGoodAtLookingAround, to make the coarsest-grain traceability chart the people can get away with.  <a href="PhilGoodwin.html">PhilGoodwin</a> said about the same thing in <a href="CritiqueOfUseCases.html">CritiqueOfUseCases</a>. --<a href="AlistairCockburn.html">AlistairCockburn</a>
      </p>
      <hr/>
      <p>
        Perhaps it all comes down to IkiWisi, Ill Know It When I See It.
      </p>
      <p>
        Because there are the Two to which Alistair refers, they want to become One, the desire and the program meeting the desire. But the Two move, each affecting the other (gravitationally perhaps) and each affected by Others as well. They cannot become One, but they can become more nearly One.
      </p>
      <p>
        Part of the value of incremental development styles such as prototyping and XP is that by showing the Two to each other, both learn and change and become more nearly One.
      </p>
      <hr/>
      <p>
        To me it's more that in XP you keep the Imprecise in the spoken realm, which is much nimbler, and put the Precise (desire and implementation of desire) into code (tests and program source). Also, <a href="UserStories.html">UserStories</a> are very short, helping traceability (we can do it in our heads, 'cuz we were just looking at that code a short while ago). --Alistair
      </p>
      <p>
        You've captured something very important about XP and any LightweightMethod worthy of the name here Alistair.  In <a href="ControlledRapidEvolutionaryDelivery.html">ControlledRapidEvolutionaryDelivery</a> we called this principle <a href="DocumentToDeliver.html">DocumentToDeliver</a>. 
      </p>
      <hr/>
      <p>
        There is no translation.
      </p>
      <p>
        There are two parties struggling to collaborate. The designer's contribution is to be a leader in this joint effort, so that the system (whose specification (s)he owns) comes out satisfying the client's requirements. As MisterNameless above says, these Two are affected by their interchange. The designer can use many techniques to aid him/herself, for example creating a Business and System Vision in which the to-be system is in use in the client's to-be context, and working well.
      </p>
      <p>
        This kind of designer is often called a business analyst or system analyst, but the task is at least as much synthesis as analysis.
        --- <a href="BruceAnderson.html">BruceAnderson</a>
      </p>
      <hr/>
    </div>
  </body>
</html>