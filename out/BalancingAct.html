<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Balancing Act
      </h1>
      <p>
        puzzlecracker wrote:
      </p>
      <p>
        <em>Given ludicrously huge promulgation of   programming languages...</em>
      </p>
      <p>
        You might want to distinguish that promulgation between active languages and 
        archived ones. Much fewer languages are leading-edge.
      </p>
      <p>
        <em>...platforms, OS's, embedded systems etc., in which environment C++ is still the most useful and the predominant   language choice.</em>
      </p>
      <p>
        The programming world occupies a spectrum from embedded to distributed. From 
        bits inside registers in specific hardware, to active content like web pages 
        that can run in any generic device.
      </p>
      <p>
        <a href="CeePlusPlus.html">CeePlusPlus</a> is efficient, modular (roughly), typesafe (roughly), and more flexible & 
        maintainable than assembler. It is also statically-typed, and purely 
        compiled.
      </p>
      <p>
        Use C++ from the embedded level to the OS level to large, performance bound 
        systems.
      </p>
      <p>
        Use a higher level language to drive C++.
      </p>
      <p>
        For example, oggle my Flea:
      </p>
      <p>
        <img src="http://flea.sourceforge.net/balancingAct.png" />
      </p>
      <p>
        That program drives <a href="OpenGl.html">OpenGl</a> with several layers of stuff. At the lowest 
        layer, the microcode in the graphics chipset in my graphics card, C++ could 
        easily have been used to blast all the bits around in an image. C++ competes 
        directly with Assembly and <a href="MachineLanguage.html">MachineLanguage</a> because programs that are easy 
        to read and change can be faster than programs that force you to think of 
        the path of each bit.
      </p>
      <p>
        But maybe the microcode in my graphics chipset wasn't C++; the miracle of 
        encapsulation and drivers means I don't know if that layer is C++.
      </p>
      <p>
        At the next layer up, the OS drivers, including OpenGL, could have been 
        written in C++, and again they might not have been. The odds are very high 
        they were written in a C language, such as Standard C or GNU C.
      </p>
      <p>
        Next, the <a href="GraphicalUserInterface.html">GraphicalUserInterface</a> frame around my OpenGL is written in Qt, which is an exquisite and 
        elegant framework written in pristing C++...
      </p>
      <p>
        ...with one exception. Because C++ uses statically typed polymorphism 
        (polymorphism that requires inheritance), and because GUIs work best with 
        the Observer Pattern written in a dynamically typed language (a 
        message-based language like Smalltalk), TrollTech invented two new C++ 
        keywords, signals and slots, and added them to your compiler.
      </p>
      <p>
        The moral is the farther you are from the hardware, the more dynamism you 
        need.
      </p>
      <p>
        In the left panel of my user interface is a snip of Ruby code, which is a 
        very high-level language that competes with Perl and Smalltalk - but 
        certainly not Assembler. My Ruby code drives the commands that generate the 
        graphical primitive commands sent into OpenGL. So the Ruby code generates 
        the shape you see, and the OpenGL code renders it.
      </p>
      <p>
        This far from the metal, the efficiency of <a href="StaticTyping.html">StaticTyping</a> is less important 
        than the flexibility of <a href="DynamicTyping.html">DynamicTyping</a>. So when my system uses Ruby to 
        generate a shape, you don't need to recompile everything just to change the 
        shape.
      </p>
      <p>
        Similarily, if you write a database engine in C++, you drive it with SQL, a 
        soft dynamic and <a href="DeclarativeLanguage.html">DeclarativeLanguage</a>.
      </p>
      <p>
        All modules in a program must perform a balancing act between too much 
        typechecking and too little. Use C++ when those benefits are obvious.
      </p>
      <p>
        --<a href="PhlIp.html">PhlIp</a>
      </p>
      <hr/>
      <p>
        CategoryWhatever, See <a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a>
      </p>
    </div>
  </body>
</html>