<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Set Theory
      </h1>
      <p>
        Probably all you need to know about it is contained in <a href="http://www.ii.uib.no/~wagner/UASCR/UAPrelm.htm.">http://www.ii.uib.no/~wagner/UASCR/UAPrelm.htm.</a>
      </p>
      <p>
        But on a more practical level, I think all undergraduate Mathematics students learn it (I certainly did), so its basic concepts and notation are a well-known body of knowledge, more so than other branches of pure mathematics and logic (which you don't study unless you specialize in it). Therefore I think it is useful to us computer people.
      </p>
      <p>
        All the nice interesting foundation questions about whether mathematics is Set Theory, or whether there are any paradoxes, are kind of irrelevant to us.
      </p>
      <p>
        -- <a href="DanielPoon.html">DanielPoon</a>
      </p>
      <hr/>
      <p>
        <a href="SetTheory.html">SetTheory</a> underpins logic, which certainly is useful to programmers.
        For instance, quantifiers can be defined in terms of sets:
      </p>
      <code>
        <strong>forall</strong> x <strong>elem</strong> A (p(x)) <-> {x:x <strong>elem</strong> A ^ p(x)=<strong>true</strong>}=A<br/>
        <strong>exists</strong> x <strong>elem</strong> A (p(x)) <-> {x:x <strong>elem</strong> A ^ p(x)=<strong>true</strong>} =/= <strong>0</strong><br/>
      </code>
      <p>
        [It would be nice to have English versions of this syntax here]
      </p>
      <p>
        So if C is a set of Customers = {p,q,r} with credit limits L(p)=10K,L(q)=20K,L(r)=30K
        then 
      </p>
      <code>
        <strong>exists</strong> x <strong>elem</strong> C (L(x)>20K) <br/>
      </code>
      <p>
        is <strong>true</strong> using the above.
      </p>
      <p>
        <em>I assume in the above statement, the term "logic" means boolean mathematics. It is no more correct to say that boolean mathematics is based on Set Theory than to claim arithmetic is based on set theory. Each is its own separate branch of mathematics, based on different underlying assumptions. As each is intended to help explain real world issues, it should be no surprise that each produces similar results, but that does not imply a relationship.</em>  
      </p>
      <p>
        [we need to clarify what we understand by "based" and "relationship". By "based" I mean "can be defined/formalized by", "a foundation for". By "relationship" typically that means a verb or preposition linking subject and object. <strong>forall</strong> and <strong>exists</strong> (quantifiers central to formal logic) above have been defined in terms of set builder notation, part of <a href="SetTheory.html">SetTheory</a> therefore clearly there is a relationship if you accept it as accurate since "have been defined" is the verb phrase. One is defined in terms of the other hence "based". Set theory is also defined in terms of logic they are inextricably entwined for instance A <strong>intersect</strong> B = {x:x <strong>elem</strong> A ^ x <strong>elem</strong> B}. Set intersection is <strong>defined</strong> in terms of the logical operator "^" (and). Logic and Set definitions are MutuallyRecursive. As for arithmetic, numbers can be defined as sets:
      </p>
      <ol>
        <li>
           = {}
        </li>
        <li>
           = {{}}
        </li>
        <li>
           = {{},{{}}}
        </li>
      </ol>
      <code>
        ...<br/>
      </code>
      <p>
        Again related. The resemblances between each branch are more than superficial. The proofs of theorems in <a href="SetTheory.html">SetTheory</a> are a direct result of the properties of logical operators in the Set operator definitions.
      </p>
      <p>
        Example: The Logic statement ~(A v B) <-> ~A ^ ~B and the Set theoretic one 
        (A <strong>union</strong> B)' = A' <strong>intersect</strong> B' are both called De Morgan's Law. Coincidence?
        The definition of A' (complement) is {x:x <strong>elem</strong> U ^ ~(x <strong>elem</strong> A)}
        where U is the universal set in consideration. Also, equality in sets is defined A=B <-> A <strong>subset</strong> B ^ B <strong>subset</strong> A. 
        Defn subset: A <strong>subset</strong> B <-> (x <strong>elem</strong> A -> x <strong>elem</strong> B).
        De Morgan's as a Set equation has the (partial) proof:
      </p>
      <code>
        (A union B)' -> exists x elem (A union B)' -> ~(x elem (A union B))<br/>
        -> ~(x elem A) ^ ~(x elem B) -> x elem A' ^ x elem B' -> x elem (A' intersect B') <br/>
        -> (A union B)' subset A' intersect B'    <br/>
      </code>
      <code>
        Similarly, it can be shown A' intersect B' subset (A union B)' (I could write it out<br/>
        but I think the point is made) hence (A <strong>union</strong> B)' = A' <strong>intersect</strong> B'<br/>
        by the definition of set equality, QED. All the steps depend on the logical connectives.<br/>
      </code>
      <p>
        Of course, a student can learn a*(b+c)=a*b+a*c without knowing Sets, just as a programmer can make programs without learning <a href="DenotationalSemantics.html">DenotationalSemantics</a>, but as a theory the foundations are important. Have you never heard of Hilbert's Program? 
        (See <a href="http://plato.stanford.edu/entries/hilbert-program/)">http://plato.stanford.edu/entries/hilbert-program/)</a>
        Ultimately it could not be carried out completely in the form he proposed but certainly it is false that ~(<strong>exists</strong>Reln(R)(R(<a href="SetTheory.html">SetTheory</a>,Logic)^R(<a href="SetTheory.html">SetTheory</a>,Arithmetic)) ]
      </p>
      <p>
        Logic and sets are closely related, and the former is a prerequisite for the latter. In the same sense, arithmetic and sets are related, to the point where the former is usually defined completely in terms of the latter. In any case, though, the reference to quantifiers means that boolean logic isn't the thing under consideration.
      </p>
      <p>
        <em></em><a href="BooleanLogic.html">BooleanLogic</a> is just one type of logic - you seem to be referring to propositional logic, which has neither variables nor quantifiers. Predicate logic introduces quantifiers, and statements in mathematics are formalized using this. There is also the distinction between 1st, 2nd, omega order, temporal, modal (which introduces new quantifiers such as <strong>necessary</strong>, diamond and square boxes). Each logic retains features of the lower order ones, i.e., universal (<strong>forall</strong>) and existential quantifiers are still part of modal logic, as are the usual ~,^,-> etc. Quantifiers were only one example of a relation between logical connectives and sets. The alphabet, sentences, operators, semantics of logics can all be treated as sets and analysed with set theory (and lattice theory, which is defined using set theory). The latter you mention (sets) is also a prerequisite for the former (logic - hence mutual recursion). For instance proving <em>Every Hintikka set is quantificationally consistent</em> requires set theory even though it is a metatheorem in predicate logic.<em></em>
      </p>
      <hr/>
      <p>
        {x : some statement} is "Set Builder Notation" like a <strong>select</strong> in <a href="StructuredQueryLanguage.html">StructuredQueryLanguage</a> (SQL) allows you to create a set from other sets. So if S = {flowers, trees, ants, bees, chickens} then B = {x : x elem S ^ Insect(x)}
        means B = {ants,bees}. <a href="PrologLanguage.html">PrologLanguage</a> has a <strong>setof</strong> functor which lets you play with this on a computer (in a method closer to <a href="SetTheory.html">SetTheory</a> notation than SQL) for example:
      </p>
      <code>
        test :- <br/>
        setof(X,testStatement(X),B),<br/>
        write(B).<br/>
      </code>
      <code>
        testStatement(X) :-<br/>
        elem(X,[flowers, trees, ants, bees, chickens]),<br/>
        insect(X).<br/>
        insect(X) :-<br/>
        elem(X,[ants,crickets,wasps,bees,butterflies]).<br/>
        elem(X,S) :- member(X,S). %built in to most prologs<br/>
      </code>
      <hr/>
      <p>
        Set constructors can be nested for instance in the definition of a <strong>completely distributive lattice</strong>, if for all index sets S,T =/= {}
      </p>
      <code>
        <strong>/\</strong>{<strong>\/</strong>{x[s,t]|t <strong>elem</strong> T}|s <strong>elem</strong> S}=<br/>
        <strong>\/</strong>{<strong>/\</strong>{x[s,<strong>phi</strong>s]|s <strong>elem</strong> S}|<strong>phi</strong>:S -> T} <br/>
      </code>
      <p>
        where "[]" are subscripts and "f:A->B" is function mapping in this case also {x:statement} is written instead as {x|statement} i.e. "such that" is "|" not ":".
      </p>
      <hr/>
      <p>
        Looking at <a href="SetTheory.html">SetTheory</a> you can't help comparing CurlyBraces in it with programming if you use C++, Java, Perl etc. But the "{}" in those languages are really tuples, not sets - the order of statements in them is important, both for statement blocks and arrays. Somehow though
      </p>
      <p>
        int main()
        <
      </p>
      <code>
        printf("hello world\n"),<br/>
        return 0<br/>
      </code>
      <p>
        >
      </p>
      <p>
        Would not quite be the same.
      </p>
      <hr/>
      <p>
        <strong>ASCII-based Examples</strong>
      </p>
      <code>
        q = set(A B C D)<br/>
        r = set(B D E)<br/>
        s = set(B D)<br/>
        t = set(E D B)<br/>
        u = set(A C)<br/>
        v = set(B C D)<br/>
      </code>
      <code>
        union(q, r)<br/>
        .<br/>
        (A B C D E)<br/>
        .<br/>
        intersection(q, r)<br/>
        .<br/>
        (B D)<br/>
        .<br/>
        intersection(s, u)<br/>
        .<br/>
        ()  // the empty set<br/>
        .<br/>
        isSubset(r, q)<br/>
        .<br/>
        False<br/>
        .<br/>
        isSubset(s, q)<br/>
        .<br/>
        True<br/>
        .<br/>
        isSubset(t, r)<br/>
        .<br/>
        True<br/>
        .<br/>
        isSubset(r, t)<br/>
        .<br/>
        True<br/>
        .<br/>
        isSubset(t, t)<br/>
        .<br/>
        True         // The subset operator is not strict - a set<br/>
        // is always a subset of itself. (One can also<br/>
        // define a "strict subset" operator. Or one could<br/>
        // add "and not Equiv(...)".<br/>
        .<br/>
        minus(q, r)    // Also known as "complement"<br/>
        .<br/>
        (A C)<br/>
        . <br/>
        minus(r, s)<br/>
        .<br/>
        (E)<br/>
        .<br/>
        disjointUnion (t, v)  // all elements in either t or v, but not in both<br/>
        . <br/>
        (E C)<br/>
        .<br/>
        Equiv(r, t)<br/>
        .<br/>
        True<br/>
        . <br/>
        Equiv(r, s)<br/>
        .<br/>
        False<br/>
        .<br/>
      </code>
      <p>
        (Dots added because Mozilla browsers show too many blank lines between examples.)
      </p>
      <hr/>
      <p>
        Does anybody know what the minimum set of operations that is required? For example, in <a href="BooleanAlgebra.html">BooleanAlgebra</a> "NAND" can be used to define all the rest of the operations. Is there something equivalent for set operations?
      </p>
      <p>
        <em>Very little. I believe all you need is a complete logical system (not, and, or, if-then, if-and-only-if), either for-each or exists-such-that (either can be defined in terms of the other), and element-of. Although all other sets and operators can be defined in terms of these, some of them need axioms to prove that they exist.</em>
      </p>
      <p>
        Are you saying that there is a tight link between Boolean and Sets such that the first's determine the second's operations? If so, is there a Nand equivalent that can compose the others?
      </p>
      <p>
        <em>Not necessarily Boolean logic, but some type of logic, yes. The leading axiomatic set theory, Zermelo-Fraenkel, uses first-order logic, but as I said, all that's necessary are the basic logical operators, element-of, and either universal or existential quantification.</em>
      </p>
      <p>
        Well, sticking with the kind of operators shown above, what is the minimum set of these operators that can produce the others in combination?
      </p>
      <hr/>
      <p>
        'Does anybody know what the minimum <strong>set</strong> of operations that is required?' Applying set theory to set theory is always interesting. Because it ultimately means that we cannot really reason about set theory mathematically - only philosophically (see also <a href="StrangeLoop.html">StrangeLoop</a>). -- .gz
      </p>
      <p>
        That isn't true on several different levels. In the general sense, applying a theory to itself does not create a <a href="StrangeLoop.html">StrangeLoop</a>. One can discuss types of type theories without any circular dependencies of concept, and one can discuss sets of set theories similarly. In the more specific sense, one doesn't need to apply set-theory to talk about the 'set' of operations needed to describe a particular set-theory (since we wouldn't be using set-theory upon that set of operations).
      </p>
      <p>
        <em>That depends on whether "talking about" includes (possibly implicit) use of set-theory.</em>
      </p>
      <hr/>
      <p>
        Related: 
      </p>
      <p>
        <a href="SetsAndPolymorphism.html">SetsAndPolymorphism</a> <a href="RelationalDatabase.html">RelationalDatabase</a> <a href="ExtendedSetTheory.html">ExtendedSetTheory</a>
      </p>
      <hr/>
      <p>
        External References:
      </p>
      <ul>
        <li>
           Basic Set Theory
          <ul>
            <li>
               <a href="http://plato.stanford.edu/entries/set-theory/primer.html">http://plato.stanford.edu/entries/set-theory/primer.html</a>
            </li>
          </ul>
        </li>
        <li>
           History of Set Theory
          <ul>
            <li>
               <a href="http://www-groups.dcs.st-and.ac.uk/~history/HistTopics/Beginnings_of_set_theory.html">http://www-groups.dcs.st-and.ac.uk/~history/HistTopics/Beginnings_of_set_theory.html</a>
            </li>
          </ul>
        </li>
        <li>
           List of Topics - Set Theory
          <ul>
            <li>
               <a href="http://en.wikipedia.org/wiki/List_of_set_theory_topics">http://en.wikipedia.org/wiki/List_of_set_theory_topics</a>
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <p>
        <a href="CategoryMath.html">CategoryMath</a>
      </p>
    </div>
  </body>
</html>