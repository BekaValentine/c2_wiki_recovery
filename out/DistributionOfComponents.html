<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Distribution Of Components
      </h1>
      <p>
        [<a href="ComponentDesignPatterns.html">ComponentDesignPatterns</a> | <a href="CategoryPattern.html">CategoryPattern</a>]
      </p>
      <p>
        <strong>Context</strong>
      </p>
      <p>
        Some of the most difficult challenges that architects and builders face in the creation of enterprise- or Internet-scale software is how to determine where components should be located, and how to deal with change.  Changing requirements and technology climate make adapting and evolving software a complicated task.  This pattern provides helpful themes in the distribution of components during system construction and operation.
      </p>
      <p>
        <strong>Problem</strong>
      </p>
      <p>
        While the component-based approach to software construction provides many benefits and can facilitate rapid delivery, complexities in architecture, design, development, and operation make it difficult for builders and assemblers to compose software that always meet requirements.
      </p>
      <p>
        <strong>Forces</strong>
      </p>
      <ul>
        <li>
           Monolithic programs make code reuse difficult and make it hard for teams to coordinate change.
        </li>
        <li>
           Designing a new system or breaking an existing up into too many components can result in overly complex and defective systems.  <a href="BigBallOfMud.html">BigBallOfMud</a> often results.
        </li>
        <li>
           Too much application logic in the client application (also known as <a href="TooMuchGuiCode.html">TooMuchGuiCode</a>) increases complexity, hardening arteries and causing high blood pressure in fat laboratory mice.
        </li>
        <li>
           But totally thin clients that are completely dependent upon servers make these servers get really large and cause them to manage state for every client.  This results in distribution, scalability, and reuse problems.
        </li>
      </ul>
      <p>
        <strong>Solution</strong>
      </p>
      <p>
        Distribute the usage of components across all tiers of the application and:
      </p>
      <ul>
        <li>
           Build clients that reuse lots of smaller components that share connection resources to access application services.  Instances are typically created and destroyed often.  They are typically graphical in nature and do not communicate directly with other components; instead, glue is used to tie them together.
        </li>
        <li>
           Build servers that consist of a defined set of larger, reusable components plugged into an application infrastructure that supports fault tolerance, is scalable, and pools server-side connection resources with clients.  Instances are typically shared across many client sessions.  They are typically not graphical and communicate with other services and external legacy and data services.
        </li>
        <li>
           Wrap legacy systems, data services, and other external systems or data feeds with components.  Connection with these components can be shared to conserve resources.
        </li>
        <li>
           Distribute your components in terms of an architecture reference model such as the <a href="ThreeTierDistributionArchitecture.html">ThreeTierDistributionArchitecture</a>, the <a href="FourLayerArchitecture.html">FourLayerArchitecture</a>, or the peer-to-peer distribution architecture.
        </li>
      </ul>
      <p>
        <strong>Resulting Context</strong>
      </p>
      <p>
        An application consisting of a distribution of components can use a <a href="LayeredComponentFramework.html">LayeredComponentFramework</a> so that components can be built in terms of frameworks that raise programming to a higher level of abstraction.  This can be performed in any tier or layer of the component-based system.  A <a href="BypassableAbstraction.html">BypassableAbstraction</a> can allow programmers more freedom where custom development is required, and <a href="LocationTransparency.html">LocationTransparency</a> can be used when scalability and flexibility are required.  Disregard for component location can lead to assumptions in performance or reliability that can decrease the value of <a href="TransparentDistribution.html">TransparentDistribution</a>.  <a href="ProcessBoundary.html">ProcessBoundary</a> can be used in to closely analyze location dependencies and make decisions about the physical location of components early on in the project lifecycle.
      </p>
      <hr/>
      <p>
        Today, we see lots of applications with small visual components plugged into client-side user interfaces that are built in web pages, Visual Basic, Visual C++, Visual Cafe, Visual Age for Java, and many other development tools that facilitate <a href="ComponentBasedDevelopment.html">ComponentBasedDevelopment</a>.
      </p>
      <p>
        Increasingly, we're seeing more emphasis on server-side components as well.  They're not as fine-grained, usually bigger, and have a different kind of lifecycle and relation to their infrastructure and other components.  With the maturing of technologies like Java Servlets, <a href="EnterpriseJavaBeans.html">EnterpriseJavaBeans</a>, CORBA OTM, and <a href="MicrosoftDotNet.html">MicrosoftDotNet</a> (or will it be <a href="MicrosoftIndigo.html">MicrosoftIndigo</a> ?), it will become easier to plug in reusable server-side components. 
      </p>
      <p>
        Check out <a href="ServiceOrientedArchitecture.html">ServiceOrientedArchitecture</a> as an example of the latest (circa 2003) evolution in concepts related to deployment of technologies, and thereby lay out the components necessary for the delivery of services.
      </p>
      <p>
        <a href="DistributionOfComponents.html">DistributionOfComponents</a>, coupled with appropriate decisions regarding location and transparency of components, is an important basis for the rest of <a href="ComponentDesignPatterns.html">ComponentDesignPatterns</a>.
      </p>
      <hr/>
      <p>
        <a href="CategoryComponents.html">CategoryComponents</a>
      </p>
    </div>
  </body>
</html>