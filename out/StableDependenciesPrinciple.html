<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Stable Dependencies Principle
      </h1>
      <p>
        SDP:
      </p>
      <dl>
        <dt> </dt>
        <dd>The dependencies between packages should be in the direction of the stability of the packages. A package should only depend upon packages that are more stable than it is. (<a href="http://www.objectmentor.com/resources/articles/stability.pdf)">http://www.objectmentor.com/resources/articles/stability.pdf)</a></dd>
      </dl>
      <p>
        <strong>See also:</strong>
      </p>
      <ul>
        <li>
           Richard Riehle, ROAD, ???, (I can't remember the issue at this moment)
        </li>
        <li>
           <a href="ObjectOrientedSoftwareConstruction.html">ObjectOrientedSoftwareConstruction</a>
        </li>
        <li>
           Robert C. Martin, Object Oriented Design Quality Metrics: An Analysis of dependencies, ROAD, Vol. 2, No. 3, Sep-Oct, 1995.	
        </li>
      </ul>
      <hr/>
      <p>
        One of the <a href="PrinciplesOfObjectOrientedDesign.html">PrinciplesOfObjectOrientedDesign</a>. 
      </p>
      <p>
        In architecture (the kind with buildings), a <a href="LoadBearingWall.html">LoadBearingWall</a>
      </p>
      <hr/>
      <p>
        <strong>The definition of "stable"</strong>
      </p>
      <p>
        "Stable" roughly means "hard to change", whereas "instable" means "easy to change".  
      </p>
      <p>
        With those definitions, you don't want to maximize stability of all packages.  You need instable packages, or your software cannot change easily.  If you're doing your job well, the hard-to-change packages will be the ones you never need to change, and the easy-to-change packages will be the ones you have to change frequently.  The principle is that no package should be dependent on packages that are more likely to change than it is.
      </p>
      <p>
        <em>Is there any reason why one package would be inherently less likely to change than another?  Wouldn't it be reasonable to expect that lower level packages (which would have more users) to need more changes than higher level packages (which would tend to have fewer users)?</em>
      </p>
      <p>
        It may be reasonable to expect that, but it is not desirable.  High-level packages should <em>not</em> be dependent on low-level packages; see the <a href="DependencyInversionPrinciple.html">DependencyInversionPrinciple</a> and the <a href="StableAbstractionsPrinciple.html">StableAbstractionsPrinciple</a> for more on that point.  The whole point of the <a href="StableDependenciesPrinciple.html">StableDependenciesPrinciple</a> is that you want to avoid a situation where you have to make frequent changes to packages with lots of users.
      </p>
      <p>
        In practically any system, there is an unequal distribution of changes to various packages.  In fact, if all packages have fairly equal distributions of change, that's probably a sign of poor organization.  The reason is that many design decisions are based upon a desire to support likely changes while simultaneously providing stability.  Of course, trying to guess what kinds of changes are likely may not be possible, so if you don't know what types of changes are likely, it is best to wait and see what happens as the system evolves.
      </p>
      <hr/>
      <p>
        This allows us to manage the stability of packages. If we don't want to have to change or recompile a package very often then we must make sure that it doesn't depend on other packages that do change often. Conversely if we want to be able to change a package then we must ensure that other packages that we don't want to have to change don't rely on it.
      </p>
      <hr/>
      <p>
        This advice contradicts the <a href="RobertCecilMartin.html">RobertCecilMartin</a> definition of stability. Because he likes definitions that don't lead to arguments, he defines "stable" as "more incoming dependencies than unstable". (is there a Wiki Link to this ideal?) This can't lead to an argument over "which is more stable?" because you just count each thing's clients and see.
      </p>
      <p>
        The definition on this page can't apply. It would lead to everyone bunching up on the early leaders.
      </p>
      <p>
        <em>It is natural for people to make changes to packages that are easy to change, and to avoid changes to packages that are hard to change.  In doing so, they make the easy-to-change packages easier to change and the hard-to-change packages harder to change.  The principle provides a guideline for determining if things are getting worse or getting better as these natural tendencies take effect.  If things are getting worse, then some refactoring may be in order.</em>
      </p>
      <p>
        The <a href="DependencyInversionPrinciple.html">DependencyInversionPrinciple</a> says concretes should depend on abstractions. So a better principle than this page's would say "the more things depend on me, the thinner and more abstract I should be".
      </p>
      <p>
        <em>That's the </em><a href="StableAbstractionsPrinciple.html">StableAbstractionsPrinciple</a>, which is described in the same article.  Combine that with the <a href="StableDependenciesPrinciple.html">StableDependenciesPrinciple</a>, and we get the <a href="DependencyInversionPrinciple.html">DependencyInversionPrinciple</a> at a package level (according to Martin).<em></em>
      </p>
      <hr/>
      <p>
        <a href="CategoryModellingLawsAndPrinciples.html">CategoryModellingLawsAndPrinciples</a>
      </p>
      <p>
        <a href="http://www.sms4pleasure.com">http://www.sms4pleasure.com</a>
        <a href="http://www.articleabode.com">http://www.articleabode.com</a>
      </p>
    </div>
  </body>
</html>