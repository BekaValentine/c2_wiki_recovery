<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Types Are Not Types They Are Types
      </h1>
      <p>
        Look up <strong>type</strong> in the dictionary.
      </p>
      <code>
        <em>Verb:</em> to classify.<br/>
      </code>
      <code>
        <em>Noun:</em> the characteristic form, classification, of a group or class, representative form.<br/>
      </code>
      <p>
        [<a href="EditHint.html">EditHint</a>: Suggest changing this topic to TypesAreClassifications]
      </p>
      <hr/>
      <p>
        Once you've done that, stop making silly pages like about how TypesAreActuallyAnimalsWithBellsOnThem or TypesAreJustYellowPilonsOnTheRoad
      </p>
      <hr/>
      <p>
        Every mental/computation process could be defined as "classification" if one wants to. Without some way to separate what is not types from what is types, "classification" is insufficient for anything approaching rigor. In other words, "falsification" (<a href="FalsifyingExistenceOfTypes.html">FalsifyingExistenceOfTypes</a>). This page is merely a dumb taunt. --top
      </p>
      <p>
        Every computational process can be defined as "classification"?  What a ridiculous statement, unless you're playing <a href="HumptyDumpty.html">HumptyDumpty</a> and redefining the word "classification" once each for such things as transformations (e.g. substitution, lambda application) and communications (process of delivering information over a medium).  It is true that some processes are forms of classification (verb form): e.g. pattern recognition is among them.  Of course, since the issue is <a href="WhatAreTypes.html">WhatAreTypes</a>, it's abundantly clear that the concern is for the <strong>noun</strong> form of 'classification', and that <strong>NO</strong> mental or computational <strong>process</strong> qualifies (because ongoing processes are verbs).
      </p>
      <p>
        But, yes, it does seem this page is a dumb taunt.  How astute of you to so classify it.
      </p>
      <p>
        <em>Without a solid and consensus definition of "classification" I cannot confirm or deny your claims. Generally it is possible to view any noun as a verb and vise versa. And I view "dumb taunt" as an attribute of this page, not a classification. But without a solid and consensus def...</em>
      </p>
      <p>
        Dictionaries are, if nothing else, fine indicators of "consensus definitions" - albeit often over-general due to the unscoped nature of the English language.  Nonetheless, you should learn to use them.
      </p>
      <p>
        My dictionary informs me that classification indicates  IS-A relationship with a 'category' or 'class' (these generally being some sort of intensive or extensive grouping) on the right-hand side.  Saying the "page is (merely) a dumb taunt" says it's a member of the group of all dumb taunts.  
      </p>
      <p>
        <strong>Being</strong> a "dumb taunt" is <strong>also</strong> an attribute of the page.  States of being (naturally is-a relationships) are always classifications.  "dumb taunt" by itself is not an attribute at all; any attribute of any object is a proposition about the state of that object, and the explicit state of "being" is critical to completing such a proposition.    
      </p>
      <p>
        <em>Dictionaries are generally not designed for rigor. Attributes and classifications are interchangeable concepts, at least computer-wise. </em>
      </p>
      <p>
        Not all rigorous conclusions require rigorous definitions; one doesn't need, for example, the definition of 'classification (noun)' to be particularly rigorous to know for certain that it does not overlap the definition of 'transform (verb)'.  
      </p>
      <p>
        But logic certainly does require rigor, despite your apparent lack of it whenever you attempt to provide any.  Attributes and classifications, for example, aren't interchangeable concepts.  One can utilize a <strong>transformation in view</strong> to flip between them, but <strong>the ability to losslessly transform an A into a B and vice versa does not mean that A and B are equivalent or interchangeable</strong>.  It only means they are <strong>homomorphic</strong>.   Homomorphism is not sufficient for the ability to <strong>interchange</strong> concepts - i.e. to casually swap out A for B or vice versa.  To help make it clear with a concrete example: you can, without loss, transform between natural numbers and prime numbers and back (0<->2, 1<->3, 2<->5, 3<->7, 4<->11, etc. - just one function (homomorphism) out of infinite possible such mappings).  This does not mean you can casually swap out prime numbers for natural numbers; attempting to do so, for example, would break RSA.  I agree that attributes vs. classifications are homomorphic (any attribute can be transformed into a classification worded as being a member of the group of all things having that attribute, and I'll leave the reverse as an exercise), but concluding that they are therefore interchangeable is fallacy.
      </p>
      <p>
        <em>That's because the internal representation is being used, e.i., the insides of the block box.</em>
      </p>
      <p>
        And that excuses fallacy and lets you get away with pretending homomorphism implies interchangeability... how?  You speak of the "insides of the black box", but it remains that to make this "black box" work after internally trading out primes for naturals, you'd need to either <em>change them back</em> (reversing the view and transformation), or equivalently you'd need to otherwise transform the rest of the box (e.g. the RSA algorithm and how it processes all its other inputs) to work in the new paradigm.  Neither of these is 'interchangeability'.  Interchangeability is not: "Oh, sure!  You can exchange cog A for cog B!  All you need to do is change the rest of the machine, too!". --<a href="AnonymousDonor.html">AnonymousDonor</a>
      </p>
      <p>
        Lets explore the "transform" verb. If we view time as merely another dimension, then a "transform(foo)" function is merely a classification of "state change X at 11:52pm on 1/1/2008" or the like. It adds the classification of belonging to the new "state set" at (and after) the given time. The time-line can be viewed as just another set of classifications. All states and their times/duration can be represented by a graph (classification network). True, that's an awkward way for humans to work with state change (verbs), but convenience is not the goal here. --top
      </p>
      <p>
        What <em>is</em> your goal here?  Am I right in assuming your entire line of argument, in the end, amounts to: "I can view X as Y, therefore I can treat them the same and win this argument"?  Because that certainly seems to be the point you're aiming at.  But it was already shown that "X can be viewed as Y" - homomorphism (a transform in view) - does NOT make X and Y equivalent or interchangeable.  It seems to me that you're basing your entire line of reasoning on an assumption that is simply (mathematically, logically, and practically) incorrect.  Transformations in views are computationally and logically significant, and cannot be wished away with a little hand-waving.  Even if your (rather informal and speculative) claims about transform(foo) and the hand-wavy creation of graphs were granted, it remains that <em>"I can view 'transform' as a noun classification!"</em> does not make the two interchangeable, equivalent, or even usefully related.  (To get a <em>useful</em> relation, you MUST guarantee other properties than just a transform between views.  A good example is in the NP-Complete definition, which requires that the mapping take only polynomial time and guarantee the yes/no answer to the decision problem is identical across the transform.  But even utility does not imply equivalence or interchangeability.)
      </p>
      <ul>
        <li>
           Re "polynomial time". Measuring performance from a theoretical standpoint may be sticky or unknown. See <a href="AlgorithmicPerformance.html">AlgorithmicPerformance</a>. I suggest you find a better example.
        </li>
        <li>
           <em>Algorithms are categorized based on their worst-case performance relative to the size of their input, and it is sufficient to provide a polynomial-time algorithm to prove there is one both practically and theoretically.  The example is fine, and measuring absolute performance is a non-issue.  I suggest you avoid such negligent ignorance in the future.</em> 
        </li>
        <li>
           Even if timing was proven in some absolute, how would that make an NP-Complete algorithm a non-classifier?  
        </li>
      </ul>
      <p>
        Actually, if you have been operating on the invalid assumption that ability-to-transform is good enough for interchange or equivalence, I suspect that this would be a significant basis for many of our differing views on such things as subjectivity/objectivity and  relativism/absolutism. --<a href="AnonymousDonor.html">AnonymousDonor</a>
      </p>
      <p>
        If you know for sure its lossy, then provide at least one instance. Or, are you are saying it hasn't been proven non-lossy in a round-about hand-wavy way? Those are two different things. --top
      </p>
      <p>
        <em>Lossiness</em> isn't the issue at all.  The assumption that ability-to-transform implies ability for interchange or equivalence is invalid... even for lossless transforms.
      </p>
      <p>
        If you mean "different interface", then that does not necessarily mean "bad interface".  If you twist or force your view of "category" hard enough, then you may indeed be able to bump out certain interfaces to space/time interpretations.
      </p>
      <p>
        <em>This has nothing to do with "good" or "bad" interfaces.</em>  
      </p>
      <p>
        <em>You seem to believe (based on your comments here and elsewhere) that if you can 'twist' your view such that one thing looks the same as another, that they must be (in essence) the same (i.e. that conclusions you make about one can be applied to the other, and that they are 'interchangeable' for purposes of argument and application).  Given that you keep making statements that take this belief as an </em>'assumption<strong> (as though you think I believe it too), I feel as though you're not quite grasping what I've been trying to tell you.  I'll try again: </strong>This belief of yours is incorrect on every level: mathematical, theoretical, and in practical application to our own world.  I don't believe it, and you shouldn't either.<em>'  Believing that one view is interchangeable with another simply because you can perform a transform is about the same as believing that a bird in the bush is equivalent to a bird in the hand.  But it's patently untrue: a bird in the bush is neither equivalent to nor interchangeable with a bird in the hand.  The reason: it takes knowledge (skill), energy, time, and effort to turn a bird in the bush into a bird in the hand... even if the transform is 'lossless' because you can put the bird back in the bush.  Similarly, it takes knowledge (an algorithm), energy, time, and effort to 'twist' one view into another, and so two such views are NOT equivalent even if this 'twisting' is lossless.  This is true even before you consider other properties: market price, for example, varies quite a bit between bird-in-hand and bird-in-bush.  The properties of views are associated with the analyses one can perform on them and especially the relative costs of these analyses.</em>  
      </p>
      <p>
        <em>The issue of the chosen 'twist' being 'lossy' or 'lossless', 'useful' or 'useless', 'good' or 'bad' is completely irrelevant to this conclusion.  Heck, homomorphisms, such as prime numbers to natural numbers, are </em>'lossless by definition<strong>... and yet the well known homomorphism between natural and prime numbers (nth prime number) </strong>doesn't<em>' make prime numbers interchangeable with or equivalent to natural numbers.  You cannot 'interchange' prime numbers for natural numbers.  If you attempt to do so, you must </em>also<em> change out other big chunks of whatever black box you're sticking them into (e.g. RSA), which is the very opposite of being "interchangeable".</em>
      </p>
      <p>
        It is true that nothing is 100% exchangeable for another. That's a given because thing A is never exactly the same as thing B (unless they are different names for the same thing). They will always differ by at least one trait (and that trait may be location).  It's all a matter of context. In context things can be made interchangeable.
      </p>
      <p>
        Anyhow, let's get back to something more practical. What's an example of a programming construct that you can point to (like the dude below) and say with absolute certainty that its not a "classification".
      </p>
      <code>
        y = verb(x);<br/>
      </code>
      <p>
        It may be that our current implementation of "verb" uses iterative techniques to calculate "y", but there may be a non-iterative approach if we were smarter or knew more. Thus, we cannot tell by the definition of "verb()" alone whether its a classification or not.
      </p>
      <p>
        <em>Iterative vs. non-iterative approaches aren't relevant, and an action (verb application) is never a classification (noun form), and the two shouldn't be mixed up (</em><a href="EquivocationFallacy.html">EquivocationFallacy</a> to do so).<em></em>
      </p>
      <p>
        <em>Here are a few things that are absolutely not classifications:</em>
      </p>
      <ul>
        <li>
           generic evaluation (e.g. computing 1+1).  
        </li>
        <li>
           any communication (e.g. set cell A to 92; send Letter to Mom).  
        </li>
        <li>
           general values (e.g. 3)
        </li>
      </ul>
      <p>
        <em>Some specific values qualify as classes or classifications, but keep in mind that "the class of all things equal to three" is not interchangeable with "the value three".</em>
      </p>
      <hr/>
      <p>
        <em>Re: But logic certainly does require rigor, despite your apparent lack of it whenever you attempt to provide any.</em>
      </p>
      <p>
        If your logic is really boolean logic, I'd suggest you try presenting it that way (along with the usual written descriptions). I doubt it really is. --top
      </p>
      <hr/>
      <p>
        <img src="http://z505.com/images/sideflag.jpg" />
        As the music plays . . . <em>Just take that old record off the shelf!!</em>
      </p>
      <p>
        So <em>this</em> is what <a href="MentalMasturbation.html">MentalMasturbation</a> looks like?
      </p>
      <p>
        <em>At its worst.  :-)</em>
      </p>
      <p>
        And I thought that was a logo on his pants. I don't wanna even see his "Double" and "Float" type.
      </p>
    </div>
  </body>
</html>