<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Language Is An Os
      </h1>
      <p>
        From <a href="OperatingSystem.html">OperatingSystem</a>
      </p>
      <p>
        The <a href="LanguageIsAnOs.html">LanguageIsAnOs</a> -- for languages that were designed to run without benefit of an independent <a href="OperatingSystem.html">OperatingSystem</a>.
      </p>
      <p>
        The development environment of the language is the entire <a href="OperatingSystem.html">OperatingSystem</a>.
      </p>
      <p>
        <em>Also known as "</em><a href="PinkyAndTheBrainLanguage.html">PinkyAndTheBrainLanguage</a>s".<em></em>
      </p>
      <hr/>
      <ul>
        <li>
           the <a href="OberonLanguage.html">OberonLanguage</a>
        </li>
        <li>
           the <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> (quite recently <a href="SqueakSmalltalk.html">SqueakSmalltalk</a> does it again, but see <a href="SmalltalkSecurity.html">SmalltalkSecurity</a>)
        </li>
        <li>
           <a href="EmacsLisp.html">EmacsLisp</a> -- (doesn't Emacs always need a host OS? <em>Emacs </em>is<em> the OS.</em>)
        </li>
        <li>
           the <a href="ForthLanguage.html">ForthLanguage</a> -- has standard block read and write words (functions) instead of a file system.  Often works as a tiny OS for microcontrollers which don't need many services. See <a href="ColorForth.html">ColorForth</a> and ForthOs ( <a href="http://ForthOs.org/">http://ForthOs.org/</a> )
        </li>
        <li>
           PC versions of <a href="BasicLanguage.html">BasicLanguage</a> in the late '70s & early '80s:  <a href="MicroSoft.html">MicroSoft</a>'s BASIC for the IBM-PC, Apple II BASIC, PET, Commodore 64, TRS-80, etc...
        </li>
        <li>
           the <a href="LispLanguage.html">LispLanguage</a> had <a href="LispMachine.html">LispMachine</a>s, which were a commercial success for a while
        </li>
        <li>
           the <a href="SchemeLanguage.html">SchemeLanguage</a> (<a href="MzScheme.html">MzScheme</a> can run on bare hardware)
        </li>
        <li>
           <a href="JavaLanguage.html">JavaLanguage</a> -- most versions live on top of an OS, but it wraps or implements every OS feature it supports.
        </li>
        <li>
           <a href="AdaLanguage.html">AdaLanguage</a> (notoriously difficult to port because of strict definition of features, such as multithreading, which are traditionally the domain of the OS and implemented differently on many different systems)
        </li>
        <li>
           <a href="UcsdPascal.html">UcsdPascal</a> <em>really?  what on?</em> On several systems, including the <a href="AppleIi.html">AppleIi</a>. See <a href="UcsdPascal.html">UcsdPascal</a> for details. Once a system booted UCSD Pascal, it could read and write Pascal-formatted disks, which were mutually unintelligible to other OSes.
          <ul>
            <li>
               <a href="ExBase.html">ExBase</a> (<a href="FoxPro.html">FoxPro</a>, dBASE)
            </li>
          </ul>
        </li>
        <li>
           <a href="RubyLanguage.html">RubyLanguage</a> (just try irb).
        </li>
      </ul>
      <p>
        However, the following languages are generally not thought of as <a href="LanguageIsAnOs.html">LanguageIsAnOs</a>:
      </p>
      <ul>
        <li>
           <a href="CeeLanguage.html">CeeLanguage</a>.  What most versions of Unix are implemented in, including <a href="LinuxOs.html">LinuxOs</a>
        </li>
        <li>
           <a href="CeePlusPlus.html">CeePlusPlus</a>.  What much of Windows is written in (allegedly), as well as <a href="BeOs.html">BeOs</a>(?)
        </li>
        <li>
           <a href="ObjectiveCee.html">ObjectiveCee</a>.  What much of <a href="NextStep.html">NextStep</a> (and the GUI part of <a href="MacOsx.html">MacOsx</a>) is written in
        </li>
        <li>
           <a href="AssemblyLanguage.html">AssemblyLanguage</a>.  What systems programs were written in before C came around.
        </li>
      </ul>
      <hr/>
      <p>
        The main difference I see in the above 2 groups is:
        Most of the first group allow you to
      </p>
      <ul>
        <li>
           type in a short function on the same command line that you would use to run a program
        </li>
        <li>
           immediately run it out of RAM.
        </li>
      </ul>
      <p>
        The second group of languages require you to run programs by
      </p>
      <ul>
        <li>
           start a text editor
        </li>
        <li>
           type in the short function
        </li>
        <li>
           save the file to disk, give it a name
        </li>
        <li>
           compile it from the command line (using some compiler that's *not* built into the OS)
        </li>
        <li>
           run the executable from the command line.
        </li>
      </ul>
      <p>
        Is that the difference that was intended, or do you mean something different by "<a href="LanguageIsAnOs.html">LanguageIsAnOs</a>"?
        -- <a href="DavidCary.html">DavidCary</a>
      </p>
      <hr/>
      <p>
        There's another view though. ALL languages, whether or not they were designed to run on bare hardware, should be considered and evaluated as operating systems. A language that makes up a bad operating system is simply a bad language. See <a href="LanguagesAreOperatingSystems.html">LanguagesAreOperatingSystems</a>
      </p>
      <p>
        <em>This metric for language quality seems to focus mostly on the scope of the language's API/features, rather than on the inherent qualities of the language itself.  Simply abstracting everything under the sun doesn't necessarily make a language good--IMHO </em><a href="JavaLanguage.html">JavaLanguage</a> has gotten a bit too big simply because <a href="SunMicrosystems.html">SunMicrosystems</a> has been trying to do exactly that.  Does a programming language need (as part of the language standard itself) such things as multimedia rendering libraries, system administration/user management libraries, etc. to qualify as a "good" language?  I think not.  It certainly should be possible to <em>build</em> such things in any language; however <a href="SeparationOfConcerns.html">SeparationOfConcerns</a> suggests that many such things should be left for other <a href="DomainExpert.html">DomainExpert</a>s to build--rather than stuffing them in the language itself.<em></em>
      </p>
      <p>
        <em>You will notice C/C++ added to the list above.  This is not to suggest that these are necessarily good languages; the limitations and weaknesses of both are well-chronicled and I don't wish to repeat that </em><a href="FlameWar.html">FlameWar</a> here.  However--entire <strong>production-quality</strong> operating systems are implemented in these.  It is true that users of such operating systems are not presented with a console (or a BrowserWindow) where they can start entering C/C++ code (as the preferred method of accessing and mutating the underlying OS).  But I say BigDeal.  One can certainly access all of the features of the OS through these languages (of course, additional APIs beyond the language standard library are needed--which makes portable C/C++ code more difficult to write) should one choose to do so.  Most <a href="EndUser.html">EndUser</a>s aren't interested in programming anyway; and aren't likely to care what language(s) an OS is written in.<em></em>
      </p>
      <p>
        <em>There seems to be a large amount of confusion between the needs of the </em><a href="EndUser.html">EndUser</a> (who wants to get work done; work which for most users involves <strong>no</strong> writing of code) and the needs of the developer (who wants to be able to write, test, and debug code as fast as possible).  The LanguageAsAnOs theory seems to be oriented towards developers<em></em>
      </p>
      <p>
        <em>Finally, to round out my point, the list above also contains such things as Forth and various BASICs for 8-bit micros.  While BASIC might well have been the default "shell" for your </em><a href="AppleTwo.html">AppleTwo</a> or <a href="CommodoreSixtyFour.html">CommodoreSixtyFour</a>--all such dialects of BASIC were truly horrible languages, which I wouldn't want to inflict on anybody.<em></em>
      </p>
      <p>
        --<a href="ScottJohnson.html">ScottJohnson</a>
      </p>
      <p>
        "Getting work done" almost always involves programming of some generality, or at least tasks which are highly programmable. 
      </p>
      <p>
        <em>"Almost always" is far too strong.  Many user tasks; such as playing games, writing letters, balancing a checkbook, producing presentations, downloading pictures off of the digital camera and publishing them on the Web, etc. involve little or no programming at all.  At least not programming in the way I think of it.</em>
      </p>
      <p>
        But there is almost never any gentle introduction to programming. Emacs might be the exception that proves the rule.
      </p>
      <p>
        <em>Lots of other exceptions.  Spreadsheets are a common one, it is often said that </em><a href="MicrosoftExcel.html">MicrosoftExcel</a> is the world's most widely used <a href="FunctionalProgrammingLanguage.html">FunctionalProgrammingLanguage</a> (I will neither agree or disagree with that statement here).  Production of document templates might also be considered programming of a sort--no knowledge of a programming language is needed here, either.<em></em>
      </p>
      <p>
        Instead of providing an environment with a gentle immersion to programming, you provide contempt for any mere "user" who demands to be able to perform those tasks without immersing themselves in a foreign programming language. 
      </p>
      <p>
        <em>Not at all.  I have the utmost respect, not contempt, for a user who wishes to learn programming.  Many users, do not.  A well-designed </em><a href="OperatingSystem.html">OperatingSystem</a> should allow laypersons to effectively use the computer without knowing the guts of how it works.<em></em>
      </p>
      <p>
        <em>Folks who drive cars would do well to know how to perform basic maintenance tasks, such as filling the gas tank, replacing a flat tire, or changing the oil.  However, most drivers need not know how to rebuild an engine.</em>
      </p>
      <p>
        Imagine the nerve; a foreigner, a <em>tourist</em>, who demands us he be able to get around a French city without learning the native language, history, and architectural principles! Why, if we allowed mere users to program, pretty soon we'd have <em>casual</em> programmers!
      </p>
      <p>
        <em>Whoever said anything about prohibiting users from programming (or about erecting knowledge </em>BarriersToEntry, to keep users away).  I never did.<em></em>
      </p>
      <p>
        In many people's minds, there is a sharp dichotomy between "users" and "developers" but in reality there is only a continuum. I speak as a user since I am not a developer. -- <a href="RichardKulisz.html">RichardKulisz</a>
      </p>
      <p>
        <em>Agree about the continuum.  I am a competent developer (at least I, and my boss, thinks so); however when I'm in </em>UserMode I can be just as lazy as the next guy.<em></em>
      </p>
      <p>
        <em>--</em><a href="ScottJohnson.html">ScottJohnson</a><em></em>
      </p>
      <p>
        An ordinary driver can learn to maintain their car on an incremental basis. First they learn to replace tyres, then the oil, then the spark plugs, and so on. Everything in the car is Object-Oriented. And this isn't due to cars being made of physical objects since "organic" systems like biological cells, houses and cities are not at all OO. Moreover, the car presents a continuum of complexity to its users. There exists a legitimate and good reason to learn about cars <em>at every step of the learning curve</em>. Additionally, <em>the slope of the learning curve is not steep</em> initially, and only as you get into more complicated repairs do you start needing to know more and more about advanced shop techniques. The ultimate constraints to home auto repair are financial and not intellectual. Most people don't have the money to install a complete machine shop at home.
      </p>
      <p>
        This is not the case with either Unix or C/C++. One either understands the system internals or one doesn't. Yes, you are able to "do many things" in Unix but that means nothing. To paraphrase: Ordinary people are amazed at how far computer science has come. People in the know are amazed how far it hasn't.
      </p>
      <p>
        For instance, it isn't possible to inspect and toy with Unix system internals like you can with Smalltalk, even if you have sufficiently high privileges. (Don't lecture me about OS security.)
      </p>
      <p>
        Similarly, one either understands C++ or one doesn't, I sure as hell don't.
      </p>
      <hr/>
      <p>
        <em>Inserting text in the middle of an argument actually seems to be a common </em>WikiParadigm.  Or at least that's been my experience.<em></em>
      </p>
      <p>
        (Unless you have someone who's as good a systems analyst as I am, and as confident in their own abilities as I am, none of the participants ever integrates the thread successfully as it evolves and nobody ever wants to integrate it after it's evolved into a huge daunting <a href="ThreadMess.html">ThreadMess</a>. So unless you have me on the scene, it's pretty much an antipattern.)
      </p>
      <p>
        See "Quote and respond" in <a href="HowToWriteAndEditThreadMode.html">HowToWriteAndEditThreadMode</a>.
      </p>
      <hr/>
      <p>
        Things to think about, though not exactly relevant:
      </p>
      <p>
        <em>[T]here is much to learn from Linux (and Linus), and I'm not referring to the technology which makes up Linux (which contains little that is new, after all).</em>
      </p>
      <hr/>
      <p>
        Self was abandoned in favour of Java due to its lack of a C style syntax. <a href="WorseIsBetter.html">WorseIsBetter</a> and compatibility all over again.
      </p>
      <hr/>
      <p>
        Making a system that replaces the entire OS is *much* simpler now that the <a href="GrandUnifiedBootloader.html">GrandUnifiedBootloader</a> exists. <em>But what about the hardware? Isn't it a major headache to have to be compatible with the bewildering array of PC hardware combinations? I hear that something called </em><a href="OsKit.html">OsKit</a> can help, but personally I'm designing my own hardware in my <a href="CopiousFreeTime.html">CopiousFreeTime</a> ? madness!<em></em>
      </p>
      <hr/>
      <p>
        This issue became obvious to me when a software tool based on top of Java had a daylight-savings bug in it (due to changes legislation). The time was right on the OS (Windows or Unix), but wrong in the Java engine. But the software tool that used Java was not tested on the Java version that had the fix, so I had to put in a fudge factor. Hopefully next year I can install the newer Java engine, or else someone will have to add another fudge factor.
      </p>
      <hr/>
      <p>
        This is something that occurred to me when I was using <a href="RubyLanguage.html">RubyLanguage</a> irb, too.  In my brief fling with <a href="RubyLanguage.html">RubyLanguage</a>, my reflex was to install Ruby via Debian's package management system.  Silly me!  It turns out that Rubyists like to be on the cutting edge, while Debianistas (and package maintainers in general, to a lesser extent) like stable systems.  If you want the latest, it's utter madness to try to install Ruby via package manager.  Ruby not only has a package manager, but it can handle multiple versions of Ruby as well (in case you're stuck maintaining an old project, but you want to start a new one using the latest in cutting-edge technology).
      </p>
      <p>
        This got me to thinking about how Ruby isn't the only system that has package management:  <a href="PythonLanguage.html">PythonLanguage</a>, <a href="PerlLanguage.html">PerlLanguage</a>, <a href="CommonLisp.html">CommonLisp</a>, and <a href="HaskellLanguage.html">HaskellLanguage</a> (I think) also have this, as well as many others.  And it isn't a stretch to think about how, even when each of these languages reach out to the OS to do things, it's no different than the OS reaching out to the BIOS (or to the computer directly) to do its magic.  And if you *really* think about it, each and every bit of code written to do something, is an extension of that language--so Unix is as much an extension of C as C may be a language running on Unix.
      </p>
      <p>
        While it would be difficult to do, conceptually, there's nothing stopping us from taking a given language, creating a run-time prompt of some sort for it, and then putting it on a computer to run all by its lonesome.  Thus, the line between OS and language is indeed a blurry one--at least, it's as blurry as you want (or need) it to be!  --Alpheus
      </p>
      <hr/>
      <p>
        There's also the case of <a href="AppleScript.html">AppleScript</a> on classic Mac OS. In addition to being a language in which to script GUI apps, it and Script Editor could also be used as a CLI on this otherwise CLI-less operating system (not to mention MPW and Commando). There was also an app that provided a hotkey popup window thing that let you type in lines of <a href="AppleScript.html">AppleScript</a>. 
      </p>
      <hr/>
      <p>
        <a href="CategoryOperatingSystem.html">CategoryOperatingSystem</a>
      </p>
    </div>
  </body>
</html>