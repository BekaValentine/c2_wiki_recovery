<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Wishful Thinking
      </h1>
      <p>
        Make a wish and (probably) it will become true.
      </p>
      <p>
        The only problem is that the person who is making the wish does not realize that his wish (may not) come true and accept his own thoughts as facts.
      </p>
      <hr/>
      <p>
        Or ... how about "decide that something <em>has</em> occurred, and it probably will."
      </p>
      <p>
        Occasionally, it already did.
      </p>
      <p>
        I have too much anecdotal (first-hand) evidence to dismiss this as nonsense.
      </p>
      <hr/>
      <p>
        Another example, via <a href="BuildForTheFuture.html">BuildForTheFuture</a> - "sure, we're selling at a loss, but we'll make it up in volume."  Scary part is, I <em>knew</em> and worked with several dot-coms that literally ran off this philosophy.
      </p>
      <hr/>
      <p>
        "Wishful Thinking" has also a positive meaning. It is a general technique for abstract thinking:
      </p>
      <p>
        Accepting that a component (class, module, ...) works without having seen its implementation, maybe even without <em>having</em> an implementation.
      </p>
      <p>
        This is taught very intensively in "Structure and Interpretation of Computer Programs" (<a href="http://www.swiss.ai.mit.edu/classes/6.001/abelson-sussman-lectures/).">http://www.swiss.ai.mit.edu/classes/6.001/abelson-sussman-lectures/).</a>
      </p>
      <p>
        Two examples from the video lectures follow.
      </p>
      <hr/>
      <p>
        "Wishful Thinking" is a very powerful programming practice:
      </p>
      <p>
        Before implementing a component you write some of the code that <em>actually uses</em> it.  This way you discover what functions with what parameters you really need, which leads to a very good interface.  You will also have some good test code for your component.
      </p>
      <p>
        The idea is based on the fact that an interface's purpose is to simplify the code that <em>uses</em> the component, not to simplify the code that <em>implements</em> it.
      </p>
      <hr/>
      <p>
        "Wishful Thinking" is a good way to think about recursion:
      </p>
      <p>
        When seeing a recursive call, you should not think about the code being executed on each sub call.  Instead, just imagine that the sub call does its job correctly.
      </p>
      <p>
        Thus, you prove the correctness of the function by assuming that it is correct (on simpler input).  This is some positive kind of self-fulfilling prophecy.
      </p>
      <p>
        Of course you still have to check for trivial cases and need to assure that the recursive call handles a simpler case of your problem.  But those are minor issues.  The hardest part is to understand the recursive calls.
      </p>
      <p>
        Without the technique of wishful thinking, you can't handle problems like "Towers of Hanoi", let alone more complicated ones.
      </p>
      <hr/>
      <p>
        <a href="https://news.ycombinator.com/item?id=5765270">https://news.ycombinator.com/item?id=5765270</a>
      </p>
      <p>
        Also kind of related - programming by "wishful thinking". You first lay out the flow of the program as calls to high level functions which don't yet exist, and then go back and fill in the functions as you can. The first few SICP video lectures are all about this style, and I found the idea simple but very useful to avoid trying to hold too much of a problem in your head at once.
      </p>
      <p>
        Yes, exactly. By writing pseudocode, I end up writing business code rather than implementation code, which inherently assumes the a high-level interface to the nitty-gritty details. This leads to an approach where the idea is expressed at a high level first, rather than getting stuck in the implementation details of some small piece of the problem.
      </p>
      <p>
        Code is a planning language, so rather than boxes and noodles or pseudocode, I tend to sketch out my plans in code itself. In SICP this is called "design by wishful thinking": you pretend that you already have a library of primitives that do the nitty-gritty work and write the high-level bits of your program using those primitives. Then, you go back and implement the primitives.
      </p>
      <p>
        Indeed, the "design by wishful thinking" was a real eye opener for me. It is one of my favourite parts of SICP. It can also be explained as way to postpone decision you can't clearly make right now. First, you pretend to have made the decision, and later on you implement the decision "you wish you had made".
      </p>
      <hr/>
      <p>
        Also apropos design/programming by <a href="WishfulThinking.html">WishfulThinking</a>: 
      </p>
      <dl>
        <dt> </dt>
        <dd><em>It is the user who should parameterize procedures, not their creators.</em> - AlanJPerlis, Epigram #76 (<a href="EpigramsInProgramming.html">EpigramsInProgramming</a>)</dd>
      </dl>
      <hr/>
      <p>
        See also: <a href="WishfulThinkingCausesBadLuck.html">WishfulThinkingCausesBadLuck</a>
      </p>
    </div>
  </body>
</html>