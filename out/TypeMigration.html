<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Type Migration
      </h1>
      <p>
        I don't know if there is a better term in the literature... but <a href="TypeMigration.html">TypeMigration</a> occurs when an object which is initially of one type changes (through some operation) to an object of a different type.  Many languages don't have this--an object's type is generally considered an immutable property of the object.
      </p>
      <p>
        Useful in the real world; as many physical objects change state over time, and some of these state changes are significant.  (Indeed, it can be argued that the distinction between an object's "type" and its "state" is artificial--<a href="ThereAreNoTypes.html">ThereAreNoTypes</a>).  That said, <a href="TypeMigration.html">TypeMigration</a> is difficult in languages with <a href="StaticTyping.html">StaticTyping</a>; even many dynamically-typed languages don't let you add/delete features from an object after construction.
      </p>
      <p>
        For instance, when an Integer counter overflows in <a href="SchemeLanguage.html">SchemeLanguage</a>, it is automatically type-migrated to a <a href="BigNum.html">BigNum</a>, and the counter keeps on counting.
      </p>
      <ul>
        <li>
           This is similar, but not true <a href="TypeMigration.html">TypeMigration</a>; Integers and <a href="BigNum.html">BigNum</a>s are both <a href="ValueObject.html">ValueObject</a>s, so what is happening here is the addition function is returning an object of a different type.  
        </li>
      </ul>
      <p>
        (That said--the distinction between type and state is artificial mainly from a semantic point of view; from an implementation point of view the distinction becomes significant).
      </p>
      <p>
        If you think of an object's type as its collection of behaviors, the <a href="RubyCoerce.html">RubyCoerce</a> page tells a saga of what might be considered <a href="TypeMigration.html">TypeMigration</a>. The saga ends with variations of the subtraction operator for a Rectangle getting swapped.
      </p>
      <hr/>
      <p>
        Related to this is the type migration of values in relational operators. Comparing two reals for equality results in a boolean.  <em>No; that's just the behavior of the operator in question; neither of the reals becomes a boolean.  Only the result is a boolean.</em>
      </p>
      <p>
        So you'd say that multiplying two floats together doesn't retain the original type, it's "just" the behavior of the operator? What are you looking for here, a definition wherein the value remains identical but the type changes? (This is on thin ice without a formal definition of "identical value".)
      </p>
      <p>
        I'll buy that, but are we now using private terminology, or is "type migration" with this definition some kind of widely used phrase in the industry?
      </p>
      <p>
        (I'm familiar with the Scheme/Lisp mechanism, but I don't recall if this phrases is standardly used to describe it.)
      </p>
      <p>
        <em>Also related, but not identical, is </em>TypeCoercion--when an object of one type <em>T1</em> is used in a context where an object of another type <em>T2</em> is expected, and the language than creates a new object of type <em>T2</em> which is somehow equivalent to the object of type <em>T1</em>.<em></em>
      </p>
      <hr/>
      <p>
        Also see <a href="SystemMutation.html">SystemMutation</a> and <a href="RuntimeTypeMutability.html">RuntimeTypeMutability</a>, <a href="TypeRefinement.html">TypeRefinement</a>, <a href="SchemaEvolution.html">SchemaEvolution</a>.
      </p>
    </div>
  </body>
</html>