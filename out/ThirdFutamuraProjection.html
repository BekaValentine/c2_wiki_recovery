<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Third Futamura Projection
      </h1>
      <p>
        <a href="PartialEvaluation.html">PartialEvaluation</a> to the third order, with communications support.
      </p>
      <p>
        The 3rd projection is what you get when a partial evaluator (specializer) applies itself to itself. The output is a CompilerCompiler, a program which takes as input an interpreter and produces as output a compiler.
      </p>
      <ul>
        <li>
           <a href="http://blog.sigfpe.com/2009/05/three-projections-of-doctor-futamura.html">http://blog.sigfpe.com/2009/05/three-projections-of-doctor-futamura.html</a>
        </li>
      </ul>
      <p>
        Currently they are not very efficient. A hand-written CompilerCompiler is usually more efficient than one produced by specializing the specializer on the specializer, and hand-written compilers are usually more efficient than compilers output by a CompilerCompiler, regardless of whether it was hand-written or generated.
      </p>
      <p>
        A CompilerCompiler is still very useful though, since it is usually easier to write an interpreter than a compiler, but interpeters are usually slower than compilers. With a CompilerCompiler, you can have your cake and eat it too.
      </p>
      <p>
        Additionally, you can chain languages together. For example, suppose you write an interpreter for a high level language in a low level language. Then you write an interpreter for a higher level language in the high level language. Normally the highest level language would be very very slow, due to multiple layers of interpretational overhead. But multiple applications of a CompilerCompiler can remove most of that interpretational overhead, and so you get the expressiveness of a high level language but the performance of a low level language. Dybkjaer used this approach to write programs in the ultra high level language of category theory.
      </p>
      <p>
        The language chaining technique is also extremely useful for domain specific languages, which are usually too special purpose to warrant the effort of creating a compiler for that language. Morgensen, for instance, used partial evaluation techniques to compile ray-tracing scenes, and got an 8-12x speedup.
      </p>
      <hr/>
      <p>
        <a href="CategoryTypeTheory.html">CategoryTypeTheory</a>
      </p>
    </div>
  </body>
</html>