<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Joy Language
      </h1>
      <p>
        Joy is a purely functional programming language devised by <a href="ManfredVonThun.html">ManfredVonThun</a>. Whereas all other functional programming languages are based on the application of functions to arguments, Joy is based on the composition of functions. Every Joy function is unary, taking a stack as argument and producing a stack as value. Consequently much of Joy looks like ordinary postfix notation. In Joy's syntax, composition of functions is simply concatenation of the text of the functions. For this reason, Joy can be referred to as a <a href="ConcatenativeLanguage.html">ConcatenativeLanguage</a>.
      </p>
      <p>
        See <a href="http://www.latrobe.edu.au/phimvt/joy.html">http://www.latrobe.edu.au/phimvt/joy.html</a> (Official site), but also mirrored (mostly) at <a href="http://www.kevinalbrecht.com/code/joy-mirror/">http://www.kevinalbrecht.com/code/joy-mirror/</a>
      </p>
      <hr/>
      <p>
        So, for example, in the program fragment
      </p>
      <ol>
        <li>
           4 +
        </li>
      </ol>
      <ol>
        <li>
           denotes the function which pushes 3 onto a stack, similarly for 4, and + denotes the function which replaces the top two values on a stack with their sum. 3 4 + is their composition [which in traditional mathematical notation might be denoted "lambda s . +(4(3(s)))"], and is equivalent to the function 7.
        </li>
      </ol>
      <p>
        -- <a href="ThomasColthurst.html">ThomasColthurst</a>
      </p>
      <hr/>
      <p>
        something I wrote.. which I'm not quite sure is correct.
      </p>
      <code>
        (* x y percent approxEqual *)<br/>
        DEFINE approxEqual == 100.0 / rotate [0 =] [pop] [dup rolldown - swap /] ifte > .<br/>
      </code>
      <p>
        -- <a href="ShaeErisson.html">ShaeErisson</a>
      </p>
      <hr/>
      <p>
        <em>So... was the language so named because it's a joy to use, or was it named after </em><a href="BillJoy.html">BillJoy</a>?<em></em>
      </p>
      <p>
        <em>-- </em><a href="ScottJohnson.html">ScottJohnson</a><em></em>
      </p>
      <hr/>
      <p>
        It algebraic properties are so clean that I argue that either Joy or a Joy derivative must cosmically speaking rule the programming world.
      </p>
      <p>
        Why? 
      </p>
      <ol>
        <li>
           If it's easy to do program proving, it is easy to write bug free programs.
        </li>
        <li>
           If it's supremely simple to programatically manipulate, then many powerful tools to lint, debug, inspect, instrument, refactor it will evolve.
        </li>
      </ol>
      <hr/>
      <p>
        <em></em><a href="JoyLanguage.html">JoyLanguage</a> is kind of a cross between <a href="ForthLanguage.html">ForthLanguage</a> and <a href="LispLanguage.html">LispLanguage</a>. Like Lisp, lists are a key data structures, and a program can be represented by a list. Unlike Lisp (and like Forth), a program stack is used for argument passing/return, and also replaces let-bindings and the like. So there are no "variable names" in <a href="JoyLanguage.html">JoyLanguage</a>.<em></em>
      </p>
      <p>
        <em></em><a href="JoyLanguage.html">JoyLanguage</a> also provides support for many of the different combinators (see <a href="EssAndKayCombinators.html">EssAndKayCombinators</a>); it could be viewed as a usable big brother to <a href="UnLambdaLanguage.html">UnLambdaLanguage</a>.<em></em>
      </p>
      <p>
        <em>It still is in the experimental stage, however... for instance, it has a set datatype (which is first-class); but the only things which can be stored in a set are the integers from 0-31.  A bit of </em>BrainDeath that comes straight out of <a href="PascalLanguage.html">PascalLanguage</a>.<em></em>
      </p>
      <p>
        <em>I think </em><a href="JoyLanguage.html">JoyLanguage</a> is theoretically important. On the other hand, I'm not a big fan of <a href="StackBasedLanguage.html">StackBasedLanguage</a>s for use as a source language -- see that page for the reasons why.<em></em>
      </p>
      <p>
        <em>-- </em><a href="ScottJohnson.html">ScottJohnson</a><em></em>
      </p>
      <p>
        A somewhat more mature implementation of the principles in <a href="JoyLanguage.html">JoyLanguage</a> can be found in <a href="FactorLanguage.html">FactorLanguage</a> (<a href="http://factor.sf.net)">http://factor.sf.net)</a>
      </p>
      <p>
        <em>I disagree, Joy is concatenative, Factor is only somewhat so. Concatenative means that you can cut code on any lexical boundary and both halves will still be legal programs. -- </em><a href="ShaeErisson.html">ShaeErisson</a><em></em>
      </p>
      <hr/>
      <p>
        <a href="CategoryProgrammingLanguage.html">CategoryProgrammingLanguage</a> <a href="FunctionalProgrammingLanguage.html">FunctionalProgrammingLanguage</a> <a href="StackBasedLanguage.html">StackBasedLanguage</a>
      </p>
    </div>
  </body>
</html>