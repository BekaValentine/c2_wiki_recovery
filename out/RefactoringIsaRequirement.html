<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Refactoring Isa Requirement
      </h1>
      <p>
        <em>What you call time to code new function involves rewriting old function. Not that you have to, you just choose to. That is "wasted time" according to my penny pinching management. But it comes with </em><a href="ExtremeProgramming.html">ExtremeProgramming</a>, just like documenting comes with other work styles. So refactoring time reads to me like a substitute for documenting time. In fact I wrote this on another page somewhere and you agreed. Where I am going with this is that a model of productivity for <a href="ExtremeProgramming.html">ExtremeProgramming</a> should take into account the time spent refactoring. -- <a href="AlistairCockburn.html">AlistairCockburn</a><em></em>
      </p>
      <p>
        It would be a good thing, as Alistair suggests, to be able to model the effect of refactoring on <a href="ExtremeProgramming.html">ExtremeProgramming</a> speed. But we don't have to model it to know that we must do it to be effective.
      </p>
      <p>
        <strong>In the context of the other </strong><a href="ExtremeProgramming.html">ExtremeProgramming</a> rules, refactoring is necessary to ensure that the code meets quality standards. It also helps development go quickly.<strong></strong>
      </p>
      <p>
        If you use <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a>, <a href="JustInTimeProgramming.html">JustInTimeProgramming</a>, <a href="DoTheSimplestThingThatCouldPossiblyWork.html">DoTheSimplestThingThatCouldPossiblyWork</a> and the other <a href="ExtremeProgramming.html">ExtremeProgramming</a> practices, the emergent property is that you are doing iterative development. You choose consciously to go as fast as possible to add functionality in order to learn most rapidly what it is you are trying to build.
      </p>
      <p>
        As <a href="DoomSayers.html">DoomSayers</a> have suggested elsewhere, these practices, unchecked, would lead to hideous spaghetti code, redundant and conflicting implementations, code bloat, unreliability, and nuclear winter. The <a href="DoomSayers.html">DoomSayers</a> are correct: you need something to balance quality against the pace of learning.
      </p>
      <p>
        To ensure that these evils don't occur, <a href="ExtremeProgramming.html">ExtremeProgramming</a> explicitly includes the rule to <a href="RefactorMercilessly.html">RefactorMercilessly</a>. We interpret <a href="DoTheSimplestThingThatCouldPossiblyWork.html">DoTheSimplestThingThatCouldPossiblyWork</a> not only to mean to pick the simplest solution, but to pick the simplest (least redundant, most communicative) code to do it with. It is this refinement process that reduces the chaos that would otherwise be caused by a rapid evolutionary process like XP's. 
      </p>
      <p>
        If we were to apply the other practices without concentration on refactoring, the code would become increasingly hard to maintain. Progress would slow. This isn't just a belief, the C3 project experienced the problem. See <a href="GoFasterWithRefactoring.html">GoFasterWithRefactoring</a>. -- <a href="RonJeffries.html">RonJeffries</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryRefactoring.html">CategoryRefactoring</a>
      </p>
    </div>
  </body>
</html>