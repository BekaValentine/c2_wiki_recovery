<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Objective Cee
      </h1>
      <p>
        Real name Objective-C.  It is an object oriented extension to the <a href="CeeLanguage.html">CeeLanguage</a> created at a time when <a href="CeePlusPlus.html">CeePlusPlus</a> was virtually unknown. It is basically C with blocks of <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> in it (but no automatic <a href="GarbageCollection.html">GarbageCollection</a> or blocks in <a href="ObjectiveCee.html">ObjectiveCee</a> 1.0, but these features have been added by Apple in the 2.0 release of Objective-C and iOS 4 respectively).
      </p>
      <hr/>
      <p>
        <em>Maaster!! You have created ... a monster!!</em>
      </p>
      <p>
        Yes, Igor! By tr-r-ransplanting Smalltalk's virtual dispatch system into zee 
        skull of my cadaver of zee C language, zee virtual messages shall move zee 
        arms and zee legs of structs and ints! Und zey vill doo our biddings!! Vee 
        vill rool zee wooorld!! Mwha-ha-haha! 
      </p>
      <p>
        <em>Vhat vill you call heem, Maaster??</em>
      </p>
      <p>
        I vill call him... <strong>Id</strong>. 
      </p>
      <hr/>
      <p>
        Very early implementations earned a reputation for slowness, and initially the only implementations were by <a href="BradCox.html">BradCox</a>.
      </p>
      <p>
        <a href="SteveJobs.html">SteveJobs</a> and <a href="NeXt.html">NeXt</a> used Objective-C for a computer based on a Mach kernel, 680x0 processor, and Unix, with lessons learned from <a href="MacApp.html">MacApp</a>/<a href="MacOs.html">MacOs</a>, and Smalltalk. It was literally 10 years ahead of its time. [Time has since caught up with it.]  <em>Time hasn't entirely caught up.  There are still OSs that are as pervasively object oriented (</em><a href="BeOs.html">BeOs</a> probably is one) and are as easy to develop for (BeOS is fun to program on, but it still doesn't come close to the old tools from that project).<em> [</em><a href="NextStep.html">NextStep</a> is the OS discussed above.]
      </p>
      <p>
        The <a href="JavaLanguage.html">JavaLanguage</a> has a run-time model similar to Objective-C (and inspired by Objective-C, according to the creator of Java), but with syntax more like <a href="CeePlusPlus.html">CeePlusPlus</a>.
        <a href="BradCox.html">BradCox</a> has a record of this at <a href="http://virtualschool.edu/objectivec/influenceOnJava.html">http://virtualschool.edu/objectivec/influenceOnJava.html</a>
      </p>
      <p>
        <em>I thought it was something about message dispatch being more like </em><a href="SmalltalkLanguage.html">SmalltalkLanguage</a> than C++.<em></em>
      </p>
      <p>
        <em></em>WayneRosing, <a href="JamesGosling.html">JamesGosling</a>, and <a href="BillJoy.html">BillJoy</a> wanted an environment "with the semantics of Smalltalk and the appearance of C". The desire was for "programmer portability"; the perception was (rightly or wrongly) that the infix syntax of Smalltalk was a major impediment to its acceptance by the development community. Smalltalk behavior was always the goal; <a href="CeePlusPlus.html">CeePlusPlus</a> and <a href="ObjectiveCee.html">ObjectiveCee</a> were thus viewed as relatively interchangeable options. -- <a href="TomStambaugh.html">TomStambaugh</a><em></em>
      </p>
      <p>
        Next, Inc. took the Objective-C portions of the gnu C compiler (and developed their own run-time library) and polished it over the next 10 years until runtime speed was comparable to (or better than?) modern Smalltalks. They didn't ship the source code to the compiler with Nextstep 10 years ago, but it available on request (on magtapes).
      </p>
      <p>
        <em>I think it's now available in Apple's Darwin project:  </em><a href="http://developer.apple.com/darwin/">http://developer.apple.com/darwin/</a> <em></em>
      </p>
      <p>
        <a href="RichardStallman.html">RichardStallman</a> mentions a disagreement with Next over the philosophy of copyleft at <a href="http://www.gnu.org/philosophy/pragmatic.html">http://www.gnu.org/philosophy/pragmatic.html</a>
      </p>
      <hr/>
      <p>
        See <a href="BradCox.html">BradCox</a>' book "<a href="ObjectOrientedProgrammingAnEvolutionaryApproach.html">ObjectOrientedProgrammingAnEvolutionaryApproach</a>"
      </p>
      <p>
        <strong>That book defines Objective-C.</strong>
      </p>
      <p>
        Another book: <a href="http://developer.apple.com/documentation/Cocoa/Conceptual/ObjectiveC/ObjC.pdf">http://developer.apple.com/documentation/Cocoa/Conceptual/ObjectiveC/ObjC.pdf</a>
      </p>
      <p>
        in HTML: <a href="http://developer.apple.com/documentation/Cocoa/Conceptual/ObjectiveC/index.html">http://developer.apple.com/documentation/Cocoa/Conceptual/ObjectiveC/index.html</a> 
      </p>
      <p>
        [ links updated -- <a href="TheerasakPhotha.html">TheerasakPhotha</a> ]
      </p>
      <hr/>
      <p>
        Objective-C has two tools, HeaderDoc and AutoDoc, that are similar to <a href="DoxyGen.html">DoxyGen</a> and <a href="JavaDoc.html">JavaDoc</a>. HeaderDoc ships with <a href="ExCode.html">ExCode</a> on Panther (<a href="MacOsx.html">MacOsx</a> 10.3)
      </p>
      <hr/>
      <p>
        Objective-C FAQ:  <a href="ftp://rtfm.mit.edu/pub/faqs/computer-lang/Objective-C/faq">ftp://rtfm.mit.edu/pub/faqs/computer-lang/Objective-C/faq</a>
      </p>
      <hr/>
      <p>
        Objective-C tutorial: <a href="http://otierney.net/objective-c.html">http://otierney.net/objective-c.html</a>
      </p>
      <hr/>
      <p>
        Does anyone know of an <a href="ObjectiveCee.html">ObjectiveCee</a> tutorial that doesn't assume knowledge of C? The apple documentation above reminds me of the Steve Martin bit "How to get a Million Dollars and Never pay Taxes": "First, Get a Million Dollars".
      </p>
      <p>
        <em>I don't know of one offhand, and since it's not one of the most popular languages in the world, you won't see a bunch of "Learn Objective-C in 20 Minutes For Dummies" books.</em>
      </p>
      <p>
        <em>However, it is a superset of C, so there isn't a pressing need for such a combination. You can buy any number of C books to learn that part of the language, and then learn the Objective-C extensions to the language, which are very small in number and can literally be learned in an afternoon or less (although, as always, it takes longer to learn effective use of the class library).</em>
      </p>
      <p>
        <em>The only feature that is actually a change, rather than an addition, is that include files should be imported via #import (which automatically enforces an only-once rule, sidestepping the ugly C hack for doing that). But even there, #include still works, so it's still backward compatible.</em> <a href="ObjectiveCee.html">ObjectiveCee</a> is, in fact, a <strong>strict</strong> superset of <a href="CeeLanguage.html">CeeLanguage</a>, meaning if you hand a <a href="CeeLanguage.html">CeeLanguage</a> source to an <a href="ObjectiveCee.html">ObjectiveCee</a> compiler, it will compile it perfectly.
      </p>
      <p>
        I was warned by using #import in gcc compiler. Should I use #include instead?
      </p>
      <code>
        $ gcc -o hello hello.m -lobjc<br/>
        hello.m:1:2: warning: #import is obsolete, use an #ifndef wrapper in the header file<br/>
      </code>
      <p>
        With the gnu compiler you should use "-Wno-import", in order to not get the warning... 
        If you want one good book to learn Obj-C, buy "Programming in Objective-C", by Stephen Kochan.
      </p>
      <hr/>
      <p>
        See also: <a href="SteveJobs.html">SteveJobs</a>, <a href="NeXt.html">NeXt</a>, <a href="ObjectiveCeePlusPlus.html">ObjectiveCeePlusPlus</a>
      </p>
      <hr/>
      <p>
        [From ObjectiveCeeLanguage]
      </p>
      <p>
        Extends the syntax of <a href="CeeLanguage.html">CeeLanguage</a> to include Smalltalk constructs. An object-oriented C created by <a href="BradCox.html">BradCox</a>. The object-oriented extensions of <a href="ObjectiveCee.html">ObjectiveCee</a> rely on dynamic pointer-based mechanisms, as opposed to <a href="CeePlusPlus.html">CeePlusPlus</a>, which gains its behavior through more pervasive modifications of both the syntax and symantics of <a href="CeeLanguage.html">CeeLanguage</a>. Many consider <a href="ObjectiveCee.html">ObjectiveCee</a> to be "more OO" than <a href="CeePlusPlus.html">CeePlusPlus</a> because of the Smalltalk heritage of <a href="ObjectiveCee.html">ObjectiveCee</a>. NeXTStep used Obj-C, and so does Apple now- the <a href="CocoaFramework.html">CocoaFramework</a> is a port of NeXTStep's APIs.(of course, they're modified in <a href="MacOsx.html">MacOsx</a>, but... the roots are the same). The <a href="GnuStep.html">GnuStep</a> project is also porting the <a href="OpenStep.html">OpenStep</a> frameworks to various OSes(*nix, Windows, etc.). Their website is <a href="http://www.gnustep.org.">http://www.gnustep.org.</a> <em>[original paragraph reworded to improve historical accuracy -- </em><a href="TomStambaugh.html">TomStambaugh</a>]<em></em>
      </p>
      <p>
        With Objective-C, one gets the low-level capabilities of C as well as the high-level, abstract object-orientedness of Smalltalk. It's far from a compromise, however - the two languages fill in each other's gaps nicely.
        Objective-C only adds one major syntactical construct - the message send.
      </p>
      <code>
        [receiver message];<br/>
      </code>
      <p>
        Classes are added as well. These are declared as follows:
      </p>
      <code>
        @interface SomeClass : ItsSuperClass<br/>
      </code>
      <p>
        @interface is a preprocessor directive that tells the preprocessor, "a class is being declared.  what follows are its instance variables and methods."
      </p>
      <p>
        <em>@interface seems not to be a preprocessor directive. cpp does nothing on it.</em> [Objective-C was originally implemented as <em>a</em> preprocessor that converted the code to straight C. This is different from <em>the</em> traditional C preprocessor which understands things like #define. Modern Objective-C compilers are true compilers, and you probably couldn't implement the language with a preprocessor anymore.]
      </p>
      <code>
        { // begin declaring instance variables<br/>
        int fooInt;<br/>
        id anObject;  // id is ' a pointer to an object.' it's a generic type-- any object can be typed as id.<br/>
        } //end declaring instance variables<br/>
      </code>
      <code>
        +(SomeClass *)objectWithFooInt:(int) theInt;<br/>
      </code>
      <p>
        Plus '+' signifies class method.  colon ':' signifies an argument.  (int) types the argument, and theInt is what the argument is named.  a 'method' is a set of instructions, something an object (in this case the class object) knows how to do. This returns an initialized, allocated, and autoreleased instance of SomeClass with a fooInt value of theInt.  in order for it to stick around for long, the coder must tell it to do so by sending it a retain message: [theObject retain]; (retain is a method of NSObject that is involved with memory management and paired with a release method.)
      </p>
      <code>
        -(id) initWithFooInt:(int) theInt object:(id) theObject;<br/>
      </code>
      <p>
        This is an instance method which is roughly analogous to a constructor;  the message is sent to an allocated instance, and the init method sets instance variables fooInt and anObject to theInt and theObject, respectively.  it returns a fully initialized instance of SomeClass.
      </p>
      <code>
        @end  //end of interface<br/>
      </code>
      <code>
        @implementation SomeClass<br/>
      </code>
      <p>
        In here, the instructions are laid out, and the methods are coded like C functions.  the exception is, they can call the superclass' implementation of the method.  polymorphism is fully supported in Objective-C. 
      </p>
      <code>
        @end<br/>
      </code>
      <p>
        -- <a href="JoeOsborn.html">JoeOsborn</a> <em>[but with modifications by </em><a href="TomStambaugh.html">TomStambaugh</a>]<em></em>
      </p>
      <p>
        Attempts to add many missing Smalltalk features, such as blocks, are underway.  See <a href="BlocksInObjectiveCee.html">BlocksInObjectiveCee</a>.
      </p>
      <hr/>
      <p>
        <strong>[From ObjectiveClanguage]</strong>
      </p>
      <p>
        An <a href="ObjectOrientedProgrammingLanguage.html">ObjectOrientedProgrammingLanguage</a> which combined the dynamic <a href="ObjectOriented.html">ObjectOriented</a> features of the <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> with the speed and low-level programming constructs of <a href="CeeLanguage.html">CeeLanguage</a>.
      </p>
      <p>
        <a href="CeeLanguage.html">CeeLanguage</a> and <a href="CeePlusPlus.html">CeePlusPlus</a> were developed by <a href="BellLabs.html">BellLabs</a>/AT&T, and <a href="ObjectiveCee.html">ObjectiveCee</a> was developed by Stepstone. With relatively high license fees, <a href="ObjectiveCee.html">ObjectiveCee</a> never saw broad use.  Its major adopter was NeXT, which based the entire application layer of its OS (<a href="NextStep.html">NextStep</a>) on <a href="ObjectiveCee.html">ObjectiveCee</a>.  <a href="ObjectiveCee.html">ObjectiveCee</a> lives on in the same role within <a href="MacOsx.html">MacOsx</a>.
      </p>
      <p>
        <em></em><a href="CeePlusPlus.html">CeePlusPlus</a> was made freely available by AT&T as a marketing ploy. It was never in the public domain. UNIX(tm) was quite intentionally a trademark of AT&T and has never been in the public domain. AT&T divested a portion of its resources, including UNIX, to NCR corporation for a short period. Meanwhile, a competing version of UNIX was created at <a href="CalBerkeley.html">CalBerkeley</a> (by <a href="BillJoy.html">BillJoy</a>, among others). For many years, the UNIX world was divided between "UNIX System V" (from AT&T/NCR) and "BSD UNIX", from Berkeley. Since AT&T offered <a href="CeePlusPlus.html">CeePlusPlus</a> for free, <a href="ObjectiveCee.html">ObjectiveCee</a> would have been "expensive" at any price. -- <a href="TomStambaugh.html">TomStambaugh</a><em></em>
      </p>
      <p>
        One of the quirkier things about ObjectiveC is its (Smalltalk-esque) syntax.  Rather than using C++ (and Java's) dot notation for invoking methods, ObjectiveC uses a square bracket form (<em>this is because a dot signifies membership/ownership - you can send any message to any object in Objective C, so a dot would inevitably be semantically wrong</em>):
      </p>
      <code>
        result = [objectInstance methodName:param];<br/>
      </code>
      <p>
        and
      </p>
      <code>
        result = [objectInstance anotherMethod:param1 with:param2 andWithAnotherParameter:param3];<br/>
      </code>
      <p>
        Another hold-over from its lineage, though this one on the <a href="CeeLanguage.html">CeeLanguage</a> side, was the use header files (for better or worse). However, at least one thing was fixed: header files are included via the "#import" directive, which automatically ensures that that file is included exactly once, obviating the conventional kludge in C/C++ to achieve that effect.
      </p>
      <p>
        In practice, both of these are minor compared to the advantages of the language.  The core concept that differentiates <a href="ObjectiveCee.html">ObjectiveCee</a> from most other compiled languages is its runtime.  (The advent of <a href="CsharpLanguage.html">CsharpLanguage</a> has started to bring the power of this concept more to the fore.)  To put it simply, in <a href="ObjectiveCee.html">ObjectiveCee</a> reflection is the way everything's done.  There's no such thing as compile-time binding.  In other words, <a href="ObjectiveCee.html">ObjectiveCee</a> is like an interpreted language in terms of flexibility and power (string-to-method-invocation is a no brainer) while having the speed of a fully compiled language (rather than being compiled only to byte code).  (Yes, other O-O languages have some the data portion of a runtime: RTTI (<a href="RunTimeTypeInformation.html">RunTimeTypeInformation</a>) for C++, and reflection accesses this information in Java, but no other compiled, C-based language uses the runtime for all method dispatch.)
      </p>
      <p>
        <em>A more significant limitation of Objective-C is its lack of namespaces and the issue of name collision.  As a result various 2 and 3 letter prefixes on class names are common.</em>
      </p>
      <p>
        This power is achieved by encoding class information into the object files (in the sense of .o files, aka .dll or .so, also known as "libraries") as strings.  Upon application execution this information is loaded into the "runtime": a collection of C data structs and functions that are linked into every <a href="ObjectiveCee.html">ObjectiveCee</a> executable.  When a method is invoked, the instance's isa pointer is de-referenced to access the related runtime structs.  The method is looked up BY NAME, first in the class and then in each superclass in order.  Once a successful lookup has occurred (or failed to occur) the associated function pointer (or pointer to the error function) is cached so that future invocations are fast (~ 2-3x a simple function call).
      </p>
      <p>
        ObjectiveC is a hybrid language.  Within its O-O side it implements all the features of a dynamic O-O language.  It supports single-parent inheritance.  The base class of all objects is Object.  (Actually the runtime supports multiple-base classes and in <a href="NextStep.html">NextStep</a>, the base class was NSObject,... details.)  Having a runtime means that "new" (and generally computationally expensive) features of other languages (like "dynamic proxy classes in Java) are built-in.
      </p>
      <p>
        <em>From 1988-1995, the base class for the </em><a href="NextStep.html">NextStep</a> AppKit was Object.  It had no reference counting; only +alloc, -init, and -free were implemented.  NSObject was introduced with the Foundation Kit in <a href="NextStep.html">NextStep</a> 3.3, but only as part of the optional Enterprise Objects Framework.  Thus, -retain and -release were introduced because of EOF's need for reference counting.  Eventually, the <a href="OpenStep.html">OpenStep</a> specification was written with NSObject as the base class, and the AppKit was rewritten massively to build on the new base class. [<a href="BrianWilloughby.html">BrianWilloughby</a>]<em></em>
      </p>
      <p>
        An interesting (and powerful) feature is that each Class is also (a special type of) Object in the runtime.  Class methods ain't "static" -- they are just as dynamic as any instance method. 
      </p>
      <p>
        One of the slicker features of Objective-C was the notion of a "category".  A category (analogous to an "extension" in Envy/IBM Smalltalk) is any collection of methods (class or instance) that are grouped together and given a a name. In addition to being a useful way of grouping class functionality so that multiple developers could conveniently work on different parts of a class, it allows for the addition of new functionality at any point in the class hierarchy by object consumers (rather than just producers). Say you need every instance of any subclass of the SuperGizmoWidget class that you purchased/found in some code library to be able to perform a "twirlAboutAxis:" method.  Well, just add such a method into a category on the SuperGizmoWidget class and voila!  In other words its the exact opposite of the notion of a "finalize"d class.  The limitation is that since instance VARIABLES, unlike instance and class METHODS affect the amount of space that's allocated for an instance, you can't add variables in a category -- or new instances would become incompatible with existing compiled ones. <em></em>
      </p>
      <p>
        There are a few tricks to categories.  Since the runtime must load the base class definition first, categories get loaded second.  Conversely method lookups happen in the reverse order: whatever is loaded last is found first. So.... you can effectively override and replace any method on an class by writing a category method of the same name.  This, of course, is generally not advised: though it does provide for a wickedly powerful tool for those terrible times when there are bugs in some otherwise very useful base class and you just wish you could fix the one broken method ... with <a href="ObjectiveCee.html">ObjectiveCee</a>, you can. <em>[As the IBM Smalltalk community discovered, this can lead to pernicious bugs when multiple extensions/categories attempt to define the same method.]</em>
      </p>
      <p>
        Another feature of the language was its <a href="DynamicTyping.html">DynamicTyping</a>.  There has been much discussion over the years as to the desireability of this trait.  One of the strongest arguments against dynamic typing was that it decreased the ability to do compile-time checks.  Compile-time typing was later added to the language -- but it doesn't affect the runtime.  In a way the type specifications in <a href="ObjectiveCee.html">ObjectiveCee</a> amount to code annotations that are parsed by the compiler and produce warnings (or errors) when there's a type mis-match or when trying to invoke a method that the compiler hasn't been informed of.
      </p>
      <p>
        More information is at: <a href="http://www.dekorte.com/Objective-C/">http://www.dekorte.com/Objective-C/</a>
      </p>
      <p>
        The original <a href="ObjectiveCee.html">ObjectiveCee</a> compiler was a <a href="CeeLanguage.html">CeeLanguage</a> pre-processor.  That was back in the 80s.  The current <a href="ObjectiveCee.html">ObjectiveCee</a> compiler has come a ways since then.  It is now (thanks to previous negotiations with NeXT) part of the <a href="GnuCompilerCollection.html">GnuCompilerCollection</a>.  The runtime has been enhanced to support multi-threading.
      </p>
      <p>
        Various notable Applications have been written in ObjectiveC:
      </p>
      <ul>
        <li>
           <a href="WorldWideWeb.html">WorldWideWeb</a>, the first graphical web browser by <a href="TimBernersLee.html">TimBernersLee</a>
        </li>
        <li>
           <a href="InterfaceBuilder.html">InterfaceBuilder</a>, the first wire-up, no code (and no code gen!) <a href="GraphicalUserInterface.html">GraphicalUserInterface</a> designer (about a decade later folks are just beginning to develop this sort of a tool in other languages).
        </li>
        <li>
           Most <a href="MacOsx.html">MacOsx</a> applications
        </li>
        <li>
           Many iOS applications
        </li>
      </ul>
      <p>
        <a href="EzraEpstein.html">EzraEpstein</a> <em>[with modifications by </em><a href="TomStambaugh.html">TomStambaugh</a>]<em> </em>[Historical note by <a href="BrianWilloughby.html">BrianWilloughby</a>]<em></em>
      </p>
      <p>
        <em>What do you mean by "no code and no code gen"?</em>
      </p>
      <p>
        Interface builder does actually generate code (but you have to force that to occur, and it only generates method stubs). However, wiring together the application via IB does not generate source code per se, it generates object instances and serializes them.
      </p>
      <hr/>
      <p>
        There is also an implementation in Clang (<a href="CeeLanguageFamilyFrontEnd.html">CeeLanguageFamilyFrontEnd</a>).
      </p>
      <hr/>
      <p>
        At WWDC 2014, Apple replaced Objective C with <a href="SwiftLanguage.html">SwiftLanguage</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryProgrammingLanguage.html">CategoryProgrammingLanguage</a> <a href="CategoryCee.html">CategoryCee</a> <a href="CategorySmalltalk.html">CategorySmalltalk</a>
      </p>
    </div>
  </body>
</html>