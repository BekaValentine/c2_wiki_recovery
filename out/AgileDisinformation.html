<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Agile Disinformation
      </h1>
      <p>
        The good news is the big software vendors are <em>finally</em> supporting <a href="UnitTest.html">UnitTest</a>s with their <a href="IntegratedDevelopmentEnvironment.html">IntegratedDevelopmentEnvironment</a>s
      </p>
      <p>
        The other good news is their spin meisters are spreading enough disinformation that we <a href="SeagullConsultant.html">SeagullConsultant</a>s don't need to fear for our jobs.
      </p>
      <p>
        From elsewhere on the 'net:
      </p>
      <dl>
        <dt> </dt>
        <dd>What is TDD's Code-First Approach?</dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd>The code-first approach to TDD requires developers to follow these tasks:</dd>
      </dl>
      <ol>
        <li>
           Thoroughly design your software. Know exactly what the software must accomplish before writing a single test.
        </li>
        <li>
           Use this design to create the interfaces and public methods for your objects (no implementation code).
        </li>
        <li>
           Use design requirements to build and execute tests, and watch them fail (Red).
        </li>
        <li>
           Write our implementation code and rerun our tests to watch them pass (Green).
        </li>
        <li>
           Interrogate the results and performance, tweak the code as necessary for structure, performance, <em>etc.</em> (Refactor).
        </li>
      </ol>
      <dl>
        <dt> </dt>
        <dd>Following this approach results in generation of a test suite, or logical grouping of automated unit tests that:</dd>
      </dl>
      <ul>
        <li>
           Are based on functional and technical design requirements
        </li>
        <li>
           Are built up front, before implementation coding begins
        </li>
        <li>
           By  following  defined  naming  conventions  and standards, represent a structured and reference-able example of how to consume, deploy, and interact with your components
        </li>
      </ul>
      <p>
        Where to start?
      </p>
      <p>
        Firstly, this is <a href="BigTestUpFront.html">BigTestUpFront</a>, not <a href="TestDrivenDevelopment.html">TestDrivenDevelopment</a>. The line "thoroughly design your software" implies someone has not yet learned the differences between hacking, <a href="BigDesignUpFront.html">BigDesignUpFront</a>, and using tests to force a design to emerge.
      </p>
      <p>
        After speculating about design, item 2 implies you write empty classes and methods. This is <a href="TopDownProgramming.html">TopDownProgramming</a> all over again. MS pitches this technique because it keeps their <a href="IntelliSense.html">IntelliSense</a> in play when you write your test. (Recall that under pure <a href="TestDrivenDevelopment.html">TestDrivenDevelopment</a>, you should write the test first, and it should be so expressive and easy to write that you should not need <a href="IntelliSense.html">IntelliSense</a>.)
      </p>
      <p>
        Line 3 implies you write many tests and fail them all.
      </p>
      <p>
        Line 4 ... ah, screw it. The general picture here is refusing to "let go" of some favored security blankets.
      </p>
      <p>
        At least this gets the kids writing more tests, so at least that's a <a href="GoodThing.html">GoodThing</a>.
      </p>
      <p>
        Right?
      </p>
      <p>
        -- <a href="PhlIp.html">PhlIp</a>
      </p>
      <hr/>
      <p>
        The article that inspired this page has been taken down and replaced with a note saying, "This topic is obsolete and has been removed from the MSDN documentation."
      </p>
      <hr/>
      <p>
        Lookit all the features we can sell in one page:
      </p>
      <ul>
        <li>
           Consider using the Class Designer (A code-generating (UML?) wizard in Visual Studio)
        </li>
        <li>
           Generate tests from your interfaces and classes. (Link to Visual Studio test generator wizard)
        </li>
        <li>
           Organize your tests into test lists (link to something in Visual Studio called a Test Manager)
        </li>
        <li>
           Run your tests (link to using the <a href="VisualStudio.html">VisualStudio</a> GUI test runner)
        </li>
      </ul>
      <p>
        <em>So maybe it's working for its </em><a href="EarlyAdopter.html">EarlyAdopter</a>s. If so, their debugging rate must be going way down. Does anyone know if it's working?<em></em>
      </p>
      <hr/>
      <p>
        <a href="CategoryAgileMethodology.html">CategoryAgileMethodology</a>
      </p>
    </div>
  </body>
</html>