<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Java Script Coding Standard
      </h1>
      <p>
        <a href="JavaScript.html">JavaScript</a> is a simple <a href="ObjectFunctional.html">ObjectFunctional</a> <a href="ProgrammingLanguage.html">ProgrammingLanguage</a>.  It was originally designed as a <a href="ScriptingLanguage.html">ScriptingLanguage</a> for web developement with many of the idioms of the <a href="SelfLanguage.html">SelfLanguage</a> and the syntax of the <a href="CeeLanguage.html">CeeLanguage</a> (<a href="CeeSyntax.html">CeeSyntax</a>).  This coding standard covers the latest standard called <a href="EcmaScript.html">EcmaScript</a> 3 that features among others:
      </p>
      <ul>
        <li>
           <a href="DynamicTyping.html">DynamicTyping</a>
        </li>
        <li>
           Everything is a <a href="DictionaryDataStructure.html">DictionaryDataStructure</a> (even Objects)
        </li>
        <li>
           <a href="FirstClassFunction.html">FirstClassFunction</a>s
        </li>
        <li>
           <a href="LexicalClosure.html">LexicalClosure</a>s
        </li>
        <li>
           <a href="PrototypeBasedProgramming.html">PrototypeBasedProgramming</a> support
        </li>
        <li>
           Some limited <a href="ArrayOrientedLanguage.html">ArrayOrientedLanguage</a> support
        </li>
      </ul>
      <p>
        Although these features makes <a href="JavaScript.html">JavaScript</a> very flexible and easy to learn, programmers inexperienced with these paradigms may have difficulty adapting.  It is not the <a href="JavaLanguage.html">JavaLanguage</a>; although, they share some concepts (due to an early partnership between <a href="SunMicrosystems.html">SunMicrosystems</a> and <a href="NetScape.html">NetScape</a>).  Nor is it the <a href="LispLanguage.html">LispLanguage</a> despite many other simularities between their individual language philosophies.  <a href="JavaScript.html">JavaScript</a> also isn't a perfect language and several <a href="JavaScriptFlaws.html">JavaScriptFlaws</a> make complex designs difficult.
      </p>
      <p>
        Therefore developing and complying with good coding standards makes coding in <a href="JavaScript.html">JavaScript</a> easier, faster, and more fun.
      </p>
      <hr/>
      <ul>
        <li>
           1. We should adopt class-based approach rather than function-based approach. This would make our code more flexible and make it easier to apply <a href="JavaScriptPatterns.html">JavaScriptPatterns</a>. <em>Bad idea; it goes against the grain and power of the language. </em><a href="JavaScript.html">JavaScript</a> is a prototyped language that supports <a href="FirstClassFunction.html">FirstClassFunction</a>s and <a href="LexicalClosure.html">LexicalClosure</a>s, this is superior to the class-based approach and far more dynamic and expressive. <a href="JavaScript.html">JavaScript</a> is not <a href="JavaLanguage.html">JavaLanguage</a>.<em></em>
        </li>
      </ul>
      <p>
        <em>While I tend to agree with this, I think a functional approach in </em><a href="JavaScript.html">JavaScript</a> can work pretty well... Also, generic algorithms may be very powerful... -- <a href="DavidDeLis.html">DavidDeLis</a><em></em>
      </p>
      <p>
        <em></em><a href="FirstClassFunction.html">FirstClassFunction</a>s and <a href="LexicalClosure.html">LexicalClosure</a>s are orthorgonal to class-based design, and they may be used together with the traditional <a href="ObjectOriented.html">ObjectOriented</a> approach.  At least, I don't see them as direct competitors. -- <a href="JimmyCerra.html">JimmyCerra</a><em></em>
      </p>
      <hr/>
      <p>
        Also I've discovered, to my dismay, that <a href="InternetExplorer.html">InternetExplorer</a> doesn't allow you to add methods to its core DOM classes - which pretty much kills the idea of using the receiver paradigm (i.e., class-based approach). See <a href="http://www.codingforums.com/showthread.php?threadid=2948">http://www.codingforums.com/showthread.php?threadid=2948</a> -- <a href="RandyStafford.html">RandyStafford</a>
      </p>
      <p>
        Wouldn't a <a href="DecoratorPattern.html">DecoratorPattern</a> work for this? Seems like it's a common approach to such situations. -- <a href="TomStambaugh.html">TomStambaugh</a>
      </p>
      <p>
        I wish I could use the <a href="DecoratorPattern.html">DecoratorPattern</a>, Tom. The problem is the web browser won't instantiate my decorators when loading a page. Instead it will instantiate its own core DOM classes - which precludes code like "document.someForm.someFunctionOfMine()". I gave up and reverted to a procedural approach, passing would-be receivers as the first arguments to functions declared on the global object. -- <a href="RandyStafford.html">RandyStafford</a>
      </p>
      <p>
        (I may be late to the conversation.) <a href="RandyStafford.html">RandyStafford</a>, why can't you still use a decorator: "f = new Decorator(document.someForm); f.someFunctionOfMine();"? -- Jimmy Cerra
      </p>
      <hr/>
      <ul>
        <li>
           2. A <a href="JavaScript.html">JavaScript</a> file should be considered as equivalent to a package in Java, i.e., all the related classes should be in one file. It's not pragmatic to have a file for each class as in Java. And name of the file should reflect its purpose in the same way a package is named in Java. If the file is too big, then it's better to divide the file further.
        </li>
      </ul>
      <ul>
        <li>
           3. Each JS file should have a header comment such as this:
        </li>
      </ul>
      <code>
        /*-------------------------------------------------------------------------<br/>
      </code>
      <ul>
        <li>
           Gui framework classes for the Web Client are stored in this file.
        </li>
      </ul>
      <code>
        *<br/>
      </code>
      <ul>
        <li>
           DEPENDENCIES
        </li>
        <li>
            - Data.js
        </li>
        <li>
            - Utils.js
        </li>
        <li>
          -------------------------------------------------------------------------/
        </li>
      </ul>
      <p>
        The first line gives a brief description of the file's contents and the DEPENDENCIES give the files that should be imported while using these classes.
        <em>Why explicitly list dependencies? Don't </em><a href="JavaScriptIde.html">JavaScriptIde</a>'s provide this kind of support?<em></em>
      </p>
      <p>
        <em>I'll add: why hinting the dependencies? The explicit list of load()s, import()s or include()s should be explicit enough... -- </em><a href="DavidDeLis.html">DavidDeLis</a><em></em>
      </p>
      <p>
        <em>For library-type files, I'm all for listing the dependencies: it has to be documented somehow, and trying to import the files without the luxury of an import statement requires assumptions about the host - it may not even be possible with some hosts. -- </em><a href="DanielBrockman.html">DanielBrockman</a><em></em>
      </p>
      <hr/>
      <p>
        <em>Don't </em><a href="JavaScriptIde.html">JavaScriptIde</a>'s provide this kind of support?<em></em>
      </p>
      <p>
        <strong>What</strong> "<a href="JavaScriptIde.html">JavaScriptIde</a>'s"? Are there any? Are any of them any good? -- <a href="TomStambaugh.html">TomStambaugh</a>
      </p>
      <hr/>
      <ul>
        <li>
           4. It's better if we have no stray functions and variables, i.e., all the methods that are declared should be declared inside a class. This will solve the namespace problem and also force the developer to code in more <a href="ObjectOriented.html">ObjectOriented</a> way. <em>While this addresses the namespace problem, generic algorithms shouldn't belong in a class... -- d</em>
        </li>
      </ul>
      <ul>
        <li>
           5.  Use <a href="PrivateVariablesInJavaScript.html">PrivateVariablesInJavaScript</a>.
        </li>
      </ul>
      <ul>
        <li>
           6. All variable declarations should be done with the "var" keyword and not just by assigning a value. <em>This is actually a very good idea. It clearly differentiate between the declaration of a variable (and maybe its first assignment) and any later assignments... -- </em><a href="DavidDeLis.html">DavidDeLis</a><em>  </em>[Variables not declared with the "var" keyword become properties of the Global object (usually "window" or "self" in <a href="WebBrowser.html">WebBrowser</a>s). -- Jimmy Cerra]<em></em>
        </li>
      </ul>
      <ul>
        <li>
           7. All classes and methods should have comment headers similar to <a href="JavaLanguage.html">JavaLanguage</a>. For e.g.,
        </li>
      </ul>
      <code>
        /**<br/>
      </code>
      <ul>
        <li>
           Utility method for getting product.
        </li>
      </ul>
      <code>
        *<br/>
      </code>
      <ul>
        <li>
           @param int a A value.
        </li>
        <li>
           @param int b Another value.
        </li>
        <li>
          /
        </li>
      </ul>
      <code>
        function Utils_product(a, b) {<br/>
        return a*b;<br/>
        }<br/>
      </code>
      <p>
        Here, you have noticed that both the parameters have type associated with it. The following point elaborates on it. <em>Good idea if we find a tool similar to </em>javadoc<em>. Also, the type information may be irrelevant for our function... -- </em><a href="DavidDeLis.html">DavidDeLis</a><em></em>
      </p>
      <p>
        Tools such as jsdoc-toolkit (<a href="http://jsdoctoolkit.org/)">http://jsdoctoolkit.org/)</a> provide functionality similar to <em>javadoc</em>. -- NathanLloydSmith
      </p>
      <p>
        I like do the same thing, but in comments:
      </p>
      <code>
        function Utils_product( /*int*/ a, /*int*/ b ) {<br/>
      </code>
      <p>
        It looks a little more like Java code this way, and brings the type closer to the variable. -- DanielCohen JavaScriptIsNotJava
      </p>
      <ul>
        <li>
           8. Since <a href="JavaScript.html">JavaScript</a> does not have any proper type concept, it's better we show the type in the method headers. This would make it clear for the reader which types the method is going to deal in. All primary types should be named after primary types of Java programming language. For types such as HTML form elements, the convention is to attach HTML before the name of the element. For e.g., HTMLForm, HTMLListBox, HTMLTextField etc. <em>I'd disagree. Every object is a class in itself (or if you play with the prototype property, we can have real classes) and therefore a type in </em><a href="JavaScript.html">JavaScript</a>. Also, many functions are type independent and there's a lot of flexibility around. Documenting a function is a good idea, but we shouldn't leave the realm of the language space... -- <a href="DavidDeLis.html">DavidDeLis</a><em>  </em>In all my years of <a href="JavaScript.html">JavaScript</a> programming, I never once had problems with variable casts (in fact, I rarely had those problems in strongly typed languages as well).  I recommend including type information only where necessary, e.g. "var elementAsString = foo(anElement);".  This way, I can concentrate on the purpose of a variable rather than its content. -- Jimmy Cerra<strong></strong>
        </li>
      </ul>
      <p>
        <em></em><a href="JavaScript.html">JavaScript</a> does have types, they are just dynamic, this is far more flexible than static types as all calls are polymorphic.<em></em>
      </p>
      <ul>
        <li>
           9. It's better to have semi-colons in the end of each statement although it's not required. It increases code reliability. <em>Definitely agreed. One should always use semicolons both as a discipline exercise and as personal consistency in their coding. Also as </em><a href="JavaScript.html">JavaScript</a> looks like <a href="CeeLanguage.html">CeeLanguage</a>, semicolons are definitely more "idiomatic"... -- d<em> Not to mention the kind of subtle bugs that automatic semicolon insertion can conjure up. -- </em><a href="DanielBrockman.html">DanielBrockman</a>
        </li>
      </ul>
      <ul>
        <li>
           10. In case inner classes are required in <a href="JavaScript.html">JavaScript</a>, the naming convention should be ParentClass$<a href="InnerClass.html">InnerClass</a>. This will tell the developer that this is an inner class. <em>I'm not sure that I understand the need or purpose of this recommendation. Inner classes are inside the classes they are defined. On the other hand they are just inner functions, so the <</em><a href="ClassName.html">ClassName</a>>_<functionName> just looks good enough for this... -- <a href="DavidDeLis.html">DavidDeLis</a><em></em>
        </li>
      </ul>
      <ul>
        <li>
           11. In case we are writing browser-specific code, then we should have it specified in the internal name of the method (Not the name declared in the signature of the class), i.e., <<a href="ClassName.html">ClassName</a>>_<methodName>_IE or <<a href="ClassName.html">ClassName</a>>_<methodName>_NS.
        </li>
      </ul>
      <p>
        <em>This is a bad idea and completely defeats the purpose of OO and shows a huge misunderstanding of what OO is really about. Just have two different classes, one to implement IE, one to implement Netscape, both with the same interface and dynamically switch them at runtime. Want to add Opera later, just write another.</em>
      </p>
      <p>
        [I agree it is a bad idea.  A better idea is to use a <a href="StrategyPattern.html">StrategyPattern</a> together with lambda functions. For example:]
      </p>
      <code>
        var fn = isIE() ? function() {<br/>
        // IE stuff<br/>
        } : isMoz() ? function() {<br/>
        // IE stuff<br/>
        } : isOpera() ? function() {<br/>
        // Opera stuff<br/>
        } : function() {<br/>
        // Default stuff<br/>
        };<br/>
      </code>
      <p>
        <em>This is still a bad idea, and it still misses the entire point of OO.  OO exists so that you don't have to do the switching, let the language do it for you and take advantage of polymorphism.  The above code shows a complete lack of understanding of polymorphism and how it should be used.  Have an Opera class, an IE class, a Mozilla class, all sharing the same interface, and decide once at startup which browser you're using, and just use that class; that's the </em><a href="StrategyPattern.html">StrategyPattern</a>. The above is not a strategy pattern, it's a case statement in disguise and it's bad code.<em> (</em><a href="CaseStatementsConsideredHarmful.html">CaseStatementsConsideredHarmful</a>)
      </p>
      <p>
        <em>I've seen this pattern in the wild (real world); it works well.  Another variant:</em>
      </p>
      <code>
        var strategy = {<br/>
        ie: function() {this.name="MSIE";},<br/>
        ns: function() {this.name="Netscape";}<br/>
        };<br/>
      </code>
      <code>
        strategy.op = function() {this.name="Opera";};<br/>
      </code>
      <code>
        var obj = new strategy[getClientUserAgentId()]();<br/>
        window.alert(obj.name);<br/>
      </code>
      <p>
        <em>-- Jimmy Cerra</em>
      </p>
      <ul>
        <li>
           12. Other than this, naming standards and other conventions should follow <a href="JavaLanguage.html">JavaLanguage</a> conventions. <em>Ahem... <g> I'd propose following as many </em><a href="LispLanguage.html">LispLanguage</a> conventions as possible with <a href="JavaScript.html">JavaScript</a> C-like syntax... or at least giving a good rethinking to this... For example, while running capitals are okay, even <a href="WikiWiki.html">WikiWiki</a> uses them!, underscored_names like recommended in <a href="PerlLanguage.html">PerlLanguage</a>, for example, are more easily readable, and closer to the <a href="LispLanguage.html">LispLanguage</a> and <a href="SchemeLanguage.html">SchemeLanguage</a> conventions as well... -- <a href="DavidDeLis.html">DavidDeLis</a><em></em>
        </li>
      </ul>
      <ul>
        <li>
           13. Document any return values using an <strong>@return</strong> <a href="JavaDoc.html">JavaDoc</a>-style comment. JavaScriptIsNotJava
        </li>
      </ul>
      <p>
        <em>It's a good list of recommendations, and the intention and idea are excellent. But I can feel a certain tendency towards Java. While </em><a href="JavaLanguage.html">JavaLanguage</a> is a powerul tool, and <a href="JavaScript.html">JavaScript</a> certainly has 'java' in the name, it's not java, just a victim of marketroids. We should try to find more idiomatic recommendations. The differences between both languages deserve some credit, so to say. Just my thoughts, though... I will try to think on more suggestions. Thank you -- <a href="DavidDeLis.html">DavidDeLis</a><em></em>
      </p>
      <hr/>
      <ul>
        <li>
           12. Other than this, naming standards and other conventions should follow <a href="JavaLanguage.html">JavaLanguage</a> conventions. - JavaScriptIsNotJava
        </li>
      </ul>
      <p>
        It appears to me that <a href="JavaScript.html">JavaScript</a> is much closer to <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> than to <a href="JavaLanguage.html">JavaLanguage</a> or <a href="CeeLanguage.html">CeeLanguage</a>, specifically with respect to <a href="DynamicTyping.html">DynamicTyping</a>, name scoping, and compilation issues. I therefore suspect that the naming standards and other conventions developed over the 20+ year experience of the <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> community will serve better than the Java conventions. -- <a href="TomStambaugh.html">TomStambaugh</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryJavaScript.html">CategoryJavaScript</a>
      </p>
    </div>
  </body>
</html>