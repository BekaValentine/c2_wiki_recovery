<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Map Function
      </h1>
      <p>
        <em>map</em> is one of the <a href="CommonHigherOrderFunctions.html">CommonHigherOrderFunctions</a> which transforms a list by applying a function to each of its elements. Its return value is the transformed list.
      </p>
      <p>
        For example:
      </p>
      <code>
        (map double (list 1 2 3 4 5))<br/>
        => (2 4 6 8 10)<br/>
        (map send-email (list message1 message2 message3))<br/>
        => (ok bad-recipient-list ok)<br/>
      </code>
      <p>
        There are many variations on the map function, the one described here is called <em>map</em> in Scheme, and <em>mapcar</em> in most Lisps.
      </p>
      <hr/>
      <p>
        <em>map</em> is doubly (ha) useful when used with anonymous functions
      </p>
      <p>
        In <a href="CommonLisp.html">CommonLisp</a>:
      </p>
      <code>
        (mapcar (lambda (x) (* 2 x)) (list 1 2 3 4 5))<br/>
        => (2 4 6 8 10)<br/>
      </code>
      <p>
        In <a href="PerlLanguage.html">PerlLanguage</a>:
      </p>
      <code>
        DB<1> x map { 2 * $_ } (1,2,3,4,5)<br/>
      </code>
      <ol>
        <li>
            2
        </li>
        <li>
            4
        </li>
        <li>
            6
        </li>
        <li>
            8
        </li>
        <li>
            10
        </li>
      </ol>
      <p>
        (this is using the perl debugger as a poor man's top-level loop. The comand "x"
        means "evaluate and display the return value")
      </p>
      <p>
        In <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>: #collect:
      </p>
      <code>
        #(1 2 3 4 5) collect: [:each | 2 * each]<br/>
      </code>
      <p>
        In <a href="PythonLanguage.html">PythonLanguage</a>:
      </p>
      <code>
        map(lambda x: 2*x, (1, 2, 3, 4, 5) )<br/>
      </code>
      <p>
        Version 2.0 of <a href="PythonLanguage.html">PythonLanguage</a> has <a href="ListComprehension.html">ListComprehension</a>s, which are nice syntactic sugar for map:
      </p>
      <code>
        [2*x for x in (1, 2, 3, 4, 5)]<br/>
      </code>
      <p>
        In <a href="RubyLanguage.html">RubyLanguage</a>
      </p>
      <code>
        [1, 2, 3, 4, 5].map { |x| 2*x }<br/>
      </code>
      <p>
        In <a href="CsharpLanguage.html">CsharpLanguage</a> 2.0 or greater
      </p>
      <code>
        int[] a = { 1, 2, 3, 4, 5 };<br/>
        int[] b = Array.ConvertAll(a, delegate(int n) { return n*2; });<br/>
      </code>
      <p>
        In <a href="CsharpLanguage.html">CsharpLanguage</a> 3.0 or greater
      </p>
      <code>
        int[] a = { 1, 2, 3, 4, 5 };<br/>
        var b = a.Select(n => n * 2); // uses built-in Select operator over sequences<br/>
        var c = from n in a select n * 2; // list comprehension syntax over previous example<br/>
      </code>
      <p>
        In <a href="CeePlusPlus.html">CeePlusPlus</a> (C++) using the <a href="StandardTemplateLibrary.html">StandardTemplateLibrary</a>
      </p>
      <code>
        int a[5] = {1, 2, 3, 4, 5};<br/>
        transform( a, a+5, a, bind1st( times<int>(), 2 ) );<br/>
      </code>
      <p>
        (or a.begin() and a.end() if you instead used a vector for 'a')
        Note: You can use another collection or the same collection to store the result.
      </p>
      <p>
        In <a href="HaskellLanguage.html">HaskellLanguage</a>
      </p>
      <code>
        map (2*) [1,2,3,4,5]<br/>
      </code>
      <p>
        In <a href="OcamlLanguage.html">OcamlLanguage</a>
      </p>
      <code>
        List.map ((*) 2) [1;2;3;4;5]<br/>
        Array.map ((*) 2) [|1;2;3;4;5|]<br/>
      </code>
      <p>
        In <a href="SmlLanguage.html">SmlLanguage</a>
      </p>
      <code>
        map (fn x => x * 2) [1,2,3,4,5]<br/>
        Vector.map (fn x => x * 2) #[1,2,3,4,5]<br/>
      </code>
      <p>
        In <a href="JavaScript.html">JavaScript</a> 1.6, arrays have a method called "map":
      </p>
      <code>
        var evens = numbers.map(function(x){return x * 2;});<br/>
      </code>
      <p>
        In <a href="SchemeLanguage.html">SchemeLanguage</a>:
      </p>
      <code>
        (map (lambda (x) (* x 2)) numbers)<br/>
      </code>
      <p>
        Note that Scheme's map is more general than described here. It actually accepts an n-ary function followed by n lists, each of length M. The output is a single list of length M, composed by calling the given function with arguments taken from the 'm'th element of each list. e.g.:
      </p>
      <code>
        (map add (list 1 2 3) (list 4 5 6))<br/>
        -> (5 7 9)<br/>
      </code>
      <p>
        In <a href="PhpLanguage.html">PhpLanguage</a>:
      </p>
      <code>
        array_map(create_function('$x', 'return 2 * $x;'), array(1, 2, 3, 4, 5))<br/>
      </code>
      <p>
        In <a href="SwiftLanguage.html">SwiftLanguage</a>:
      </p>
      <code>
        [1,2,3,4,5].map { 2 * $0 }<br/>
      </code>
      <p>
        In <a href="StructuredQueryLanguage.html">StructuredQueryLanguage</a> (SQL):
      </p>
      <code>
        select x * 2 as Double   // make sure not a reserved word<br/>
        from original_list<br/>
      </code>
      <p>
        Note you must use an expression, since many dialects don't allow user-defined functions (or don't make it easy).
      </p>
      <hr/>
      <p>
        One of the nice things about the <a href="RubyLanguage.html">RubyLanguage</a> is that these iterated constructs can be programmed in the language. A method may be passed a closure, and within the method you can coroutine with that closure using the 'yield' construct.
      </p>
      <code>
        def silly<br/>
        yield "one"<br/>
        yield "two"<br/>
        yield "three"<br/>
        end<br/>
      </code>
      <code>
        silly { |s|  puts s }	# outputs one, two, three<br/>
      </code>
      <p>
        So, for example, Ruby doesn't have the equivalent of Smalltalk's 'inject'. However, it's simple to write one. If we assume the existence of an <a href="InternalIterator.html">InternalIterator</a> in the current class called 'each', which invokes its closure for each element in a collection (a Ruby convention), then 'inject' would be
      </p>
      <code>
        class ACollection<br/>
        # ...<br/>
        def inject(n)<br/>
        each { |value| n = yield(n, value) }<br/>
        n<br/>
        end<br/>
        end<br/>
      </code>
      <code>
        a = ACollection.new<br/>
        sum = a.inject(0) { |result, value| result + value }<br/>
        product = a.inject(1) { |result, value| result * value |<br/>
      </code>
      <p>
        and so on.
      </p>
      <p>
        In fact, you'd probably define <em>inject</em> as a method in the existing module <em>Enumerable,</em> and every collection would automatically support it from then on.
      </p>
      <p>
        It's fun to be able to code so flexibly in this functional style.
      </p>
      <p>
        <em>Actually ruby has #inject since version 1.8</em>
      </p>
      <hr/>
      <p>
        <em>Hmmmm... I"ve always thought of </em>map<em> as being more like </em>#do<em> in </em><a href="SmallTalk.html">SmallTalk</a>. It <em>allows</em> you to create a new list, but it doesn't <em>necessarily</em> create a new collection object. For example, the <em>map</em> function in Perl acts much like #do in <a href="SmallTalk.html">SmallTalk</a>. You can print each item in the list, apply a procedure, create a new collection just of evaluation results, or not. I think the problem is the way input and output work in a Functional Language as opposed to an <a href="ObjectOriented.html">ObjectOriented</a> language like <a href="SmallTalk.html">SmallTalk</a>. In something like map, you can compose by giving it another iterator as an argument, instead of just some expression to evaluate on each member. This makes it <strong>seems</strong> like it works as #collect but it actually operates like #do, just in a functional environment. I'm just kind of guessing, is this assumption incorrect?<em></em>
      </p>
      <p>
        I'm afraid it is incorrect. <em>map</em> as in Scheme always creates a new list. 
        The equivalent of 'do:' is for-each (a standard scheme procedure). See <a href="http://www-swiss.ai.mit.edu/~jaffer/r5rs_8.html#SEC48">http://www-swiss.ai.mit.edu/~jaffer/r5rs_8.html#SEC48</a>
      </p>
      <code>
        (define (for-each f lst)<br/>
        (if (not (null? lst))<br/>
        (begin<br/>
        (f (car lst))<br/>
        (for-each f (cdr lst)))))<br/>
      </code>
      <p>
        In <a href="CommonLisp.html">CommonLisp</a>, mapcar is the <a href="MapFunction.html">MapFunction</a> as described here, and mapc behaves like Scheme's for-each. There are a few related functions: maplist, mapl, mapcan, and mapcon. The last two are very seldom needed...
      </p>
      <hr/>
      <p>
        If we construe lists (and kindred collection types) as mappings (input is the index, hash key or whatever; bags and similar need to be construed, via iteration, as lists to fit them into this concept) then we can regard map as simply the composition operation among functions. A list h, in these terms, is just a function
      </p>
      <code>
        h[i] <- i<br/>
      </code>
      <p>
        from some initial subset, n, of the naturals (so i is in n). Our function f is then
      </p>
      <code>
        f(x) <- x<br/>
      </code>
      <p>
        and map(f, h) is just
      </p>
      <code>
        f(h[i]) <- i<br/>
      </code>
      <p>
        which is simply the result of composing f after h; it's f function from n, just as h was (so it's a list) which feeds h's input through h and h's output through f. 
      </p>
      <hr/>
      <p>
        One of the distinguishing characteristics of <a href="ExBase.html">ExBase</a> is a kind of <a href="MapFunction.html">MapFunction</a> capability over a given table, but also with predicate filtering, similar to an SQL "WHERE" clause. (Early dialects only allowed this on built-in functions, not user-defined ones.)
      </p>
      <p>
        Pseudo-code for it would resemble:
      </p>
      <code>
        Perform function a() on table b where x > y and foo=7<br/>
      </code>
      <p>
        Ideally, a reference to the current "row" would be passed to the function, but <a href="ExBase.html">ExBase</a> used a more primitive default scope for such. This simplified rapid prototyping and interactive work, but would not work well for large shared libraries.
      </p>
      <hr/>
      <p>
        <a href="CategoryFunctionalProgramming.html">CategoryFunctionalProgramming</a> <a href="CategoryInManyProgrammingLanguages.html">CategoryInManyProgrammingLanguages</a> <a href="CategoryObjectFunctionalPatterns.html">CategoryObjectFunctionalPatterns</a>
      </p>
    </div>
  </body>
</html>