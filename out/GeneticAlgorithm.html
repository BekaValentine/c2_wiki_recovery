<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Genetic Algorithm
      </h1>
      <p>
        Genetic Algorithms (GAs) were developed by Prof. <a href="JohnHolland.html">JohnHolland</a> and his students at the University of Michigan during the 1960s and 1970s. Essentially, they are a method of "breeding" computer programs and solutions to optimization or search problems by means of simulated evolution. Processes loosely based on natural selection, crossover, and mutation are repeatedly applied to a population of binary strings which represent potential solutions. Over time, the number of above-average individuals increases, and highly-fit building blocks are combined from several fit individuals to find good solutions to the problem at hand. 
      </p>
      <p>
        The Canonical GA (pseudo code): 
      </p>
      <code>
        choose initial population<br/>
        evaluate each individual's fitness<br/>
        determine population's average fitness<br/>
        repeat<br/>
        select best-ranking individuals to reproduce<br/>
        mate pairs at random<br/>
        apply crossover operator<br/>
        apply mutation operator<br/>
        evaluate each individual's fitness<br/>
        determine population's average fitness<br/>
        until terminating condition (e.g. until at least one individual has <br/>
        the desired fitness or enough generations have passed)<br/>
      </code>
      <p>
        <em>This pseudo-code does not hint what the averaging is for.</em>
      </p>
      <ul>
        <li>
           To let you know what sort of progress they've made so far, and also sometimes the individual rankings are made against the group average. So it's not necessarily absolutely necessary.
        </li>
        <li>
           <em>Perhaps we should present a "bare bones" algorithm and "fancy" one. Another thing that's optional is the variation methods used. Only one of cross-over and mutation ("bit-flipping") is necessary to qualify as a GA. In some experiments, one or the other seems to work well by itself, depending on the optimization topic and other factors. Also, cross-over that allows position transposition and inversion generally approximates direct mutation. In other words, the more "random" crossover is, the less need there is for direct mutation because crossover can potentially provide sufficient randomness by itself.</em>
        </li>
      </ul>
      <p>
        Ending conditions can be:
      </p>
      <ul>
        <li>
           Fixed number of generations reached
        </li>
        <li>
           Budgeting: allocated computation time/money used up
        </li>
        <li>
           An individual is found that satisfies minimum criteria
        </li>
        <li>
           The highest ranking individual's fitness is reaching or has reached a plateu such that successive iterations are not producing better results anymore.
        </li>
        <li>
           Manual inspection. May require start-and-stop ability
        </li>
        <li>
           Combinations of the above
        </li>
      </ul>
      <p>
        GAs are sensitive to the mutation and crossover rates, which is unsurprising when you think about an extreme case: a 99% chance of a mutation of each bit on each generation means too little stability; the genome will always be essentially random.
      </p>
      <p>
        GAs are sensitive to the encoding scheme of its bits; using gray code, for instance, means that adjacent solutions in the search space will be adjacent in the encoding space as well, requiring fewer mutations to discover.
      </p>
      <p>
        GAs are sensitive to the gradient of the search space curve leading towards solutions, as are almost all search algorithms (except exhaustive search and pure random search); if there's no way to tell when you're getting close to a solution, then there's no way to optimize the search. Thus GAs will not help a naive search for factors of a huge number: you don't know when you're close to the right factors, you only know when you've hit them exactly.
      </p>
      <p>
        Most importantly of all, GAs are critically dependent on the fitness function. If you can't define the fitness function, then you can't apply a GA. This is obvious in some cases: if you want a GA to create music, but you don't know music theory, then you won't know how to create a fitness function to evaluate the degree of harmony of the results. But it is less obvious in other cases; if you have bugs in your fitness function, then the GA will evolve to "take advantage" of those bugs -- what else could they do?
      </p>
      <ul>
        <li>
           Re: "if you want a GA to create music, but you don't know music theory, then you won't know how to create a fitness function..." - Actually one can simply listen to it to judge whether it's "good". However, that's going to be a lot of manual work. "Art" evolution has been done on the Internet by allowing passer-by's to judge the art. The best-voted variations were then mutated into multiple candidates for another round of judging. If those scored lower than their parent, they were not displayed as often for votes. Thus, they were competing for attention and votes. It was pretty interesting. 60's hippies would have dug it.
        </li>
      </ul>
      <p>
        I discussed this in my talk on "The Evolution of Dishonesty" in regard to my 1986 work on breeding Tic Tac Toe colonies. Most people are surprised to hear that it didn't matter whether the underlying mechanism implemented simulated CPUs with branching or whether they were neural nets trained by GA evolution of weights. The evolution results and rate of convergence were essentially identical. -- <a href="DougMerritt.html">DougMerritt</a>
      </p>
      <p>
        More material on GAs:
      </p>
      <ul>
        <li>
           Goldberg, D. E. (1989), <em>Genetic Algorithms in Search, Optimization, and Machine Learning</em>. Reading, MA: Addison-Wesley, ISBN 0201157675
        </li>
        <li>
           Forrest, S. (1993), "Genetic algorithms: Principles of natural selection applied to computation", <em>Science</em> 261: 872-878
        </li>
        <li>
           Holland, J. H. (1992), "Genetic algorithms", <em></em><a href="ScientificAmerican.html">ScientificAmerican</a><em> July 1992:66-72</em>
        </li>
        <li>
           Mitchell, M. (1996), <em>An Introduction to Genetic Algorithms</em>, Cambridge, MA: MIT Press, ISBN 0262133164
        </li>
        <li>
           <a href="news:comp.ai.genetic">news:comp.ai.genetic</a>
        </li>
        <li>
           the comp.ai.genetic FAQ: <a href="ftp://alife.santafe.edu/pub/USER-AREA/EC/Welcome.html#SEC12">ftp://alife.santafe.edu/pub/USER-AREA/EC/Welcome.html#SEC12</a>
          <ul>
            <li>
               or <a href="http://www.faqs.org/faqs/ai-faq/genetic/">http://www.faqs.org/faqs/ai-faq/genetic/</a>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           research on exploring basic algorithms: <a href="http://www.egr.msu.edu/~hujianju/HFC.htm">http://www.egr.msu.edu/~hujianju/HFC.htm</a> 
        </li>
      </ul>
      <hr/>
      <p>
        I did transport scheduling (an <a href="NpHard.html">NpHard</a> problem) using GAs back in 1993, and it worked at least as well as the alternatives. It didn't perform a whole lot better than random generation of solutions, but that may have been that we didn't apply the right optimizations. -- <a href="PeteBevin.html">PeteBevin</a>
      </p>
      <hr/>
      <p>
        <strong>Confusion over the terms </strong><a href="GeneticAlgorithm.html">GeneticAlgorithm</a> and <a href="GeneticProgramming.html">GeneticProgramming</a>:<strong></strong>
      </p>
      <p>
        A genetic algorithm is simply the algorithm used to simulate evolution. It takes candidate solutions, selects some of the best using user-defined evaluation functions, applies user-defined transformations (often called mutation and crossover, but implementations of these depend on the problem), and makes new candidate solutions.
      </p>
      <p>
        <a href="JohnHolland.html">JohnHolland</a>'s 'classical' genetic algorithm specifically used raw bitstrings as the candidate solutions, a problem-specific evaluation function depending on the problem, and simple bit-flip mutations and bitstring swapping for cross-over. This is just <em>one</em> type of genetic algorithm. See Faulkenauer's <em></em><a href="GeneticAlgorithmsAndGroupingProblems.html">GeneticAlgorithmsAndGroupingProblems</a><em> for a good introduction to the differences between implementations. </em>
      </p>
      <p>
        <a href="GeneticProgramming.html">GeneticProgramming</a> is yet another example of the genetic algorithm. It uses instruction trees as candidate solutions, problem-specific evaluation functions, and sometimes complicated tree pruning, swapping, and random branch generation (among other methods) to generate new candidate solutions. Aside from the user-specific strategies (see <a href="StrategyPattern.html">StrategyPattern</a>), the main algorithm is the same.
      </p>
      <p>
        So, whether the candidate solutions are 'data structures' or 'programs', it doesn't matter, they all can be manipulated by a genetic algorithm.
      </p>
      <hr/>
      <p>
        There's a thriving business in crafting <a href="EvolutionaryAlgorithm.html">EvolutionaryAlgorithm</a>s so that their performance improves relative to random search -- I've done it myself for years as a consultant. In essence, GAs and other <a href="EvolutionaryAlgorithm.html">EvolutionaryAlgorithm</a>s involve an intricate interplay between the problem you're trying to solve, its representation, the search operators you choose, and the performance measure you choose (like "how many individual evaluations of different potential solutions", or "how much wall clock time to improve on the starting guesses").
      </p>
      <p>
        The whole process comes down to <a href="MetaOptimization.html">MetaOptimization</a>, which I suppose is my coinage of about 10 years back. -- <a href="BillTozier.html">BillTozier</a>
      </p>
      <hr/>
      <p>
        For those interested in learning more about <a href="GeneticAlgorithm.html">GeneticAlgorithm</a>s and EvolutionaryComputation in general, a great place to start is <a href="http://gnu.egr.msu.edu/pub/EC/">http://gnu.egr.msu.edu/pub/EC/</a> [<a href="BrokenLink.html">BrokenLink</a>].
      </p>
      <p>
        <a href="WikiGnome.html">WikiGnome</a>s: that link referred to "Encore" a.k.a. "The Hitch-hiker's Guide To Evolutionary Computation". It appears that this originated at alife.santefe.edu, and was once very widely mirrored, but now is gone, nor did I see it at alife.org. I only found one copy: <a href="http://www.cs.bham.ac.uk/Mirrors/ftp.de.uu.net/EC/clife/">http://www.cs.bham.ac.uk/Mirrors/ftp.de.uu.net/EC/clife/</a> Anyone know of some other mirrors to help prevent bitrot? (Or do you want to mirror it?)
      </p>
      <p>
        Here's another (via <a href="http://en.wikipedia.org/wiki/Genetic_programming#External_links):">http://en.wikipedia.org/wiki/Genetic_programming#External_links):</a> <a href="http://www6.uniovi.es/ftp/pub/EC/FAQ/www/">http://www6.uniovi.es/ftp/pub/EC/FAQ/www/</a>
      </p>
      <hr/>
      <p>
        One of the things I like most about <a href="GeneticAlgorithm.html">GeneticAlgorithm</a>s is that if you decide some aspect of the solution is more important than you originally thought, you can just change the scoring function to weight it higher (or add it).
      </p>
      <p>
        <em>Why is this specific to genetic algorithms? You can do this with any form of optimization, no?</em>
      </p>
      <p>
        Because the population at any iteration includes a wide variety of solution-fragments. When you change the scoring function, a new solution may arise from the previously less-optimal individuals. In a traditional optimization algorithm with only one or a few candidate solutions, no candidate will be near the new goal and you may have trouble escaping a local maximum.
      </p>
      <p>
        <em>In other words: Using an evolutionary approach to optimization is a good idea in some </em>DynamicOptimization problems (which is what the previous writer was getting at). The lion's share of GA applications (and theory), though, applies them to static problems, where the goals, constraints, and the problem definition itself are fixed at the start. That is, OfflineOptimization.<em> -- </em><a href="BillTozier.html">BillTozier</a>
      </p>
      <hr/>
      <p>
        <em>The primary problem with GAs is that they require that the entire search-space be a valid input to the evaluation function. Most physical problems are constrained. The result is a lot of culled mutoids that could never live, making it very inefficient. Worse still, genetic algorithms can severely distort the search space. This is a good thing for getting a fast convergence, but prevents GAs from being general. Simulated annealing (and </em><a href="SimulatedQuenching.html">SimulatedQuenching</a>) do not suffer from this. Hybrid functions try to blend the generality of stochastic techniques with the very fast convergence of GAs.<em> -- </em><a href="RichardHenderson.html">RichardHenderson</a>.
      </p>
      <p>
        This is not true (there is no such requirement of GAs). An important concern is to choose appropriate transformations to supply the GA with new candidate solutions. See Faulkenauer in his <em></em><a href="GeneticAlgorithmsAndGroupingProblems.html">GeneticAlgorithmsAndGroupingProblems</a><em> book [ISBN: 0471971502]. This essentially means that GAs are not a panacea and you can't just toss a GA at a problem willy nilly without thinking. Which is just another way of saying the </em><a href="NoFreeLunchTheorem.html">NoFreeLunchTheorem</a>. All <a href="MetaHeuristic.html">MetaHeuristic</a>s (GAs, <a href="SimulatedAnnealing.html">SimulatedAnnealing</a>, <a href="TabuSearch.html">TabuSearch</a>, etc.) suffer from this limitation, so to say it of GAs, as if it made them worse than other techniques, is misleading.
      </p>
      <p>
        <em>I think I understand you. On the first point, it is possible to transform the set of inputs appropriately, but this is not in any way simple. Annealing techniques tend to directly model the network equations and constraints. This is a huge advantage. Furthermore GAs are weak heuristics. They cannot guarantee to search the entire parameter space. What they can do is integrate a huge number of variables, and converge quickly to an entire set of good solutions. For small to medium scale models, however, particularly homogenous [</em>homogeneous?''] ones, my experience is that simulated annealing has superior characteristics. I'm sure this is entirely problem dependent. I must now see what is this thing '<a href="TabuSearch.html">TabuSearch</a>' :). -- <a href="RichardHenderson.html">RichardHenderson</a><em></em>
      </p>
      <hr/>
      <p>
        The interest in GA (this applies to <a href="NeuralNetworks.html">NeuralNetworks</a> also, that other great comp sci fad of modern times) comes from capitalists wanting to reduce their dependence on labour by replacing skilled programmers with raw processing power. Additionally, from corporations wanting to reduce their product liability by blaming the inevitable errors on the intrinsic unknowability and unpredictability of GA. OTOH, if programmers produce bugs then the corporation could be liable for failing to use code review and formal methods (corporations live in abject fear that one day consumers and citizens will cease to tolerate bugs).
      </p>
      <p>
        <em>I've worked for a company that produces a GA. We use it because the problem domain under consideration is very large and no precise solution is applicable in all cases, so this is available as a reasonable back-up. So your invective is inaccurate.</em>
      </p>
      <p>
        I don't understand your point. Can you explain why a GA was used instead of an algorithm programmed by a beta team?
      </p>
      <p>
        <em>We have some extra algorithms programmed in. The GA is for when these aren't that applicable. Optimizing a non-linear function over a constrained binary space is hard.</em>
      </p>
      <p>
        Not only capitalists want to reduce dependence human labour - I'm an anarchist/socialist/utopist and I want to reduce dependence on unnecessary labour as well, so we humans can devote our time to art and philosophy. 
      </p>
      <hr/>
      <p>
        The only reason GA produces anything remotely interesting is because silicon is thousands of times faster than flesh. So why is it that computer science people waste their time on GAs instead of AI? Ultimately, even GA enthusiasts admit that GA produces substandard solutions when you have fixed expectations. Since this applies to everything but pure research, one wonders why GA isn't dismissed as irrelevant mathematics instead of being taught by comp sci departments. The only aspect under which GA (and neural nets) are useful is as simulations useful in developing principles to help us understand already existing phenomena. That is, sandboxes in which we can study evolution and cognitive science.
      </p>
      <p>
        <em>This view is both narrow and wrong, and it will only become more wrong as time goes on. </em><a href="GeneticAlgorithm.html">GeneticAlgorithm</a>s <strong>are</strong> a type of AI. For one example off the top of my head, one branch of GAs, called <a href="GeneticProgramming.html">GeneticProgramming</a>, has been used to develop useful patents which have never before existed, and which passed all criteria required for a patent (i.e. non-obvious, etc.).<em></em>
      </p>
      <p>
        The following comments go wrong in using a wrong definition of AI (look at the algorithms presented in any introductory AI text). They become correct or at least arguably correct in reference to "strong AI". I have therefore inserted "strong AI" below:
      </p>
      <p>
        GA seem like strong AI only if your level of abstraction is sufficiently low. If you're trying to evolve a complex program by doing random <a href="CopyAndPasteProgramming.html">CopyAndPasteProgramming</a> on low-level pieces of code, then the idiocy (literal inability to learn from past experience) of GA becomes apparent.
      </p>
      <p>
        Ultimately, GA can never be strong AI because a strong AI must be able to construct abstractions, evaluate the completeness of those abstractions and decide when to work at a higher level of abstraction. GAs do the first, maybe, but they cannot do the second and third so cannot switch over to a higher level of abstraction when appropriate. GAs do not encapsulate solutions so as to be reused systematically. Unless of course, you program a strong AI that happens to use GA instead of neural nets at its base. That would not make GA a type of strong AI any more than it makes neural nets a type of strong AI.
      </p>
      <p>
        The idea that GA is strong AI comes from the meme theory of mind, a theory which explains nothing new and only serves to deny the cognitive functions of the mind. See <a href="MemesShmemes.html">MemesShmemes</a>.
      </p>
      <p>
        Also, automated theorem provers have no doubt constructed novel and elegant mathematical theorems which humans had never thought of before. Nobody would call them strong AI on that basis.
      </p>
      <p>
        <em>I use the pragmatic definition of AI, which is verifiable. The cognitive definition will always be up for debate, and that belongs on another page. The basis for calling GA AI: If you took a course on AI and it didn't talk about GAs, I'd say you got ripped off.</em>
      </p>
      <p>
        Note that e.g. theorem provers are a canonical example of weak AI, whereas there has never been even one instance of a strong AI (and many/most people are still arguing that strong AI is impossible).
      </p>
      <p>
        Given how easy for the human mind to interpret real-life, organic evolution as design, I see no reason to dismiss the classification offhandedly of GAs as a form of AI.
      </p>
      <hr/>
      <p>
        Sometimes, I feel people are missing the point. I was originally fascinated by genetic algorithms for their simple appeal of beng able generally to solve any problem no matter whether an algorithmic solution already existed for it. (I was breeding <a href="NeuralNetworks.html">NeuralNetworks</a> long before I learned about BackPropagation.) But to confuse it with <a href="GeneticProgramming.html">GeneticProgramming</a> is a grave mistake. I've implemented <a href="GeneticProgramming.html">GeneticProgramming</a> several times. I'm ready to admit that you can happily throw a <strong>lot</strong> more processing power at it, making it more useful. But its solution domain is quite distinct from that of GAs. Firstly GAs usually operate on fixed structures, making the design of a GA very problem-specific. GP, on the other hand, can change the size of its solution (you can even include brevity in your fitness measure), and so it can adapt. If your original guess at the complexity of a solution was completely wrong, the GP programs will simply grow until a solution becomes viable. Furthermore, it's more general than any other solution-finding mechanism I know of. It's not AI, I'll readily admit, but it can solve jsut about any problem for which you can define a <a href="UnitTest.html">UnitTest</a>. In fact, I'd guess you could create a general GP system that spits out solutions to <a href="UnitTest.html">UnitTest</a>s. Only that we don't have the CPU power currently to do anything but offline evolution.
      </p>
      <p>
        Consider a modern GeforceFX chip with 8 pipelines of 64k instructions each. If we remove all the fancy memory bandwidth stuff and set up 512 or better 1024 pipelines instead, then we're getting into a realm where for, say, a robot control program, we can each second evolve a new program from what we learned the previous second. Society of Minds if anybody has read that.
      </p>
      <p>
        Please bring out your pros and contras here (especially the hard core statisticians ;). -- <a href="SvenNeumann.html">SvenNeumann</a>
      </p>
      <hr/>
      <p>
        AI is a term that sort of fell from favor when it became apparent how cheeky it was to call something artificial that we could not define in the first place.  It broke down into the subdisciplines of robotics, machine vision, A-life, neural nets, GP, etc.
      </p>
      <p>
        <a href="GeneticProgramming.html">GeneticProgramming</a> is an application of the <a href="GeneticAlgorithm.html">GeneticAlgorithm</a> using a linear array or parse tree of code as the chromosome instead of an encoded string or similar representation.
      </p>
      <p>
        Sven, you are a man of vision:
        <em>"...but it can solve jsut about any problem for which you can define a </em><a href="UnitTest.html">UnitTest</a>. In fact, I'd guess you could create a general GP system that spits out solutions to <a href="UnitTest.html">UnitTest</a>s. Only that we don't have the CPU power currently to do anything but offline evolution."<em></em>
      </p>
      <p>
        <a href="WardCunningham.html">WardCunningham</a> and I have collaborated to create such a system. The concept is called <a href="ExtremeGeneticProgramming.html">ExtremeGeneticProgramming</a> and involves using the <a href="UnitTestAsFitnessFunction.html">UnitTestAsFitnessFunction</a>. I believe it is the purest form of <a href="TestFirstDesign.html">TestFirstDesign</a>. Self-directed teams shepherd the evolution of software by <a href="PairProgramming.html">PairProgramming</a> unit tests using an integrated version of the <a href="FrameworkForIntegratedTest.html">FrameworkForIntegratedTest</a>. The GP application, called Neovolve, then uses the tests to converge on a solution.
      </p>
      <p>
        Luckily, GP lends itself to parallelizing. Using the PowerKernel Java parallel computing framework has allowed me to use standard PC's on regular networks to scale computational power to solve <a href="GeneticProgramming.html">GeneticProgramming</a> problems.
      </p>
      <p>
        Results can be found on the <a href="FitWiki.html">FitWiki</a> at <a href="http://fit.c2.com">http://fit.c2.com</a> and at <a href="http://www.neocoretechs.com">http://www.neocoretechs.com</a>
      </p>
      <p>
        -- <a href="JonGroff.html">JonGroff</a>
      </p>
      <p>
        <em>Aah, an excellent example of </em><a href="GreenspunsTenthRuleOfProgramming.html">GreenspunsTenthRuleOfProgramming</a>.<em></em>
      </p>
      <p>
        How's that again?  If I'm not mistaken, they've got a <strong>very</strong> formally specified, unbuggy implementation of something that's not really common lisp... and it's being used for a 'higher' purpose (i.e., that which makes it apply to Greenspuns is the starting point, not the finish point of the software).
      </p>
      <p>
        The Greenspun comment does not apply.  XGP bugs are optimized out from the beginning rather than being added in later such as the code you are probably most familiar with.
      </p>
      <hr/>
      <p>
        See also 
      </p>
      <ul>
        <li>
           <a href="MetaHeuristic.html">MetaHeuristic</a>.
        </li>
        <li>
           <a href="AlgorithmsRoadMap.html">AlgorithmsRoadMap</a>
        </li>
      </ul>
      <hr/>
      <p>
        <a href="CategoryEvolution.html">CategoryEvolution</a>
      </p>
    </div>
  </body>
</html>