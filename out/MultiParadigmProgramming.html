<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Multi Paradigm Programming
      </h1>
      <p>
        There are many ways to structure computer programs.  They include: object-oriented, event-driven, procedural, functional, dataflow and table-driven.  It is likely that more will be discovered in the future.  Many languages support particular programs particularly well and the two are strongly associated: lisp and list processing, or <a href="PascalLanguage.html">PascalLanguage</a> and procedural.  Of course it is possible, for example, to do OO in C or functional programming in Java, and often this is a good thing, but it's not <a href="WithTheGrain.html">WithTheGrain</a> of the language.  
      </p>
      <p>
        No one structuring paradigm is "right" for all programs.  This is one reason why there is no single right language.  It's also a large part of why learning new languages helps you develop as a programmer.  For many programs it might even be good to use more than one style within the same program.  
      </p>
      <p>
        <a href="PythonLanguage.html">PythonLanguage</a> and <a href="RubyLanguage.html">RubyLanguage</a> seems particularly good at allowing you to mix and match structures within a single language.  The "default" (the way we write <a href="HelloWorld.html">HelloWorld</a>) is procedural, but it feels equally natural to write OO or functional or reflective programs.  This lets it solve many different problems, and also means that experienced programmers keep discovering new things.
      </p>
      <p>
        <a href="CommonLisp.html">CommonLisp</a> has much the same feature, though it's a less approachable
        language for newcomers. Its origins are in the functional world, but
        it works well for procedural programming too and probably has the
        world's most powerful object system. One nice feature of <a href="CommonLisp.html">CommonLisp</a>
        is that its macro system makes it possible to build any paradigm you want
        right into the language. (On the other hand, for many programmers
        <em>nothing</em> in any variety of Lisp feels "natural"...)
      </p>
      <p>
        On the functional side, <a href="ObjectiveCaml.html">ObjectiveCaml</a> also tries to be multi-paradigm.
      </p>
      <p>
        [<em></em><a href="CeePlusPlus.html">CeePlusPlus</a> is then as well a <a href="MultiParadigmProgrammingLanguage.html">MultiParadigmProgrammingLanguage</a> in the exactly the same sense as <a href="CommonLisp.html">CommonLisp</a>, and <a href="InteLib.html">InteLib</a> demonstrates it ;-) -- <a href="AndreyStolyarov.html">AndreyStolyarov</a><em>]</em>
      </p>
      <hr/>
      <p>
        <strong>See Also:</strong> <a href="MultiParadigmProgrammingLanguage.html">MultiParadigmProgrammingLanguage</a>, <a href="ProgrammingParadigm.html">ProgrammingParadigm</a>, <a href="MixingParadigms.html">MixingParadigms</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryMultiparadigm.html">CategoryMultiparadigm</a>
      </p>
    </div>
  </body>
</html>