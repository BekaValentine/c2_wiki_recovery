<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Ee Language
      </h1>
      <p>
        An <a href="ObjectCapabilityLanguage.html">ObjectCapabilityLanguage</a> with the <a href="WikiUnFriendlyName.html">WikiUnFriendlyName</a> E.
      </p>
      <p>
        E is "the secure distributed pure-object platform and <a href="PeerToPeer.html">PeerToPeer</a> <a href="ScriptingLanguage.html">ScriptingLanguage</a> for writing Capability-based Smart Contracts" (contracts expressed as programs, where the logic of the program's execution helps enforce the terms of the contract. See <a href="http://www.erights.org/smart-contracts/">http://www.erights.org/smart-contracts/</a> .)
      </p>
      <ul>
        <li>
           <a href="http://www.erights.org/elang/">http://www.erights.org/elang/</a>
        </li>
        <li>
           <a href="http://wiki.erights.org/">http://wiki.erights.org/</a>
        </li>
      </ul>
      <p>
        E is a <a href="BigIdea.html">BigIdea</a> language, the big idea being <a href="CapabilityComputing.html">CapabilityComputing</a>. E also implements <em>distributed</em> capability computing, which is where things get interesting - your program can safely interact with remote E programs.  The implementation enforces the above constraints <strong>securely</strong>: it ensures (by the use of cryptography in the distributed case --
        see <a href="DistributedObjectCapabilityModel.html">DistributedObjectCapabilityModel</a>) that the rules cannot be violated. Lastly, E is specified to support (but at present does not implement) <a href="OrthogonalPersistence.html">OrthogonalPersistence</a> and 'AutomaticMobileCode'.
      </p>
      <p>
        <a href="EeLanguage.html">EeLanguage</a> is descended from <a href="JouleLanguage.html">JouleLanguage</a> -- see also <a href="http://www.erights.org/history/overview.html">http://www.erights.org/history/overview.html</a> . Like Joule,
        E belongs to the family of <a href="ActorLanguages.html">ActorLanguages</a>. It supports synchronous method calls (like most OO languages) as well as the asynchronous calls normally associated with the <a href="ActorsModel.html">ActorsModel</a>.
      </p>
      <hr/>
      <ul>
        <li>
           Money in 21 lines of code: <a href="http://www.erights.org/elib/capability/ode/ode-capabilities.html">http://www.erights.org/elib/capability/ode/ode-capabilities.html</a>
        </li>
      </ul>
      <hr/>
      <p>
        The reference implementation of E is currently implemented in <a href="JavaLanguage.html">JavaLanguage</a>, and programs written in E can use most of Java's libraries.
      </p>
      <p>
        There is a current project to run E code on the <a href="SqueakSmalltalk.html">SqueakSmalltalk</a> <a href="VirtualMachine.html">VirtualMachine</a>, called Ee On Squeak: <a href="http://www.google.com/search?q=%22E-on-Squeak%22">http://www.google.com/search?q=%22E-on-Squeak%22</a> (not to be confused with <a href="SqueakEe.html">SqueakEe</a>)
      </p>
      <p>
        As an experiment, it has been suggested to use this Wiki to discuss E development issues -- see below.
      </p>
      <p>
        [But also see <a href="WalledGardens.html">WalledGardens</a>. E language is very cool, but keep the E stuff on this page, or start an E wiki elsewhere]
      </p>
      <hr/>
      <p>
        I am finding the 'eventual' sends very interesting, as they return promises [<a href="PromisePipelining.html">PromisePipelining</a>]. It's not quite like promises in <a href="SchemeLanguage.html">SchemeLanguage</a>, but more in the asynchronous sense of, when the send arrives to that object, it will do as the message says, even an eventual creation returns an immediate promise of that object so you can send eventual messages. There's a try-catch mechanism for this called <em>when-catch</em>, which is the only part on the program that waits until the promise is resolved (either remotely or locally). This prevents deadlocks, very interesting... -- <a href="DavidDeLis.html">DavidDeLis</a>
      </p>
      <hr/>
      <p>
        (Besides being wiki-unfriendly this name is also GoogleHostile, not that C [<a href="CeeLanguage.html">CeeLanguage</a>], C++ [<a href="CeePlusPlus.html">CeePlusPlus</a>], PL/I [<a href="PliLanguage.html">PliLanguage</a>], Icon [<a href="IconLanguage.html">IconLanguage</a>] or TOM [<a href="TomLanguage.html">TomLanguage</a>] are any better in this respect...)
      </p>
      <hr/>
      <p>
        Open E development issues below:
      </p>
      <hr/>
      <p>
        E-like asynch I/O
      </p>
      <p>
        <a href="EeLanguage.html">EeLanguage</a> needs to replace its current I/O API with a non-blocking one. The non-blocking API should be designed according to the principles of E's eventual-send messaging style.
      </p>
      <p>
        The thread root is <a href="http://www.eros-os.org/pipermail/e-lang/2002-May/006517.html">http://www.eros-os.org/pipermail/e-lang/2002-May/006517.html</a>
      </p>
      <p>
        The dangling end is
        <a href="http://www.eros-os.org/pipermail/e-lang/2002-June/007083.html">http://www.eros-os.org/pipermail/e-lang/2002-June/007083.html</a>
      </p>
      <p>
        <em>Is there some concrete proposal for an API to comment on?</em>
      </p>
      <p>
        Yes: <a href="http://www.erights.org/elib/concurrency/eio/">http://www.erights.org/elib/concurrency/eio/</a>
      </p>
      <p>
        <em></em><a href="http://www.erights.org/elib/concurrency/eio/obtaining.html">http://www.erights.org/elib/concurrency/eio/obtaining.html</a> says<em></em>
      </p>
      <p>
        The sched parameter says how the operation should be scheduled:
      </p>
      <ul>
        <li>
           NOW - The operation is performed immediately, whether or not sufficient elements are ready. [...]
        </li>
        <li>
           WAIT - Warning: may block the vat and cause deadlock. If the operation can succeed immediately, it is performed immediately. [...]
        </li>
        <li>
           LATER - Registers a claim for the next atLeast..atMost elements, and returns a promise for them.
        </li>
      </ul>
      <p>
        <em>These should be considered different primitives, not variations of the same primitive. IIUC, E has a naming convention for methods that return promises, and I think it should also have one for methods that can (intentionally) block. Methods that have one of several concurrency behaviours depending on their parameters arguably should not be encouraged.</em>
      </p>
      <p>
        This is part of the motivation for providing the convenience methods. However, currently, we have no convenience methods for the WAIT case; perhaps we should? Perhaps we should have "readNow", "readWait", and "readLater"? (This is especially appealing because the current "read" really means "readNow"; whereas someone coming from the C tradition may very well expect "read" to mean "readWait".)
      </p>
      <p>
        Even if we introduce further convenience methods, your question remains: should we split the obtain primitive up into more simpler primitives according to their return type? The problem with this argument is knowing when to stop. ELEMENTS vs STATUS also makes for different return types -- making for 6 primitives instead of one.
      </p>
      <p>
        <em>Also, the OutStream design doesn't seem to be sufficient to provide proper backpressure on the producer. The pending messages sent to the OutStream will act as an unlimited buffer, so the producer's vat may run out of memory if it sends a lot of data faster than it can be consumed. One way of fixing this is for a client of an OutStream to be able to tell how much data is</em> <strong>locally</strong> <em>buffered. There probably also needs to be a variant of 'write' that returns a promise when the amount of local buffered data has fallen below a threshold.</em>
      </p>
      <p>
        You may have missed <a href="http://www.erights.org/javadoc/org/erights/e/elib/eio/Stream.html#whenAvailable%28int,org.erights.e.elib.base.Thunk%29">http://www.erights.org/javadoc/org/erights/e/elib/eio/Stream.html#whenAvailable%28int,org.erights.e.elib.base.Thunk%29</a>
      </p>
      <p>
        The intention of whenAvailable/2 is to enable just this kind of cooperative backpressure. It doesn't do what you're suggesting (it doesn't tell you how much is locally buffered), but does it tell you what you need? Does it address your concern?
      </p>
      <hr/>
      <p>
        What issue tracking software should we use?
      </p>
      <p>
        Current candidates are Wiki, The software used by <a href="RubyGarden.html">RubyGarden</a>, and Roundup.
      </p>
      <p>
        <em>News: We now have a Roundup at </em><a href="http://lambda.sieve.net/cgi-bin/roundup.cgi/demo/''">http://lambda.sieve.net/cgi-bin/roundup.cgi/demo/''</a>
      </p>
      <p>
        <em>Many thanks to Ka-Ping Yee and Steve Jenson!</em>
      </p>
      <p>
        The thread root is
        <a href="http://www.eros-os.org/pipermail/e-lang/2002-June/007069.html">http://www.eros-os.org/pipermail/e-lang/2002-June/007069.html</a>
      </p>
      <p>
        The dangling end of the e-lang thread is
        <a href="http://www.eros-os.org/pipermail/e-lang/2002-June/007084.html">http://www.eros-os.org/pipermail/e-lang/2002-June/007084.html</a>
      </p>
      <hr/>
      <p>
        See <a href="CapabilitySecurityModel.html">CapabilitySecurityModel</a>, <a href="ObjectCapabilityModel.html">ObjectCapabilityModel</a>, <a href="ObjectCapabilityLanguage.html">ObjectCapabilityLanguage</a>, <a href="ActorLanguages.html">ActorLanguages</a>, <a href="ActorsModel.html">ActorsModel</a>, <a href="DistributedObjectCapabilityModel.html">DistributedObjectCapabilityModel</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryProgrammingLanguage.html">CategoryProgrammingLanguage</a>
      </p>
    </div>
  </body>
</html>