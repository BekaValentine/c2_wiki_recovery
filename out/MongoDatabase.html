<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Mongo Database
      </h1>
      <p>
        A <a href="NoSql.html">NoSql</a> database, <a href="http://www.mongodb.org/">http://www.mongodb.org/</a> , with a _long_ list of customers, and only primal database abilities:
      </p>
      <ul>
        <li>
           JSON (<a href="JavaScriptObjectNotation.html">JavaScriptObjectNotation</a>) based documents
        </li>
        <li>
           A server with CRUD & ACID
        </li>
        <li>
           the ability to store arbitrary dictionaries as data buckets, in flat collections, in databases.
        </li>
        <li>
           blazing fast indices
        </li>
        <li>
           replication & clustering
        </li>
        <li>
           unique record IDs
        </li>
      </ul>
      <p>
        That's all. To get schemas, relations, & migrations, you write them yourself into your ORM layer. OR you encode them as embedded application-specific <a href="JavaScript.html">JavaScript</a> that Mongo stores & calls at various trigger times.
      </p>
      <p>
        Transactions in MongoDB are limited to a single document, though one can apply all the normal tricks involved with <a href="ReadCopyUpdate.html">ReadCopyUpdate</a> and <a href="PersistentDataStructure.html">PersistentDataStructure</a> to explicitly model larger transactions. Similarly, we can model 'pending transactions' explicitly as document state, assuming sufficient cooperation between applications. 
      </p>
      <p>
        This is a lot of extra complexity for the application and schema developers to deal with, but I guess the hope is that it isn't often necessary.
      </p>
      <hr/>
      <p>
        After I switched to MongoDB, I was surprised how little SQL I missed. It seems that adding whatever touch of relations you need, to your ORM, is actually cheaper than adding all the excess cruft you need to connect a modern language to classical SQL statements. --<a href="PhlIp.html">PhlIp</a>
      </p>
      <p>
        <em>What sort of application are you developing?</em>
      </p>
      <p>
        A ThinServer that pushes dynamic content to iPads, and journals which iPads have what version of what content.
      </p>
      <p>
        These are not us, but we are in this space:
      </p>
      <p>
        <a href="http://www.macrumors.com/2011/08/23/united-airlines-deploying-11000-ipads-to-pilots-as-electronic-flight-bags/">http://www.macrumors.com/2011/08/23/united-airlines-deploying-11000-ipads-to-pilots-as-electronic-flight-bags/</a>
      </p>
      <p>
        <a href="http://www.tampabay.com/sports/football/bucs/article1187879.ece">http://www.tampabay.com/sports/football/bucs/article1187879.ece</a>
      </p>
      <p>
        Fat server (the <a href="WorldWideWeb.html">WorldWideWeb</a>) was fun, but we are on to the next big thing. And we don't use Mongo for the actual relations, not because they are too few, but because they are too many!
      </p>
      <hr/>
      <p>
        <em>As a fellow application developer, I'm not surprised at how little SQL you missed.  Or, how little you missed SQL.  You will miss SQL, however, when management decides your storage solution (which is what </em><a href="NoSql.html">NoSql</a> databases are) needs to be concurrently shared by multiple applications -- some legacy, and some new, in a variety of languages and platforms -- and support ad-hoc queries from popular reporting and/or ETL tools.<em></em>
      </p>
      <p>
        Ah, the "older, wiser, and more experienced than you" argument. I'm sure <a href="NoSql.html">NoSql</a> can be abused, but point of our server is stash everything in a common database cluster, and serve it all via REST to multiple applications. So, yes, we have the ad-hoc query layer...
      </p>
      <p>
        <em>No, that would be the "been there, done that, got the T-shirt" argument.  What you have is a general access mechanism using a recognised architectural style.  You have neither a standard query language nor a standardised protocol, either of which could be the basis for an ad-hoc query layer.  As described, there's nothing "ad-hoc" about it.</em>
      </p>
      <hr/>
      <p>
        See also: <a href="DynamicRelational.html">DynamicRelational</a>
      </p>
    </div>
  </body>
</html>