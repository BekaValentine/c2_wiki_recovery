<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Temporal Classes And Identity
      </h1>
      <p>
        <a href="CircleAndEllipseProblem.html">CircleAndEllipseProblem</a> describes the difficulty when we get clashes between attributes and behaviour.
      </p>
      <p>
        There is a similar problem with OO and classes that change over time. 
      </p>
      <p>
        For example, we have a bank account class. It can either be active or it can be inactive. The attributes and behaviour of each are different. However for an object of type bank account, the id remains the same. 
      </p>
      <p>
        The standard way is to represent the id as an attribute, and then create new class instances whenever the type changes. 
      </p>
      <p>
        It would be nicer to keep the identity, and change the type. 
      </p>
      <p>
        The class invariants need to be enforced. Not all transitions are legal.
      </p>
      <p>
        This then solves the mutability issue with circle/ellipse.
      </p>
      <p>
        Are there any programming languages that do this?
      </p>
      <p>
        -- NickLeaton
      </p>
      <hr/>
      <p>
        Check out <a href="CecilLanguage.html">CecilLanguage</a> and <a href="PredicateClasses.html">PredicateClasses</a>.  <a href="PredicateDispatching.html">PredicateDispatching</a> also lets you do it, in a more roundabout way, but the biggest subset of predicate dispatching you're going to get is, again, Cecil.  -- <a href="JonathanTang.html">JonathanTang</a>
      </p>
      <p>
        Am I the only one that finds predicate classes absurd?
      </p>
      <p>
        The only elegant solution when you need an object to change its class is to go ahead and make parent classes dynamic. This is the case in <a href="SelfLanguage.html">SelfLanguage</a>. I guess this means that prototyping is strictly superior to classing, making them NOT equivalent. -- <a href="RichardKulisz.html">RichardKulisz</a>
      </p>
      <p>
        Cecil is a <a href="PrototypeBasedLanguage.html">PrototypeBasedLanguage</a>, or at least all the papers on <a href="PredicateDispatching.html">PredicateDispatching</a> describe how to do it with a protoype-based object model.  Some of the equivalencies between <a href="PatternMatching.html">PatternMatching</a> and <a href="PredicateDispatching.html">PredicateDispatching</a> become significantly easier with prototypes.
      </p>
      <p>
        This is somewhat expected, as the guy who invented <a href="PredicateClasses.html">PredicateClasses</a> (CraigChambers) got his PhD on the Self project.  
      </p>
      <ul>
        <li>
           Not really.  When you redefine *parent, you keep all the predicates and they just specialize the new parent (assuming dynamic typing semantics; the Cecil papers specify how to do dispatch with both <a href="StaticTyping.html">StaticTyping</a> and <a href="DynamicTyping.html">DynamicTyping</a>, and dynamic inheritance makes no sense with static typing).  But <a href="PredicateClasses.html">PredicateClasses</a> themselves are often a better, more structured way to handle dynamically-changing class membership.  Predicate classes still let you reason statically about a program, something that's completely impossible with dynamic inheritance.  And most of the uses for dynamic inheritance (eg. <a href="CircleAndEllipseProblem.html">CircleAndEllipseProblem</a>) can be solved just as easily with predicates.  -- jt
        </li>
      </ul>
      <p>
        Oh, and prototypes and classes are equivalent iff you have metaclasses.  A <a href="MetaClass.html">MetaClass</a> is just an object that functions like a class, though, so you could argue that it's really a prototype anyway.  Except that it still follows the "blueprint" instead of the "prototype" model (it describes how to lay out a class, it doesn't provide a model to copy).  -- <a href="JonathanTang.html">JonathanTang</a>
      </p>
      <hr/>
      <p>
        For languages that do not allow a class to dynamically change its type, the <a href="StatePattern.html">StatePattern</a> offers one possible solution. Perhaps this page could be merged with <a href="DualityBetweenStateAndClass.html">DualityBetweenStateAndClass</a>.
      </p>
    </div>
  </body>
</html>