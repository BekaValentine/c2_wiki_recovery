<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Things We Love About Visual Basic Dot Net
      </h1>
      <p>
        Things we love about <a href="VisualBasicDotNet.html">VisualBasicDotNet</a>:
      </p>
      <p>
        <em>(...sometimes related to </em><a href="ThingsWeLoveAboutVbClassic.html">ThingsWeLoveAboutVbClassic</a>.)<em></em>
      </p>
      <p>
        <em>Not to be confused with </em><a href="ThingsWeHateAboutVisualBasicDotNet.html">ThingsWeHateAboutVisualBasicDotNet</a>.<em></em>
      </p>
      <hr/>
      <p>
        <strong>List:</strong>
      </p>
      <ul>
        <li>
           XML Literals, right in the source code.
        </li>
        <li>
           SQL-like DLinq (LinqToSql) syntax.
        </li>
        <li>
           The <strong>Overrides</strong> keyword.
        </li>
        <li>
           The <strong>Shared</strong> keyword, for "static" Fields and Methods.
        </li>
        <li>
           Has optional <a href="NamedParameter.html">NamedParameter</a>s that are designed fairly well. I <em>loooove</em> named parameters.
        </li>
      </ul>
      <hr/>
      <hr/>
      <p>
        <strong>Discussion:</strong>
      </p>
      <hr/>
      <ul>
        <li>
           <strong>XML Literals, right in the source code.</strong>
        </li>
      </ul>
      <p>
        You can embed XML literals right into your source code:
      </p>
      <code>
        Dim xmlVar As XElement = _<br/>
        <rootElement><br/>
        <innerElement1/><br/>
        <innerElement2>Constant text here.</innerElement2><br/>
        </rootElement><br/>
      </code>
      <p>
        and you can embed expressions to dynamically change element and attribute names and values
      </p>
      <code>
        Dim xmlVar As XElement = _<br/>
        <rootElement><br/>
        <nameElement type=<%= greetingType %>><%= "Hello " + nameVar + "." %></nameElement><br/>
        <<%= dynamicElementName %> <%= dynamicAttributeName %>="static attribute value"/><br/>
        </rootElement><br/>
      </code>
      <p>
        and <a href="VisualBasic.html">VisualBasic</a> automatically does all the appropriate quoting, giving one a high level of protection against <a href="SqlInjection.html">SqlInjection</a> attacks.
      </p>
      <hr/>
      <hr/>
      <ul>
        <li>
           <strong>SQL-like DLinq (</strong>LinqToSql) syntax.<strong></strong>
        </li>
      </ul>
      <p>
        Query syntax in DLinq (LinqToSql) is much more like the <a href="StructuredQueryLanguage.html">StructuredQueryLanguage</a> (SQL) syntax we're accustomed to, rather than the "collections library" style syntax in C#.
      </p>
      <p>
        In <a href="VisualBasicDotNet.html">VisualBasicDotNet</a>, one might do a DLinq query like this:
      </p>
      <code>
        SELECT p2.ProductName, p1.UnitPrice<br/>
        FROM dbo.ProductsCostingMoreThan(80.50)<br/>
        AS p1 INNER JOIN Products AS p2 ON p1.ProductID = p2.ProductID<br/>
      </code>
      <p>
        Where in the <a href="CsharpLanguage.html">CsharpLanguage</a> (C#), it would look more like this:
      </p>
      <code>
        var q =<br/>
        from p in db.ProductsCostingMoreThan(80.50m)<br/>
        join s in db.Products on p.ProductID equals s.ProductID<br/>
        select new {p.ProductID, s.UnitPrice};<br/>
      </code>
      <p>
        The VB.NET syntax is much more like the <a href="RelationalDatabase.html">RelationalDatabase</a>'s SQL syntax than the C# version.
        The C# version has all the same clauses, but they're in some other order that's "more natural" for a collections library.
      </p>
      <p>
        Related: <a href="LanguageIntegratedQueryProject.html">LanguageIntegratedQueryProject</a>
      </p>
      <hr/>
      <hr/>
      <ul>
        <li>
           <strong>The Overrides keyword.</strong>
        </li>
      </ul>
      <p>
        For a <a href="VisualBasic.html">VisualBasic</a> subclass to override a superclass method, you <strong>must</strong> use the <strong>Overrides</strong> keyword:
        If the method signatures match and you don't have the <strong>Overrides</strong> keyword, it's a compile error.
        The Java 5 <strong>@Override</strong> annotation is nice, but when it's missing, the program might or might not still be overriding a superclass method, and the original programmer might or might not have been intending to override a superclass method; it can be hard to be sure.
        But with <a href="VisualBasic.html">VisualBasic</a> the intention and implementation are always clear:  You see the <strong>Overrides</strong> keyword <a href="IfAndOnlyIf.html">IfAndOnlyIf</a> this method overrides a superclass method.
      </p>
      <hr/>
      <hr/>
      <ul>
        <li>
           <strong>The Shared keyword, for "static" Fields and Methods.</strong>
        </li>
      </ul>
      <p>
        The <strong>Shared</strong> keyword more clearly expresses that fields and methods are <strong>Shared</strong> across all instances of a class -- making its usage much less error-prone than the C/C++/C#/Java overloading of the <strong>static</strong> keyword for this purpose, particularly for relatively less experienced developers.
      </p>
      <hr/>
      <p>
        <a href="CategoryVisualBasic.html">CategoryVisualBasic</a> <a href="CategoryDotNet.html">CategoryDotNet</a>
      </p>
    </div>
  </body>
</html>