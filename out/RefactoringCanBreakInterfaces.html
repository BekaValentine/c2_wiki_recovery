<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Refactoring Can Break Interfaces
      </h1>
      <p>
        Refactoring often requires breaking interfaces. The same forces that created the code you wish to refactor also created the interfaces, therefore the interfaces are often less than desirable, which means if you are continually improving code you must also improve the interfaces. 
      </p>
      <p>
        You can't possibly say your code base is improving and not improve the interfaces as well. There's nothing special about interfaces that means they were correct. There's nothing special about interfaces that means they can be a fixed center around which everything turns.
      </p>
      <p>
        If stuff breaks then it breaks. Your <a href="UnitTest.html">UnitTest</a>s and compiler will help you fix it. It's no different than any other changes.
      </p>
      <p>
        Yes, refactoring often requires changing interfaces.  So, <em>Don't publish interfaces prematurely. Modify your code ownership policies to smooth refactoring</em> -- <a href="RefactoringImprovingTheDesignOfExistingCode.html">RefactoringImprovingTheDesignOfExistingCode</a>, chapter 2, Problems with Refactoring.  It also talks a little bit about what to do when an interface is published.
      </p>
      <hr/>
      <p>
        <strong>When you're using other peoples' published interfaces.</strong>
      </p>
      <p>
        Better wrap those external interfaces so you can keep control.  See <a href="ShieldPattern.html">ShieldPattern</a>, <a href="AdapterPattern.html">AdapterPattern</a>, <a href="BridgePattern.html">BridgePattern</a>, <a href="ProxyPattern.html">ProxyPattern</a>...  The basic idea is to create an interface that you control, and the rest of your code uses.  Behind that interface, you make calls to the code that is not under your control.  This allows the rest of your code to be mostly immune to changes in the external code - just change your wrapper code.  Also, you can often insert workarounds for bugs in the external code.
      </p>
      <p>
        <strong>When other people are using your published interfaces</strong>
      </p>
      <p>
        Say you've written some kind of widget which has an interface so that programs can embed the widget in their user interface, tell it to do things, and get information back from it about what it's doing.  If you decide to <a href="ReFactor.html">ReFactor</a> the interface between your widget and the outside world, third-party developers using your widget are going to curse your name because now their code doesn't work, and they have to finish the <a href="ReFactoring.html">ReFactoring</a> that you started.  This happens regularly with <a href="LinuxKernel.html">LinuxKernel</a>, GeeLibCee and <a href="GnomeDesktopEnvironment.html">GnomeDesktopEnvironment</a>.
      </p>
      <p>
        That's why interfaces with dependencies from code you can't change shouldn't change.  They should aggregate with new versions, be replaced by new versions and eventually deprecate when (and if) old dependencies migrate to the new versions.
      </p>
      <hr/>
      <p>
        Every piece of code as interface to some other piece of code. Logically then nothing
        can be refactored.
      </p>
      <p>
        <em>If you can't change the code that depends on an interface and all of the code falls into that category, then yes, nothing can be refactored.  Refactoring requires the ability to modify code.</em>
      </p>
      <hr/>
      <p>
        <strong>Distinguish between internal and external projects.</strong>
      </p>
      <p>
        Even on a large internal project i can break interfaces and recover because
        we have control. If you have interfaces to paying customers then you
        would be much more committed not to breaking those interfaces.
      </p>
      <hr/>
      <p>
        See <a href="NonPublishedPublicInterfacesAreRefactorable.html">NonPublishedPublicInterfacesAreRefactorable</a>.
      </p>
    </div>
  </body>
</html>