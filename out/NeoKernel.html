<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Neo Kernel
      </h1>
      <p>
        A term (coined by <a href="TomAnderson.html">TomAnderson</a> for want of a better one) to describe <a href="OperatingSystem.html">OperatingSystem</a>s which don't really fit on the monolithic-microkernel-nanokernel-exokernel spectrum. In particular, <a href="OperatingSystem.html">OperatingSystem</a>s in which the application-OS boundary is blurred.
      </p>
      <p>
        <a href="NeoKernel.html">NeoKernel</a>s typically require that applications are written in some safe language, so that the usual guarantees about memory and processor use can be enforced by the compiler (that is, the compiler which emits native code; the applications may be supplied as bytecode). For example, if the OS has control over compilation, and applications are written in a language which cannot express unsafe operations (such as the <a href="JavaLanguage.html">JavaLanguage</a> or <a href="ModulaThree.html">ModulaThree</a>), then MemoryProtection is not needed. Similarly, if programs cannot make jumps to arbitrary memory locations, access to the OS API can be controlled at compile-time, and so many of the security checks which normally accompany OS calls can be elided. Preemptive threading may also be redundant, as the compiler can insert the necessary code to do cooperative threading. All of these lead to performance improvements. Further performance improvements can come from the ability to compile application and OS components at the same time, which allows such things as inlining OS calls.
      </p>
      <p>
        A particular example is <a href="SpinOs.html">SpinOs</a>. The <a href="LispMachine.html">LispMachine</a> <a href="OperatingSystem.html">OperatingSystem</a>, Genera, was also a <a href="NeoKernel.html">NeoKernel</a> - as usual, LISP was way ahead of its time.
      </p>
      <hr/>
      <p>
        Can a user process run by a <a href="NeoKernel.html">NeoKernel</a> provide abstractions to other users in a manner indistinguishable from the safe language's? And can a user process with sufficiently high priviledge modify the language? I don't understand the subject but my impression is that the answers to both of these questions are no.
      </p>
      <p>
        <em>The 'abstractions' supplied by the language are typically things like variables, arrays, control structures and the other normal linguistic constructs; user processes export abstractions at the level of interfaces and objects. In LISP, these two are somewhat interchangeable, of course. The language is constant across all processes.</em>
      </p>
      <p>
        If that is the case then the 'kernel' is the safe language and <a href="NeoKernel.html">NeoKernel</a>s are <a href="MegaKernel.html">MegaKernel</a>s.
      </p>
      <p>
        <em>What is a </em><a href="MegaKernel.html">MegaKernel</a>, and why does this make a <a href="NeoKernel.html">NeoKernel</a> one? My guess at the meaning of '<a href="MegaKernel.html">MegaKernel</a>' would involve the kernel being huge, containing all sorts of functionality that would normally be found in user space such as a WindowSystem, CommandShell, <a href="TextEditor.html">TextEditor</a>, email client, admin tools, etc. If that is the case, then, in a sense, <a href="NeoKernel.html">NeoKernel</a>s are indeed <a href="MegaKernel.html">MegaKernel</a>s, except that they're equally the ultimate <a href="ExoKernel.html">ExoKernel</a>s. The point is that the boundary between kernel and application is blurred, so it is no longer entirely possible to distinguish between the two.<em></em>
      </p>
      <p>
        By <em>the language is constant across all processes</em> do you mean that if one process modifies an object (say, class Array) then this modification will not appear to other processes?
      </p>
      <p>
        There are ways to modify a language so that multiple untrusted processes can share it. The naive way is to change every reference into a capability (perhaps with something like SubjectiveObjects: <a href="http://citeseer.nj.nec.com/smith96simple.html).">http://citeseer.nj.nec.com/smith96simple.html).</a> I don't know of any other ways but I'm guessing they would have to be fairly exotic (which is why I'm not interested in them). What I'm guessing people do is give each process a pristine copy of a base language and, perhaps, provide limited access to user extensions in a distinct space. If that's the case then the system is not an <a href="ExoKernel.html">ExoKernel</a> since it doesn't allow user processes to bypass the "kernel" by making their own modifications to it and sharing them.
      </p>
      <p>
        Even if you lobotomized a language by stripping away all its libraries, leaving behind only the <a href="ByteCode.html">ByteCode</a>, this may simply be too abstract to be considered a pure <a href="ExoKernel.html">ExoKernel</a>.
      </p>
      <hr/>
      <p>
        And could someone explain the difference between kernel and OS? I never got a solid grasp on that one. -- <a href="RichardKulisz.html">RichardKulisz</a>
      </p>
      <p>
        Simple.  "Kernel" is a term with a simple technical definition.  "OS" is a term with no coherent definition of any sort, either technical, legal, or popular.  The two leading usages of "OS" are, respectively: "thing which came on one CD and allows my computer to function"; and "kernel". -- <a href="DanielKnapp.html">DanielKnapp</a>
      </p>
      <p>
        <a href="WhatIsaKernel.html">WhatIsaKernel</a>?
      </p>
    </div>
  </body>
</html>