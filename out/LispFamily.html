<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Lisp Family
      </h1>
      <p>
        Originally, the term <em>Lisp</em> referred to the language which was the brainchild of <a href="JohnMcCarthy.html">JohnMcCarthy</a>.
      </p>
      <p>
        Nowadays, when unspecified, the term <em>Lisp</em> either refers to <em></em><a href="CommonLisp.html">CommonLisp</a><em> (a language), or the </em>Lisp family of languages<em>, all of which share the </em><a href="LambdaNature.html">LambdaNature</a> (see <a href="LanguageFamilies.html">LanguageFamilies</a>). 
      </p>
      <p>
        A less strict criterion for inclusion of a language into the <a href="LispFamily.html">LispFamily</a> is the use of parenthesized lists to represent a program, and manipulation of lists made of two-field cells that can be manufactured and connected by a function called CONS (see <a href="ConsCell.html">ConsCell</a>s). It's somewhat of a custom that whenever someone writes a one-weekend interpreter for such a language, it is given a name that includes the word "Lisp". (Never heard of that - where is that?) Much newbie confusion arises from all of the different things that are called Lisp but have nothing to do with the mature, complex, super-powerful <a href="CommonLisp.html">CommonLisp</a>, which, as the result of the combined efforts of the dominating lisp communities, is seen by many as the only thing that should be called Lisp (see <a href="TheEvolutionOfLisp.html">TheEvolutionOfLisp</a>).
      </p>
      <p>
        'SEXP-Syntax is neither sufficient nor necessary' for a Lisp dialect.
      </p>
      <hr/>
      <p>
        The sharing of the CONS function is something I borrowed from a paper by KentPitman in which he tries to pin down what exactly makes something Lisp. (See <a href="http://www.nhplace.com/kent/PS/Lambda.html.">http://www.nhplace.com/kent/PS/Lambda.html.</a> Also see <a href="ParentheticallySpeaking.html">ParentheticallySpeaking</a>.) 
        There, he also argues that there is no lambda commonality among things calling themselves Lisp; the syntax varies - some things don't have lexical closures, others closures that can only be passed down, not returned, etc. <a href="LambdaNature.html">LambdaNature</a> cannot exist without lexical scoping, so that the <a href="LambdaExpression.html">LambdaExpression</a> creates a function-object that has captured the lexical bindings.
      </p>
      <ul>
        <li>
           Why is <a href="LambdaNature.html">LambdaNature</a> dependent on lexical scoping, given that lambda is so much older than Lisp lexical scoping?
        </li>
      </ul>
      <p>
        But note that I disagree with this paper on the whole; Pitman believes that there is a <a href="LispFamily.html">LispFamily</a>, but that it arises out of some vague cultural connections rather than any specific language features. I view myself strictly as a <a href="CommonLisp.html">CommonLisp</a> user, and nothing more. I stay away from anything else that resembles Lisp, and don't feel that I belong to any broader community. Communities based on sharing a programming language are a fiction. Two people who don't know each other at all, but just happen to use the same programming language, text editor, operating system or whatever, are not automatically a community! That they can be is just some touchy-feely thinking thinking that might be called TechnoCollectivism. Or maybe it's a spinoff idea from BrandIdentification that westerners grow up with. If you drive a certain make of car, you are suddenly a member of the group of people who drive that car, and somehow this is more than just a dry mathematical observation that places you in a set. But really, to have a community, you must have a group of individuals who identify together in some concrete way, and actually know and recognize each other. I might form a community with some CL users, but not all of them at once!
      </p>
      <hr/>
      <p>
        <a href="PaulGraham.html">PaulGraham</a> provides another reasoning what defines Lisp. See <a href="http://www.paulgraham.com/diff.html">http://www.paulgraham.com/diff.html</a>
      </p>
      <hr/>
      <p>
        <a href="GeraldSussman.html">GeraldSussman</a> and <a href="GuySteele.html">GuySteele</a> named their dialect Scheme at a time when it was fashionable to give each Lisp dialect their own name (MDL, T, NIL, Conniver, and so on). Note that in the original papers about Scheme, Scheme is always described as a Lisp dialect. Further note that today's Scheme looks remarkably different to the original Scheme. Further further note, that the original Lisp didn't have lexical closures but that they were introduced in a clean way in Scheme. The <a href="CommonLisp.html">CommonLisp</a> designers have taken the <a href="LexicalClosure.html">LexicalClosure</a> concept from Scheme. (In turn, lexical closures were first defined in <a href="AlgolLanguage.html">AlgolLanguage</a>.)
      </p>
      <p>
        There are many reasons why to prefer <a href="CommonLisp.html">CommonLisp</a> over <a href="SchemeLanguage.html">SchemeLanguage</a> (see <a href="LispSchemeDifferences.html">LispSchemeDifferences</a>), and vice-versa, but to describe Scheme as not being a Lisp is as simplistic as to say that Scheme and Lisp are more or less the same. The truth is somewhere in between.
      </p>
      <hr/>
      <p>
        I wouldn't care if the Scheme people take over the word Lisp, and the <a href="CommonLisp.html">CommonLisp</a> people then rename their language and stop using the word. The point is that the term is simply too diluted when it takes on too many meanings, and as such it has little value. We can't even agree on what Lisp means; so maybe there is no point in using this word? Yet somehow it seems so coveted that people get ruffled when someone dares suggest that their pet language is not Lisp. Maybe "Lisp" is just a synonym for "cool". So if you say that some language is not Lisp, you are really saying that it's not cool. Also, because "cool" is hard to define, "Lisp" is hard to define. Moreover, things that are obviously not Lisp at all are clearly uncool. I can't think of a single counterexample when "Lisp" does not mean "cool", except when it's used in the name of some concrete language or implementation. AutoLISP doesn't mean AutoCOOL, and Common Lisp doesn't mean Common Cool. But as an adjective, to say that something is Lisp simply means that it has hacker approval.
      </p>
      <hr/>
      <p>
        Okay, so how about this: Lisp as an adjective means "cool". Lisp as a noun that is part of a noun phrase designating a programming language adds the semantic attribute "language derived from cool ideas". And used entirely by itself, in the absence of historic context, it means "ANSI Common Lisp", where this second occurrence of Lisp is not subject to the cool-substitution, but simply stands for itself. In some proper historic context it means "the language invented by <a href="JohnMcCarthy.html">JohnMcCarthy</a> and peers". There, it's settled!
      </p>
      <hr/>
      <p>
        <em>So, Lisp == cool? I thought that </em><a href="CsharpLanguage.html">CsharpLanguage</a> == cool! By transitivity, this implies that Lisp == C#<em></em>
      </p>
      <p>
        <em>Amazing. And all this time I had thought that C#/</em><a href="DotNet.html">DotNet</a> was little more than a blatant ripoff of Java (both the language and the platform)! Now we find it's really Lisp in disguise!<em></em>
      </p>
      <p>
        <em>So, then why doesn't C# have </em><a href="EssExpressions.html">EssExpressions</a>?<em></em>
      </p>
      <p>
        Ah, I think your "==" operator means, in this context, "is a member of the set".
      </p>
      <p>
        <em>No, "==" means equality. The development codename for the C# project at Microsoft was "Cool", one of the worst-kept secrets of the past couple years. The rest of the above section is tongue-in-cheek</em>
      </p>
      <p>
        <em>So... when do you think we will see </em>MicrosoftVisualLisp (or, for that matter, VisualLispDotNet?????) What will the <a href="LispHippie.html">LispHippie</a>s do if their favorite language is taken over by the EvilEmpire? I guess it would make writing macros in <a href="MicrosoftExcel.html">MicrosoftExcel</a> more fun!<em></em>
      </p>
      <p>
        <em>-- </em><a href="ScottJohnson.html">ScottJohnson</a><em></em>
      </p>
      <p>
        Well, long, long ago, there was already an MS Lisp...
        <a href="http://groups.google.com/groups?q=microsoft+lisp&ie=ISO-8859-1&hl=en">http://groups.google.com/groups?q=microsoft+lisp&ie=ISO-8859-1&hl=en</a>
      </p>
      <p>
        <em>There is a Visual Lisp product from Autodesk for use with its popular </em>AutoCAD software. Not surprisingly, the appearance of Visual Lisp coincided with the full-scale conversion of AutoCAD from a cross-platform tool into an application deeply rooted in, and heavily dependent on, the Windows environment (with ActiveX, etc.). -- <a href="JeffRead.html">JeffRead</a><em></em>
      </p>
      <ul>
        <li>
           I hadn't noticed that it used to be heavily cross-platform. Anyway, just to avoid confusion: <a href="AutoCad.html">AutoCad</a> included <a href="AutoLisp.html">AutoLisp</a> since 1985, and <a href="AutoDesk.html">AutoDesk</a> added the VisualLisp programming environment for <a href="AutoLisp.html">AutoLisp</a> in 1997. <a href="http://courses.home.att.net/autolisp/ahistory.htm">http://courses.home.att.net/autolisp/ahistory.htm</a>
        </li>
      </ul>
      <hr/>
      <p>
        A few things that might define some core of Lisp dialects and their typical implementation:
      </p>
      <ul>
        <li>
           supports functional programming (LAMBDA, higher order functions, anonymous functions, local functions, APPLY, recursion, ...)
        </li>
        <li>
           supports imperative programming (SETQ, BLOCK, TAGBODY, ...)
        </li>
        <li>
           code transformation with macros
        </li>
        <li>
           S-Expression notation as external notation for data-structures
        </li>
        <li>
           Read Eval Print Loop for interactive programming
        </li>
        <li>
           some form of automatic memory management
        </li>
        <li>
           types declarations are optional
        </li>
        <li>
           runtime generation and loading of source code
        </li>
        <li>
           image-based programming environment
        </li>
        <li>
           support for datastructures (symbols, functions, numbers, strings, arrays, conses, structures/classes, ...)
        </li>
        <li>
           basic error handling
        </li>
        <li>
           basic I/O with streams
        </li>
      </ul>
      <p>
        Scheme extends this list by:
      </p>
      <ul>
        <li>
           defined syntax
        </li>
        <li>
           defined semantics
        </li>
        <li>
           hygienic macros
        </li>
        <li>
           continuations
        </li>
        <li>
           lexical scope
        </li>
        <li>
           tail-call optimization
        </li>
      </ul>
      <p>
        Common Lisp extends the list by too many things to list:
      </p>
      <ul>
        <li>
           declarations (types, compiler directives, ...)
        </li>
        <li>
           multiple values
        </li>
        <li>
           lexical scope as the default in addition to dynamic scope
        </li>
        <li>
           Common Lisp Object System
        </li>
        <li>
           compiler
        </li>
        <li>
           extensive error handling (condition system)
        </li>
        <li>
           more datatypes (extensive numeric tower, hashtables, streams, pathnames, ...)
        </li>
        <li>
           environment functions (ED, INSPECT, DESCRIBE, TRACE, ...)
        </li>
        <li>
           read-macros
        </li>
      </ul>
      <p>
        Let's look at Dylan (the later Dylan):
      </p>
      <ul>
        <li>
           declarations
        </li>
        <li>
           lexical scope
        </li>
        <li>
           object system built-in (simple version of CLOS)
        </li>
        <li>
           error-handling
        </li>
        <li>
           type-checking at compile time
        </li>
      </ul>
      <p>
        Dylan lacks (despite its name) as a language the dynamic nature of the environment (though implementations are providing it as an addition): no read-eval-print-loop, no image-based development, no runtime code generation and no loading, ... Dylan also lacks the S-Expression syntax (the earlier Dylan version had it).
      </p>
      <hr/>
      <p>
        <em>What do you consider the boundary between early-Dylan and late-Dylan? The switch to misfix syntax, or the demise of </em>AppleDylan? AFAIK, the original AppleDylan had image-based development and a REPL loop. <a href="GwydionDylan.html">GwydionDylan</a> lacked it because the Gwydion implementation was incomplete (funding pulled), but the original intent of the Gwydion project was to develop a state-of-the-art IDE that most likely would've included those features. Recent versions (2.3.10 and up) have added a REPL anyway. -- <a href="JonathanTang.html">JonathanTang</a><em> </em>
      </p>
      <p>
        Generally I see Dylan as a language with several implementations. There were implementations of both versions of the language (early Dylan was more Lisp-like, late Dylan was more static with a different syntax).
      </p>
      <p>
        Early Dylan was a OODL (Object-oriented dynamic language). Basically, it was Scheme-like with the CLOS object-system (plus conditions, ...). The later Dylan was more concerned with efficient compilation and a mixfix (infix/prefix) syntax. It was also in many respects quite similar in spirit to EuLisp (an European attempt at an efficient and modern Lisp). Though I would say that Dylan is smaller and more monolithic than EuLisp. But EuLisp was the much better Lisp - compared to Dylan. As a Lisp programmer I liked the earlier version more - but Lisp programmers were not the target audience.
      </p>
      <p>
        The AppleDylan development environment was a bit unusual for an integrated Lisp system. (btw., It was not written in Dylan, but Common Lisp) Typically it had the source stored in a database and had remote connections to running Dylan applications. Though the GUI builder was written in Dylan and was running inside the remote Dylan application. So it is a bit similar in spirit (remote Lisp controlled by a foreign IDE) with Emacs-based IDEs for Common Lisp. Many Common Lisp IDEs are running inside the same image like the applications they are used to develop. One exception is CMUCL/Hemlock. There also is the idea of some 'slave' Lisp. I would say that the AppleDylan environment was not very typical for a Lisp-based development environment - though it was a logical step from earlier systems.
      </p>
      <p>
        The Gwydion team start with bold ideas of a novel programming environment. But they never got far in that direction. They were mostly busy implementing the language. For quite some time.
      </p>
      <hr/>
      <p>
        <a href="CategoryLisp.html">CategoryLisp</a>
      </p>
    </div>
  </body>
</html>