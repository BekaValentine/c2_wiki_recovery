<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Bottom Type
      </h1>
      <p>
        A type, in type theory, which has the property that it is the subtype of all other types in the universe. As it is impossible for an instance to be a member of all types (there is no instance which is a record, AND a boolean, AND a function, for instance); this type is empty or "uninhabited"; no instances of this type exist.
      </p>
      <p>
        Called Bot (_|_) in Haskell; called Void (VoidType) in <a href="EiffelLanguage.html">EiffelLanguage</a>. C/C++ void has some properties similar to a bottom type; however neither language makes the claim that it is a universal subtype. (Of course, C doesn't HAVE a notion of subtypes and supertypes to begin with). Nil in <a href="CommonLisp.html">CommonLisp</a> is also the <a href="BottomType.html">BottomType</a>.
      </p>
      <p>
        Unlike the universal supertype <a href="TopType.html">TopType</a>, which is found in most OO languages (<a href="CeePlusPlus.html">CeePlusPlus</a> being an exception, although "void *" is often used to emulate it), <a href="BottomType.html">BottomType</a> causes problems with strong type systems; as virtually everything needs to be checked if it is a <a href="BottomType.html">BottomType</a> or not. (In addition, there is the problem of casting something to <a href="BottomType.html">BottomType</a>, and then casting it back to something else.)
      </p>
      <p>
        <em>Is this right? If there can be no instance of the bottom type, then it is impossible for you to ever receive an instance of it where you were expecting something else. And if you did somehow, then by definition it would be valid (as it would be a subtype of whatever it is you were expecting). Notably, 'null' as implemented in many (most?) languages is not the member of the bottom type; it is a singleton value of another class hierarchy which is special cased to allow it to be used in place of a normal value. Lastly, casting </em>anything<em> to the bottom type is a type error (again, by definition), and would be flagged as such at runtime if not at compile type. -- </em><a href="WilliamUnderwood.html">WilliamUnderwood</a><em></em>
      </p>
      <ul>
        <li>
           Well, it's an exaggerated phrasing. Consider naive set theory. The null set is a subset of all sets, it is always an empty set (<strong>the</strong> empty set), it is the result of intersecting sets with no members in common. But it certainly exists. <a href="BottomType.html">BottomType</a> is precisely the same thing, there's no contradiction.
        </li>
        <li>
           You are correct that fiddling with <a href="BottomType.html">BottomType</a> is a type error, because essentially, <a href="BottomType.html">BottomType</a> is precisely that, the type that indicates type error, so it's not an issue that it "would be flagged as such at runtime if not at compile type", that is in fact a tautology. Any operation involving <a href="BottomType.html">BottomType</a> yields <a href="BottomType.html">BottomType</a>. On the other hand, rather than propagating errors, they can instead cause the computation to halt. The IEEE floating point standard supports either propagation of <a href="BottomType.html">BottomType</a> (NaN, not a number) or signalling upon encounter of <a href="BottomType.html">BottomType</a>. The difference between a computation that runs to completion and yields the result "error", and one that abruptly ceases and yields the result "error", is often not significant other than the convenience of waiting a shorter period of time.
        </li>
        <li>
           Despite the phrasing above, <a href="BottomType.html">BottomType</a> almost always "exists" in some sense, in any language in which type errors are possible; it just may or may not have an explicit representation in any particular language, since it's a mathematical entity. Formally, only completely polymorphic languages (those in which all functions accept <a href="TopType.html">TopType</a> as a parameter) can avoid having at least an implicit <a href="BottomType.html">BottomType</a>, since that's the only way to avoid the possibility of type error across all possible programs. -- <a href="DougMerritt.html">DougMerritt</a>
        </li>
      </ul>
      <p>
        Despite not existing; it is often used for several things:
      </p>
      <ol>
        <li>
           As the "return type" of <a href="FirstClassContinuation.html">FirstClassContinuation</a>s. Since continuations do not return, the fact that there are no values of <a href="BottomType.html">BottomType</a> is not a problem, and this approach allows the usual subtyping rules for function types to work for continuations.
        </li>
      </ol>
      <ol>
        <li>
           As type of the <a href="NullPointer.html">NullPointer</a> (see <a href="WhatIsNull.html">WhatIsNull</a>). Eiffel does this; <a href="CeeLanguage.html">CeeLanguage</a> kinda does this. (NULL is ((void *)0) in C). <a href="CeePlusPlus.html">CeePlusPlus</a> undid this (redefining NULL to simply be 0); though <a href="BjarneStroustrup.html">BjarneStroustrup</a> has proposed (<a href="http://www.cuj.com/documents/s=8009/cuj0209stroustr/)">http://www.cuj.com/documents/s=8009/cuj0209stroustr/)</a> making NULL a void * once again.
        </li>
      </ol>
      <ol>
        <li>
           As an exception type. Useful in this context if you only want to have one type of exception; if you want to have exceptions that have information; using <a href="BottomType.html">BottomType</a> for this purpose doesn't work as well.
        </li>
      </ol>
      <ol>
        <li>
           As an indication of divergence (in other words, a function that doesn't return). Absent a stack overflow, a function that doesn't return won't return Bot, so not returning something that doesn't exist sort of works. <a href="HaskellLanguage.html">HaskellLanguage</a> does this.
        </li>
      </ol>
      <p>
        -- <a href="ScottJohnson.html">ScottJohnson</a>
      </p>
      <hr/>
      <p>
        See also <a href="MeetsAndJoins.html">MeetsAndJoins</a>, <a href="LatticeStructure.html">LatticeStructure</a>
      </p>
      <p>
        <a href="CategoryLanguageTyping.html">CategoryLanguageTyping</a>
      </p>
    </div>
  </body>
</html>