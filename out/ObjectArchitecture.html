<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Object Architecture
      </h1>
      <p>
        An Object Architecture describes how one's (abstract) "objects" relate to the underlying <a href="TuringMachine.html">TuringMachine</a> / <a href="HardwareArchitecture.html">HardwareArchitecture</a>. This is in slight contrast to an <a href="ObjectModel.html">ObjectModel</a> which describes how one's Objects relate to <em>machine memory</em>.
      </p>
      <p>
        <strong>Programmatically, the distinction relates to the issue of an object grouping operator/symbol vs. raw data.  Of this distinction marks a divergence point where many arguments have been made:  where a class definition starts and were the data starts.  Without this boundary being clear, people conflate issues of subtyping vs. sub<em>classing</em> -- two similarly sounding items but have opposite <em>structural</em> relationships.</strong>
      </p>
      <p>
        An <a href="ObjectArchitecture.html">ObjectArchitecture</a> is friendly with <a href="AbstractDataType.html">AbstractDataType</a>s (as they come from the implicit <a href="ObjectArchitecture.html">ObjectArchitecture</a> in C++), in that they are both rooted to the machine, but separate from an <a href="ObjectModel.html">ObjectModel</a>, which is rooted in an abstraction of "Object".
      </p>
      <p>
        <em>Please explain the difference between </em><a href="ObjectModel.html">ObjectModel</a> and <a href="ObjectArchitecture.html">ObjectArchitecture</a>. The whole point of a program in <a href="CeePlusPlus.html">CeePlusPlus</a> is to avoid bugs which break the model, so I cannot see the difference for well formed program.<em> -- </em><a href="JohnFletcher.html">JohnFletcher</a>
      </p>
      <p>
        In <a href="CeePlusPlus.html">CeePlusPlus</a> (as noted elsewhere on the wiki), the one key distinction between machine types (or <strong>structs</strong>) and class objects is that the latter has <strong>privacy</strong> by default.
      </p>
      <ul>
        <li>
           [It is true that in C++, struct and class are equivalent, except member elements of structs are public by default whereas class member elements are private by default. However, "machine types (or structs)" does not make sense in this context. How do machine types relate to classes and structs?]
        </li>
      </ul>
      <ul>
        <li>
           This is where the term "magic happens" is appropriate. As long as there's a clear distinguishing between physics and magic, it's not a problem.
        </li>
      </ul>
      <ul>
        <li>
           [I'm not clear what point you're making by "distinguishing between physics and magic" -- in your previous post, were you attempting to draw some equivalence between machine types and structs? If so, that's perhaps not inappropriate in some respects, but I don't see how it relates to private member elements. I could guess, but I'd rather not. In short, could you explain what you meant by, "the one key distinction between machine types (or <strong>structs</strong>) and class objects is that the latter has <strong>privacy</strong> by default" in terms of machine types? Do you mean that machine types hide their internal representation, similar to private members of a class?]
        </li>
      </ul>
      <p>
        One common architecture is given by <a href="AlanKay.html">AlanKay</a> in his <a href="AlanKaysDefinitionOfObjectOriented.html">AlanKaysDefinitionOfObjectOriented</a>. It is being claimed that this experiment went the wrong way. See <a href="ObjectOrientedRefactored.html">ObjectOrientedRefactored</a>.
      </p>
      <p>
        <em>This text needs more refinement: How does Object Architecture differ from </em><a href="TypeModel.html">TypeModel</a> or <a href="TypeTheory.html">TypeTheory</a>? A type system relates to underlying registers.<em></em>
      </p>
      <p>
        <strong>Yes, you are correct. These distinctions need to be clarified. I would suggest that an </strong><a href="ObjectArchitecture.html">ObjectArchitecture</a> is synonymous with <a href="TypeModel.html">TypeModel</a>; and "<a href="ObjectModel.html">ObjectModel</a>", while not synonymous with <a href="TypeTheory.html">TypeTheory</a>, works in the same <em>domain</em> of such. See also <a href="ComputerScienceVersionTwo.html">ComputerScienceVersionTwo</a>.<strong></strong>
      </p>
      <p>
        {A type system is an abstraction. Certain types are often related to underlying registers, but they certainly don't have to.}
      </p>
      <p>
        <em>Yes, that seems to be a convention within academia, but I argue that this is also cause for enormous confusion. The relationship to mathematics is the source of confusion. Mathematical models of computation relate to a Platonic space where there are no "real" types. But </em><a href="ComputerScience.html">ComputerScience</a> should also relate to concrete facts of the machine and these facts are not mere abstractions. What is the use of a programming language that cannot be implemented on a machine?<em></em>
      </p>
      <p>
        {A type system that does not reflect the underlying registers is certainly implementable and hardly a source of confusion. It's perfectly reasonable and not confusing, for example, to have a language whose only integer type is infinite precision but runs on machines with fixed-precision integer registers. Arguably, it's <em>more</em> confusing to have integers with seemingly-arbitrary limits and machine dependencies that complicate code portability.}
      </p>
      <p>
        Yes, I understand that hooking types to machine registers seems an unnecessary and ugly limitation to the pure theorists, but the point of an <em>architecture</em> (as this page title says) is to build a higher-order <em>relationship</em> to the underlying realities of the lower-order hardware. Please see <a href="UnifiedDataModel.html">UnifiedDataModel</a> for more information.
      </p>
      <p>
        {I can't speak for pure "theorists", but hooking types to general-purpose machine registers is perfectly reasonable if you want to maximise performance, and hooking types to special-purpose machine registers or memory addresses is -- among other things -- the way to write device drivers using higher-level languages. My point is that it's perfectly reasonable -- and, depending on requirements, desirable -- to have languages with <strong>no</strong> types based on machine registers. It's also reasonable -- and, depending on requirements, desirable -- to have languages with types based on machine registers.}
      </p>
      <p>
        {Similarly, it's reasonable, depending on requirements, to write code employing the <a href="LiskovSubstitutionPrinciple.html">LiskovSubstitutionPrinciple</a>. In other cases, it's reasonable (again, depending on requirements) to write code that violates the <a href="LiskovSubstitutionPrinciple.html">LiskovSubstitutionPrinciple</a>.}
      </p>
      <p>
        {There is no "enormous confusion" in any of this, and working programmers happily embrace these notions as a matter of course. Whilst I can appreciate that your goal of a <a href="GrandUnification.html">GrandUnification</a> with a <a href="UnifiedDataModel.html">UnifiedDataModel</a> perhaps benefits from a particular combination of the above language characteristics and approaches, it would be unreasonable to expect that all programming, everywhere, will take part in said <a href="GrandUnification.html">GrandUnification</a> or that it would benefit from doing so.}
      </p>
      <hr/>
      <p>
        See <a href="ObjectOriented.html">ObjectOriented</a>.
      </p>
    </div>
  </body>
</html>