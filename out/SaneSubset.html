<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Sane Subset
      </h1>
      <p>
        All languages must err on the side of excess. They must let you put together features in ways that encourage or cause bugs. For example, C++ is evil because it lets you write many statements on one line, preventing readability.
      </p>
      <p>
        So all programmers must err on the side of caution. They must only type statements known to work the way they expect them to; production code should not explore the dark corners of the language.
      </p>
      <p>
        <a href="SaneSubset.html">SaneSubset</a> means using a subset of the language features, not the generative possibilities. You have to do that anyway because there are an infinite number of expressions possible in most languages.
      </p>
      <p>
        <a href="SaneSubset.html">SaneSubset</a>s differ from <a href="BadStyleGuides.html">BadStyleGuides</a>; the former are intrinsic features of a language, learned by coding in it, and the latter are imposed without technical foundations.
      </p>
      <hr/>
      <p>
        Example:
      </p>
      <p>
        Don't define the body of a friend member function inside another class that befriends it:
      </p>
      <code>
        class<br/>
        ClassB {<br/>
        void FunctionB (); // no body<br/>
        ...<br/>
        };<br/>
      </code>
      <code>
        class<br/>
        ClassA {<br/>
        friend void ClassB::FunctionB () { ... }<br/>
        ...<br/>
        };<br/>
      </code>
      <p>
        FunctionB is <em>not</em> a member of ClassA, but its body is inside the definition of ClassA. Don't do this to your colleagues - there is simply no technical reason to.
      </p>
      <p>
        This example differs from placing a free function inside a befriending class.
      </p>
      <hr/>
      <p>
        I can't think of any feature of Eiffel or Smalltalk which does not belong to the sane subset.
      </p>
      <p>
        <em>Some peoples' "sane subset" of Eiffel would exclude taking away methods in subclasses, e.g Emu subclassing Bird and removing the fly() method.</em>
      </p>
      <p>
        [Covariant argument types ought to be out of the <a href="SaneSubset.html">SaneSubset</a> as well]
      </p>
      <p>
        Some people, yes. C++ is unusual in that the author of the language himself seems to advise against using certain features.
      </p>
      <p>
        <em>All languages must err on the side of excess. Languages which do not err on the side of excess are called "</em><a href="BondageAndDisciplineLanguage.html">BondageAndDisciplineLanguage</a>s". Their <a href="SaneSubset.html">SaneSubset</a> is imposed upon you by the languages' authors. The only thing worse than <a href="BadStyleGuides.html">BadStyleGuides</a> imposed by an employer are those imposed by a language author. -- <a href="PhlIp.html">PhlIp</a><em></em>
      </p>
      <p>
        In Smalltalk, I would consider changing the classes of True and False to switch the semantics of ifTrue and ifFalse to be outside the sane subset.
      </p>
      <p>
        [In Smalltalk, an explicit return from a code block that outlives the referencing environment in which it is created is often considered a no-no. <em>It will cause a runtime error ("Attempt to return twice" or something similar)</em>]
      </p>
      <hr/>
      <p>
        Some language features exist only for compatibility with previous versions. It's generally a good idea to use their more up-to-date replacements. For example: use "static const" variables in C++ instead of #define, where possible. <em>(Don't you mean 'anonymous namespaces'? ;-)</em>
      </p>
      <p>
        As for strict standards of what subset to use... I find that good programmers will use only language, library and system features that directly contribute to successful implementation of the system they're developing. One never uses a cool new feature (in a production program) just to try it out, or just because it's there. Therefore, good programmers will always end up using a small subset of the language 99% of the time, and will only use advanced features of the language (multiple inheritance and partial specialization of templates, for example) when needed. Thus, I would generally be <strong>against restricting your team to a strictly defined subset of a language</strong> or library -- unless you think they're irresponsible.
        <em>(In which case, why don't you fire them and hire competent help?  ;-)</em> -- <a href="JeffGrigg.html">JeffGrigg</a>
      </p>
      <p>
        Okay, that's odd. I won't claim necessarily that I'm a "good programmer", but I <em>often</em> use a cool new feature "just to try it out". I prefer to do so on a small program than a major project (or test it first on a prototype, THEN use it on the big project), but I do this a lot, and intentionally. I find that it keeps me abreast of the field, and learning new things. A good example would be that as soon as they added <a href="GeneratorsInPython.html">GeneratorsInPython</a>, I arranged some scripts so they used them. It probably wasn't the best design every time, but without experimenting, how would I ever learn? And "learn on your own time, not your boss's" won't work for me: my learning takes more of my time and effort than that. -- <a href="MichaelChermside.html">MichaelChermside</a>
      </p>
    </div>
  </body>
</html>