<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Category Polymorphism
      </h1>
      <p>
        Click on the above link to see a complete list of pages in this category.
      </p>
      <p>
        <em></em><a href="PolyMorphism.html">PolyMorphism</a><em> (what a horrible </em><a href="WikiName.html">WikiName</a>, but what can you do?) is the development of algorithms or data structures (or more concrete language constructs, such as objects or functions) which operate successfully on multiple types, doing things appropriate for the type.
      </p>
      <p>
        <em>Some take issue with polymorphism being based solely on "types". Answering a particular message (method call) does not necessarily depend on typing. Your viewpoint probably depends on where you stand in the static-versus-dynamic </em><a href="HolyWar.html">HolyWar</a>.<em></em>
      </p>
      <p>
        [Note that even when there isn't a formal type system per se, one can still divine the concept of type. Smalltalk is often called untyped. However, if you have a set of classes that respond to the message 
      </p>
      <code>
        doThis: andThat: andTheOther:<br/>
      </code>
      <p>
        one could say that this set represents a type, distinct from its inverse (which doesn't respond to the above message). Of course, you are getting away from type hierarchies, and into set-based or predicate-based type systems. Which are more flexible than hierarchies, but arguably more difficult to implement efficiently. -- <a href="ScottJohnson.html">ScottJohnson</a>]
      </p>
      <p>
        I am not sure set-based types or predicate-based types could even be called "types". I suppose one's world view could be that EverythingIsaType, for good or bad. But, that is a subjective perception, not necessarily something objectively in say Smalltalk.
      </p>
      <hr/>
      <p>
        Types of polymorphism:
      </p>
      <ul>
        <li>
           GenericPolymorphism, also known as <a href="ParametricPolymorphism.html">ParametricPolymorphism</a>: Generic algorithms, templates, parameteric types, etc. See <a href="GenericFunction.html">GenericFunction</a>s (for Lisp discussion), <a href="CategoryCppTemplates.html">CategoryCppTemplates</a> (they get a category all their own! Lots of useful links in here). 
        </li>
      </ul>
      <p>
        <em>Is </em><a href="StaticPolymorphism.html">StaticPolymorphism</a> GenericPolymorphism?<em></em>
      </p>
      <ul>
        <li>
           SubtypePolymorphism: Polymorphism based on <em>subtyping</em> (the notion that one type can extend/implement the behavior of another in such fashion that any valid operation on the supertype is valid on the subtype), <em>subsumption</em> (allowing a subtype to be used in a context where a supertype is expected), and <em></em><a href="DynamicDispatch.html">DynamicDispatch</a><em> (selecting a function or data based on the runtime type of its arguments - see </em><a href="SingleDispatch.html">SingleDispatch</a>, <a href="DoubleDispatch.html">DoubleDispatch</a>, <a href="MultipleDispatch.html">MultipleDispatch</a> (aka <a href="MultiMethods.html">MultiMethods</a>)). <a href="JavaLanguage.html">JavaLanguage</a>, <a href="CeePlusPlus.html">CeePlusPlus</a>, etc., all have subtype polymorphism. See also VirtualFunctions, <a href="DynamicCast.html">DynamicCast</a>, <a href="RunTimeTypeInformation.html">RunTimeTypeInformation</a>
        </li>
      </ul>
      <ul>
        <li>
           <a href="BoxingConversions.html">BoxingConversions</a>: Automagically converting expressions of a type which has undergone <a href="TypeErasure.html">TypeErasure</a> to one that hasn't or vice versa. Going from "int" (an intrinsic type) to "Integer" (a class) in Java 1.5 (and <a href="CsharpLanguage.html">CsharpLanguage</a>, though the names might be different) is one example.
        </li>
      </ul>
      <ul>
        <li>
           <a href="AdHocPolymorphism.html">AdHocPolymorphism</a>: Anything else.
        </li>
      </ul>
      <p>
        Also see <a href="GenericVsObjectOrientedProgramming.html">GenericVsObjectOrientedProgramming</a>, <a href="AlternateObjectOrientedProgrammingView.html">AlternateObjectOrientedProgrammingView</a>, <a href="OnUnderstandingTypes.html">OnUnderstandingTypes</a>
      </p>
      <p>
        Issues in polymorphism:
      </p>
      <ul>
        <li>
           <a href="InternalPolymorphism.html">InternalPolymorphism</a> vs <a href="ExternalPolymorphism.html">ExternalPolymorphism</a>. Does a type itself "contain" knowledge of its identity, and participate in the implementation of polymorphism? Or is it entirely external to the type definition?
        </li>
      </ul>
      <ul>
        <li>
           <a href="PointerCastPolymorphism.html">PointerCastPolymorphism</a>. What to do if you are working in a low-level language (like <a href="CeeLanguage.html">CeeLanguage</a>)
        </li>
      </ul>
      <ul>
        <li>
           <a href="MultipleInheritance.html">MultipleInheritance</a>. Having more than one supertype. <a href="MultipleInheritanceIsNotEvil.html">MultipleInheritanceIsNotEvil</a>, <a href="MultipleInheritanceInSmalltalk.html">MultipleInheritanceInSmalltalk</a>, <a href="MixIn.html">MixIn</a>
        </li>
      </ul>
      <ul>
        <li>
           Inheritance vs delegation vs redirection. Inheritance (subclassing) is when all parts of a base type object are pasted into a derived type object (with some of them capable of being overwritten). Delegation (<a href="DelegationPattern.html">DelegationPattern</a>) is kindasorta "inheritance by pointer", where a reference to a base type object is stored in the derived object; however, the subtype relationship is preserved. (Sometimes, multiple instances of a derived object can share the same base object instance). Redirection is similar to delegation, but it's "one-way". <a href="PolymorphismAndInheritance.html">PolymorphismAndInheritance</a>, <a href="DelegationInheritance.html">DelegationInheritance</a>, <a href="DelegationIsInheritance.html">DelegationIsInheritance</a>, <a href="PrototypeBasedProgramming.html">PrototypeBasedProgramming</a>, <a href="UseCompositionAndInterfacesWithoutClassInheritance.html">UseCompositionAndInterfacesWithoutClassInheritance</a>, <a href="CompositionInsteadOfInheritance.html">CompositionInsteadOfInheritance</a>
        </li>
      </ul>
      <ul>
        <li>
           The infamous <a href="FragileBaseClassProblem.html">FragileBaseClassProblem</a>.
        </li>
      </ul>
      <ul>
        <li>
           A few well-known modeling prolems. <a href="CircleAndEllipseProblem.html">CircleAndEllipseProblem</a> (see also <a href="CirclesAintEllipses.html">CirclesAintEllipses</a>, <a href="CirclesAreEllipses.html">CirclesAreEllipses</a>)
        </li>
      </ul>
      <ul>
        <li>
           Some argue that subtyping (and/or types themselves) is flawed, disagree on how subtypes ought to act with regards to their supertypes, a <a href="UsefulLie.html">UsefulLie</a>, or perhaps a not-so-useful lie. See <a href="PolymorphismLimits.html">PolymorphismLimits</a>, <a href="ContextSensitiveSubtyping.html">ContextSensitiveSubtyping</a>, <a href="LimitsOfHierarchies.html">LimitsOfHierarchies</a>, <a href="LiskovSubstitutionPrinciple.html">LiskovSubstitutionPrinciple</a>, <a href="WhatAreTypes.html">WhatAreTypes</a>, <a href="ThereAreNoTypes.html">ThereAreNoTypes</a>, <a href="SetsVersusTypes.html">SetsVersusTypes</a>
        </li>
      </ul>
      <ul>
        <li>
           Are there other better ways of implementing polymorhpism than the ones we've seen implemented so far?
        </li>
      </ul>
      <hr/>
      <p>
        See Also: <a href="CategoryConditionalsAndDispatching.html">CategoryConditionalsAndDispatching</a>, <a href="CategoryLanguageTyping.html">CategoryLanguageTyping</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryCategory.html">CategoryCategory</a>
      </p>
    </div>
  </body>
</html>