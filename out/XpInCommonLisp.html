<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Xp In Common Lisp
      </h1>
      <p>
        Much of the <a href="ExtremeProgramming.html">ExtremeProgramming</a> discussion here is using <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> or <a href="JavaLanguage.html">JavaLanguage</a> for illustration: while the tenets of XP are fundamentally language-independent, there's still a degree to which the choice of programming language can make <a href="ExtremeProgrammingPractices.html">ExtremeProgrammingPractices</a> more or less easy to achieve.
      </p>
      <p>
        This page examines the fit between XP and <a href="CommonLisp.html">CommonLisp</a>.  It's not intended to be a general discussion of Lisp's worth: general complaints that CAR and CDR are silly names, or that XML is a bad reinvention of sexps, 
        should be directed elsewhere.
      </p>
      <p>
        Pro:
      </p>
      <ul>
        <li>
           Lisp as a language is easily extendable in more directions than most other languages.  If you're programming Lisp "right" (see e.g. <a href="OnLisp.html">OnLisp</a>) you end up with a domain-specific programming language in which to describe your problem.  Truly <a href="TheSourceCodeIsTheDesign.html">TheSourceCodeIsTheDesign</a>.
        </li>
      </ul>
      <ul>
        <li>
           Because the system is typically interactive, the usual mode of development is to alternate between creating new methods and typing in expressions at the top-level to see if they work (<a href="PiecemealGrowth.html">PiecemealGrowth</a>, <a href="AskTheCode.html">AskTheCode</a>).  These toplevel expressions can often be formalised into extra <a href="UnitTest.html">UnitTest</a>s for little expense beyond that of <a href="CutAndPaste.html">CutAndPaste</a>.
        </li>
      </ul>
      <ul>
        <li>
           Low cost of refactoring: very few changes are actually going to need the system to be rebuilt (unlike <a href="CeePlusPlus.html">CeePlusPlus</a>).  Class names are not tied to file names (unlike Java).  Decent CL environments (including the free ones like Emacs' <a href="IlispMode.html">IlispMode</a>) have "find all callers" functionality.
        </li>
      </ul>
      <ul>
        <li>
           <a href="DynamicTyping.html">DynamicTyping</a> makes a lot of sense when covered by thorough <a href="UnitTest.html">UnitTest</a>s.  <a href="StaticTyping.html">StaticTyping</a> can only ensure syntactical coherency, while <a href="UnitTest.html">UnitTest</a>s can ensure semantic coherency.  See: <a href="DavidThomasOnTheBenefitsOfDynamicTyping.html">DavidThomasOnTheBenefitsOfDynamicTyping</a>.
        </li>
      </ul>
      <ul>
        <li>
           CL's package system makes it far easier than in, say, C to have the test provide fake implementations of other modules, for putting the "unit" in <a href="UnitTest.html">UnitTest</a>.
        </li>
      </ul>
      <ul>
        <li>
           Macros allow duplication one to factor out duplication that would otherwise be inherent to the language, facilitating <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a>
        </li>
      </ul>
      <p>
        Cons?  Some people might argue that
      </p>
      <ul>
        <li>
           The ability to evaluate arbitrary code and redefine functions at runtime is going to make it actually quite difficult to find <em>all</em> callers
        </li>
      </ul>
      <ul>
        <li>
           The language provides no particularly cast-iron guarantees of encapsulation (so you can get at other packages' private symbols with little extra effort) making it easy to bypass public interfaces and increase the risk that refactoring breaks something.  This is probably not a big problem: <a href="PairProgramming.html">PairProgramming</a> will stop us doing that and <a href="UnitTest.html">UnitTest</a>s will catch us if we do.  <a href="PythonLanguage.html">PythonLanguage</a> and other similar languages have the same attitude, and it doesn't seem to impede them.
        </li>
      </ul>
      <p>
        Given more pages like this for other languages (see also <a href="RefactoringWithCeePlusPlus.html">RefactoringWithCeePlusPlus</a>) I wonder if we could factor out a general list of desirable attributes for an XP-friendly programming language/environment. -- <a href="DanBarlow.html">DanBarlow</a>, <a href="WikiGnome.html">WikiGnome</a>s
      </p>
      <hr/>
      <p>
        For what it's worth, I'm starting a (commercial, paid-for) project where
        I most certainly intend to do <a href="XpInCommonLisp.html">XpInCommonLisp</a>.
      </p>
      <p>
        Well, we, at Memetrics (<a href="http://www.memetrics.com)">http://www.memetrics.com)</a> have been doing XP
        (well, as XP as we can) for about 6 months now.  Specifically, we do:
      </p>
      <ul>
        <li>
           <a href="PairProgramming.html">PairProgramming</a>
        </li>
        <li>
           <a href="RelentlessTesting.html">RelentlessTesting</a>
        </li>
        <li>
           <a href="UserStories.html">UserStories</a>
        </li>
        <li>
           <a href="PlanningGame.html">PlanningGame</a>
        </li>
      </ul>
      <p>
        Lisp seems not to help or hinder either was as far as XP is concerned.
        (Of course, it's the best language in the world, for <em>other</em> reasons. :-)
        So far, I think programming is just plain hard, and while XP helps, and
        provides the most pleasant programming experience I know of, its no <a href="SilverBullet.html">SilverBullet</a>
        and we still have to stay on our toes.
      </p>
      <p>
        The design and constant refactoring aspects, in particular, are painful, but,
        that being said, our project would probably have failed massively by now
        in a <a href="WaterfallModel.html">WaterfallModel</a>.  On the whole, we like it, and will keep doing it.
        -- <a href="AlainPicard.html">AlainPicard</a>
      </p>
      <p>
        <strong>Update</strong> Our product is shipping!  XOS (see Memetrics's web site)
        is now available.  The back end is written in CL and was developed in
        a (mostly) XP fashion.  I keep meaning to write up a report of our
        experiences.  Would there be any interest?  --<a href="AlainPicard.html">AlainPicard</a>
      </p>
      <p>
        <em>Sure!  First-hand experience-sharing is one of the best things done on this Wiki.</em>
      </p>
      <p>
        See <a href="CommonLispUnit.html">CommonLispUnit</a>, <a href="CommonLispXpTest.html">CommonLispXpTest</a>, also <a href="SchemeUnit.html">SchemeUnit</a>
      </p>
      <hr/>
      <p>
        <strong>Management Testimonial</strong>
      </p>
      <p>
        A bit more on XP and Lisp at Memetrics.
      </p>
      <p>
        We have been doing XP for close to a year now with excellent results.  New people are writing code the first week which is the highest value to the company.  I have been doing commercial software development for nearly 20 years and this is the highest quality code I have seen produced.  The expense of constant refactoring is very low as the overall development cost is much less. The value of rapid feature evolution to meet changing demands is a large strategic advantage.
      </p>
      <p>
        We are doing 24/7 client/server code, which means that the code can't afford to fail.  Hey, if the code can fail, you can do it in any language.  Using <a href="CommonLisp.html">CommonLisp</a> means that we can change server code on the fly without having to bring down the server. If you want processes to live for years, you basically need to use a dynamic language.  For commercial multi-platform delivery the leading choices are really Lisp or Smalltalk.  (<a href="AndrewAppel.html">AndrewAppel</a> has a paper advocating <a href="MlLanguage.html">MlLanguage</a> for this purpose, however; see his homepage.)
      </p>
      <p>
        We are very pleased with both XP and Lisp as development choices.
        --<a href="KenDickey.html">KenDickey</a>  [CTO, Memetrics]
      </p>
      <hr/>
      <p>
        Is it possible that XP is the juice that lisp was missing when it tried to find a home outside of the ivory towers?
      </p>
      <p>
        <em>Dunno.  I think Lisp and XP are orthogonal.  Lisp has many problems, but every one of them is social, not technical.  --</em><a href="AlainPicard.html">AlainPicard</a><em></em>
      </p>
      <p>
        That might make them less orthogonal [sic] than one might think. Xp primarily addresses the social problems that this activity we call development is prone to. 
      </p>
      <p>
        It seems to me that the things that makes the Lisps great overlap heavily with the things that make Smalltalk great, and since Xp comes out of the Smalltalk world, we might expect XP and Lisp to be a good fit. But just that, a good fit. Given the way that XP developers want to interact with their code Lisp <em>should</em> neither help nor hinder XP, but rather just let you do your development the XP way without distractions from the language. 
      </p>
      <p>
        A language with, oh I dunno, unit tests and refactorings as first class entities might aid XP, Intercal would probably hinder it. I'm tempted to add that Intercal would hinder anything, but actually I suspect that using a language that clunky on any kind of large scale would probably demand some big design up front and so forth, since the code won't be telling you anything it'd help you to hear. --<a href="KeithBraithwaite.html">KeithBraithwaite</a>
      </p>
      <hr/>
      <p>
        See also <a href="AgileLisp.html">AgileLisp</a>.
      </p>
      <p>
        <a href="CategoryCommonLisp.html">CategoryCommonLisp</a> <a href="CategoryExtremeProgramming.html">CategoryExtremeProgramming</a>
      </p>
    </div>
  </body>
</html>