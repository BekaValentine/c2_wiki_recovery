<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Proposed Exam Questions
      </h1>
      <p>
        If you were in charge of creating a programmer certification exam, what are some of the questions you would supply? Remember, it should probably not favor any one language, and probably cover multiple paradigms (OOP, functional, procedural, logical, relational, etc.) Separate questions with horizontal rules. Include the correct answer.
      </p>
      <hr/>
      <p>
        <strong>Q:</strong> The main purpose of relational schema normalization is to:
      </p>
      <ul>
        <li>
           Improve speed
        </li>
        <li>
           Remove duplication of information
        </li>
        <li>
           Make SQL queries easier to write
        </li>
        <li>
           Make deletion easier
        </li>
      </ul>
      <p>
        <strong>A:</strong> Remove duplication of information (and thereby avoid update anomalies that result from redundancy.)
      </p>
      <p>
        <em>Why is this important? Shouldn't it be enough to know of databases and their power, and recognize when a database is the most natural tool to use?</em>
      </p>
      <p>
        Somebody who doesn't understand schema normalization doesn't understand one of the biggest differences between relational databases and their alternatives. 
      </p>
      <p>
        Furthermore, relational schema normalization is a mechanization of <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a>.  It is therefore fundamental to every paradigm, even if it is only formally recognized in the <a href="RelationalModel.html">RelationalModel</a>.
      </p>
      <p>
        <em>Someone writes:</em>  I ask about schema normalization in all interviews for programmer positions.  But, as far as I can remember, so far every applicant knew at least the concept at one level or the other.
      </p>
      <hr/>
      <p>
        Certification makes sense only in highly mature areas, whereas much software is still done in exploratory areas where craftsmanship is a key element.
      </p>
      <p>
        Metaphorically: Certifying engineers who build bridges makes perfect sense now that bridge-building is a mature field. Certifying engineers who build interstellar rockets is madness; it's a purely speculative field, and as such, anyone designing the exams might well be Neanderthal compared with pretty much everyone taking the exam, and in any case, there is no objective basis.
      </p>
      <p>
        Also, the question at top of page was "creating a programmer certification exam", and "cover multiple paradigms (OOP, functional, procedural, logical, relational, etc.)", yet the single answer so far is about schema normalization, which surely is important for programmers who will ever do DB work, which includes essentially all business application programmers -- but the question was not thus limited, and <strong>most</strong> of the many dozens of kinds of software development that are <strong>not</strong> about business applications do <strong>not</strong> use databases significantly at all.
      </p>
      <p>
        In other words, given the open ended question, how about if I suggest exam questions covering compiler theory, parallel algorithms for fine-grained parallel architectures, computational number theory, Computer-Human Interaction ergonomics, 2D and 3D graphic modelling and rendering, etc. etc.?
      </p>
      <p>
        The blithe assumption that any programmer certification should unquestionably involve DB issues shows precisely why such certifications are of highly questionable value in the first place; they are based on assumptions that are blind to the vast variety that exists in the industry.
      </p>
      <p>
        IMNSHO, programmer certification should be considered only for areas where human life is at stake, e.g. medical equipment software, nuclear reactor software, aeronatic/aerospace software, since then there's an overriding interest (safety) regardless of whether the subfield is or is not mature. However, all such areas <strong>already</strong> have very tight (which is not to say perfect) safety protocols that do their best to give guarantees regardless of whether individual employees have met hypothetical guild standards.
      </p>
      <p>
        <em>Hear hear.</em>
      </p>
      <hr/>
      <p>
        <strong>Q:</strong> Tell me about your last project and the design decisions you made.
      </p>
      <p>
        <strong>A:</strong> There is no one right answer, but the candidate should be able to describe the project clearly and have good reasons for choices made.  I may not know the problem domain of that project, but I should be able to understand the answer and learn something from it.
      </p>
      <hr/>
      <p>
        <strong>Q:</strong> If you were do to the project again, what would you do differently?
      </p>
      <p>
        <strong>A:</strong> The candidate should be able to describe what they learned along different dimensions of the project:  technical, project management, team, development process, customer interaction, etc.
      </p>
      <hr/>
      <p>
        <strong>Q:</strong> Tell me about some big design mistake you made in the past, how you dealt with the fallout, and what you'd do different if starting again.
      </p>
      <p>
        <strong>A:</strong> (If candidate avoids self-criticism, put up a yellow flag.)
      </p>
      <hr/>
    </div>
  </body>
</html>