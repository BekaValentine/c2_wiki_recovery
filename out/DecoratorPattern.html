<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Decorator Pattern
      </h1>
      <p>
        <strong>Intent:</strong> Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality. 
      </p>
      <p>
        <em>While reading the </em><a href="GangOfFour.html">GangOfFour</a> book on CD I noticed that the original name of this pattern was "Wrapper". -- <a href="DaveMitchell.html">DaveMitchell</a><em></em>
      </p>
      <p>
        <strong>See also:</strong> <a href="CompositePattern.html">CompositePattern</a>, <a href="ProxyPattern.html">ProxyPattern</a>, <a href="DesignPatterns.html">DesignPatterns</a>
      </p>
      <p>
        This pattern was also called <em>shadowing</em> in LPC.
      </p>
      <hr/>
      <ul>
        <li>
           <a href="http://www.patnys.com/archive/2008/04/21/decorator-pattern.aspx">http://www.patnys.com/archive/2008/04/21/decorator-pattern.aspx</a>
        </li>
        <li>
           <a href="http://home.earthlink.net/~huston2/dp/decorator.html">http://home.earthlink.net/~huston2/dp/decorator.html</a>
        </li>
        <li>
           <a href="http://wiki.cs.uiuc.edu/patternStories/DecoratorPattern">http://wiki.cs.uiuc.edu/patternStories/DecoratorPattern</a>
        </li>
        <li>
           <a href="http://perldesignpatterns.com/?word=decorator+pattern">http://perldesignpatterns.com/?word=decorator+pattern</a>
        </li>
        <li>
           <a href="http://www.dofactory.com/Patterns/PatternDecorator.aspx">http://www.dofactory.com/Patterns/PatternDecorator.aspx</a>
        </li>
        <li>
           <a href="http://www.lukeredpath.co.uk/2006/9/6/decorator-pattern-with-ruby-in-8-lines">http://www.lukeredpath.co.uk/2006/9/6/decorator-pattern-with-ruby-in-8-lines</a>
        </li>
        <li>
           <a href="http://delphipatterns.blog.com/2011/02/22/decorator-5/">http://delphipatterns.blog.com/2011/02/22/decorator-5/</a>
        </li>
      </ul>
      <hr/>
      <p>
        This pattern can also be used as a way to refactor a complex class into smaller pieces.  Even if you don't need to attach responsibilities dynamically it can be clearer to have each responsibility in a different class.  Somewhat like <a href="MixIn.html">MixIn</a>s. -- <a href="ChristianTaubman.html">ChristianTaubman</a>
      </p>
      <p>
        Also see <a href="AspectOrientedProgramming.html">AspectOrientedProgramming</a>
      </p>
      <hr/>
      <p>
        <em>The "Adapter" pattern is also known as "Wrapper" pattern  (</em><a href="WrapperPattern.html">WrapperPattern</a>). Is Wrapper/Adapter/Decorator the same pattern?<em></em>
      </p>
      <p>
        No.  <a href="AdapterPattern.html">AdapterPattern</a> is used to convert the interface of an object into something else.  <a href="DecoratorPattern.html">DecoratorPattern</a> is used to extend the functionality of an object while maintaining its interface.  Both of these are probably sometimes called <a href="WrapperPattern.html">WrapperPattern</a> since both of them do "wrap" an object.
      </p>
      <hr/>
      <p>
        My understanding is that the <a href="DecoratorPattern.html">DecoratorPattern</a> does not refer to just <strong>any</strong> dynamic modifications to a class. My understanding is that it works like this:
      </p>
      <ul>
        <li>
           You have an instance, and you put another instance inside of it. They both support the same (or similar) interfaces. The one on the outside is a "decorator."
        </li>
        <li>
           You use the one on the outside. It either masks, changes, or pass-throughs the methods of the instance inside of it.
          <ul>
            <li>
               (Jim Coplien calls this a Letter/Envelope idiom, with the inner instance being the letter and the outer instance being the envelope.)
            </li>
          </ul>
        </li>
      </ul>
      <p>
        This is <strong>very different</strong> from what I've heard people say "the Decorator Pattern" means - I've heard people saying that <em>pretty much anything</em> that dynamically changes a class is an instance of "the Decorator Pattern."
      </p>
      <p>
        So for instance, if you dynamically change a class at run-time in a language that lets you do that, you are now using, "The Decorator Pattern." If there's a feature of a language that lets you add a method to a class at run-time, they're calling that use of "the decorator pattern."
      </p>
      <p>
        Reality check?
      </p>
      <hr/>
      <p>
        The description above implies that decorating an object changes its behaviour but not its interface. Is that necessarily true? For example, say you have a spell-check dictionary object. You want to get statistics on the most commonly misspelled words, so you wrap your spell-check dictionary in an envelope that tracks statistics. It exposes new methods for reading the stats.
      </p>
      <p>
        Now it's true that the original client of the spell-check dictionary is in no way aware of the expanded interface. So from its perspective, your modification has not changed the interface. Isn't this an example of the <a href="DecoratorPattern.html">DecoratorPattern</a>?
      </p>
      <hr/>
      <p>
        In python, the 'random' module has a shuffle function which shuffles a list: random.shuffle(lyst) but what you mean is lyst.shuffle(); so importing the random module should add the shuffling behaviour to lists. Is this the <a href="DecoratorPattern.html">DecoratorPattern</a>?
      </p>
      <hr/>
      <p>
        An example of this pattern is how java.io's Readers and Writers work.
      </p>
      <hr/>
      <p>
        The difference that I see between a <a href="DecoratorPattern.html">DecoratorPattern</a> and subclassing is that you can decorate any class that implements an interface with a single class.  Say I wanted to give myself a java.util.Map that printed a message whenever I added or removed a key.  If I only ever actually used java.util.<a href="HashMap.html">HashMap</a> I could just create PrintingMap as a subclass of <a href="HashMap.html">HashMap</a> and override put & remove.  But if I want to create a printing version of <a href="TreeMap.html">TreeMap</a> then I either create PrintingTreeMap (which has almost identical code to PrintingMap (which should itself become PrintingHashMap)), or I create a Map decorator.
      </p>
      <p>
        In short, you are trading "have to write pass-throughs for every method, not just the ones you're changing & do 2 step object creation", for "have to write a subclass for each concrete class you want to change".  This goes from helpful to imperative if you are writing a library for others to use.
      </p>
      <hr/>
      <p>
        In java jdk 1.3 added dynamic proxy
      </p>
      <p>
        that is a great way to "decorate" any object
      </p>
      <p>
        author has added pre-method / post-method processing, which is decorating the instance
      </p>
      <p>
        <a href="http://www.ibm.com/developerworks/java/library/j-jtp08305.html">http://www.ibm.com/developerworks/java/library/j-jtp08305.html</a>
      </p>
      <hr/>
      <p>
        The term "wrapper" its used for several software design patterns, so an alternative, more specific identifier, should be used.
      </p>
      <p>
        The Decorator Design Pattern has several requirements.
      </p>
      <p>
        (1) An object that requires the extension.
      </p>
      <p>
        Example:
      </p>
      <p>
        A window control that requires additional optional features like:
      </p>
      <ul>
        <li>
           horizontal scrollbar
        </li>
        <li>
           vertical scrollbar
        </li>
        <li>
           titlebar
        </li>
        <li>
           footerbar or statusbar
        </li>
        <li>
           other
        </li>
      </ul>
      <p>
        An example with an Object Oriented C style pseudocode:
      </p>
      <code>
        public class WindowClass<br/>
        {<br/>
        // ...<br/>
        } // class<br/>
      </code>
      <p>
        (2) Several objects that support the extension by "decoration". Usually, those objects share a common interface, traits, or superclass, and sometimes, additional, intermediate superclasses .
      </p>
      <code>
        /* abstract */ public class WindowDecoratorClass<br/>
        {<br/>
        // ...<br/>
        } // class<br/>
      </code>
      <code>
        /* concrete*/ public class WindowTitleBarClass:<br/>
        extends WindowDecoratorClass<br/>
        {<br/>
        // ...<br/>
        } // class<br/>
      </code>
      <code>
        /* concrete*/ public class WindowStatusBarClass:<br/>
        extends WindowDecoratorClass<br/>
        {<br/>
        // ...<br/>
        } // class<br/>
      </code>
      <code>
        /* abstract */  public class WindowScrollbarClass:<br/>
        extends WindowDecoratorClass<br/>
        {<br/>
        // ...<br/>
        } // class<br/>
      </code>
      <code>
        /* concrete*/ public class WindowHorizontalScrollbarClass:<br/>
        extends WindowScrollbarClass<br/>
        {<br/>
        // ...<br/>
        } // class<br/>
      </code>
      <code>
        /* concrete*/ public class WindowVerticalScrollbarClass:<br/>
        extends WindowScrollbarClass<br/>
        {<br/>
        // ...<br/>
        } // class<br/>
      </code>
      <p>
        (3) The decorated object (class or prototype instantation), and the decorator objects have one or several common features. In order to enssure that functuonality, the decorated object & the decorators have a common interface, traits, or class inheritance.
      </p>
      <p>
        In the next example, the "Draw();" method & the "GetDescription();" method are the features that are the requirement, and are defined by the "DrawingControlInterface", 
      </p>
      <code>
        public interface WindowDecoratorInterface<br/>
        {<br/>
        // ...<br/>
      </code>
      <code>
        public String GetDescription() { ... }<br/>
      </code>
      <code>
        public void Draw() { ... }<br/>
      </code>
      <code>
        // ...<br/>
        } // interface<br/>
      </code>
      <code>
        public class WindowClass:<br/>
        implements WindowDecoratorInterface<br/>
        {<br/>
        public String GetDescription() { ... }<br/>
      </code>
      <code>
        public void Draw() { ... }<br/>
        } // class<br/>
      </code>
      <code>
        /* abstract */ public class WindowDecoratorClass:<br/>
        implements WindowDecoratorInterface<br/>
        {<br/>
        public String GetDescription() { ... }<br/>
      </code>
      <code>
        public void Draw() { ... }<br/>
        } // class<br/>
      </code>
      <code>
        /* concrete*/ public class WindowTitleBarClass:<br/>
        extends WindowDecoratorClass<br/>
        {<br/>
        public String GetDescription() { ... }<br/>
      </code>
      <code>
        public void Draw() { ... }<br/>
        } // class<br/>
      </code>
      <code>
        /* concrete*/ public class WindowStatusBarClass:<br/>
        extends WindowDecoratorClass<br/>
        {<br/>
        public String GetDescription() { ... }<br/>
      </code>
      <code>
        public void Draw() { ... }<br/>
        } // class<br/>
      </code>
      <code>
        /* abstract */  public class WindowScrollbarClass:<br/>
        extends WindowDecoratorClass<br/>
        {<br/>
        public String GetDescription() { ... }<br/>
      </code>
      <code>
        public void Draw() { ... }<br/>
        } // class<br/>
      </code>
      <code>
        /* concrete*/ public class WindowHorizontalScrollbarClass:<br/>
        extends WindowScrollbarClass<br/>
        {<br/>
        public String GetDescription() { ... }<br/>
      </code>
      <code>
        public void Draw() { ... }<br/>
        } // class<br/>
      </code>
      <code>
        /* concrete*/ public class WindowVerticalScrollbarClass:<br/>
        extends WindowScrollbarClass<br/>
        {<br/>
        public String GetDescription() { ... }<br/>
      </code>
      <code>
        public void Draw() { ... }<br/>
        } // class<br/>
      </code>
      <hr/>
      <p>
        <a href="CategoryPattern.html">CategoryPattern</a> | <a href="CategoryStructuralPatterns.html">CategoryStructuralPatterns</a>
      </p>
    </div>
  </body>
</html>