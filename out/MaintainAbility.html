<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Maintain Ability
      </h1>
      <p>
        Maintainability should subsume various properties defining <a href="InternalQuality.html">InternalQuality</a> :
      </p>
      <ul>
        <li>
           cohesion
        </li>
        <li>
           low coupling (see <a href="CouplingAndCohesion.html">CouplingAndCohesion</a>)
        </li>
        <li>
           concision
        </li>
        <li>
           simplicity (<a href="WhatIsSimplest.html">WhatIsSimplest</a>?  See <a href="ElegantSimplicity.html">ElegantSimplicity</a> and <a href="XpSimplicityRules.html">XpSimplicityRules</a>)
        </li>
        <li>
           generality
        </li>
        <li>
           clarity (which is related to simplicity and cohesion)
        </li>
      </ul>
      <p>
        because the final reason for a software product to hold these properties is the cost of maintenance.
      </p>
      <p>
        Personally I like the term because when speaking about quality, I always had to distinguish things : 
      </p>
      <p>
        <a href="ExternalQuality.html">ExternalQuality</a> is quality of the product, as the people using the software can define it (<em>grosso modo</em>).
        <a href="InternalQuality.html">InternalQuality</a> is quality of the design, as defined by the technical people making the software. 
        When <a href="ExternalQuality.html">ExternalQuality</a> is high, the customers are happy (nearly tautologic definition). When <a href="InternalQuality.html">InternalQuality</a> is high developers are happy, and keeping the customers happy is less expensive. And so on.
      </p>
      <p>
        Now I just use "Quality" when speaking about properties the user or customer requires for the software product, and <a href="MaintainAbility.html">MaintainAbility</a> for all the internal properties that facilitate the production and maintenance of the software product. --<a href="ChristopheThibaut.html">ChristopheThibaut</a>
      </p>
      <hr/>
      <p>
        Are there any metrics for maintainability that can be derived from the code?
      </p>
      <p>
        And if there are, how much are they subject to Heisenberg problems (e.g. the <a href="HeisenbergUncertaintyPrinciple.html">HeisenbergUncertaintyPrinciple</a>)? If you measure maintainability metrics, will you get higher metrics, but code that's still as unmaintainable or worse? 
      </p>
      <p>
        In <a href="CodeComplete.html">CodeComplete</a>, <a href="SteveMcConnell.html">SteveMcConnell</a> lists the following metrics for maintainability:
      </p>
      <ul>
        <li>
           Number of parameters passed to each routine
        </li>
        <li>
           Number of local variables used by each routine
        </li>
        <li>
           Number of routines called by each routine
        </li>
        <li>
           Number of decision points in each routine
        </li>
        <li>
           Control-flow complexity in each routine
        </li>
        <li>
           Lines of code in each routine
        </li>
        <li>
           Lines of comments in each routine
        </li>
        <li>
           Number of data declarations in each routine
        </li>
        <li>
           Number of blank lines in each routine
        </li>
        <li>
           Number of <em>goto</em>s in each routine
        </li>
        <li>
           Number of input/output statements in each routine
        </li>
      </ul>
      <p>
        The SEI has published a Maintainability Index Technique for Measuring Program Maintainability:  <a href="http://www.sei.cmu.edu/str/descriptions/mitmpm.html.">http://www.sei.cmu.edu/str/descriptions/mitmpm.html.</a>
        It is based on:
      </p>
      <ul>
        <li>
           Average Halstead Volume per module
        </li>
        <li>
           Average Extended <a href="CyclomaticComplexityMetric.html">CyclomaticComplexityMetric</a> per module
        </li>
        <li>
           Average <a href="LinesOfCode.html">LinesOfCode</a> per module
        </li>
        <li>
           Average percent of lines of comments per module
        </li>
      </ul>
      <hr/>
      <p>
        See <a href="HowToWriteUnmaintainableCode.html">HowToWriteUnmaintainableCode</a>.
      </p>
      <hr/>
      <p>
        Personally, I am very intrigued by the relationship between coupling and maintainability. Many authors have claimed that high cohesion and low coupling is the way to go, yet I believe that a linear relationship between coupling and maintainability just don't seem to make sence. Under such an assumption, less coupling is better. However, everyone will agree that striving for no coupling at all is the ultimate guideline for creating <a href="GodClass.html">GodClass</a> -es, which are not exactly ideals w.r.t. maintainability.
      </p>
      <p>
        Of course, this relationship depends on how you define coupling. I would suggest to consider coupling as the number of collaborations you need to implement a semantically related set of requirements. Under that definition, having no coupling truly leads to <a href="GodClass.html">GodClass</a> -es, and having maximum coupling would lead to heavily coupled tool classes which all are responsible for only a very minor detail in the stated set of requirements. This relates to <a href="DesignPatterns.html">DesignPatterns</a> in that they propose a degree of collaboration (and therefore coupling) which distributes responsibilities evenly over a number of classes. Maybe <a href="DesignPatterns.html">DesignPatterns</a> can be used as the optimal degree of coupling, from which deviations (to both the <a href="GodClass.html">GodClass</a> -es and overly distributed responsibilities extremes) would have negative effect on maintainability.
      </p>
      <p>
        Such a relationship between coupling and maintainability could be visualized as a U-shaped curve in a 2-dimensional space with a Y-axis for maintenance effort and a X-axis for coupling. This model, of course, is totally hypothetical, but seems - at least from my experience - to be more realistic than a linear relationship. -- Bart Du Bois
      </p>
      <hr/>
      <p>
        <em>Many authors have claimed that high cohesion and low coupling is the way to go, yet I believe that a linear relationship between coupling and maintainability just don't seem to make sence.</em>
      </p>
      <p>
        Your confusion seems to stem from trying to force the maintainability to be a function of only the coupling.  What those authors usually mean is that if you hold <em>everything else</em> constant, lower coupling and higher cohesion reduces maintenance costs.  This would mean that the number and size of the classes must remain constant while you change the coupling and cohesion.  Pushing the coupling so low that it forces other variables to change (i.e. class size) is outside of their claims.
      </p>
      <p>
        Another hypothetical model:  maintenance_effort = K1 * coupling_metric + K2 * (sum of squares of class sizes) (+ some other factors, which we can ignore for now).  This explains your visualized U-shaped curve and maintains the linear relationship between coupling and maintenance. 
      </p>
      <p>
        Or, another alternative, which could be applied (recursively) to anything made up of smaller parts: maintenance_effort = K1 * coupling_between_parts + sum of maintenance_effort for all parts.  For a program, the parts could be global objects and classes.  For a class, methods and members.  For a method, parameters, statements, and expressions.  For an expression, operands and operators.
      </p>
      <hr/>
      <p>
        <em>Your confusion seems to stem from trying to force the maintainability to be a function of only the coupling.</em>
      </p>
      <p>
        You are right. Moreover, your hypothetical model outline is quite interesting, e.g. to explain preference for a decomposition strategy. Are you aware of any references or known usage? -- Bart Du Bois
      </p>
      <p>
        <em>No, I just made it up while editing the page.  It seems to fit my experience.  For example, the tendency for non-OO functions to be longer than OO methods.  The classes provide an additional layer of decomposition that can be taken advantage of to limit interactions between program parts, and effectively reduce the possible coupling.</em> 
      </p>
    </div>
  </body>
</html>