<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Four Levels Of Feature
      </h1>
      <p>
        This page discusses features for <a href="ProgrammingLanguage.html">ProgrammingLanguage</a>s, APIs, Frameworks, and <a href="OperatingSystem.html">OperatingSystem</a>s (which are really the same thing: <a href="ApiIsLanguage.html">ApiIsLanguage</a>, <a href="FrameworkIsLanguage.html">FrameworkIsLanguage</a>, <a href="LanguageIsAnOs.html">LanguageIsAnOs</a>). Examples of features can be found on pages such as <a href="OperatingSystemsDesignPrinciples.html">OperatingSystemsDesignPrinciples</a>, <a href="KillerUserInterface.html">KillerUserInterface</a>, <a href="GuiEngineGoals.html">GuiEngineGoals</a>, <a href="KeyLanguageFeature.html">KeyLanguageFeature</a>.
      </p>
      <p>
        Features are often discussed as though they were binary in nature. And, for objective features of digital artifacts on digital machines (i.e. ignoring features that name a user or programmer as a 'participant'), that often isn't too far from the truth. But even objective features tend to describe <em>amalgamations</em> of other, finer-grained properties. Even if these fine-grained properties are individually binary, the amalgamation is combinatorial and will appear from the two-foot head-to-monitor view to exist on a continuous scale.
      </p>
      <p>
        This page discusses features appearing on such a continuum, and offers rubrics to discuss their 'level'. This page reflects <a href="FourLevelsOfCompetence.html">FourLevelsOfCompetence</a>. The <a href="FourLevelsOfFeature.html">FourLevelsOfFeature</a> at increasing levels of feature are:
      </p>
      <ol>
        <li>
           <a href="TuringTarpit.html">TuringTarpit</a>: You don't have the feature, and you can't merely compose existing features to achieve it. You might be unable to 'abstract' the feature for <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a>. Alternatively, you may need to build infrastructure (framework, api, and protocol) to implement the feature, and this leaks and introduces coupling in a manner that painfully limits portability, composition, or future options (related: <a href="MissingFeatureSmell.html">MissingFeatureSmell</a>). <a href="SelfDiscipline.html">SelfDiscipline</a> and analysis consistently fail even skilled programmers. Essentially, you're gonna fall prey to <a href="GreenspunsTenthRuleOfProgramming.html">GreenspunsTenthRuleOfProgramming</a>. 
        </li>
        <li>
           <a href="SelfDiscipline.html">SelfDiscipline</a>: You can consistently achieve the feature through careful constraint of one's programming behavior, and maybe even scale it up to a team behavior. Correctness can be determined by analysis tools, <a href="UnitTesting.html">UnitTesting</a>, and code-reviews. The feature might be something you can abstract to some limited degree, but you must still apply <a href="SelfDiscipline.html">SelfDiscipline</a> to use of the abstraction. 
        </li>
        <li>
           <a href="BondageAndDiscipline.html">BondageAndDiscipline</a>: The feature is forced on you, and you are (painfully) aware of it. You're forced to deal with it even when you'd rather be involved with something else, even when you don't want the feature. The feature is achieved by use of barriers and <a href="DiscontinuitySpike.html">DiscontinuitySpike</a>s, and you're continuously tripping over them. It may be that the feature doesn't have the vaunted <a href="FirstClass.html">FirstClass</a> status.
        </li>
        <li>
           <a href="ElegantSimplicity.html">ElegantSimplicity</a>: the feature is just <em>there</em> when you need it, and its achievement doesn't get in your way when you don't want to think about it. If the language has barriers to achieve the feature, they aren't in your way or they seem like natural fixtures so you don't ever feel the need to try plowing through them. There are no gotchas with the feature - no need for self-discipline; <a href="SymmetryOfLanguage.html">SymmetryOfLanguage</a> for the feature is implicit.
        </li>
      </ol>
      <p>
        There are, of course, ranges in between these four levels. For example, multi-threading safety and deadlock resistance fall somewhere below <a href="SelfDiscipline.html">SelfDiscipline</a> for <a href="CeeLanguage.html">CeeLanguage</a> + Pthreads (since application of <a href="SelfDiscipline.html">SelfDiscipline</a> is hardly consistent in achieving safety or resisting deadlocks, and deadlock-free programs do not in general compose to create larger deadlock-free programs), but somewhere above <a href="TuringTarpit.html">TuringTarpit</a> (since a degree of safe abstraction is possible). 'Pure' <a href="CeeLanguage.html">CeeLanguage</a> would be at the level of <a href="TuringTarpit.html">TuringTarpit</a> for these features, since <a href="CeeLanguage.html">CeeLanguage</a> itself has no way to express multi-threading. For single-threaded data safety, <a href="CeeLanguage.html">CeeLanguage</a> is at the <a href="SelfDiscipline.html">SelfDiscipline</a> level with a small dose of <a href="BondageAndDiscipline.html">BondageAndDiscipline</a>. The regular requirement for reinterpret cast in programs of even moderate complexity, however, suggests that even <a href="SelfDiscipline.html">SelfDiscipline</a> doesn't provide <em>type</em> safety. (Data-safety is not just type-safety.)
      </p>
      <p>
        We all know about <a href="BondageAndDiscipline.html">BondageAndDiscipline</a>, of course. <a href="ManifestTyping.html">ManifestTyping</a>, <a href="CheckedExceptionsAreOfDubiousValue.html">CheckedExceptionsAreOfDubiousValue</a>, etc. 
      </p>
      <p>
        <a href="ElegantSimplicity.html">ElegantSimplicity</a> is rare on a broad scale, in part because <a href="LifeIsaBigMessyGraph.html">LifeIsaBigMessyGraph</a>, but is still available for fine-grained features. <a href="DataflowProgramming.html">DataflowProgramming</a> and good <a href="DependencyInjection.html">DependencyInjection</a> frameworks are candidates. <a href="AbstractFactory.html">AbstractFactory</a> for <a href="PluginArchitecture.html">PluginArchitecture</a>, as used in browsers, is certainly up there, at least up to the point of safety and security concerns. <a href="ImplicitTyping.html">ImplicitTyping</a> with typeclasses or overloading, and especially Static <a href="DuckTyping.html">DuckTyping</a> (as in <a href="ScalaLanguage.html">ScalaLanguage</a>), seem to exist at this level. <a href="SoftwareTransactionalMemory.html">SoftwareTransactionalMemory</a> certainly does; it allows arbitrary safe composition of concurrent access to data, and most code can be written entirely ignorant of it. <a href="GarbageCollection.html">GarbageCollection</a> would also be at the <a href="ElegantSimplicity.html">ElegantSimplicity</a> level, albeit with a few caveats for realtime systems (unless realtime-GC is achieved).
      </p>
      <p>
        Not all features can be achieved simultaneously, and amalgamation features tend to be implied (e.g. for <a href="GarbageCollection.html">GarbageCollection</a>, one assumes safety, security, maybe a certain amount of performance based on modern implementations, etc.) unless explicitly redacted, so there may be some need to issue explicit caveats.
      </p>
      <hr/>
      <p>
        Regarding the <a href="TuringTarpit.html">TuringTarpit</a>, what if an interface to an app or scripting language can be made so that the cases the kit cannot handle can be custom programmed? This may not work with languages, but perhaps with API's.
      </p>
      <p>
        <em></em><a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a> is a powerful design option for apps, and a good scripting language or API can elevate some features to a higher level (<a href="ApiIsLanguage.html">ApiIsLanguage</a>, after all), but this does not eliminate the possibility of features remaining at the <a href="TuringTarpit.html">TuringTarpit</a> level. If you are continuously forced to reinvent or re-implement something in scripts or extensions with slight variations, for example, that is <a href="TuringTarpit.html">TuringTarpit</a> level. Similarly if you are forced to explicitly weave code... e.g. to deal with GC, concurrency, transactions, error-handling, <a href="PolicyInjection.html">PolicyInjection</a>, etc.<em></em>
      </p>
      <hr/>
      <p>
        It is my opinion that to <a href="KeepItSimple.html">KeepItSimple</a>, one may have to forgo portions of the higher-numbered levels. <a href="GoldPlating.html">GoldPlating</a> a nascent standard will often prevent it from being initially accepted. The market-place better accepts incremental improvements, even if this makes the final result less elegant than a 4-level-up-front kit. This is not a reality we can expect to change, only work within knowing its pattern. -t
      </p>
      <p>
        <em>That depends on the </em>'"it"<strong> in question - i.e. are you trying to keep it simple for the implementor? or are you trying to keep it simple for the users? Which decision is more economically sound depends on how many users and how many times they plan to use it - i.e. on the developer:user ratio - so can't be decided without more knowledge. Anyhow, the idea of achieving 'incremental improvement' is often restricted by practical concerns for </strong><a href="BackwardsCompatibility.html">BackwardsCompatibility</a>, <a href="MindOverhaulEconomics.html">MindOverhaulEconomics</a>, and CodebaseInertia. It is fortunate for upgrades to higher-level features that the market-place, in practice, accepts periodic overhauls (i.e. new gaming consoles, new programming languages, <a href="RewriteCodeFromScratch.html">RewriteCodeFromScratch</a>, 'major' revisions, etc.) and continuously deprecates applications that can't keep up, otherwise old <a href="OperatingSystem.html">OperatingSystem</a>s and such could never be significantly upgraded, and we'd still have a choice only between Fortran and Lisp.<em></em>
      </p>
    </div>
  </body>
</html>