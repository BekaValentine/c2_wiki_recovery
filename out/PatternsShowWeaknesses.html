<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Patterns Show Weaknesses
      </h1>
      <p>
        Some patterns show weaknesses in the languages that require them. These are some examples I thought of. Feel free to add/remove/modify/comment them. -- <a href="AurelianoCalvo.html">AurelianoCalvo</a>
      </p>
      <ul>
        <li>
           <a href="StatePattern.html">StatePattern</a>: Inability to change the object class (and underlying behaviour).
        </li>
        <li>
           <a href="ResourceAllocationIsInitialization.html">ResourceAllocationIsInitialization</a>: Inability to pass code to a method (see how files are handled in <a href="RubyLanguage.html">RubyLanguage</a> and <a href="LispLanguage.html">LispLanguage</a>).
          <ul>
            <li>
               Hmm. RAII is mainly (only?) seen in <a href="CeePlusPlus.html">CeePlusPlus</a>, where the ruby/lisp method of using a <a href="HigherOrderFunction.html">HigherOrderFunction</a> is also possible. So is this really weaker or just different?
            </li>
            <li>
               In fact isn't it obvious that if your RAII object is also a functor, that accepts another functor as an argument, these are exactly the same idioms?
            </li>
          </ul>
        </li>
        <li>
           <a href="SingletonPattern.html">SingletonPattern</a>: Can't set behaviour for a single object.
        </li>
        <li>
           <a href="DecoratorPattern.html">DecoratorPattern</a>: Inability to add behaviour to an object (the decorator and the decoratee represent the same underlying object).
        </li>
        <li>
           <a href="PimplIdiom.html">PimplIdiom</a>: Can't separate interface and implementation cleanly. <em>Well, </em><a href="CeePlusPlus.html">CeePlusPlus</a> is so #$^%#$#&@ that it has its own exclusive patterns.<em></em>
        </li>
      </ul>
      <hr/>
      <p>
        I don't understand the weakness for <a href="DecoratorPattern.html">DecoratorPattern</a>. Would someone give an example? -- <a href="JasonFelice.html">JasonFelice</a>
      </p>
      <p>
        <em>If you can dynamically add behavior to an object, you don't have to use a decorator class. -- </em><a href="EricHodges.html">EricHodges</a><em></em>
      </p>
      <p>
        Not true! You have a FileParser which delegates to a FileReader. You make a GzipReader decorator for the FileReader so you can read compressed files.
      </p>
      <p>
        (And, I might mention, I spend a lot of time with <a href="RubyLanguage.html">RubyLanguage</a> and poke and override methods on classes which are not mine all the time. It's just that in this case, it would make FileReader heavy. You'd be introducing a <a href="StrategyPattern.html">StrategyPattern</a> anyway if you made the one class handle both cases; <a href="DecoratorPattern.html">DecoratorPattern</a> seems simpler.) -- <a href="JasonFelice.html">JasonFelice</a>
      </p>
      <p>
        Well, forget classes for a moment. If you were able to replace the "read" method with a new one in the object that is required to uncompress the gzipped file, you wouldn't need to use the decorator. The advantage of this posibility is that it's not possible to call the decoratee (why would the programmer want to read without uncompress). But the real reason is that both decoratee and decorator refer to the same conceptual object.
      </p>
      <p>
        <em>You are talking about extending an </em>instance<em> then. OK, but you need to change "read", "write", and "seek" messages, which are defined in terms of the underlying primitives in this case. You could poke a method onto the class "make_compressed" which would redefine those three methods, but what advantage is this, compared to </em><a href="DecoratorPattern.html">DecoratorPattern</a>? Hmm. What language are you thinking in?<em></em>
      </p>
      <p>
        Object means instance, btw, when you can add/change/remove behavior from an object, you don't need decorators, <a href="JavaScript.html">JavaScript</a> and <a href="SelfLanguage.html">SelfLanguage</a>, <a href="PrototypeBasedLanguage.html">PrototypeBasedLanguage</a>s, are examples of this idiom. <em>(So is </em><a href="RubyLanguage.html">RubyLanguage</a>.)<em></em>
      </p>
      <p>
        OK, I'll agree that a language's <em>requiring</em> the use of <a href="DecoratorPattern.html">DecoratorPattern</a> shows inability to add behavior to an object. The page title originally suggested to me that <em>use</em> of these patterns shows the language weaknesses. -- <a href="JasonFelice.html">JasonFelice</a>
      </p>
      <hr/>
      <p>
        Doesn't <a href="AreDesignPatternsMissingLanguageFeatures.html">AreDesignPatternsMissingLanguageFeatures</a> already cover this?
      </p>
      <p>
        <em>Well, yes, but </em><a href="ResourceAllocationIsInitialization.html">ResourceAllocationIsInitialization</a> and the <a href="PimplIdiom.html">PimplIdiom</a> are not canonical "<a href="DesignPatterns.html">DesignPatterns</a>".<em></em>
      </p>
      <p>
        Perhaps they should be on IdiomsShowWeaknesses then? It might be interesting to consider natural languages too?
      </p>
      <hr/>
      <p>
        <em>Well, yes, but </em><a href="ResourceAllocationIsInitialization.html">ResourceAllocationIsInitialization</a> and the <a href="PimplIdiom.html">PimplIdiom</a> are not canonical "<a href="DesignPatterns.html">DesignPatterns</a>".<em></em>
      </p>
      <p>
        There's a canon for design patterns now? Did I miss the Pattern Pope's council?
      </p>
      <p>
        <em>No, you've just forgotten the magical transformation that happens to information when impressed upon trees - especially when encased on three sides with stiff pieces of heavily compressed tree-pulp with ribbon appendages. Once corporealized upon pressed-tree-pulp, it can be put to the </em>useful<em> end of meeting social recognition needs if properly displayed.</em>
      </p>
      <p>
        It seems to me that RAII and pimpl are not "Design Patterns" in the sense of being patterns for the abstract design of software, so much as they are techniques for getting around some of the perceived shortcomings of <a href="CeePlusPlus.html">CeePlusPlus</a>.
      </p>
      <hr/>
      <p>
        Related:
      </p>
      <ul>
        <li>
           <a href="PatternBacklash.html">PatternBacklash</a>
        </li>
      </ul>
      <hr/>
      <p>
        <a href="JulyZeroSix.html">JulyZeroSix</a> (but barely so)
      </p>
      <hr/>
      <p>
        <a href="CategoryPattern.html">CategoryPattern</a>
      </p>
    </div>
  </body>
</html>