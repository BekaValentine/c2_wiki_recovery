<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        If Foo Is So Great How Come You Are Not Rich
      </h1>
      <p>
        The idea was discussed somewhere here on wiki, but it did not come to a conclusion. Some claim that certain technologies or techniques (let's call it "Foo") can make software "significantly simpler" to create and/or maintain. If this was the case, then why don't gurus in Foo produce commercial software that goes up against the big titles such as MS-Excel, Auto-Cadd, SAP, etc and blow them out of the water? If Foo makes it twice as easy to write software, then your profit margins would be gigantic compared to the roughly 5% usually expected and you'd grow to dominate everybody. It is hard to believe out of the (at least) 1,000 fans of Foo, not one of them is taking advantage of this golden opportunity. This makes it seem as if Foo fans are full of you know what. Can all 1,000 Foo fans really be Altruistic? 
      </p>
      <p>
        <em>It doesn't matter how quickly you can create an MS-Excel, </em>AutoCAD or SAP clone, if you don't have the marketing clout, reputation and long-term industry momentum of Microsoft, Autodesk or SAP AG, you're not even going to be noticed.  Specialist technologies are a powerful tool when you build bespoke applications and compete with other bespoke application developers.  With the right tool, you can genuinely blow your competitors out of the water.  Such tools can make a big difference in custom and vertical markets.  They make no difference in horizontal, COTS markets.<em></em>
      </p>
      <p>
        Those are claims, not evidence nor detailed analysis. I can't do much with that paragraph as given other than consider it a general anecdote.
      </p>
      <p>
        {Similar could be said of the first paragraph.}
      </p>
      <p>
        It's mostly a question, and 2 wrongs don't make a right.
      </p>
      <p>
        {<a href="GarbageInGarbageOut.html">GarbageInGarbageOut</a>. There is such a thing as bad questions, which don't allow for good answers. But that doesn't mean the answer was wrong. Can you prove it was wrong?}
      </p>
      <p>
        As typical with anecdotal observations, I cannot confirm nor deny it. Statements like "With the right tool, you can genuinely blow your competitors out of the water" should have more detail behind it (even if that detail is more anecdotes), otherwise it's not worth stating, in my opinion. It's far too general.
      </p>
      <p>
        {I'm not the author of the 'blow out of the water' comment, and I'd agree it contains some content that is dubious or irrelevant. OTOH, it is almost never worth elaborating any point other than the main point. Which, in this case, was in the first sentence - referring to 'marketing clout' and 'reputation', which are specific examples of <a href="NetworkEffects.html">NetworkEffects</a>. Of course, even <a href="NetworkEffects.html">NetworkEffects</a> are an incomplete answer; another factor is simply that software development costs are usually a very small fraction of a company's budget. Writing equal software twice as fast doesn't mean anywhere near twice the profit from the CEO's perspective; in many cases (e.g. for internal business software), it might only amount to a 1% difference.}
      </p>
      <p>
        Software development and maintenance (SDM) cost is a big part of the budget of a software company. For a software company, assume about 1/3 of their budget is SDM, which I believe to be realistic. If a <a href="GoldenHammer.html">GoldenHammer</a> improves SDM costs by 50%, then their revenues would be roughly 17% higher (50% x 0.33). That's a huuuuuge advantage: you'd be eating the markup up. I believe the answer is because there is no <a href="GoldenHammer.html">GoldenHammer</a>.
      </p>
      <p>
        <em>I'm not the author of the 'blow out of the water' comment -- at least I don't recall writing it -- but I agree with it.  I also agree that it's irrelevant to the main point, but as there's some curiosity about it I'll provide an anecdote to back it up:  In the late 1980s, I founded a small software company with some partners.  We originally intended to develop videogames, but the videogame market at the time was unstable and risky so we refocused on developing bespoke (custom) business software.  Initially, we used </em><a href="ExBase.html">ExBase</a> -- as did most similar consultancies at the time.  However, as <a href="ComputerScience.html">ComputerScience</a> graduates (which was relatively uncommon for consultancies at the time -- most were staffed with accountants and/or downsized middle managers) we recognised the flaws and limitations of <a href="ExBase.html">ExBase</a> and developed an alternative consisting of  C (later, C++) libraries and associated tools designed to facilitate building custom business applications.  That was highly successful.  Our in-house libraries and tools allowed us to develop more user-friendly applications that exhibited better performance than <a href="ExBase.html">ExBase</a>, and develop them faster, and re-use code more easily than <a href="ExBase.html">ExBase</a>.  That allowed us to bid lower than our <a href="ExBase.html">ExBase</a>-using competitors and deliver better quality.  Within a few years, we were the only bespoke business software developer in our market area -- our competitors simply couldn't compete with us.  For us, our C/C++ tools were a <a href="GoldenHammer.html">GoldenHammer</a> -- at least compared to <a href="ExBase.html">ExBase</a>.<em></em>
      </p>
      <p>
        I've seen C/C++ custom biz apps fail to last because lower-level pointer and RAM management issues created lots of odd bugs. I saw no evidence it was a competitive threat to <a href="ExBase.html">ExBase</a> in general, or I would have jumped into it. True, it gave you far more control over the hardware and graphics, but the flip side is that mistakes in the lower-level stuff created odd bugs like random crashes and data corruption. Perhaps some know how to use C/C++ well in such a domain and others don't. C/C++ itself is not a <a href="GoldenHammer.html">GoldenHammer</a>, but the combination of the right staff members using the right tool in the right domain. Those who mastered <a href="ExBase.html">ExBase</a> and knew where to use it and where not to also did well and created successful products. Master your tool and respect both its strengths and weaknesses and you can do well with a wide variety of tools.
      </p>
      <hr/>
      <p>
        <em>I think that what you are missing is something the economists call "the network effect". It means that a network is more valuable when a node is added. Think about having an marvellous cellphone that can't call anybody, because the cellphone network isn't part of the usual telephone network. It's conceivable that Foo, on the conditions of the stablished product (Bar) would be better. But Bar has the "network effect" and that's why is the chosen one. I think that the </em>PrisionerDilema has some connections with it. Programming languages and their popularity are very tied to the "network effect".<em> (cf. </em><a href="http://en.wikipedia.org/wiki/Network_effect)">http://en.wikipedia.org/wiki/Network_effect)</a>
      </p>
      <p>
        Why does popularity matter?
      </p>
      <p>
        <em>Popularity matters because of the network effect, and various other forms of inertia in technology. See also: </em><a href="http://en.wikipedia.org/wiki/Virtuous_circle_and_vicious_circle''">http://en.wikipedia.org/wiki/Virtuous_circle_and_vicious_circle''</a>
      </p>
      <p>
        I mean specific to <em>this</em> topic. Do you mean like staffing? Having sufficient replacement staff available in the market-place before investing/relying-on a given technology? But such is a real factor to consider, as described in <a href="GreatLispWar.html">GreatLispWar</a>. -t
      </p>
      <p>
        <em>Human resources - e.g. education or staffing - is certainly one aspect of the network effect. But there are dozens of such aspects: libraries, frameworks, documentation, tools and IDEs, man-hours spent on compilers and optimizers, marketing or visibility, etc. all increase with popularity, with the size of the 'network'. These are all part of the network effect for programming languages. The reality is that Foo can't win by being 20% better than its incumbent competitor for its purpose, because it is never given a fair chance. So even if there is a technology that would save a company 30 man-days each year, you'll never get to use it unless some big company is willing to back it. Foo needs to be about 10x better for its purpose to compete on technical merit alone. Conversely, if a big company is willing to back a technology (e.g. Google with its 'Go' language, or Sun with Java) it can succeed despite dubious technical merit. One can have enough money and influence to bootstrap the network effect. Or one can get lucky, or seize some opportunity (like Netscape and Brendan Eich did, rushing </em><a href="JavaScript.html">JavaScript</a> to beat Microsoft to the goal). The network effect is incredibly unfair, but so is life.<em></em>
      </p>
      <p>
        Why would the network affect matter that much? I agree it matters some, but not to the level you describe, especially in new industries where big libraries of tools and add-ons don't exist yet anyhow in the legacy or current tools/languages.
      </p>
      <p>
        <em>It is true that in "new industries" without the established incumbency, new tools can more readily establish a niche or foothold. For example, that's how </em><a href="JavaScript.html">JavaScript</a> won in the first place. There is also a notion of <a href="KillerApplication.html">KillerApplication</a> - e.g. <a href="RubyOnRails.html">RubyOnRails</a> was the primary cause of success for Ruby, the first language to provide and heavily promote that sort of framework. Of course, new industries are relatively rare (because they quickly mature into established industries) and must often integrate with old industries. And almost any <a href="KillerApplication.html">KillerApplication</a> can be cloned to other languages within a year or two, eventually negating that advantage. Network effects aren't evenly distributed. But they are significant enough to have crushed many projects and companies... and more than sufficient to answer the topic question.<em></em>
      </p>
      <p>
        If they can be cloned and be nearly equally competitive, then the original language/tool wasn't significantly better after all. But there is also the age old quick-to-write versus quick-to-read trade-off in that a language/tool tuned for "get it up quick" (in the right hands) may not be optimized for team maintenance. Being useful for rapid prototyping and/or experimenting is a good feature to have in some circumstances, but may force tradeoffs in other areas that may become more important in a maturing market. <a href="RubyOnRails.html">RubyOnRails</a> has a bit of a reputation for being a "write-only framework" in that it can drive second-generation maintainers crackers when "clever abstractions" are a bit too clever, and thus perhaps is favored by sleazy marketers promising "we can build you a full interactive site for cheap cheap cheap, or your mattress is freeeeee!" 
      </p>
      <p>
        <em>I would agree if you reworded that to: "if they can be cloned with nearly equal </em>'quality<strong>." If a clone is only competitive because of network effects (e.g. because the clone was developed in a popular language), but otherwise had poor quality (e.g. poor performance, security, extensibility, maintainability, and other </strong><a href="NonFunctionalRequirements.html">NonFunctionalRequirements</a>) then it doesn't seem reasonable to conclude that the original wasn't significantly better. Conversely, of course, it's quite feasible that a clone has even higher quality (and this isn't always a reflection of the tools; sometimes it's just lessons learned). In any case, I didn't mention <a href="KillerApplication.html">KillerApplication</a>s as 'evidence of quality' (they aren't!); rather, I mentioned them only a common vector by which a non-mainstream tool or PL can gain some penetration and footholds in an established industry despite heavy resistance from network effects.<em></em>
      </p>
      <hr/>
      <p>
        <strong>Alice:</strong> Bob, why are you unwilling to try this new great technology?
      </p>
      <p>
        <strong>Bob:</strong> Because it's new. It hasn't proven itself yet.
      </p>
      <p>
        <strong>(years later) Alice:</strong> Bob, why are you unwilling to try this old great technology? It has been used in several projects to great success.
      </p>
      <p>
        <strong>Bob:</strong> Those are just a few minor projects. The technology hasn't established itself in the industry. Nobody else is using it, and I can't hire people that know it. I have a lot on my plate, and don't have time to learn some newfangled idea. The company that initially developed it went under because nobody would buy. Clearly, if it was better, then people like me would have picked it up years ago, and they'd be rich.
      </p>
      <p>
        <strong>Alice:</strong> sigh...
      </p>
      <hr/>
      <p>
        It would be really nice if the parties involved in this continuous back-and-forth sniping could do so without creating new pages every day that contain minor variations on pointed rhetorical questions that weren't interesting to begin with. Serious case of WikiPollution. Take it to email, please.
      </p>
      <p>
        <em>It is a fairly common question in my observation, in more than one language/paradigm even.</em>
      </p>
      <p>
        Yes, but it's not really a question about programming. Starting a successful business entails a zillion factors other than technical merits of a technology, not the least of which is chance. Do you really want to have a discussion such a broad, general topic? Pointless. And for any number of specific programming technologies, there are other places where this has been discussed ad nauseum -- collect the information together on a more specific page if it's of interest as a separate topic.
      </p>
      <p>
        Also, the snide tone of this page's title, and several others which have been created recently, grates. It seems ... juvenile. Nyeah nyeah nyeah.
      </p>
      <p>
        <em>You are welcome to smooth out the snideness.</em>
      </p>
      <p>
        There is no point.  It's simply a <a href="FlameWar.html">FlameWar</a>, and in a war, there is no incentive for either side to say, "You win!" Another page, say IfBarCanBeSoCompellingWhyAmEyeNotUsingIt, will be created if people successfully answer the question on this page. Here, one obvious value of Foo can be answered with <a href="PaulGraham.html">PaulGraham</a>. But then you have people releasing the mainline of attacks on Paul's character, or his achievements, etc. Or they'll ask, "Why aren't all Foobaristas rich?" And right now on a WhyWeHateFoo page, someone's manipulating reality to say that improving Foo is impossible. Of course, I could say one acronym to shut that position down. But then another snide head will pop up, to be bashed with the padded stick. It's pointless. The best you can do is stem the worst of the wiki, and accept that some lies will get through, polluting the stream. It's all a DoS attack so you don't get any work done. I'm certain there is at least one troll at work, just having fun, and I salute him. There is enough good content in
        the world, for those who take the time to browse and think, and for those who don't... perfect, let them stay with a community that wants as many people as it can get its hands on. Win-win.
      </p>
      <p>
        <em>While the tone and tenor of this page is a bit snide, I'll agree... the page seems to be a clear reference to </em><a href="PaulGraham.html">PaulGraham</a>s (in)famous comment that he considers a particular value of foo--<a href="CommonLisp.html">CommonLisp</a> to be precise--to be a "competitive advantage".  To me, that sounds like a claim that "shops which use Lisp can do things demonstrably faster and/or cheaper than shops that don't."  While I don't doubt that many tasks can be done better in Lisp--especially in the hands of skilled Lisp programmers, the <a href="SecretWeaponArgument.html">SecretWeaponArgument</a> has numerous holes in it that it's hard not to take seriously.<em></em>
      </p>
      <p>
        I find your arguments completely reasonable. But let's just take this page on face value. If I actually spread an enormously convincing argument that Foo=Rich, enough that all the FlameWarriors stop posting on the wiki and start making money, guess what -- Foo would no longer be so profitable. I mean, we are getting into logical binds here, whose very rules force one to discriminate against Foo. It's just sad now. For all his flaws, <a href="PaulGraham.html">PaulGraham</a> is a zillion times better than some of these snide WikiPolluters. Many of his critics (I'm not talking about you) don't come near the standard they hold for him.
      </p>
      <p>
        I'm sick of this wiki; I only come here to rebut the worst lies, and it's just... I think it's fun for once a week, but any more and it's an unrewarding job.
      </p>
      <p>
        <em>You seem unwilling to face the reality that </em><a href="MostHolyWarsTiedToPsychology.html">MostHolyWarsTiedToPsychology</a>.<em></em>
      </p>
      <hr/>
      <p>
        Re: "For all his flaws, <a href="PaulGraham.html">PaulGraham</a> is a zillion times better than some of these snide..."
      </p>
      <p>
        Paul is just one person who got rich perhaps because of Lisp. However, there does not appear to be tons of others doing the same. Many successful dot-com's used ASP, PHP, Java, etc. also. In fact, Yahoo is rewriting much of Paul's Lisp code into C++ or PHP (IIRC), although the reasons they give are odd.
      </p>
      <p>
        <em>Getting rich has little to do with what language you pick, there are far too many other factors involved in business.  Quality of product has little to do with success, microsoft already proved that marketing has far more impact on success than quality, language, skill, or anything else you can think of.</em>
      </p>
      <p>
        Yes, but even if the software part is only 20% of total costs, a big advantage there may make your profit margin go from say 1% to 10%. (Anybody have cost breakdown figures for a typical fledgling software company?) As often described in natural selection discussions, a small percent difference can add up over time. If a company competing with Microsoft grew one percent faster than MS when it first went public, the one percent would compound to make such a company about 30 percent larger than MS about now.
      </p>
      <p>
        {Being a start-up in a new industry may not be representative of software projects in general. Writing maintenance-friendly code for a "typical" developer may require a different technique than growing faster than your competitor in the dot-com gold-rush. Paul doesn't have a lot of experience in a more typical organization, so his perspective is a bit tilted to a specific situation.}
      </p>
      <hr/>
      <p>
        <a href="MicroSoft.html">MicroSoft</a> is rich, and most of its products suck.  I think that says enough about the assumptions underlying this page's title.
      </p>
      <p>
        <em>Many consider their products "good enough". Plus, MS's prices were often better than compitors at the time before they used "product lock-in" as their primary weapon. For example, Lotus-123 was slow to get a GUI and damn expensive compared to MS-Excel. MS-Word was easier to use than Word-Perfect (for newbies, at least). Besides, I am thinking of more niche-based products as a comparison rather than mass-market software. There's a lot of niche software out there.</em>
      </p>
      <p>
        <em>Microsoft products were relatively feature-rich for a reasonable price. Thus, between </em>'features, quality, and cost<strong>, MS scored high on </strong>two<strong> of those and that's largely why they succeeded. Nobody's ever shown they can master all 3 in multiple products. It may be because </strong><a href="WorseIsBetter.html">WorseIsBetter</a>.<em></em>
      </p>
      <hr/>
      <p>
        "Study Finds You Don't Have To Be Smart To Get Rich": <a href="http://www.informationweek.com/news/showArticle.jhtml?articleID=199201363">http://www.informationweek.com/news/showArticle.jhtml?articleID=199201363</a>
      </p>
      <hr/>
      <p>
        Merge this topic with <a href="SecretWeaponArgument.html">SecretWeaponArgument</a>?
      </p>
      <p>
        Then again, some of the discussion in <a href="SecretWeaponArgument.html">SecretWeaponArgument</a> is actually about trade secrets, which was not the intention of this page.
      </p>
      <hr/>
      <p>
        First of all, several comments have brought <a href="PaulGraham.html">PaulGraham</a> into the mix.  In his case, he's been saying "Foo *is* great!  It's how I got rich!"  Thus, he isn't exactly the best person to look at, as an example of <a href="IfFooIsSoGreatHowComeYouAreNotRich.html">IfFooIsSoGreatHowComeYouAreNotRich</a>.  Indeed, he's a counter-example.
      </p>
      <p>
        Second, the observation that network effects, and even business decisions, affect the success of a business, independently of the value of a given technology, is spot-on.  I know of one company that made rugged little computers that could be put into all sorts of uses.  By the time they figured out their best market, they ran out of funds, and were unable to continue.
      </p>
      <p>
        I even remember someone telling me of a great literal network product, considerably faster than Ethernet, and had a few other advantages to boot.  But because the device wasn't called "Ethernet", they had a very difficult time convincing businesses to go with it!  So they literally went out of business, because they couldn't get a big enough network off the ground that could take advantage of their business model.
      </p>
      <p>
        Third, using technology can be easy--nothing is stopping any of us from picking up a Lisp, and writing a program that repeats, ad nausium, "Hello World" all the time.  But to extend that to a 3D game, with lots of math and stuff, is hard!  (And this is from someone who, as a mathematician who loves such things, has actually tried to do this, albeit in Python and not yet in Lisp or Haskell.)  It takes time to put together something complex.  In the meantime, I have a family to feed, so I need to convince others to pay me money, and I generally do this by using libraries and languages and platforms and even the computer hardware that was chosen for me, to one extent or another.  I am now working for a Telecommunications Company, and their basis is a product called Asterisk, because it was the platform available at the time; there's a new platform called FreeSWITCH, that does things better...but the company hasn't switched (even though we're interested in the new platform) because of all the resources and scripts that rely on Asterisk.
      </p>
      <p>
        All this new technology is wonderful, but old technology isn't completely useless just because it's inferior.  There's a cost to switching, or even to something new, and unless those costs can be overcome, sometimes you're just stuck at being poor.  Heck, sometimes you're stuck at being well-off.  While Paul Graham is fortunate enough to have become rich, there's the possibility--however unlikely--that a startup will reach a "local maximum" where there's just enough customers to please, but not enough to continue to grow, that you become a profitable business that won't necessarily become rich.  But that doesn't mean the business--or the technology it's founded upon--isn't worthwhile!  --Alpheus
      </p>
      <hr/>
      <p>
        I find it statistically unlikely that say a Lisp-centric software company would not eventually form to kick the standard language companies' asses if it was really a true productivity improver. Lisp was popular in the 80's due to the AI bubble and many were eager to hop into the fad and run with it. I realize there is more to a company than programming cost, but in a software publisher org it's roughly half the total costs. If Lisp gave them a 20% productivity advantage over Algol/C-style languages, then they'd have a 10% productivity advantage over competitors. That would give them a pretty hefty profit margin and they'd grow fairly quickly compared to the "Algies". If you can make the argument that Lisp has not been commercially tried often enough, please do. -t
      </p>
      <p>
        <em>I suspect your 'statistically unlikely' has no statistical basis whatsoever. In any case, software companies rarely compete in terms of "productivity". They compete in terms of: domain expertise, good ideas, location, software performance and quality, networking, marketing, reputation, persistence, and a bunch of other things. I sincerely doubt productivity is even among the top ten factors for success.</em>
      </p>
      <p>
        You are saying that if all the developers only worked 4 hours a day, nobody would know the difference? And "productivity" is not necessarily explicitly-measured productivity. If your biz depends heavily on software, then a roughly 10% increase in programming productivity should eventually manifest itself in terms of profit and market-share, especially among multiple companies using the "better" approach. (Some text since added after reply below.)
      </p>
      <p>
        [Point nicely misunderstood.]
      </p>
      <p>
        Anyhow, we'd probably have to look at actual expenditures to see how much is related to software development and maintenance cost. I expect that for niche markets with a fairly close-nit or slowly-changing customer base, development labor would be a significant part. It's "executive"-oriented "marketing-ware" that has a high BullshitBudget.
      </p>
      <hr/>
      <p>
        For the sake of argument, lets say hiring a room full of Lisp whizes <em>would</em> work for most companies if they simply just did it. However, the decision makers have no <em>visible</em> reason to try unless enough companies try it and <strong>demonstrate it works first</strong>. It's not realistic to expect them to take your word for it; they want to see it working "live" first in sufficient quantity. Around four is the magic number I'd estimate to get the industry's attention: if 4 software-heavy companies were clearly successful and had relatively recently hired a room full of Lisp whizes, other companies would begin to take notice and try it themselves such that it would start self-perpetuating.
      </p>
      <p>
        <em>Lisp has and always had the "industry's attention".  Whilst it's not as popular as mainstream languages like C#, Python and Java -- and its quirky nature means it probably never will be -- many large, diverse code shops employ it somewhere.  In some industries, like financial services and automated trading, it -- along with other functional programming languages -- is popular.</em>
      </p>
      <p>
        I am mostly considering "mainstream" IT. I agree it has some niches where it may do well, but these are largely domains that benefit from a so-called <a href="HackerLanguage.html">HackerLanguage</a>.
      </p>
      <p>
        <em>By some definitions of "mainstream" IT, there isn't any need for languages outside of </em><a href="VisualBasic.html">VisualBasic</a> and <a href="MicrosoftExcel.html">MicrosoftExcel</a>, and there's a lot more need for the latter than the former.<em></em>
      </p>
      <p>
        I don't see that to be the case. I've worked in shops where "write-only" programming would have been a good fit, but managers resisted techniques favoring such, largely out of unfamiliarity. And the opposite can happen: a coder may be proficient using a very "compact" form of expression, and nobody complains because work is getting done: UNTIL this coder leaves and the follow-on programmer is confused by the prior technique. A lot of it depends on the personally of the organization or specific managers at the time, not necessarily an overall plan. But being burned by the second sticks in their mind far more than the first. Lost "extra" productivity margins are not very visible to owners/managers (unless it's their main cash cow), while <strong>outright stoppage</strong> due to the second is quite visible and memorable. An analogy would be home water heaters: If your heater is inefficient, you may grumble a bit while paying bills, but when it's outright broken, you cuss your ass off under the cold shower.
      </p>
      <p>
        There's a related "war saying" that the best way to defeat your enemy is to subliminally nibble away at them, not bash them in the face.
      </p>
      <p>
        <em>You don't see what to be the case?  You don't see a lot of </em><a href="VisualBasic.html">VisualBasic</a> and <a href="MicrosoftExcel.html">MicrosoftExcel</a>?<em></em>
      </p>
      <ul>
        <li>
           Perhaps there is a reference confusion. It's not clear to me what's being compared, even after 3 readings.
        </li>
      </ul>
      <ul>
        <li>
           <em>I'm not comparing anything.</em>
        </li>
      </ul>
      <p>
        Some of it may be a case of <a href="SovietShoeFactoryPrinciple.html">SovietShoeFactoryPrinciple</a>, but one should probably factor in the existence of <a href="SovietShoeFactoryPrinciple.html">SovietShoeFactoryPrinciple</a> when making economic decisions or recommendations. The "systems" must work (fit) in environments where decision makers may not have perfect knowledge. If you plan with the assumption that decision makers are all-knowing, your plan will probably fail when put into the real world where <a href="SovietShoeFactoryPrinciple.html">SovietShoeFactoryPrinciple</a> plays a big part because they will eventually boot out systems that don't fit their expectations as-is.
      </p>
      <p>
        <em>Some of what may be a case of </em><a href="SovietShoeFactoryPrinciple.html">SovietShoeFactoryPrinciple</a>?<em></em>
      </p>
      <p>
        The drawbacks of Lisp may be more visible to decision makers than the benefits.
      </p>
      <p>
        <em>Probably.  Lisp is quirky.  It's in use, even popular, where specialist requirements drive the need for a language of its capability.  Mainstream IT doesn't demand much of programming languages.</em>
      </p>
      <p>
        Depends on how you define "demand much". Most orgs want "serviceable" software at a "good" price with little or no interruption due to shifting staff. Those are "demands". If you can build a better mouse-trap that delivers those without significant new drawbacks, you'll be Kazillionare. 
      </p>
      <p>
        In general higher abstraction is harder to manage, verify (by owners), and hire for. That's just the way it is. Some niches can handle the tradeoffs for higher abstraction due to the nature of the domain or happenstance of personnel. But just like winning the Superbowl, that requires skill, luck, timing, and perhaps <strong>gambling</strong> that the right combination of people click with each other and stay around. 
      </p>
      <p>
        Plus, what works under one management style may not work under another. The "traditional" approach will never be "A" grade, but it will usually be <em>at least</em> "C" under most management styles. An <strong>abstraction-leveraged management technique</strong> may be "A" under it's current (optimal fitting) management style, but perhaps would be "D" or "F" under most others. Thus, a change in owners or a retirement could send things spiraling down.
      </p>
      <p>
        As far as the <a href="PopularityOfLisp.html">PopularityOfLisp</a>, I disagree, but will leave that topic to that wiki topic. 
      </p>
      <p>
        <em>By "mainstream IT doesn't demand much of programming languages", I mean "mainstream IT" generally doesn't demand higher-level constructs, metaprogramming and generative programming, high-performance arbitrary-precision numerical processing, extreme fault-tolerance, and so on.  What it does generally demand are facilities to produce simple data recording, processing and reports, in a repeatable and maintainable fashion at reasonable cost, without requiring a high degree of technical competence.</em>
      </p>
      <p>
        Not this fuzzy argument again. How do we know if something "demands higher-level constructs", and what are "higher-level constructs" exactly? Without some kind of definition or sample sets to compare and study, your statements are not useable to readers. Are we back to HOF-square-one yet again? I encounter apps all the time that could make use of meta-programming techniques, but I usually avoid them because it makes non-me maintenance more difficult, NOT because it's not a useful technique. It's the balancing point between the power of more abstract techniques and team-skills & staffing issues as discussed in <a href="EconomicsOfAdvancedProgramming.html">EconomicsOfAdvancedProgramming</a> (which is largely about productivity versus risk).
      </p>
      <p>
        <em>What argument?  I'm still not clear what you're arguing for or against.  Are you arguing that higher-level constructs -- like higher-order functions, for example -- shouldn't exist at all?</em>
      </p>
      <p>
        I am saying that the need-level for "high-level" constructs is not really what's shaping "mainstream" expectations or shop practices. The industry found that a reliable supply of <a href="PlugCompatibleInterchangeableEngineers.html">PlugCompatibleInterchangeableEngineers</a> is more important than the benefits of higher abstraction. And I suspect the areas where Lisp shines is in <a href="WriteOnlyLanguage.html">WriteOnlyLanguage</a>-type of apps or sub-systems, such as one-time throw-away queries, reports, or studies. However, it then wouldn't really show up on the language radar (like <a href="TiobeIndex.html">TiobeIndex</a>) because the org wouldn't care whether one used Lisp, APL, or <a href="BrainFsck.html">BrainFsck</a> for fungible sub-apps as long as the programmer "gets it done" quick and reliably.
      </p>
      <p>
        <em>Of course the need-level for "high-level" constructs is not </em>'mainly<em>' what's shaping "mainstream" expectations or shop practices, though it clearly has some influence.  High-level constructs do, over time, make their way into mainstream languages.  However, Lisp is a specialist language for meeting specialist requirements.  It is used by organisations that have such specialist requirements, which by definition are fewer than those with mainstream requirements.  Therefore, Lisp is not as popular as languages used to meet mainstream requirements.  There is nothing to debate here -- that is how it is.</em> 
      </p>
      <p>
        That's not the position of a "typical" <a href="SmugLispWeenie.html">SmugLispWeenie</a>. To them, Lisp should be almost everywhere and is not a niche language. You killed the original <a href="SmugLispWeenie.html">SmugLispWeenie</a> and took over their body, didntcha!
      </p>
      <p>
        <em>I can't speak for </em><a href="SmugLispWeenies.html">SmugLispWeenies</a>, as I am not one.  I consider languages on their merits alone, and try to avoid Fanboyism.<em> [</em><a href="FanBoy.html">FanBoy</a>]
      </p>
      <ul>
        <li>
           Note there are "merit" fanboys also, such as focusing on one or a few narrow factors above all others. "Factor fanatics".
        </li>
      </ul>
      <ul>
        <li>
           <em>Like you with "</em><a href="WetWare.html">WetWare</a>" or employment patterns?<em></em>
        </li>
      </ul>
      <ul>
        <li>
           If the main <a href="PurposeOfProgramming.html">PurposeOfProgramming</a> is to communicate with other humans AND make a profit, then those ARE big factors. If staff were free, then obviously labor costs wouldn't matter.
        </li>
      </ul>
      <ul>
        <li>
           <em>Wow. I didn't expect you to prove my point so quickly. Thanks.</em>
        </li>
      </ul>
      <ul>
        <li>
           Seems "narrow" is in the eye of the beholder. 
        </li>
      </ul>
      <p>
        How does your position relate to the topic, then?
      </p>
      <p>
        <em>It doesn't, particularly.  Should it?</em>
      </p>
      <p>
        It helps to be on-topic :-)
      </p>
      <p>
        <em>I responded directly to your comments.</em>
      </p>
      <p>
        Maybe that was a mistake :-)
      </p>
      <hr/>
      <p>
        If there was an algorithmic solution to achieving domination and blowing your competitors out of the water, everyone would be employing it and everyone would be blowing everyone else out of the water. There wouldn't be much left in the water.
      </p>
      <p>
        The whole process of competition in a free market is predicated on high failure rates. If those failures can't be on technical grounds then they must be on other grounds - however specious those grounds may be. But there have to be failures.
      </p>
      <hr/>
      <p>
        Because being rich is almost completely about luck. Many people that work hard every day of their lives die poor and plenty of fantastic ideas, books, inventions never get realised because of a lack of money or being in the right place at the right time. If Steve Jobs had not met Steve Wozniak, we would never have heard of either of them, for example. So, naturally, Foo being great is no guarantee of being rich.
      </p>
      <p>
        <em>I disagree it's purely about luck. </em><a href="SteveJobs.html">SteveJobs</a> is more likely than the average bear to do well because of his passion and (selective) charisma regardless of where the ebb and flow of life would take him. I would point out that he helped kick-start the CGI animated movie industry per Pixar and Toy Story in his time away from Apple. He has a nose for the future, for what can be squeezed out of existing technology, and for consumer reaction to as-of-yet unseen ideas. True, he has failed big at times both inside and outside of Apple (expensive Lisa, Next, "cube" Mac), but the size of his successes seem to greatly over-shadow his failures. <em></em>
      </p>
      <hr/>
      <p>
        See also <a href="HowCanSomethingBeSuperGreatWithoutProducingExternalEvidence.html">HowCanSomethingBeSuperGreatWithoutProducingExternalEvidence</a>, <a href="IfSmalltalkIsSoGoodWhyDoesNobodyUseIt.html">IfSmalltalkIsSoGoodWhyDoesNobodyUseIt</a>, <a href="GreatLispWar.html">GreatLispWar</a>, <a href="PopularityOfLisp.html">PopularityOfLisp</a>, <a href="EconomicsOfAdvancedProgramming.html">EconomicsOfAdvancedProgramming</a>, <a href="ExBaseRant.html">ExBaseRant</a>, <a href="WebStoresDiscussion.html">WebStoresDiscussion</a>
      </p>
      <p>
        <a href="JulyThirteen.html">JulyThirteen</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryEconomics.html">CategoryEconomics</a>, <a href="CategoryEmployment.html">CategoryEmployment</a>, <a href="CategoryEvidence.html">CategoryEvidence</a>
      </p>
    </div>
  </body>
</html>