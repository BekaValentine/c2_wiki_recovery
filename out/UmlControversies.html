<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Uml Controversies
      </h1>
      <p>
        <a href="UnifiedModelingLanguage.html">UnifiedModelingLanguage</a> was never regarded as a bright idea or very useful tool inside <a href="WikiCommunity.html">WikiCommunity</a>. Static typists and dynamic typists, XPers, agile folks and <a href="NoProcess.html">NoProcess</a> guys never cared to express favorable opinions about UML. However, there's a strong undercurrent that the UML has over the mindshare of key executive decision makers in the industry. 
      </p>
      <p>
        I've seen more and more products come packaged with UML features at the expense of great complexity and to the detriment of the users. Borland aquired <a href="TogetherSoft.html">TogetherSoft</a>, and now all of their products, including the UML flagship <a href="TogetherJava.html">TogetherJava</a>, are geared towards serving you with UML-style development. IBM aquired <a href="RationalRose.html">RationalRose</a>, and of course their flagship "enterprise" development (IBM WebSphereStudio). Oracle has UML integrated as well in Oracle JDeveloper with lesser features. But all these vendors are pushing promises of <a href="ModelDrivenArchitecture.html">ModelDrivenArchitecture</a>, model driven development, click your way through our UML diagrams and you'll have your platform independent model and that will be translated to a platform specific model and then into EJB or .NET and everything will be wonderful. Actually they don't quite have anything to show yet, not even in the way of <a href="HelloWorld.html">HelloWorld</a>, but they do have a <a href="RoadMap.html">RoadMap</a> and they claim that even without UML.
      </p>
      <p>
        All this time, Microsoft has kept quiet, not pushing UML at all other than supporting it in Visio, which is a drawing tool (and a very good drawing tool at that) more than a development tool. Among the many noted researchers that now work for <a href="MicrosoftResearch.html">MicrosoftResearch</a> and in product teams, there's nobody of notoriety supporting UML. In particular there's TerryHalping, the inventor of <a href="ObjectRoleModeling.html">ObjectRoleModeling</a> notation and approach to data modeling who is on record underlining many limitations of UML for the purpose of <a href="InformationModeling.html">InformationModeling</a> activities. The latest Visio for "architects" has excellent support for using ORM to model the information in the system and forward engineer a database schema into SQL Server. To make matters worse for the fate of UML inside Microsoft, they have hired our very own <a href="WardCunningham.html">WardCunningham</a> who is a preeminent <a href="ExtremeProgrammer.html">ExtremeProgrammer</a>.
      </p>
      <p>
        To surprise some observers, beyond this tacit neglect of UML by the Microsoft camp, a noted architect from their development solutions team, went public with an article outlining what we all mortals in the trenches knew for a long time, but very few from the top layer in the industry had the courage to say, for fear of going against the pseudo-official directions of all the heavyweights gatehred into OMG, an organization that still has a lot of clout. <a href="http://www.bptrends.com/publicationfiles/01-04%20COL%20Dom%20Spec%20Modeling%20Frankel-Cook.pdf">http://www.bptrends.com/publicationfiles/01-04%20COL%20Dom%20Spec%20Modeling%20Frankel-Cook.pdf</a>
      </p>
      <p>
        Steven Cook from Microsoft advocates the position that UML has a lot of deficiencies as a "modeling language", plus it is inadequate for many tasks, plus it is not very popular with developer in the trenches, therefore solutions to modeling problems should be sught in other directions, namely <a href="DomainSpecificLanguage.html">DomainSpecificLanguage</a>s. Big surprise, somebody from the top of the industry takes a position that is favored in the trenches and by hackers (mostly OO and functional hackers) and very much favored by the <a href="ComputingScience.html">ComputingScience</a> research community. In the end, however it looks like <a href="GradyBooch.html">GradyBooch</a> and a few other heavyweuights replied back, and now we have something that looks like a blog war:
      </p>
      <ul>
        <li>
           <a href="http://blogs.msdn.com/stevecook">http://blogs.msdn.com/stevecook</a> (against UML)
        </li>
        <li>
           <a href="http://blogs.msdn.com/alan_cameron_wills/archive/2004/11/11/255831.aspx">http://blogs.msdn.com/alan_cameron_wills/archive/2004/11/11/255831.aspx</a>
        </li>
        <li>
           <a href="http://www.booch.com/architecture/blog.jsp">http://www.booch.com/architecture/blog.jsp</a>
        </li>
      </ul>
      <p>
        What do others lurkers on Wiki think about it ? There's a long time tacit bias against UML reflected on UML related pages, a noted researcher was quoted putting UML amongst ModernDinosaurs, but can we find a <a href="DevilsAdvocate.html">DevilsAdvocate</a> amongst ? Is it the case that we should question our against UML prejudices, or is it more like a confirmation of what geek attitude knew all along. Because amongst geeks the situation is quite clear: you won't see a UML diagram of the Linux kernel anytime soon, not even of the Python runtime or other popular and successful open source projects.
      </p>
      <p>
        <em>Personally, my biggest problem with UML is that it is not bidirectional. Although there are some very specific and contrived exceptions, one cannot create UML from code, then recreate the original code from that UML. Also, UML cannot capture all the non-orthogonal issues in real-world software more readably than the original code. Although it has some use for communicating system design to other programmers, it offers no advantage over a requirements document, </em><a href="DoxyGen.html">DoxyGen</a> diagrams of the code, or <a href="GalacticModelingLanguage.html">GalacticModelingLanguage</a> diagrams drawn with accompanying verbal descriptiosn between <a href="PairProgrammer.html">PairProgrammer</a><em>'s.</em> - <a href="LayneThomas.html">LayneThomas</a>
      </p>
      <p>
        We all seem to agree on that, but we cannot seem to find a <a href="DevilsAdvocate.html">DevilsAdvocate</a> for UML. At least for the sport of it. After all, somebody like <a href="GradyBooch.html">GradyBooch</a> is a pretty good guy, even an ex-geek judging by some Ada packages he wrote that are still available as open-source. Yet, he seems to be seeing something in this UML, MDA and the complicated 4 layers of models and metamodels that I cannot understand at all. Are we really dumb or is it that the emperror is naked after all ?
      </p>
      <p>
        I'd say that UML is currently a reasonable Whiteboard language, but is not good for formal descriptions because it is not a programming language. It does support Executable Profiles, but using these is a niche activity (e.g. see <a href="ShlaerMellorMethod.html">ShlaerMellorMethod</a>). For programming C++ or Java, the text based syntax of those languages is subjectively superior for actualy programming, so its not surprising that programmers prefer the text syntax. Of course "Subjective" is ,um, subjective, so some people may prefer a Java subset of UML.
      </p>
      <p>
        I think UML is in the same state as Microsoft Windows was in its 2.x release. It has potential, but is not yet ready for prime time. UML was never intended to be a programming language, and so it isn't. But it needs to become one. An interesting analogy might be Hardware Description Languages. VHDL and Verilog we originaly invented as "modeling" languages, But then some smart people work out how to build "Synthesis" tools which could translate a sufficient subset of the language into adequate hardware implementations much faster than a human designer could. So these days, hardware designers use textual HDLs instead of graphical schematic capture. UML needs to do something similar if it is to move programmers from the world of text into the world of graphical programming. Until UML *is* source code, it won't be accepted. Round-trip just isn't enough.
      </p>
      <p>
        [The fatal assumption there, is thinking programmers "want" graphical programming, a few do, the vast majority, especially those you'd call "hackers" or "guru's" don't, at least as far as I can tell, and I'm with em, text is best.  Words/Symbols make for better abstractions with less effort in a more clear fashion that I imagine pictures ever will.  There's a reason humans communicate best with language and written symbols rather than pictures.]
      </p>
      <p>
        <em>Humbly, I submit that this misses the point big-time. UML is a language for specs. That's to say, it says </em>'what<strong> to build, not how. Ergo you will never ever be able to execute your junk. What you can do, and what would be really cool to do, is to use UML as test documentation for </strong><a href="TestDrivenDevelopment.html">TestDrivenDevelopment</a>. What's wanted is a <a href="FitNesse.html">FitNesse</a>-integrated <a href="UmlWiki.html">UmlWiki</a>. Then we can take our BAs and Testers by the hand and teach them how to make their specs connect up with the really truly code that really truly executes within their really truly testable specs. Face it - UML solves a problem that we all have - connecting non-programmer members of our team with programmer members. <strong>Iff</strong> UML could be used almost exclusively for spec-driven-testing, and then test-driven-development, I will go go on record as saying it'd be an entirely appropriate and very useful thing.<em> --</em><a href="PeterMerel.html">PeterMerel</a>
      </p>
      <p>
        If UML is used only for communication between programmers and non-programmers, then the problem is that non-programmers never understand what kind of information they are <strong>not</strong> getting from the diagrams. -- <a href="PanuKalliokoski.html">PanuKalliokoski</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryUml.html">CategoryUml</a>
      </p>
    </div>
  </body>
</html>