<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Comparing Paradigms
      </h1>
      <p>
        This is to clear up issues regarding comparing different software engineering paradigms. 
      </p>
      <p>
        First, one must be clear exactly what is being claimed. Possibilities include:
      </p>
      <ol>
        <li>
           A is better than B 
        </li>
        <li>
           The benefits between A and B are unknown 
        </li>
        <li>
           The benefits between A and B are subjective (<a href="BenefitsAreSubjective.html">BenefitsAreSubjective</a>)
        </li>
        <li>
           The benefits between A and B are the same 
        </li>
        <li>
           A is more popular than B
        </li>
        <li>
           A fits the internal mind of more people than B (even if subjective)
        </li>
      </ol>
      <hr/>
      <p>
        <strong>Burden of Evidence</strong>
      </p>
      <p>
        One viewpoint is that the burden of evidence is on the person or group who claims that their given choice is objectively better than another. A second viewpoint is that the most popular paradigm is the default, and that anybody challenging that it deserves the popularity must show objective evidence that their challenging paradigm is better.
      </p>
      <p>
        One problem with the "popularity" challenge viewpoint is that things may be popular in different circles or perspectives. For example, software engineering celebrities may favor a given technology, but rank-and-file IT workers may not. Also, it opens the possibility that fads could get stuck at the top by default with no way of coming down if the competitors are equal or if benefits are largely subjective.
      </p>
      <hr/>
      <p>
        If somebody claims that the differences are largely subjective, do they need to provide evidence of the subjectivity? How can it be proved that something is subjective?
      </p>
      <p>
        And supposing that the differences were somehow "proved" to be subjective, what  of it? Unless we know why it matters to know if these differences are subjective or objective, we have no reason to care one way or the other. "Subjective" seems to be being used almost as a term of abuse here.
      </p>
      <p>
        <em>It is important in order to distinguish between things like </em><a href="PersonalChoiceElevatedToMoralImperative.html">PersonalChoiceElevatedToMoralImperative</a> and objective benefits. Someone might say, "It works better for me, therefore it is better for everybody". If you say, "there is no evidence for it being better beyond your AnecdotalEvidence", then you may offend somebody. If the <a href="BenefitsAreSubjective.html">BenefitsAreSubjective</a>, then the problem is partly solved. It can both work better for that person, yet still not be objectively better.<em></em>
      </p>
      <hr/>
      <p>
        In my experience, a major problem in prgramming today is the application of a paradigm to problems which it is poorly suited to. Every paradigm has a very small domain in which it is advantageous, outside of which it neutral or even a hindrance. 
      </p>
      <p>
        It is no coincidence that OO rose to prominence at the same time that GUIs did, as visual interfaces happen to be one of those problems at which OO really shines - it is essentially a form of modelling, and modelling was what OO was first developed for. However, it rarely is very useful for, say, data processing - objects are too fine-grained and atomic, and poorly reflect the relationships between different types of data. It is also poor at numeric analysis, for much the same reasons. 
      </p>
      <p>
        Conversely, FP never caught on except in a handful of areas because it's great strengths - numerical analysis and symbolic processing -  are rarely in the public spotlight. 
      </p>
      <p>
        Relational programming, being the strongest approach for handling vast quantities of loosely structured, <a href="DeeplyIntertwingled.html">DeeplyIntertwingled</a> data, makes up the vast majority of real-world coding; but outside of that one area, it's fundamental assumptions simply don't apply. 
      </p>
      <p>
        <a href="NotationalDesign.html">NotationalDesign</a> (one of my own favorite approaches) is usually complementary to some other paradigm, and works best for problems with a complex set of highly-parameterized interfaces - in other words, those places where a script language is called for. For most problems, it is simply too heavyweight an approach, and would add too much complexity.
      </p>
      <p>
        The only paradigm that is equally applicable to all problems is low-level procedural programming, as typified by <a href="CeeLanguage.html">CeeLanguage</a> and <a href="AssemblyLanguage.html">AssemblyLanguage</a> - and that only in the JackOfAllTradesMasterOfNone sense of being equally mediocre for all types of problems. This 'default' quality, along with the large number of existing algorithms for it, and the low design and implementation hurdles, are the real reasons why the majority of 'object-oriented', 'relational', and 'functional' code is really thinly disguised procedural code - the 'official' paradigm doesn't match the problem domain, so the programmer is forced to 'cheat' in order to force-fit a solution. 
      </p>
      <p>
        The solution? I think that what is needed is a system of <a href="ParadigmaticAnalysis.html">ParadigmaticAnalysis</a> - a meta-methodology for determining the best-fit paradigm for a given problem. Such a discipline would also require a method of recognizing the 'edge cases' where two different paradigms collide, and how to cross the boundaries gracefully. 
      </p>
      <p>
        Of course, these assertions could easily reflect my own multi-paradigm bias. It is probably telling that of my current favorite languages - Scheme, Python, Perl, and C - three of them are multiparadigm languages, while the fourth is a very-low-level procedural language. - <a href="JayOsako.html">JayOsako</a>
      </p>
      <hr/>
      <p>
        See Also: <a href="EvidenceTotemPole.html">EvidenceTotemPole</a>, <a href="OoEmpiricalEvidence.html">OoEmpiricalEvidence</a>, <a href="MixingParadigms.html">MixingParadigms</a>
      </p>
    </div>
  </body>
</html>