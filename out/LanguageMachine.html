<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Language Machine
      </h1>
      <p>
        The language machine is a toolkit for language and grammar that is published by <a href="PeriHankey.html">PeriHankey</a> under the Gnu GPL at <a href="http://languagemachine.sourceforge.net.">http://languagemachine.sourceforge.net.</a> 
      </p>
      <p>
        As can be seen from <a href="http://languagemachine.sourceforge.net/lambda.html,">http://languagemachine.sourceforge.net/lambda.html,</a> the language machine is in effect an engine for functional and grammatical evaluation which contains the capabilities of the <a href="LambdaCalculus.html">LambdaCalculus</a> and adds the ability to apply unrestricted rules for recognising and substituting grammatical sequences.
      </p>
      <p>
        The key components are
      </p>
      <ul>
        <li>
          a grammatical engine
        </li>
        <li>
          a <a href="MetaLanguage.html">MetaLanguage</a> called lmn (<a href="LmnLanguage.html">LmnLanguage</a>)
        </li>
        <li>
          a <a href="MetaLanguage.html">MetaLanguage</a> compiler
        </li>
      </ul>
      <p>
        The grammatical engine is written in <a href="DeeLanguage.html">DeeLanguage</a>, and the lmn <a href="MetaLanguage.html">MetaLanguage</a> is written in <a href="LmnLanguage.html">LmnLanguage</a>. There are descriptions and examples at the website. The key features of the system are
      </p>
      <ul>
        <li>
          the grammatical engine applies rules to analyse and respond to a stream of input symbols
        </li>
        <li>
          each rule has a left-side and a right-side
        </li>
        <li>
          the left-side of a rule describes a pattern to be recognised
        </li>
        <li>
          the right-side of a rule describes a substitution for what was recognised
        </li>
        <li>
          both left- and right-sides of a rule can include any number of symbols and side-effect actions
        </li>
        <li>
          either side of a rule can usefully be empty
        </li>
      </ul>
      <p>
        The symbols that can occur in the left- and right-sides of rules are
      </p>
      <ul>
        <li>
          terminal symbols that can occur in the external input stream
        </li>
        <li>
          lexical symbols which represent sets of terminal symbols
        </li>
        <li>
          nonterminal symbols which can occur only within rules
        </li>
      </ul>
      <p>
        Applying a rule involves
      </p>
      <ul>
        <li>
          a triggering event - a mismatch between a goal symbol and an input symbol
        </li>
        <li>
          a recognition phase in which the left-side is matched
        </li>
        <li>
          a substitution phase in which the right-side is substituted as if it had appeared in the input
        </li>
      </ul>
      <p>
        Because mismatch events typically occur during the recognition phase of a rule application, the recognition phases of rules tend to be nested within each other. Substitution phases tend also to be nested. You can tell a great deal about the workings of an analysis by looking at the way nested recognition phases overlap with nested substitution phases, and this can be displayed in a diagram which is explained at <a href="http://languagemachine.sourceforge.net.">http://languagemachine.sourceforge.net.</a>
      </p>
      <p>
        The lmn language allows rules to be written so that they can be related to specific classes of mismatch event. When a mismatch event occurs there is a limited number of alternative rules available for resolving the mismatch, and these are tried in turn and in a predictable order. So the language machine has a systematic way of dealing with partial ambiguity, and can be made reasonably efficient.
      </p>
      <p>
        The side-effect actions in rule left- and right-sides can include assignments, conditionals, loops, and calls on external procedures, and they can also construct and transmit transformed representations of material that has been analysed. The value  of a variable can itself be a deferred sequence of symbols and actions, and variable references can produce material to be matched as part of the left-side of a rule, or material to be substituted as part of the right-side of a rule.
      </p>
      <p>
        In effect, the language machine directly implements a parser which applies unrestricted grammatical rules. But it turns out that there is a strong relationship between this difficult concept and the much better understood concept of a macro processor - one that happens to recognise and substitute grammatical patterns. And it also turns out that perfectly ordinary rules which directly represent and evaluate the <a href="LambdaCalculus.html">LambdaCalculus</a> are a subset of the rules that can usefully be applied by the language machine.
      </p>
      <hr/>
      <p>
        <a href="CategoryProgrammingLanguage.html">CategoryProgrammingLanguage</a>
      </p>
    </div>
  </body>
</html>