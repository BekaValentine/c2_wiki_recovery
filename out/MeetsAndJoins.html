<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Meets And Joins
      </h1>
      <p>
        <a href="EditHint.html">EditHint</a>: Could be merged/recombined with <a href="PartialOrder.html">PartialOrder</a>, <a href="ConstraintLogicProgramming.html">ConstraintLogicProgramming</a>, <a href="BooleanLattice.html">BooleanLattice</a>, <a href="DirectedAcyclicGraph.html">DirectedAcyclicGraph</a> (all <a href="CategoryMath.html">CategoryMath</a> I guess)
      </p>
      <p>
        <a href="EditHint.html">EditHint</a> 2: An appropriate place for most stuff could be <a href="LatticeStructure.html">LatticeStructure</a>.
      </p>
      <p>
        Meet and join are two fundamental operations on types; which come from <a href="CategoryTheory.html">CategoryTheory</a>. A <em>meet</em> of two types <strong>T1</strong> and <strong>T2</strong> is a type <strong>Tm</strong> with the following properties:
      </p>
      <ul>
        <li>
           <strong>Tm</strong> is a (not necessarily proper) subtype of both <strong>T1</strong> and <strong>T2</strong>. (<strong>Tm</strong> <= <strong>T1</strong>; <strong>Tm</strong> <= <strong>T2</strong>).
        </li>
      </ul>
      <ul>
        <li>
           There is no type <strong>Tx</strong> such that <strong>Tx</strong> <= <strong>T1</strong>, <strong>Tx</strong> <= <strong>T2</strong>, and <strong>Tm</strong> < <strong>Tx</strong>. (If there is, then <strong>Tx</strong> and not <strong>Tm</strong> might be a meet of <strong>T1</strong> and <strong>T2</strong>
        </li>
      </ul>
      <p>
        Note that if <strong>T1</strong> < <strong>T2</strong>, then <strong>Tm</strong> = <strong>T1</strong>. Similarly, if <strong>T2</strong> < <strong>T1</strong>, then <strong>Tm</strong> = <strong>T2</strong>, and if <strong>T1</strong> = <strong>T2</strong>, then <strong>Tm</strong> = <strong>T1</strong> = <strong>T2</strong>.
      </p>
      <p>
        Likewise, a <em>join</em> is the opposite function; it has the following properties:
      </p>
      <ul>
        <li>
           <strong>Tj</strong> is a (not necessarily proper) supertype of both <strong>T1</strong> and <strong>T2</strong>. (<strong>Tj</strong> >= <strong>T1</strong>; <strong>Tm</strong> >= <strong>T2</strong>).
        </li>
      </ul>
      <ul>
        <li>
           There is no type <strong>Tx</strong> such that <strong>Tx</strong> >= <strong>T1</strong>, <strong>Tx</strong> >= <strong>T2</strong>, and <strong>Tj</strong> > <strong>Tx</strong>. (If there is, then <strong>Tx</strong> and not <strong>Tj</strong> might be a join of <strong>T1</strong> and <strong>T2</strong>
        </li>
      </ul>
      <p>
        Note that if <strong>T1</strong> < <strong>T2</strong>, then <strong>Tj</strong> = <strong>T2</strong>. Similarly, if <strong>T2</strong> < <strong>T1</strong>, then <strong>Tj</strong> = <strong>T1</strong>, and if <strong>T1</strong> = <strong>T2</strong>, then <strong>Tj</strong> = <strong>T1</strong> = <strong>T2</strong>.
      </p>
      <p>
        In a type system with single inheritance, and neither <strong>T1</strong> nor <strong>T2</strong> is a subtype of the other, then their meet doesn't exist (alternatively, it could be said to be the <a href="BottomType.html">BottomType</a>, and no instances of that exist). In a single-inheritance system, two types may have either one join or none; in singly-rooted systems without MI, any two types will have exactly one join (which may be <a href="TopType.html">TopType</a>).
      </p>
      <p>
        In a type system with <a href="MultipleInheritance.html">MultipleInheritance</a>, a class which inherits from <strong>T1</strong> and <strong>T2</strong> is a meet of the two types, unless it has a supertype which is a meet of <strong>T1</strong> and <strong>T2</strong>. Likewise, multiple joins are possible in such a system. (The Java type system runs into difficulties with this; as the type of the ternary (? :) operator is - or ought to be - defined as the join of the types of the two choices. Since Java interfaces allow multiple joins to exist, the language takes the easy way out and uses Object instead, rather than selecting any particular join).
      </p>
      <p>
        A <em>meet</em> can also be called an <em>intersection</em>, and a <em>join</em> can be called a <em>sum</em> or <em>union</em> (preferably not <em>union</em>, since unions in <a href="CeeLanguage.html">CeeLanguage</a> are not joins).
      </p>
      <p>
        However, a <a href="CeeLanguage.html">CeeLanguage</a> union can certainly be used to represent a meet:
      </p>
      <code>
        union {<br/>
        struct foo *pFoo;<br/>
        struct bar *pBar;<br/>
        } foobar_u;<br/>
      </code>
      <p>
        There have been many times I've wished for a way to have a <a href="JavaLanguage.html">JavaLanguage</a> (or occasionally <a href="CeeSharpLanguage.html">CeeSharpLanguage</a>) reference have a meet-of-interfaces type.  (Actually defining this meet as a new interface doesn't work -- because <a href="JavaLanguage.html">JavaLanguage</a> uses NominativeTyping instead of <a href="StructuralTyping.html">StructuralTyping</a>, classes that implement all necessary interfaces would have to have the new interface explicitly added to their supertype list.)  In <a href="CeeSharpLanguage.html">CeeSharpLanguage</a> the concept sometimes falls apart because the same method may have multiple different implementations dispatched on the type of the reference.
      </p>
      <p>
        See also <a href="ConstraintLogicProgramming.html">ConstraintLogicProgramming</a>, <a href="BooleanLattice.html">BooleanLattice</a>, <a href="DirectedAcyclicGraph.html">DirectedAcyclicGraph</a>
      </p>
    </div>
  </body>
</html>