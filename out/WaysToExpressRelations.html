<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Ways To Express Relations
      </h1>
      <p>
        There are many ways to express relations in programming, where a <em>relation</em> is defined herein as a (mathematical) function of 1 or more arguments (zero if you count the trivial relations "true" and "false") which returns a boolean as a result.  (Some systems may allow states besides "true" and "false"--"unknown" and "contradiction" are often found; see <a href="ThreeValuedLogic.html">ThreeValuedLogic</a>).  The restriction on returning booleans isn't really that much of a restriction (though it's a pain when you <em>implement</em> relational system); a <em>k</em>-ary function returning an arbitrary value can be <a href="ReFactor.html">ReFactor</a>ed easily into a (<em>k+1</em>)-ary relation which does return a boolean.
      </p>
      <p>
        There are many techniques that <a href="ComputerScience.html">ComputerScience</a> has come up with to express relations; each with their advantages and disadvantages:
      </p>
      <ul>
        <li>
           Enumeratively: by storing elements of the relation in a <a href="RelationalDatabase.html">RelationalDatabase</a> table or other appropriate data structure. (In most such systems, the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> is used: if a corresponding entry in a table appears then the answer is true, otherwise it's false).
        </li>
        <li>
           Imperatively: providing an algorithm (procedure) to compute the relation.
        </li>
        <li>
           Declaratively: by providing <em>rules</em> to compute the relation based on other relations, use of a <a href="TheoremProvingSystem.html">TheoremProvingSystem</a> to solve an arbitrary query.
        </li>
      </ul>
      <p>
        The first technique has the advantage of always terminating (assuming the data structure used is finite), and is an excellent way of representing arbitrary facts (which is one reason that <a href="RelationalDatabase.html">RelationalDatabase</a>s are in such wide use).  Plus you get (potentially) all the other advantages of an RDBMS.
      </p>
      <p>
        The second technique is what programmers are used to (though most programmers aren't used to expressing arbitrary functions as relations). Arbitrary functions might not halt, of course, though many programmers are skilled in the art of avoiding this situation.
      </p>
      <p>
        The third technique is (coupled with the first) the hallmark of <a href="ConstraintProgramming.html">ConstraintProgramming</a> and <a href="LogicProgramming.html">LogicProgramming</a> systems.  In general, <a href="TheoremProvingSystem.html">TheoremProvingSystem</a>s may not halt, but there are important subsets (such as those based on Horn clauses) for which theorem-proving is decidable. (<a href="PrologLanguage.html">PrologLanguage</a> is based on this).
      </p>
      <p>
        I'm aware of numerous programming systems which provide two of the three (well); I'm not aware of many that provide all three.
      </p>
      <hr/>
      <p>
        See also <a href="DatabaseIsRepresenterOfFacts.html">DatabaseIsRepresenterOfFacts</a>
      </p>
    </div>
  </body>
</html>