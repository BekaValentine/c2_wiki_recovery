<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Csharp Vs Java
      </h1>
      <p>
        For an articulate, blow-by-blow comparison of the two, see <a href="http://www.soften.ktu.lt/~mockus/gmcsharp/csharp/c-sharp-vs-java.html">http://www.soften.ktu.lt/~mockus/gmcsharp/csharp/c-sharp-vs-java.html</a> (but note, this article is dated 2001 and is substantially out of date).
      </p>
      <hr/>
      <p>
        <strong></strong><a href="CsharpLanguage.html">CsharpLanguage</a> and <a href="JavaLanguage.html">JavaLanguage</a>:<strong></strong>
      </p>
      <ul>
        <li>
           Both have single <a href="ImplementationInheritance.html">ImplementationInheritance</a> and multiple <a href="InterfaceInheritance.html">InterfaceInheritance</a>.
        </li>
        <li>
           Both have automatic <a href="GarbageCollection.html">GarbageCollection</a>.
        </li>
        <li>
           There is a broad overlap of common operators and keywords (41 of 43 operators; 38 of 50 keywords, 46 if you allow for synonyms).
        </li>
        <li>
           Java is defined through the <a href="JavaCommunityProcess.html">JavaCommunityProcess</a>. C# is an ECMA standard.
        </li>
        <li>
           <a href="PassByReference.html">PassByReference</a>
          <ul>
            <li>
               Java only has <a href="CallByValue.html">CallByValue</a>.
            </li>
            <li>
               C# has <a href="CallByValue.html">CallByValue</a> and <a href="CallByReference.html">CallByReference</a>.  <a href="CallByValue.html">CallByValue</a> is the default.  Marking a parameter with the <strong>ref</strong> keyword indicates that it is passed by reference.  Marking a parameter with the <strong>out</strong> keyword indicates that it is returned from the method.
            </li>
          </ul>
        </li>
        <li>
           Delegates
          <ul>
            <li>
               More powerful than <a href="FunctionPointer.html">FunctionPointer</a>s (which don't exist in Java).
            </li>
            <li>
               Represents a bound method with a given signature and invokes it polymorphically.
            </li>
            <li>
               C# has a built-in delegate mechanism.
            </li>
            <li>
               Java uses <a href="AnonymousInnerClass.html">AnonymousInnerClass</a>es for the same uses
            </li>
            <li>
               Described as "fully object-oriented", which is a totally meaningless statement.  Anonymous inner classes are arguably more "object oriented" than delegates.
            </li>
            <li>
               See <a href="http://www.onjava.com/pub/a/onjava/2003/05/21/delegates.html">http://www.onjava.com/pub/a/onjava/2003/05/21/delegates.html</a> for delegates in Java.
            </li>
          </ul>
        </li>
        <li>
           <a href="MicrosoftWindowsApi.html">MicrosoftWindowsApi</a>
          <ul>
            <li>
               It may be easier in C# to design for Windows.
            </li>
            <li>
               This may not be a universal advantage.
            </li>
          </ul>
        </li>
        <li>
           <a href="OperatorOverloading.html">OperatorOverloading</a>
          <ul>
            <li>
               C# can overload some operators.
            </li>
            <li>
               The C# String type has its == operator overloaded to provide value semantics.
            </li>
            <li>
               When you overload ==, and != will work as expected.
            </li>
            <li>
               When you overload ++, both prefix and postfix forms work as expected.
            </li>
          </ul>
        </li>
        <li>
           switch on "strings" 
          <ul>
            <li>
               This was added to Java 7. Previously it could be done in Java using a series of <strong>if () {} else if ()</strong> statements.
            </li>
          </ul>
        </li>
        <li>
           <a href="GoTo.html">GoTo</a>
          <ul>
            <li>
               C# has it; Java doesn't.
            </li>
            <li>
               <em>Does C# have labelled breaks?</em> No, break and continue can't have a label.
            </li>
          </ul>
        </li>
        <li>
           struct
          <ul>
            <li>
               In C#, a <strong>struct</strong> is a <a href="ValueObject.html">ValueObject</a> allocated on the stack.
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <em>C# structs are dangerously and cryptically implemented: See </em><a href="CsharpQuestions.html">CsharpQuestions</a> (search on word 'struct') <em></em>
      </p>
      <ul>
        <li>
           You can use <a href="NullableTypes.html">NullableTypes</a> to allow such types to support null values.
        </li>
        <li>
           Java has no analogue at the language level but the JVM is able to allocate objects on the stack when it determines that they do not live longer than the method activation that creates them.
          <ul>
            <li>
               Preprocessor
            </li>
          </ul>
        </li>
        <li>
           C# has a preprocessor similar to the <a href="CeePreprocessor.html">CeePreprocessor</a>.
        </li>
        <li>
           You can't do some things like <strong>#define private public</strong>. It's simply a means to create symbols for conditional compilation.
          <ul>
            <li>
               Attributes
            </li>
          </ul>
        </li>
        <li>
           Allow you to embed meta-data in the compiled binaries.
        </li>
        <li>
           This is an enhancement of reflection.
        </li>
        <li>
           Attributes were introduced in C# but are now also supported in Java 5.
          <ul>
            <li>
               Calling native code
            </li>
          </ul>
        </li>
        <li>
           In Java, use <a href="JavaNativeInterface.html">JavaNativeInterface</a> or a third-party enhancement to JNI.
        </li>
        <li>
           In C#, use P/Invoke. See <a href="http://www.ondotnet.com/pub/a/dotnet/2002/02/18/cominterop.html">http://www.ondotnet.com/pub/a/dotnet/2002/02/18/cominterop.html</a>
          <ul>
            <li>
               <a href="ExceptionHandling.html">ExceptionHandling</a>
            </li>
          </ul>
        </li>
        <li>
           In Java, most application exceptions are <a href="CheckedException.html">CheckedException</a>s; however, <a href="RuntimeException.html">RuntimeException</a>s and Errors are <a href="UncheckedException.html">UncheckedException</a>s.
        </li>
        <li>
           C# uses <a href="UncheckedException.html">UncheckedException</a>s.
        </li>
        <li>
           <a href="ExceptionHandling.html">ExceptionHandling</a> is a little looser in C# than in Java, without the need to declare thrown exceptions or catch those declarations. There is a still an exception-based error handling system; it's just more implicit than explicit. -- <a href="BrettMcNamara.html">BrettMcNamara</a>
          <ul>
            <li>
               Properties
            </li>
          </ul>
        </li>
        <li>
           In Java, getName and setName are methods for manipulating properties, per <a href="JavaBeans.html">JavaBeans</a>.
        </li>
        <li>
           In C# the property Name wraps get and set methods and is explicitly defined as a property.
        </li>
        <li>
           (Contributors: <a href="BrettMcNamara.html">BrettMcNamara</a>)
        </li>
        <li>
           Properties can be little misleading, though, as they can be mixed with data members within methods of same class. (For other classes, this is not a problem because there should be no public data members.) One can easily create a property that performs a HTTP request to return value, somehow forget that it's not a data member, and then wonder why performance is so bad. To some extent, this can be fixed by profiling, but anyway that's unpleasant. (See also <a href="SyntacticallyEquivalentMembersAndProperties.html">SyntacticallyEquivalentMembersAndProperties</a>)
          <ul>
            <li>
               Both languages support <a href="BoxingConversions.html">BoxingConversions</a>.
            </li>
          </ul>
        </li>
        <li>
           C# autoboxes values to heap-allocated values <em>of the same type</em>.
        </li>
        <li>
           Java autoboxes values to heap-allocated objects <em>of a different type</em>.  This complicates reflective code.
          <ul>
            <li>
               Closures
            </li>
          </ul>
        </li>
        <li>
           Java has <a href="AnonymousInnerClass.html">AnonymousInnerClass</a>es.
        </li>
        <li>
           C# has <a href="AnonymousMethod.html">AnonymousMethod</a>s.
          <ul>
            <li>
               <a href="InnerClass.html">InnerClass</a>es
            </li>
          </ul>
        </li>
        <li>
           Java has both static and instance <a href="InnerClass.html">InnerClass</a>es.
        </li>
        <li>
           C# only has static <a href="InnerClass.html">InnerClass</a>es.
          <ul>
            <li>
               <a href="EnumeratedTypes.html">EnumeratedTypes</a>
            </li>
          </ul>
        </li>
        <li>
           C# has enumerated types similar to those in <a href="CeePlusPlus.html">CeePlusPlus</a>. Each enumerated value resolves to an integer constant.
        </li>
        <li>
           Java's enumerated types are actually immutable classes. Each enumerated value is an immutable object, complete with polymorphic methods.
          <ul>
            <li>
               Events
            </li>
          </ul>
        </li>
        <li>
           C# has language support for publish/subscribe style events
        </li>
        <li>
           Java uses coding conventions to implement publish/subscribe events with listener interfaces and methods to add and remove listeners.
          <ul>
            <li>
               Generics
            </li>
          </ul>
        </li>
        <li>
           C# has real generic types: generic types exist at compile time and at runtime.
        </li>
        <li>
           Java generic types are compiled away:  only non-generic types exist at runtime.
        </li>
      </ul>
      <hr/>
      <p>
        <strong>Summary:</strong>
      </p>
      <ul>
        <li>
           slightly more <a href="ObjectOriented.html">ObjectOriented</a> than <a href="JavaLanguage.html">JavaLanguage</a>
          <ul>
            <li>
               <em>in what way? just </em><a href="BoxingConversions.html">BoxingConversions</a>? or am I missing something?<em>  </em><a href="EverythingIsa.html">EverythingIsa</a> object.
              <ul>
                <li>
                   <em>sorry to repeat myself. in what way? primitives are still primitives, unless they're boxed. This is true in Java, also.</em> No, they aren't primitives; they inherit from object. They are <em>implemented</em> using primitives, and they are <em>optimized</em> using a mechanism called <a href="BoxingConversions.html">BoxingConversions</a> Using your reasoning, everything is just ones and zeroes, which isn't a really useful model of things. You could even go as far as saying everything is just "energy," and refuse to accept further abstraction. However, programming is all about abstraction.
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
           Slightly less <a href="ObjectOriented.html">ObjectOriented</a> than <a href="JavaLanguage.html">JavaLanguage</a>. Doesn't support true <a href="InnerClass.html">InnerClass</a>es, therefore it doesn't support closures at all. Also structs are not objects; you cannot force clients to call a proper constructor on structs (although structs allow constructors), and you cannot test for null. Such a bad design decision is especially significant in System.DateTime struct which cannot be nullified. Mapping a datetime field from a database to a datetime member in <a href="CeeSharp.html">CeeSharp</a> is therefore impossible whereas in <a href="JavaLanguage.html">JavaLanguage</a>, Date objects can simply be null. 
          <ul>
            <li>
               <em>Both of these issues are addressed in v2 of the language</em> - <a href="AnonymousMethod.html">AnonymousMethod</a>s provide fully-fledged closures (with full access to the closure's outer variables - no stupid <em>final</em> restrictions like in Java), and the non-nullability of value types is address with <a href="NullableTypes.html">NullableTypes</a>, which allow you to mark any instance of a value type as being nullable, without boxing it, and hence giving up the performance advantages of a lightweight, stack-based object (this is mostly just a thin veneer of <a href="SyntacticSugar.html">SyntacticSugar</a> over the System.Nullable<T> struct, with some compiler magic to 'lift' operators from the underlying type, and various other things [now, if only they'd do something similar to provide <em>non</em>-nullable objects, so you can deal with things without having to sprinkle null checks all over the place...])
              <ul>
                <li>
                   Mike are you able to help out with question in <a href="MicrosoftExpress.html">MicrosoftExpress</a>? Sorry for interjection -- dl <a href="DeleteWhenCooked.html">DeleteWhenCooked</a>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
           may be easier for <a href="MicrosoftWindows.html">MicrosoftWindows</a> application development
        </li>
      </ul>
      <hr/>
      <p>
        For the record, the snide remarks above are by me. Don't mean to be too rude, I just really have a hard time seeing the alleged improvements from <a href="JavaLanguage.html">JavaLanguage</a> to <a href="CeeSharp.html">CeeSharp</a>. To me, as a Java programmer, C# has exactly two things that I envy: close integration with the <a href="MicrosoftWindowsApi.html">MicrosoftWindowsApi</a>, and structs that can be allocated on the stack. So much of what I see is 'save four keystrokes' (isn't that what editor macros are for?). And so many of the alleged improvements to the <a href="VirtualMachine.html">VirtualMachine</a>, pardon me, <a href="CommonLanguageRuntime.html">CommonLanguageRuntime</a>, seem like old hat. Multiple languages in one program? Woohoo! I'm not going to take the stance that this is a management nightmare; if properly managed, it's wonderful. But I've had reasonably large Java runtime programs written in a combination of <a href="SchemeLanguage.html">SchemeLanguage</a>, <a href="JavaLanguage.html">JavaLanguage</a>, and <a href="PythonLanguage.html">PythonLanguage</a>, and never had any problems... and never really longed for any other languages, except <a href="PerlLanguage.html">PerlLanguage</a>. I want to be converted, if for no other reason than I want something new to play with... but I just can't get <a href="CeeSharp.html">CeeSharp</a> or <a href="DotNet.html">DotNet</a> to excite me. -- <a href="AdamBerger.html">AdamBerger</a>
      </p>
      <ul>
        <li>
          I think the fact that Microsoft makes an active effort to make the CLR a good target for multiple and diverse languages is a very significant advantage. Sure, you can compile <a href="SchemeLanguage.html">SchemeLanguage</a> to JVM bytecode, too, but whereas the JVM has some things set in stone that make this necessarily cumbersome or inefficient, Microsoft has (or so I've been told) actually changed their VM in response to issues raised by people who wanted to target the CLR with Scheme. This means that <a href="DotNet.html">DotNet</a> is a universal platform, whereas <a href="JavaPlatform.html">JavaPlatform</a> is just a platform for <a href="JavaLanguage.html">JavaLanguage</a>, which, it has to be said, has many weaknesses.
        </li>
      </ul>
      <p>
        <em></em><a href="CeeSharp.html">CeeSharp</a> has more features than <a href="JavaLanguage.html">JavaLanguage</a>, and is therefore more complex. You'll not see these features from a high level. What about CLR (<a href="CommonLanguageRuntime.html">CommonLanguageRuntime</a>) attributes for instance? Do you really understand what they are about?<em></em>
      </p>
      <p>
        Nope, I'm not sure I fully do. Can you elaborate more? My (limited) understanding is that the CLR's 'big feature' is that it allows interaction of multiple languages (hence the CL), allowing things like classes in one language extending and using those in another. This isn't a property unique to the <a href="CommonLanguageRuntime.html">CommonLanguageRuntime</a>, though. You see it anywhere a single bytecode is expressing more than one language... my example above was the <a href="JavaVirtualMachine.html">JavaVirtualMachine</a>. Are there other things I'm missing?
      </p>
      <p>
        <em>Sometimes 'save four keystrokes' is very important, not because it makes code easier to write, but because it makes code easier to read.  In </em><a href="JavaLanguage.html">JavaLanguage</a>, pulling an Integer out of a List ends up looking way too complicated when you read the code that does it.  <a href="BoxingConversions.html">BoxingConversions</a> would help a lot with this.<em>  -- </em><a href="ChristianTaubman.html">ChristianTaubman</a>
      </p>
      <p>
        <a href="SyntacticSugar.html">SyntacticSugar</a> is one of the things that make the two languages interesting.  I'm more comfortable with <a href="JavaLanguage.html">JavaLanguage</a>, but I like how <a href="CeeSharp.html">CeeSharp</a> is more "Principles Atheist."  Java polices you a little by not providing functionality that could be considered bad coding practice to use.  C# gives you the right to do those things (<a href="GoTo.html">GoTo</a>, <a href="OperatorOverloading.html">OperatorOverloading</a>), encouraging you not to shoot yourself in the foot, but letting you govern yourself, so to speak, as far as what is "good" programming and what is "messy" programming.
      </p>
      <hr/>
      <p>
        Well, you get Perl <a href="RegularExpression.html">RegularExpression</a>s.
      </p>
      <p>
        <em>Indeed. In </em><a href="JavaLanguage.html">JavaLanguage</a>, you need a separate package for this (the best I know of is Jakarta ORO). I also envy <a href="CeeSharp.html">CeeSharp</a> developers the built-in API for bytecode modification, whose closest approximation in Java is IBM AlphaWorks' <a href="JikesCompiler.html">JikesCompiler</a> Bytecode Toolkit.<em></em>
      </p>
      <p>
        <strong>Perl </strong><a href="RegularExpression.html">RegularExpression</a>s are in JDK 1.4 in java.util.regexp<strong></strong>
      </p>
      <hr/>
      <p>
        And does anyone but me want to call it C Hash?  
      </p>
      <p>
        <em>I prefer to call if D-flat.</em>
      </p>
      <p>
        Here's another vote for C Hash.
      </p>
      <p>
        "C-pound."
      </p>
      <p>
        I think they should spell it with a Unicode sharp sign -- as opposed to a plain hash -- if they insist on calling it that.
      </p>
      <p>
        "C Octothorpe"
      </p>
      <p>
        Is the sharp(#) overlapped plus-plus(++)?
      </p>
      <p>
        <em></em><a href="InTheory.html">InTheory</a>.<em></em>
      </p>
      <hr/>
      <p>
        I think this whole page misses the point. <a href="MicroSoft.html">MicroSoft</a> isn't pushing <a href="DotNet.html">DotNet</a> as a better way because <a href="CsharpLanguage.html">CsharpLanguage</a> is significantly better than <a href="JavaLanguage.html">JavaLanguage</a>. It's because they claim the .Net environment (<a href="CeeSharp.html">CeeSharp</a> and the other languages, <a href="VirtualMachine.html">VirtualMachine</a>, runtime libraries, etc.) is better than the Java environment. <a href="CsharpLanguage.html">CsharpLanguage</a> is not obviously much worse than <a href="JavaLanguage.html">JavaLanguage</a>. That's all MS needs from it.
      </p>
      <p>
        <em>To some extent, I think this may be the most insightful comment on the page. On the other hand, the page </em>is<em> </em><a href="CsharpVsJava.html">CsharpVsJava</a>, so we have to find some way to compare them. As to 'not being worse' being good enough... well, from a marketing point of view, I'll accept that. But from a developer's point of view, it's kind of a disturbing attitude.
      </p>
      <ul>
        <li>
          Note, however, that this is not necessarily the attitude that Microsoft has, and that <a href="CeeSharpLanguage.html">CeeSharpLanguage</a> is not necessarily just "not obviously worse". I, for one, think that <a href="CeeSharpLanguage.html">CeeSharpLanguage</a> is the better language.
        </li>
      </ul>
      <p>
        And, moreover, I'm not at all convinced <a href="DotNet.html">DotNet</a>'s environment is that revolutionary. (Is there already a page like DotNetVsJava, or shall we move some of this over there? [Well, we do have <a href="DotNetWillKillJava.html">DotNetWillKillJava</a>, <a href="EjbVsDotNetNews.html">EjbVsDotNetNews</a>, <a href="JavaAndDotNetPhilosophies.html">JavaAndDotNetPhilosophies</a>.]) It seems like much of .Net's astounding new capabilities are things I've been doing, on a daily basis, in Java. And the Java APIs, while a few things are missing from the core (like <a href="RegularExpression.html">RegularExpression</a>s, mentioned above <em>[</em><a href="RegExp.html">RegExp</a>s are in fact in the core, as mentioned above]<em>), do have the advantage of a lot more maturity... and today, if not tomorrow, much more third-party support.</em>
      </p>
      <ul>
        <li>
          Nothing about <a href="DotNet.html">DotNet</a> is all that revolutionary. Most of what is good about it has existed for several decades. The news is not that it's revolutionary, but that it isn't; these good things are finally being accepted by the masses.
        </li>
      </ul>
      <p>
        I agree most of what can be done in <a href="DotNet.html">DotNet</a> can be done in Java. But not out of the box; there's a certain amount of installation and systems integration needed to get things working in Java (that's the downside of the "much more third-party support"). <a href="MicroSoft.html">MicroSoft</a> has also taken the opportunity to do a lot with areas of .Net that aren't anything much to do with language or standard libraries: a very neat cache (heavily used in <a href="AspDotNet.html">AspDotNet</a>), assemblies (so easing version problems), etc, etc. Nothing innovative in the individual items, but the whole is, IMO, and the evolution is controlled by one company, making uniformity much easier to achieve (which is good and bad, of course). For instance, you're pretty much required to use <a href="VisualStudioDotNet.html">VisualStudioDotNet</a>. Good: all add-on developers have one platform to aim at. Bad: other <a href="IntegratedDevelopmentEnvironment.html">IntegratedDevelopmentEnvironment</a> vendors have huge barriers to entry. <em>You are not required to use </em><a href="VisualStudio.html">VisualStudio</a> (not even close)!.<em></em>
      </p>
      <p>
        pretty much required to use <a href="VisualStudioDotNet.html">VisualStudioDotNet</a>. <em>You are? In what way?</em>
      </p>
      <p>
        Actually, the luscious support for <a href="CeeSharp.html">CeeSharp</a> provided by <a href="VisualStudioDotNet.html">VisualStudioDotNet</a> is a distinguishing virtue all on its own.
      </p>
      <p>
        I might have been wrong. It seems it's not strictly true (it seems that the SDK is enough to support a compiler, etc.), but there're a lot of integration and <a href="DotNet.html">DotNet</a>-specific tools in <a href="VisualStudioDotNet.html">VisualStudioDotNet</a> which would be difficult to compete with, so I think the barriers-to-entry-point still stands.
      </p>
      <p>
        There's an <a href="OpenSource.html">OpenSource</a> <a href="IntegratedDevelopmentEnvironment.html">IntegratedDevelopmentEnvironment</a> for <a href="CeeSharp.html">CeeSharp</a> which is completely written in C#: <a href="http://www.icsharpcode.net/OpenSource/SD/Default.aspx">http://www.icsharpcode.net/OpenSource/SD/Default.aspx</a>
      </p>
      <p>
        <em>Well, I'm not a fan of IDEs so there may be some bias, but I certainly don't feel that I'm missing out by not using </em><a href="VisualStudioDotNet.html">VisualStudioDotNet</a>.  I also can't think of anything in VS.Net that other vendors wouldn't be able to compete with.  Anyway, this is about <a href="CeeSharp.html">CeeSharp</a>/<a href="JavaLanguage.html">JavaLanguage</a>, not VS.Net/Java.  For what it's worth, I think the language debate is largely pointless, painfully emotive, and almost always carried forth by programmers who have very little experience of the other language.<em>  </em>
      </p>
      <p>
        <em>"You don't need [VAR parameters] in an object-oriented program." If I have to interpret this then I had to paraphrase it with "VAR parameters aren't required to write object-oriented programs." I find this a very unenlightened view - higher level languages aren't necessary to write programs; we could still manipulate bits and bytes directly. Why the change then? Because higher level languages make things easier for programmers. And if VAR parameters make things easier in C#, then why don't use them in such cases?</em>
      </p>
      <hr/>
      <p>
        <a href="PageAnchor.html">PageAnchor</a>: generalization
      </p>
      <p>
        Well, as a <a href="JavaLanguage.html">JavaLanguage</a> programmer I've been forced to work with <a href="AspDotNet.html">AspDotNet</a> / <a href="CeeSharp.html">CeeSharp</a>. I liked it. As Java is built on the memory of <a href="CeePlusPlus.html">CeePlusPlus</a> errors, so C# used the experience with Java for improvements. Indeed, not all are good (about 68% are good). ASP.NET has a very similar <a href="ObjectModel.html">ObjectModel</a> for building a <a href="DeskTop.html">DeskTop</a> application. I find it very helpful.
      </p>
      <p>
        We should also remember that it is not <a href="CsharpLanguage.html">CsharpLanguage</a> vs. <a href="JavaLanguage.html">JavaLanguage</a>, but <a href="DotNet.html">DotNet</a> vs. <a href="IbmCorporation.html">IbmCorporation</a> vs. Oracle vs. Bea and friends.
      </p>
      <p>
        One BIG problem with <a href="JavaLanguage.html">JavaLanguage</a>/<a href="JavaTwoEnterpriseEdition.html">JavaTwoEnterpriseEdition</a> is over-generalization. Generalization is basically good when it is essential and minimal. Remember that OO code reuse has not reached the highest expectations. (failed for business logic, if you ask me). Too many choices killed <a href="CeePlusPlus.html">CeePlusPlus</a>. <em>(The reports of C++'s death are greatly exaggerated.)</em> Let's not make the same mistake with Java. Why does Java need two user interfaces frameworks?  I don't like all this Java-naming scheme. Make java.swt (my hope) -> java.ui, make javax.jms -> java.messaging. I prefer uniting all JAXP JAXB JAXS JAXX into java.xml and make one SIMPLE standard. See how well it is done in <a href="DotNet.html">DotNet</a>.
      </p>
      <p>
        <em>I prefer the Unix model of having a ton of small programs (analogy to the small APIs you mention) that do exactly what they're supposed to do very well, and nothing more.  You take those small pieces of functionality and combine them and you get something extremely powerful.  Yes if you want to do a specific task, you need to comprehend the technology you need to use.  Throwing separate APIs under a common namespace only hinders this.</em>
      </p>
      <hr/>
      <p>
        <a href="CsharpLanguage.html">CsharpLanguage</a> is better at managing memory.  We're developing statistical applications for analysis of MicroArray and MassSpec data (that's genes and proteins).  When a single dataset has 1000 columns and 50000 rows (all doubles), memory means a lot.  Then, you generate even more data as part of the analysis.  We compared <a href="JavaLanguage.html">JavaLanguage</a> to <a href="CsharpLanguage.html">CsharpLanguage</a> and found that Csharp used less memory.
      </p>
      <ul>
        <li>
          I think these are implementation features rather than language features.
        </li>
      </ul>
      <ul>
        <li>
           Implementation features is very important when the language is made and controlled from the very same company who implemented it. If Sun java implementation sucks that's telling something.
        </li>
      </ul>
      <ul>
        <li>
           What is it telling?  How is using less memory "better at managing memory".  What if the garbage collector was much faster but used more memory?  Is there only one implementation of the Java VM?  How much less memory did Csharp use than Java when storing a giant array of doubles?  Why is the quality of the entries on this page of such low quality?
        </li>
      </ul>
      <hr/>
      <p>
        <em>Discussion moved to </em><a href="CsharpLanguage.html">CsharpLanguage</a>.<em></em>
      </p>
      <hr/>
      <p>
        See <a href="CsharpLanguage.html">CsharpLanguage</a>, <a href="CsharpFeatures.html">CsharpFeatures</a>, <a href="CsharpLanguageDiscussion.html">CsharpLanguageDiscussion</a>, <a href="HolyWar.html">HolyWar</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryJava.html">CategoryJava</a> <a href="CategoryCeeSharp.html">CategoryCeeSharp</a> <a href="CategoryComparisons.html">CategoryComparisons</a> <a href="CategoryProgrammingLanguageComparisons.html">CategoryProgrammingLanguageComparisons</a>
      </p>
    </div>
  </body>
</html>