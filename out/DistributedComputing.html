<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Distributed Computing
      </h1>
      <p>
        <a href="DistributedComputing.html">DistributedComputing</a> is another one of those vague topics that encompasses just about everything... <a href="ClientServer.html">ClientServer</a>, TheInternet, RMI and CORBA... basically anything where you have a computer interacting with one or more computers.
      </p>
      <p>
        <em>If I had to write a definition of </em><a href="DistributedComputing.html">DistributedComputing</a>, I'd say something like "A distributed system where the bulk of computation is done by the machines at the edges of the network." Such a definition would include canonical examples such as distributed.net and SETI@Home (<a href="SetiAtHome.html">SetiAtHome</a>), but would exclude things such as email and Usenet.<em></em>
      </p>
      <p>
        It is such a hard topic, we should better collect <a href="ReasonsForDistributedComputing.html">ReasonsForDistributedComputing</a> , the forces that drive people into using <a href="DistributedComputing.html">DistributedComputing</a> besides the marketing hype that tells them so. (<em>-- </em><a href="PeterSommerlad.html">PeterSommerlad</a><em>)</em>
      </p>
      <p>
        <a href="HalHildebrand.html">HalHildebrand</a> once defined a destributed computer network as one in which a bug on one machine will cause another totally unrelated machine to crash mysteriously some hours later (this is called a <a href="HeisenBug.html">HeisenBug</a>).
      </p>
      <hr/>
      <p>
        <a href="DistributedComputing.html">DistributedComputing</a> doesn't seem all that vague a notion anymore.  <a href="SetiAtHome.html">SetiAtHome</a> now has over 3 million people registered (whether that represents more or less than 3 million machines is a question, but they get the use of six that I have under my control, so I'd bet more).  <a href="SetiAtHome.html">SetiAtHome</a> has established what has become the paradigm model, and most of the companies operating in this space (see <a href="SetiAtHome.html">SetiAtHome</a> for a list) are using elaborations of their architecture, which might be thought of as a Client Browser Agent model.  In theory this could be done with Java Applets running directly from within Web browsers.  In practice, a custom agent application is delivered that talks to the net in much the same way a browser would, but which can be automagically run at boot time as a background application/screen saver.
      </p>
      <p>
        A central server (in effect, a Web transaction server) breaks a problem into many small pieces.  Client-side agents using the client's spare MIPS request work from and deliver results back to the server, which stores the results for later analysis and saves user stats.  It's a nice simple model which can be readily scaled using traditional Web server cluster scaling solutions.  So far scaling hasn't been an issue.  <a href="SetiAtHome.html">SetiAtHome</a> recently passed the zettaflop (10^21) mark in terms of its parallel computing capacity, and it still runs the whole thing from a single central server (there is some additional capacity behind that for running the database, doing meta-analysis, etc, but the single server mediates all client agent requests).  Very impressive.
      </p>
      <p>
        The primary elaborations associated with commercial versions are (1) a multi-application model that allows multiple distributed applications to be managed within the same distributed network, (2) an API that allows commercial applications to be packaged for distribution within secure envelopes that both protect the client machine and provide standard services, and (3) an abstraction of the control server which distributes the applications and keeps user statistics from the data server(s).  Control servers actually handle the distributed network and the distribution of applications to clients.  The client applications talk to the data servers to get and post data.
      </p>
      <p>
        This has become a big business, and the more successful companies in this space are turning the internal networks of large companies into distributed computing networks.  Public efforts continue as well.  
      </p>
      <p>
        Two of the more interesting ones I've found include 
      </p>
      <ul>
        <li>
           Globus Project 
          <ul>
            <li>
               <a href="http://www.globus.ae">http://www.globus.ae</a> 
            </li>
          </ul>
        </li>
        <li>
           Parallel Virtual Machine (PVM)
          <ul>
            <li>
               <a href="http://www.epm.ornl.gov/pvm">http://www.epm.ornl.gov/pvm</a>
            </li>
          </ul>
        </li>
      </ul>
      <p>
        -- <a href="DavisFoulger.html">DavisFoulger</a>
      </p>
      <p>
        <em>I don't think the </em><a href="SetiAtHome.html">SetiAtHome</a> example is applicable to most large businesses. Its data has a high <strong>chomp ratio</strong>. This is the ratio of computation to data. Most business systems have a relatively low chomp ratio. Transactions under a low chomp ratio often require that many other nodes be contacted to provide the answer or finish the task. This tends to defeat the purpose of distribution. -- top<em></em>
      </p>
      <p>
        <a href="WebStoresDiscussion.html">WebStoresDiscussion</a> perhaps makes a good case for it.
      </p>
      <hr/>
      <p>
        If we have good HTTP browser GUI protocols (not quite yet, so lets assume HTML+DOM+JS), then we don't need a lot of distributed systems. If it does not matter where on the Internet/intranet your servers are, then why not have one big server, or at least one big server room?
      </p>
      <p>
        Distributed apps are tricky to partition. If you partition by say sales area, you still cannot physically partition by product line (since products are available to every sales office). Physical divisions and logical data divisions can only correlate on one variable (or entity splitting) for the most part, but usually there are multiple candidate variables, and these are not likely to split geographically.
      </p>
      <p>
        Perhaps these central servers may be clustered or something, but I see no reason to spread them all over the map (except for maybe backups and the emergancy mirror centers).
      </p>
      <p>
        I don't get this "distributed" movement. I suspect it is hype from SUN trying to sell more Java boxes.
      </p>
      <hr/>
      <p>
        Warning - <a href="http://www.distributed.net/">http://www.distributed.net/</a> has posted information to the effect that an <strong>Unauthorized Worm</strong> has been spreading around the net using copies of their 'dnetc client'.  They refer the reader to their 'Trojan page' at <a href="http://distributed.net/trojans.html.en">http://distributed.net/trojans.html.en</a>   The implication here is that there are authorized worms??? -- <a href="RobChamberlin.html">RobChamberlin</a> 
      </p>
      <hr/>
      <p>
        <em>Moved from </em><a href="DotNetAsDistributedObjectSystem.html">DotNetAsDistributedObjectSystem</a>:<em></em>
      </p>
      <p>
        <strong>re: Is easy </strong><a href="DistributedComputing.html">DistributedComputing</a> possible?<strong></strong>
      </p>
      <p>
        Distributed computing is difficult because it forces the system to interact with the <a href="RealWorld.html">RealWorld</a> frequently--at each component boundary. Whenever a system has to deal with the <a href="RealWorld.html">RealWorld</a>, it has to dump the Principle of Assumed Correctness and begin to handle multitude of errors. A distributed system can make this easier by limiting the number of possible errors a programmer <em>must</em> deal with, whilst simultaneously describing each possible error to great detail (to do intelligent error recovery if necessary, and to facilitate debugging). For instance, it may be well and good to trap five different network errors, but sometimes it's better just to have an abstraction: Succeed or Fail.
      </p>
      <p>
        <em>The more I read about the various specifications for "web services", i.e. UDDI, SOAP, and WSDL, the more I see that "Web services" transcends .NET.  It really is another run at the ubiquitous-distributed-computing fence.  Perhaps the tools available this time will help us deal with the </em><a href="RealWorld.html">RealWorld</a> better than former systems (CORBA, COM, RMI, etc.)  -- <a href="StuCharlton.html">StuCharlton</a><em></em>
      </p>
      <hr/>
      <p>
        <strong>re: Is easy </strong><a href="DistributedComputing.html">DistributedComputing</a> possible?<strong></strong>
      </p>
      <p>
        Yes.  I'm working on some tools to help make it easier.  I would think with ubiquitous computing that whoever ends up winning in the long run must take it easy and add an abstraction layer that is lightweight, cross-platform, and thin.  They must solve the simple problem first rather than solving the whole world's problems first.  My toolkit lets you run a node that has three simple components that provide the simplest possible implementation to help you arrive at a true two-way network.  I'm starting there, then seeing where it takes me.
      </p>
      <p>
        <a href="TimBernersLee.html">TimBernersLee</a> had a brilliant epiphany when he realized that <em>broken links are OK</em>.  In any complex adaptive system, successful systems are always somewhere around the edge of chaos, and brokenness is a part of the game.  Take a look at New York City.  If these distributed computing guys who are making life hard tried to build New York City, I'm sure they would have failed or never finished, because it would need to be exact and intellectually pure (the MIT approach).  Water always flows, electricity only went out once, and FDNY really has their sh*t together; yet, people still get hit by cars, shoot heroine in Hell's Kitchen, construction never ends, and potholes magically appear often.
      </p>
      <p>
        -- <a href="PhilipEskelin.html">PhilipEskelin</a>
      </p>
      <p>
        <em>And yet, I and many others consider NYC unlivable.  Maybe we're just perfectionists. :-) -- </em><a href="MattBehrens.html">MattBehrens</a><em></em>
      </p>
      <p>
        I would think this factor is actually a parameter of its success.  I know from personal experience in living there over five years that much of what makes it move comes and goes through bridges & tunnels every day.  Try observing what goes on at Grand Central Station, Penn Station, or WTC any day during the week at 830am, then at 530pm. -- <a href="PhilipEskelin.html">PhilipEskelin</a>
      </p>
      <hr/>
      <p>
        <em></em><a href="TimBernersLee.html">TimBernersLee</a> had a brilliant epiphany when he realized that <strong>broken links are OK.</strong><em></em>
      </p>
      <ul>
        <li>
           Do what? They are <em>not</em>, and I doubt that TimBL ever did think such a thing, given that he wrote 
          <ul>
            <li>
               Cool URI's don't Change
              <ul>
                <li>
                   <a href="http://www.w3.org/Provider/Style/URI.html">http://www.w3.org/Provider/Style/URI.html</a> .
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
           The difference was that he didn't require the system as a whole to maintain the correctness of links, which limited the scalability of earlier similar system.
        </li>
      </ul>
      <p>
        <em>This may be an "organic versus predictable" argument. It probably depends on the nature of the application. We probably do no want "organic accounting systems". However, for search agents it may be okay. If numerical accuracy, traceability, and auditing is not really an issue, then organic approaches may be easier to set up and manage. Related: </em><a href="LimpVersusDie.html">LimpVersusDie</a>. I'll propose that <a href="DistributedComputing.html">DistributedComputing</a> is the better solution if most of these are true:<em></em>
      </p>
      <ul>
        <li>
           Approaching perfection is not necessary and some degree of "bad links" or missing sub-systems at any given time are acceptable.
        </li>
        <li>
           High volume of computation or storage
        </li>
        <li>
           Communication bottlenecks make remote connections impractical or expensive
        </li>
        <li>
           Distribution improves resiliency during catastrophe or attacks
        </li>
        <li>
           Unified political/managerial control over the entire system is not a necessity or even detrimental (such as slow response to resource requests).
        </li>
      </ul>
      <hr/>
      <p>
        What seems to be missing in a lot of talk about shared components is how you ensure security.  Distributed objects are about opening up systems and sharing components to make up applications.  Security policies demand the opposite, ie. locking down systems, physically separating components and not providing automatic trust between applications.  These goals are in conflict so how does a system of shared and distributed components deal with this?  -- <a href="AndrewJoyner.html">AndrewJoyner</a>
      </p>
      <p>
        <em>Even </em><a href="SetiAtHome.html">SetiAtHome</a> had to deal with such issues. They implemented special techniques to reduce the chance of fraud. It adds complexy and processing overhead that a centralized system may not need.<em></em>
      </p>
      <hr/>
      <p>
        <a href="WorseIsBetter.html">WorseIsBetter</a>. The difference is SOAP etc are protocol based, not API based. I can use any tool set, any language, as long as i follow the protocol. This allows a separate evolution of parts of the system. With RPC, CORBA, DNS, EJB, etc you really need to use the official APIs or complicated products from major players. The difference between defining a protocol using understandable  and reproducable mechanisms vs APIs based on complicated mechanisms is major.
      </p>
      <p>
        How many perl bindings for CORBA? When did they come out? Yet any idiot can make an http library and the stuff that goes over it. It lacks advanced features but it is at least doable. HTML succeeded because anyone can do it. HTTP succeeded because anyone can make it work. The roots of XML are simple, although people seem to be doing their best and complicting it into irrelevance. The organism that succeeds fits its niche, it doesn't have to optimize over all niches. <em>Related: </em><a href="KissWebServices.html">KissWebServices</a><em></em>
      </p>
      <hr/>
      <p>
        DistributedComputingIsUbiquitous - these days, at least. I have network drives attached to my PC at work. To make stuff happen, two separate machines are involved. That's distributed computing. At home, I run programs to snarf the contents of the Canberra Times classifieds from their web page. That's distributed computing. Multiplayer games. Coke machines. POS systems and ATM machines. Ouside of pure numerical computing, I can't think of any application these days that doesn't involve distributed computing. If we include exchanging data between machines on physical media as a form of transport, I can't think of any serious application (outside of pure numerical computing) that didn't. -- <a href="PaulMurray.html">PaulMurray</a>
      </p>
      <hr/>
      <p>
        <a href="DistributedComputing.html">DistributedComputing</a> Tools:
      </p>
      <ul>
        <li>
           <a href="ZooKeeper.html">ZooKeeper</a>
        </li>
      </ul>
      <p>
        Related concepts:
      </p>
      <ul>
        <li>
           <a href="ApplicationLayerFraming.html">ApplicationLayerFraming</a> and <a href="IntegratedLayerProcessing.html">IntegratedLayerProcessing</a>
        </li>
        <li>
           <a href="CloudComputing.html">CloudComputing</a>
        </li>
        <li>
           <a href="ComponentDesignPatterns.html">ComponentDesignPatterns</a> (<a href="FacadesAsDistributedComponents.html">FacadesAsDistributedComponents</a>,  <a href="DistributionOfComponents.html">DistributionOfComponents</a>, <a href="ProcessBoundary.html">ProcessBoundary</a>)
        </li>
        <li>
           <a href="DistributedCoalition.html">DistributedCoalition</a>
        </li>
        <li>
           <a href="DistributedGames.html">DistributedGames</a>
        </li>
        <li>
           <a href="DistributionIdioms.html">DistributionIdioms</a>
        </li>
        <li>
           <a href="MessageQueuingArchitectures.html">MessageQueuingArchitectures</a>
        </li>
        <li>
           <a href="MiddleWare.html">MiddleWare</a>
        </li>
        <li>
           <a href="RmiPatterns.html">RmiPatterns</a>
        </li>
        <li>
           <a href="RmiVsCorba.html">RmiVsCorba</a>
        </li>
        <li>
           <a href="TupleSpace.html">TupleSpace</a>s: <a href="LindaTupleSpaces.html">LindaTupleSpaces</a>, <a href="JavaSpaces.html">JavaSpaces</a>Patterns
        </li>
        <li>
           <a href="XmlProtocol.html">XmlProtocol</a>
        </li>
      </ul>
      <p>
        Read the <a href="EightFallaciesOfDistributedComputing.html">EightFallaciesOfDistributedComputing</a> to see what assumptions to avoid (anti-forces).
      </p>
      <p>
        <strong>See also</strong> 
      </p>
      <ul>
        <li>
           <a href="UnderstandingDistributedSystems.html">UnderstandingDistributedSystems</a>
        </li>
        <li>
           <a href="HeisenBug.html">HeisenBug</a>
        </li>
        <li>
           <a href="BohrBug.html">BohrBug</a>
        </li>
        <li>
           <a href="InSearchOfClusters.html">InSearchOfClusters</a>
        </li>
        <li>
           <a href="DistributionIsOptimization.html">DistributionIsOptimization</a>
        </li>
      </ul>
      <hr/>
      <p>
        <a href="CategoryCollaboration.html">CategoryCollaboration</a>, <a href="CategoryDistributed.html">CategoryDistributed</a>
      </p>
    </div>
  </body>
</html>