<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Four Out Of Five Rule
      </h1>
      <p>
        In the paper <em>Fundamentals Of Object-Oriented Databases</em>, by Stanley B. Zdonik and David Meier, a conjecture called (by the authors) "The Three Out Of Four Rule" is put forth.  In it, it is claimed that a type system can have three out of the following four properties, but not all four:
      </p>
      <ul>
        <li>
           Mutability of variables
        </li>
        <li>
           <a href="SpecializationByConstraint.html">SpecializationByConstraint</a>
        </li>
        <li>
           <a href="StaticTyping.html">StaticTyping</a>
        </li>
        <li>
           Substitutabilty (what many OO authors mean by "polymorphism"; use of a derived-type object in a context where a base type is expected).
        </li>
      </ul>
      <p>
        In the paper <em></em>TowardsAnAgreeableModelOfTypeInheritance<em> by </em><a href="HughDarwen.html">HughDarwen</a> (available on <a href="http://www.thirdmanifesto.com,">http://www.thirdmanifesto.com,</a> and summarized in the book <a href="TheThirdManifesto.html">TheThirdManifesto</a>); Darwen shows that all four of the above properties can be had in a type system, provided that <a href="ObjectIdentity.html">ObjectIdentity</a> is abandoned; <a href="DateAndDarwensTypeSystem.html">DateAndDarwensTypeSystem</a> is based on this.  With this in mind, the rule is extended to the "Four Out Of Five Rule", which holds that a type system can have four out of the following five desirable properties, but not all five:
      </p>
      <ul>
        <li>
           Mutability of variables
        </li>
        <li>
           <a href="SpecializationByConstraint.html">SpecializationByConstraint</a>
        </li>
        <li>
           <a href="StaticTyping.html">StaticTyping</a>
        </li>
        <li>
           Substitutability
        </li>
        <li>
           <a href="ObjectIdentity.html">ObjectIdentity</a>
        </li>
      </ul>
      <hr/>
      <p>
        [moved from <a href="DateAndDarwensTypeSystem.html">DateAndDarwensTypeSystem</a>]
      </p>
      <p>
        D&D choose to abandon <a href="ObjectIdentity.html">ObjectIdentity</a> to get the remaining 4.  You might note that the major language families are largely defined by which of these 5 they give up.  Haskell and other functional languages drop Mutability and can keep the rest.  Most <a href="ScriptingLanguage.html">ScriptingLanguage</a>s drop <a href="StaticTyping.html">StaticTyping</a>.  Procedural languages drop Substitutability.  Most OO languages drop type constraints - actually, I think most languages drop type constraints, whether or not they support the others.  -- <a href="JonathanTang.html">JonathanTang</a>
      </p>
      <p>
        <em>I'm not at all convinced -- I think you can have all 5. For example Haskell </em>'does<strong> support Mutability, using monads. Actually pretty much any </strong><a href="StaticallyTyped.html">StaticallyTyped</a> <a href="MultiParadigmProgrammingLanguage.html">MultiParadigmProgrammingLanguage</a> should be able to manage all 5. Granted that there are only a few of those (<a href="AliceLanguage.html">AliceLanguage</a>, <a href="OhHaskell.html">OhHaskell</a>). Are D&D placing more constraints on Substitutability than usual? -- <a href="DavidSarahHopwood.html">DavidSarahHopwood</a><em></em>
      </p>
      <p>
        Does "mutability" in this context refer merely to MutableObjects--objects whose state can change?  Or does it refer to <a href="TypeMigration.html">TypeMigration</a> -- having the <em>type</em> of an object alterable at runtime?
      </p>
      <p>
        <em>I agree that </em><a href="TypeMigration.html">TypeMigration</a> is difficult to integrate with <a href="StaticTyping.html">StaticTyping</a>. It depends whether you're only doing <a href="TypeMigration.html">TypeMigration</a> during development or whether you want to be able to predict whether an update to a live system will be 100% typesafe; the latter is <strong>very</strong> complicated (but still possible -- I saw a paper on this recently, and will add a reference here when I find it again). IMHO a more productive approach is to integrate it with <a href="SoftTyping.html">SoftTyping</a>: typically there will be type errors that are technically possible just after the <a href="TypeMigration.html">TypeMigration</a> but can be seen not to actually occur, so a conventional static type system may be too strict.<em></em>
      </p>
      <p>
        Monads, LinearTypes, and other ways that that pure <a href="FunctionalProgrammingLanguage.html">FunctionalProgrammingLanguage</a>s implement <a href="SideEffect.html">SideEffect</a>s while piously pretending not to (much like the president of the local temperance union who comes home and sips bathtub gin--<a href="HaHaOnlySerious.html">HaHaOnlySerious</a>) suffice for the former; they don't necessarily suffice for the latter.
        <a href="TypeMigration.html">TypeMigration</a> (excluding MonotonicTypeMigration) is very difficult to reconcile with <a href="StaticTyping.html">StaticTyping</a>, as the former makes it very easy to invalidate the invariants assumed by the latter).
      </p>
      <p>
        <em>The point of pure functional programming is to preserve </em><a href="ReferentialTransparency.html">ReferentialTransparency</a>. <a href="TypeMigration.html">TypeMigration</a> is not incompatible with <a href="ReferentialTransparency.html">ReferentialTransparency</a>.<em></em>
      </p>
      <p>
        It refers to objects whose state can change.  I know that monads can simulate side-effects and state, but don't they give up <a href="ObjectIdentity.html">ObjectIdentity</a>?
      </p>
      <p>
        <em>No, see </em><a href="OhHaskell.html">OhHaskell</a>. Also see <a href="EqualRightsForFunctionalObjects.html">EqualRightsForFunctionalObjects</a>: by definition, any object that can change has identity (assuming a language that defines an equality operator on references), no matter how that is implemented or simulated.<em></em>
      </p>
      <p>
        I thought the point of the I/O monad, for example, is that "there is only one world", so all modifications to it explicitly affect that one world and don't have the aliasing problems D&D mention.  How would the circle/ellipse code from Appendix G of <a href="TheThirdManifesto.html">TheThirdManifesto</a> look in monadic Haskell?
      </p>
      <code>
        VAR E ELLIPSE;<br/>
        VAR C CIRCLE;<br/>
      </code>
      <code>
        C := CIRCLE(LENGTH(3.0));<br/>
        E := C;<br/>
        THE_MINOR_AXIS(E) := LENGTH(4.0));<br/>
      </code>
      <p>
        I know next to nothing about monads, so I'm not sure whether the same issues would arise.  -- <a href="JonathanTang.html">JonathanTang</a>
      </p>
      <p>
        <em>Exactly the same issues do arise, and so do exactly the same solutions as in non-(pure functional) languages.</em>
      </p>
      <hr/>
      <p>
        <a href="CategoryDatabase.html">CategoryDatabase</a>
      </p>
    </div>
  </body>
</html>