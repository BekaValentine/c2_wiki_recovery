<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Quality Attributes
      </h1>
      <p>
        Lots of questions??
      </p>
      <p>
        What does it mean if we say we want a system to be portable or secure?  Are things like performance really an entirely different sort of requirement to making the system provide specific business etc related functionality?  Doesn't the architecture of a chosen system make it either more or less likely they will meet these requirements?
      </p>
      <p>
        In the Bass, Clements and Cazman book Software Architecture In Practice, they define the concept of qualityAttributes.  These are cover all aspect of quality both functional and what often gets called non-functional (<a href="NonFunctionalIsNonsense.html">NonFunctionalIsNonsense</a>).
      </p>
      <p>
        The question for me at the moment is - can we make a mapping between <a href="QualityAttributes.html">QualityAttributes</a> and <a href="ArchitecturalPattern.html">ArchitecturalPattern</a>s or may be <a href="ArchitecturalStyle.html">ArchitecturalStyle</a>?  I want to be able to have something that captures the knowledge that there is a tradeoff between the various quality attributes and to have some receipies that tell me that if I want this mix of quality attributes, I could try this architectural pattern(s).
      </p>
      <p>
        So what does anybody think??
      </p>
      <hr/>
      <p>
        I take the tradeoff referred to above to be between "quality" and price. I believe that over the normal range of quality, there is not in fact a tradeoff. It does not really cost more to get acceptable performance, it does not really cost more to get acceptable reliability.  
      </p>
      <p>
        On the contrary, aggressive ongoing testing practices, built into the overall process, reduce cost by increasing development speed, while ensuring the level of quality you want.
      </p>
      <p>
        Performance, over the normally-required range, works the same way.  Selection of a reasonable architecture, followed by orderly implementation of the system and its tests, followed by measurement and optimization of the working system, will generally result in acceptable performance at a quite reasonable cost.  
      </p>
      <p>
        See <a href="UnitTest.html">UnitTest</a>, <a href="FunctionalTest.html">FunctionalTest</a>, <a href="WorstThingsFirst.html">WorstThingsFirst</a>, <a href="CostReliabilityTradeoff.html">CostReliabilityTradeoff</a>. --<a href="RonJeffries.html">RonJeffries</a>
      </p>
      <hr/>
      <p>
        Actually, what I was really talking about was the more general trade off between different <a href="QualityAttributes.html">QualityAttributes</a> (of which one might be "cost" (or something very like it) and another might be reliability (which is related to reducing the number of bugs).  
      </p>
      <p>
        The other sorts of trades of which are of interest are things like performance vs security, portability vs performance (you often add layers to give greater portability but this probably slows down the execution).
      </p>
      <p>
        Not all <a href="QualityAttributes.html">QualityAttributes</a> are likely to be influenced by <a href="ArchitecturalPattern.html">ArchitecturalPattern</a>s  but some are.
        -<a href="AndyMoorley.html">AndyMoorley</a>
      </p>
      <hr/>
      <p>
        The classic trade-off is time versus space. Eg you can often make something faster by adding a (memory hungry) cache. -- <a href="DaveHarris.html">DaveHarris</a>
      </p>
      <hr/>
      <p>
        Someone at the top asked for patterns which relate to architectural quality attributes. Come on down to <a href="MicroArchitecture.html">MicroArchitecture</a> and see if it looks right. --<a href="RichardHenderson.html">RichardHenderson</a>.
      </p>
      <hr/>
      <p>
        For more detailed information on <a href="QualityAttributes.html">QualityAttributes</a> and <a href="SoftwareArchitecture.html">SoftwareArchitecture</a> see <a href="AttributeBasedArchitecturalStyles.html">AttributeBasedArchitecturalStyles</a> and <a href="ArchitectureTradeoffAnalysisMethod.html">ArchitectureTradeoffAnalysisMethod</a>. -- <a href="RobertDiFalco.html">RobertDiFalco</a>
      </p>
      <hr/>
      <p>
        Functionality, extensibility and reliability are important attributes for architecture and design.
      </p>
      <p>
        All of these can be viewed as direct corresponding with *representation*, which should be sufficient, and *complexity*, which should be minimized. Extensibility can then be considered as identifying likely areas for future development. --<a href="ThomasWhitmore.html">ThomasWhitmore</a>
      </p>
      <p>
        <a href="http://www.sce-tech.com">http://www.sce-tech.com</a>
      </p>
      <hr/>
      <p>
        <a href="QualityAttributes.html">QualityAttributes</a> amusingly and concisely defined as established *fact* (qualified as "the definition that's stood the longest test of time ... pretty generally accepted ... for almost 30-something years"), from Robert L. Glass,  Facts and Fallacies ofSoftware Engineering (Addison-Wesley, 2002).  ISBN 0321117425
      </p>
      <p>
        "Fact 46: Quality is a collection of attributes.
      </p>
      <ol>
        <li>
            Portability is about creating a software product that is easily moved to another platform.
        </li>
      </ol>
      <ol>
        <li>
            Reliability is about a software product that does what its supposed to do, dependably.
        </li>
      </ol>
      <ol>
        <li>
            Efficiency is about a software product that economizes on both running time and space consumption.
        </li>
      </ol>
      <ol>
        <li>
                Human engineering (also known as usability) is about a software product that is easy and comfortable to use.
        </li>
      </ol>
      <ol>
        <li>
                Testability is about a software product that is easy to test.
        </li>
      </ol>
      <ol>
        <li>
                Understandability is about a software product that is easy for a maintainer to comprehend.
        </li>
      </ol>
      <ol>
        <li>
                Modifiability is about a software product that is easy for a maintainer to change." -- pp. 129-130
        </li>
      </ol>
      <p>
        Note that his notion of efficiency (attribute #3 above) conflates time and space, long recognized as a classic software tradeoff.
      </p>
      <p>
        Glass notes that these attributes are not listed in any particular order.  Relative priorities will differ by project and he considers it essential to prioritize all the above attributes for each project.  (He does not attempt any mapping of such <a href="QualityAttributes.html">QualityAttributes</a> priority rankings to any particular <a href="DesignPatterns.html">DesignPatterns</a>, <a href="ArchitecturalPattern.html">ArchitecturalPattern</a>s or <a href="AttributeBasedArchitecturalStyles.html">AttributeBasedArchitecturalStyles</a>.)
      </p>
      <p>
        Glass also defines <a href="QualityAttributes.html">QualityAttributes</a> negatively (and somewhat incoherently in light of the above):
      </p>
      <p>
        "Fact 47: Quality is not user satisfaction, meeting requirements, meeting cost and schedule targets, or reliability." -- p. 132 
      </p>
      <p>
        Taking his two facts together, it appears Quality resides in a software product, beyond all reach of such mundane concerns as whether or not it can be made at all.  Money and time and the relationship of software to human purposes can mean but little to the essence of software Quality.
      </p>
      <p>
        One is left to wonder how else but some metric for "user satisfaction" to decide between  "a software product that is easy and comfortable to use" and one not so usable or human engineered (quality attribute #4, asserted in Fact 46).  Further, "reliability" is the very name for Glass's second listed attribute of quality software, a plain contradiction.  Either he is equivocating from page to page or he is deeply confused about the relationship of attributes and definitions, if not software quality, an exercise I'll leave to the reader. Chapter 3, "About Quality", is freely browsable online. Begin at the beginning, with the author's revealing  reference to "that wonderful book", Zen and the Art of Motorcycle Maintenance: "the main character in the book, an academic looking into the real meaning of the word [Quality], went mad seeking a workable definition!" -- p. 127.   -- <a href="PaulWilson.html">PaulWilson</a>   
      </p>
      <hr/>
      <p>
        <a href="CategoryQuality.html">CategoryQuality</a>
      </p>
    </div>
  </body>
</html>