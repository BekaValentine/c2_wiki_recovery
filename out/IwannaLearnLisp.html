<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Iwanna Learn Lisp
      </h1>
      <p>
        The <a href="LispLanguage.html">LispLanguage</a> seems powerful and intriguing. How would the good <a href="WikiZen.html">WikiZen</a>s suggest one would go about starting with it? (Maybe this page should have been named IwannaBea<a href="SmugLispWeenie.html">SmugLispWeenie</a>.) 
      </p>
      <p>
        <em>To get an idea of how to read Lisp code in the below materials, see </em><a href="LispIndentation.html">LispIndentation</a>.<em></em>
      </p>
      <hr/>
      <p>
        <strong>Major Proprietary </strong><a href="CommonLisp.html">CommonLisp</a> implementations with free trials; work on Windows<strong></strong>
      </p>
      <ul>
        <li>
           <a href="AllegroCommonLisp.html">AllegroCommonLisp</a> (<a href="http://www.franz.com/)">http://www.franz.com/)</a> personal edition with IDE 
        </li>
        <li>
           <a href="LispWorks.html">LispWorks</a> (<a href="http://www.lispworks.com/)">http://www.lispworks.com/)</a> personal edition with IDE
        </li>
      </ul>
      <p>
        <strong>Major </strong><a href="OpenSource.html">OpenSource</a> <a href="CommonLisp.html">CommonLisp</a> implementations for Unix-- more at lisp.org<strong></strong>
      </p>
      <ul>
        <li>
           Lisp in a Box (<a href="http://common-lisp.net/project/lispbox/),">http://common-lisp.net/project/lispbox/),</a> also for Windows and Mac.
        </li>
        <li>
           GnuClisp (<a href="http://clisp.cons.org/)">http://clisp.cons.org/)</a> 
        </li>
        <li>
           CMUCL CarnegieMellonUniversityCommonLisp (<a href="http://www.cons.org/cmucl/)">http://www.cons.org/cmucl/)</a>
        </li>
        <li>
           SBCL SteelBankCommonLisp (<a href="http://sbcl.sourceforge.net/)">http://sbcl.sourceforge.net/)</a> -- branch of CMUCL
        </li>
      </ul>
      <p>
        <strong></strong><a href="CommonLisp.html">CommonLisp</a> Learning resources<strong></strong>
      </p>
      <ul>
        <li>
           <a href="PracticalCommonLisp.html">PracticalCommonLisp</a> by <a href="PeterSeibel.html">PeterSeibel</a> -- recent work, now finished. (<a href="http://www.gigamonkeys.com/book/)">http://www.gigamonkeys.com/book/)</a>
        </li>
        <li>
           <a href="CommonLispaGentleIntroductionToSymbolicComputation.html">CommonLispaGentleIntroductionToSymbolicComputation</a> by DavidTouretsky -- newbie intro, on Web
        </li>
        <li>
           <a href="CastingSpelsInLisp.html">CastingSpelsInLisp</a> -- a comic-book tutorial on the web
        </li>
        <li>
           <a href="AnsiCommonLisp.html">AnsiCommonLisp</a> by <a href="PaulGraham.html">PaulGraham</a> -- not a standards book; the standard intro
        </li>
        <li>
           <a href="CommonLispHyperSpec.html">CommonLispHyperSpec</a> -- standard reference, included or freely downloadable
        </li>
        <li>
           <a href="OnLisp.html">OnLisp</a> By <a href="PaulGraham.html">PaulGraham</a> -- not for beginners, excellent intro to macros, on Web
        </li>
        <li>
           <a href="ParadigmsOfArtificialIntelligenceProgramming.html">ParadigmsOfArtificialIntelligenceProgramming</a> by <a href="PeterNorvig.html">PeterNorvig</a> -- classic AI intro
        </li>
        <li>
           <a href="PascalCostanzasHighlyOpinionatedGuideToLisp.html">PascalCostanzasHighlyOpinionatedGuideToLisp</a>
        </li>
        <li>
           <a href="http://www.lisp.org">http://www.lisp.org</a> (the server of the Association of Lisp Users)
        </li>
        <li>
           <a href="http://alu.cliki.net/">http://alu.cliki.net/</a> (the wiki of the Association of Lisp Users
        </li>
        <li>
           <a href="http://www.lisp.org/table/learn.html">http://www.lisp.org/table/learn.html</a>
        </li>
        <li>
           <a href="http://www.cliki.net">http://www.cliki.net</a> (a wiki for 'free' Lisp programming on Unix platforms)
        </li>
        <li>
           <a href="http://cl-cookbook.sourceforge.net">http://cl-cookbook.sourceforge.net</a>
        </li>
      </ul>
      <hr/>
      <p>
        <strong>Other Lisp Learning resources</strong>
      </p>
      <ul>
        <li>
           Lush (<a href="http://lush.sourceforge.net/)">http://lush.sourceforge.net/)</a> is a Lisp which has an older syntax, but great integration with C and a range of external libraries for signal processing, numerical work and AI. Used for development of DejaVu alternative to PDF. You can get started playing with video and SDL in no time - but maybe it lacks some of the language features you were looking for. Not <a href="CommonLisp.html">CommonLisp</a>. 
        </li>
      </ul>
      <hr/>
      <p>
        Aside from the libraries, how different are the languages themselves?
      </p>
      <p>
        <em>Different enough to be incompatible. ;-)</em>
      </p>
      <hr/>
      <p>
        <em>For those of us considering playing around with either CLisp, CMUCL or SBCL, which would be recommended for a beginner?</em>
      </p>
      <p>
        If you just want to play around, I suggest getting Lisp in a Box, as it includes everything you need (IDE, etc.) in a single, easy-to-install package.
      </p>
      <p>
        All of the above are fine for learning Lisp. My preference would be CMUCL or SBCL. But you can also can download <a href="AllegroCommonLisp.html">AllegroCommonLisp</a> from Franz and the <a href="LispWorks.html">LispWorks</a> personal edition for several platforms. Especially <a href="LispWorks.html">LispWorks</a> has an IDE written in Lisp. Such an IDE might be helpful for learning Lisp development (debugger, inspector, editor, stepper, etc. as GUI-based tools).
      </p>
      <p>
        If you decide to go the open-source way, you'll still need an IDE. The canonical way to do that, recently, has been to use Emacs+Slime+SBCL. For more information, see <a href="http://www.cliki.net/Slime">http://www.cliki.net/Slime</a>
      </p>
      <hr/>
      <p>
        I suggest that the discussion about the differences between <a href="SchemeLanguage.html">SchemeLanguage</a> and <a href="CommonLisp.html">CommonLisp</a> be better discussed on another page (maybe there is already one). Learning about the differences is surely interesting (for example for choosing which Lisp dialect to learn), but does not really help much in learning to program in Lisp. ;-)
      </p>
      <p>
        Much discussion moved to <a href="LispSchemeDifferences.html">LispSchemeDifferences</a>.
      </p>
      <hr/>
      <p>
        Any comments on <a href="EmacsLisp.html">EmacsLisp</a>? I always wanted a super-charged editor that I can customize all kinds of features into. It might be a good road to start Lisp.
      </p>
      <ul>
        <li>
           Programming in Emacs Lisp is IMHO slightly harder than Scheme or <a href="CommonLisp.html">CommonLisp</a> but there's very good documentation and tutorials available with the emacs distribution, and you can do useful stuff fast. I recommend it as way to get started on lisp, although Lisp in a Box may be better. - anon
        </li>
      </ul>
      <hr/>
      <p>
        One way to speed up learning Lisp/Scheme is to put it on your <a href="HandHeld.html">HandHeld</a>. <a href="LispMe.html">LispMe</a> for Palm, <a href="PocketScheme.html">PocketScheme</a> for <a href="PocketPc.html">PocketPc</a>. Then while waiting on the bus or other idle time you can experiment.
      </p>
      <p>
        <em>Too many parenthesis and you blow the stack, zapping your neighbour's pace maker :-)</em>
      </p>
      <hr/>
      <p>
        <strong>Recognizing Function Calls</strong>
      </p>
      <p>
        One thing I seem to have a problem with as a Lisp beginner is knowing whether something is a list or a function call when visually scanning code. Often one cannot tell the difference without knowing the context. For example, a LET statement (in <a href="EmacsLisp.html">EmacsLisp</a>) may have a set of variables to assign values to. One cannot tell which is a variable assignment and which is a function call without first finding the LET. This is not something I ever had to do with "normal" programming languages [1], so I am at odds on how to overcome it. Or, is it just an inherent shortcoming of Lisp that is compensated for in other ways?
      </p>
      <p>
        [1] The one exception was arrays versus functions in MS Basic dialects. Some call it "polymorphism" to justify it. I guess I half agree since I had to switch implementation from arrays to function calls a few times and it came in handy.
      </p>
      <p>
        <em>With practice this becomes easier. You'll learn to quickly recognize macros like LET by their indentation style. With a good editor you should also have the source and documentation for everything at your fingertips when you want to look something up, and even have some information (like function/macro argument lists) automatically displayed. That helps tremendously while you familiarize yourself with new functions and macros.</em>
      </p>
      <p>
        <em>In </em><a href="EmacsLisp.html">EmacsLisp</a>, try 'M-x eldoc-mode' to automatically see documentation for the function/macro at point, and 'M-x find-function' to jump to the sources to the function called at point. And don't miss Emacs's comprehensive built-in online help system, described at <a href="http://www.gnu.org/software/emacs/manual/html_chapter/emacs_10.html#SEC42''">http://www.gnu.org/software/emacs/manual/html_chapter/emacs_10.html#SEC42''</a>
      </p>
      <hr/>
      <p>
        <strong>Special Characters</strong>
      </p>
      <p>
        Different dialects seem to have different symbols as operators or markers of some sort, such as dots, colons, etc. Is there a pattern or brief catalog of what these mean and which dialects support them?
      </p>
      <p>
        <em>Yes, somewhere on </em><a href="http://www.cliki.net/''">http://www.cliki.net/''</a>
      </p>
      <hr/>
      <p>
        I was wondering if there is not a simplified "Lisp lite" language out there that is nothing but lists. No single quoting, colons, etc. One would use Eval on strings instead of symbols (single quote). I realize it may run slower, but that is the tradeoff for being "lite".
      </p>
      <p>
        I am a Lisp newbie and just kicking around ideas, so forgive me if it is a naive question. I have a habit of learning by asking weird questions.
      </p>
      <p>
        <em>The things that you mention are already much closer to standard Lisp than you would think. For instance, single quote has always just been an abbreviation for the special form (quote ...), and the only thing that differs between strings and symbols is how they are eval'ed.</em>
      </p>
      <p>
        <em>So although it may seem you are suggesting a "Lisp lite" dialect, actually that's still just Lisp.</em>
      </p>
      <p>
        <em>There are, of course, ultra-tiny implementations of Lisp, such as the classic eval-written-in-Lisp that tends to be presented as part of every intro to Lisp course and book.</em>
      </p>
      <p>
        You may also want to check out <a href="SchemeLanguage.html">SchemeLanguage</a>, which is designed to be simple and minimalistic. It has no keyword args, no <a href="GenericFunction.html">GenericFunction</a>s, no <a href="GeneralizedReference.html">GeneralizedReference</a>s, and a different macro system. Still has quoting (which, as mentioned above, merely expands to the form (QUOTE ...)), but that's necessary in any language where <a href="CodeIsData.html">CodeIsData</a>. The naming conventions are also more logical than in <a href="CommonLisp.html">CommonLisp</a>.
      </p>
      <p>
        There's also <a href="GooLanguage.html">GooLanguage</a>, which is Scheme + object orientation (in the form of generic functions). This is a research project from MIT, and is also supposed to be a simple language suitable for teaching. Unfortunately, the function names in it can be a bit cryptic.
      </p>
      <p>
        Depending on what you mean by "simple", <a href="PaulGraham.html">PaulGraham</a> has been working on <a href="ArcLanguage.html">ArcLanguage</a>, a "simplified" version of <a href="CommonLisp.html">CommonLisp</a>. While more complex than <a href="SchemeLanguage.html">SchemeLanguage</a>, <a href="ArcLanguage.html">ArcLanguage</a> seeks to remove a lot of the "cruft" from <a href="CommonLisp.html">CommonLisp</a>.
      </p>
      <ul>
        <li>
           I cry foul, there is no public Arc definition yet, let alone available implementation, and may not be for years.
        </li>
      </ul>
      <p>
        <em>Depending on what you're doing with it, you may find that </em><a href="TclLanguage.html">TclLanguage</a> is this "simple" Lisp which you desire. That said, it is a <strong>much</strong> less powerful language in many ways.<em></em>
      </p>
      <hr/>
      <p>
        Lisp blog:
        <a href="http://lemonodor.com/">http://lemonodor.com/</a>
      </p>
      <p>
        <em>I wonder how many other languages have a blog? -- </em><a href="DavidCary.html">DavidCary</a><em></em>
      </p>
      <hr/>
      <p>
        I'm a <a href="PerlLanguage.html">PerlLanguage</a>, <a href="PythonLanguage.html">PythonLanguage</a>, and <a href="EmacsLisp.html">EmacsLisp</a> hacker with some experience in <a href="SchemeLanguage.html">SchemeLanguage</a>, so neither basic lisp, lexical scoping, nor closures are really foreign to me. I've written some really powerful <a href="EmacsLisp.html">EmacsLisp</a>, but what I want to learn is how I can start using a lisp environment like SBCL to replace a lot of my one-offs in perl and python. Let me give you a few of the one-offs I'm talking about:
      </p>
      <ul>
        <li>
           Web page update checker: Recursively crawl a bunch of web pages. Store the URL and content in some persistent fashion -- the filesytem's not great, since I have to attach more metadata later. Flag pages that match certain regular expressions (must be able to match line boundaries but also cross lines, ala perl's /sm modifiers). If the page content differs, display where they differ. I previously used wget and cobbled together some scripts with diff, but have been moving it to use WWW::Mechanize, DBD::SQLite, and Algorithm::Diff (well, now it's mothballed...).
        </li>
      </ul>
      <ul>
        <li>
           Spam DNSBL checker: Given a large list (thousands) of domains, look up all IP's associated with them, including A, NS, and MX, and check these IPs against spam blacklist DNS zones. Do this as simultaneously as possible. Previously used Net::DNS and POE (puke), converted to use stackless python and nonblocking DNS lookups instead. Of course, storing the results in a database is de rigeur (I used Postgresql for that).
        </li>
      </ul>
      <ul>
        <li>
           SOAP client: I have to query a few web services and craft some queries by hand. So I need to more or less be able to hand-craft SOAP queries and parse the answers, including dealing with error codes, preferably without touching raw XML.
        </li>
      </ul>
      <ul>
        <li>
           Various input munging filters: Perl is still great as a sort of super-duper sed and awk fusion. I look for lisp tutorials, and I can't even get a good answer on how to read a stream in less code than it would take Java, much less match and transform them. There must be some good syntax sugar libraries that let me do sed-like things, no?
        </li>
      </ul>
      <p>
        <em>You can use cl-awk. It's at </em><a href="http://www.geocities.com/mparker762/clawk.html''">http://www.geocities.com/mparker762/clawk.html''</a>
      </p>
      <ul>
        <li>
           All of these should be easy to plug into CGI client backends. FastCGI would be nice, but not required. Lisp-only webserver interfaces I'm not too interested in, because I need to be able to swap implementation languages in and out if I really want to (not everyone here is keen on lisp).
        </li>
      </ul>
      <p>
        You might say some of these examples are "stacked" against lisp, requiring libraries or coroutine facilities that aren't present. Of course that's why I've tended to gravitate toward perl in the first place... If a scheme implementation is a better answer for these, terrific. Basically, what I'm looking for is LispForPerlHackers ...
      </p>
      <hr/>
      <p>
        See also: <a href="IwannaLearnScheme.html">IwannaLearnScheme</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryLisp.html">CategoryLisp</a>, <a href="IwannaLearn.html">IwannaLearn</a>
      </p>
    </div>
  </body>
</html>