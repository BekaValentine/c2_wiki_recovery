<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Unit Testing Costs Benefits
      </h1>
      <p>
        <a href="PairProgrammingCostsBenefits.html">PairProgrammingCostsBenefits</a> gives very convincing evidence that <a href="PairProgramming.html">PairProgramming</a> is where it's at. But is there any evidence besides thought experiments (or perhaps <em>including</em> thought experiments) that <a href="UnitTest.html">UnitTest</a>ing is definitely a good investment?
      </p>
      <p>
        The answer can be found sarcastically in "<a href="BigBangTesting.html">BigBangTesting</a>". More specifically, when you have a bug in a class, that bug will manifest later as incorrect behavior. That manifestation will be noticed by a human. Humans are much more costly than computers, so I'd prefer to get my notice:
      </p>
      <ol>
        <li>
           as soon as possible.
        </li>
        <li>
           with sufficient detail to solve the problem quickly.
        </li>
        <li>
           without wasting other people's time.
        </li>
      </ol>
      <p>
        All of these are possible with automated unit testing.
      </p>
      <p>
        But these are all reasons based on intuition. Is there any <strong>evidence</strong> that <a href="CommonSense.html">CommonSense</a> is correct? For example, can we find 2 similar projects, one of which used pervasive unit testing; the other relied on compiler errors and acceptance tests. Which of these
      </p>
      <ul>
        <li>
           got to market sooner?
        </li>
        <li>
           had lower support costs?
        </li>
        <li>
           gained greatest market share in the long term?
        </li>
      </ul>
      <hr/>
      <p>
        Over the past 9 months I rewrote an application that had become a <a href="BigBallOfMud.html">BigBallOfMud</a>. Using <a href="UnitTest.html">UnitTest</a>s made the program's design better, and ensured that there would be fewer bugs. The new program had the same functionality in 1/10 the <a href="LinesOfCode.html">LinesOfCode</a>. A reduction from 215,000 lines to 22,000 lines. I am sure that I would not have been able to accomplish this without <a href="UnitTest.html">UnitTest</a>s. Our customer also claims that the application looks and performs better. The original took 3 people a year, and this took just me 9 months. The rate of bug reports has dropped off by more than 90%.
      </p>
      <hr/>
      <p>
        It is very hard to talk about benefits of <a href="UnitTest.html">UnitTest</a>ing without knowing the answer to the following question: How many defects per 1000 lines of code remain in the code covered by <a href="UnitTest.html">UnitTest</a>s when it is put into production?
      </p>
      <p>
        Does anyone have some statistics regarding this? <em>-- </em><a href="DmitryJemerov.html">DmitryJemerov</a><em></em>
      </p>
      <p>
        Why does this statistic help? Not all lines of code are equal nor are all "defects" equal and there are a lot of things which may or may not be covered under the term "defects."
      </p>
      <p>
        <em>The </em><a href="PersonalSoftwareProcess.html">PersonalSoftwareProcess</a> book has data on programmer defect rates. One of the extreme books has a conference paper showing when there's cost-benefit of refactoring (implying unit tests), from a model of software as disease propagation. Can't remember the title...<em></em>
      </p>
      <hr/>
      <p>
        I finally found a study comparing a project with and without unit testing. It was done by Monster Consulting in Utah. Interestingly, the programmers were a group of 5 engineers, four of whom were practicing pair programming. They had tried unit testing a year ago but gave up on it because "the architecture of their software did not lend itself to unit testing." Monster Consulting had them write a toy program, then trained them on testing, and had them write a second toy program. Here's the study: <a href="http://www.agilealliance.com/articles/articles/IntegratingUnitTesting.pdf">http://www.agilealliance.com/articles/articles/IntegratingUnitTesting.pdf</a>
      </p>
      <p>
        I will summarize the results and comment on them. Each "result" compares the pre-training toy program with the post-training toy program. The numbers I am typing in are my rough estimates from reading off their charts.
      </p>
      <p>
        <strong>Total lines of code, including testing code, doubled on average</strong>
      </p>
      <ul>
        <li>
           single, developer 1: 400 --> 700
        </li>
        <li>
           pair, developers 2+3: 340 --> 550
        </li>
        <li>
           pair, developers 4+5: 300 --> 900
        </li>
      </ul>
      <p>
        <strong>Lines of production code (excluding test code) were the same or slightly more</strong>
      </p>
      <p>
        <strong>Development time in minutes</strong>
      </p>
      <ul>
        <li>
           single, developer 1: 125 --> 175
        </li>
        <li>
           pair, developers 2+3: 75 --> 225
        </li>
        <li>
           pair, developers 4+5: 125 --> 275
        </li>
      </ul>
      <p>
        <strong>Quality test pass rate</strong>
      </p>
      <ul>
        <li>
           single, developer 1: 55%-->75%
        </li>
        <li>
           pair, developers 2+3: 0% --> 65%
        </li>
        <li>
           pair, developers 4+5: 27% --> 100%
        </li>
      </ul>
      <p>
        <strong>My commentary</strong>
        I'm glad someone finally did an empirical study, but this was a tiny project! 400 lines of code? 120 minutes -- two hours -- of coding time? Of course testing will slow you down on such a tiny project!
      </p>
      <p>
        Where I see the value of testing is on longer, larger, more complex projects. My personal rough estimate is that testing becomes more efficient than not testing once your project is at least three days' work. Other people would say it has to be at least a week long. I would love to see empirical results on this. But I bet there is a point at which a project has so many interacting parts that having tests saves you major debugging time, which would mean you spend overall less time coding. Also, when a project is big enough to include refactorings, the size of the code base should quickly drop. On these larger projects, you don't have to choose between getting done fast without testing and slowly developing quality code with testing. Instead, on large projects unit testing both increases quality and drops development time.
      </p>
      <p>
        (By the way, I skipped their results on productivity, measured as number of lines of code per hour, because I care only about getting features done, not on generating more lines of code per hour.)
      </p>
      <p>
        -- <a href="JeanCzerlinski.html">JeanCzerlinski</a>
      </p>
      <hr/>
      <p>
        <em>when a project is big enough to include refactorings, the size of the code base should quickly drop</em>
      </p>
      <p>
        Not to mention that the unit tests save you a lot of time by telling you right away if your refactorings broke anything. Of course, they are not 100% accurate at this, but they're much much better than no tests at all.
      </p>
    </div>
  </body>
</html>