<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Popularity Of Java Script
      </h1>
      <p>
        Is <a href="JavaScript.html">JavaScript</a> common because many developers like it, or because it's the built-in language of web browsers, avoiding the need for client-side pluggins. Such browser entrenchment could be seen as a form of <a href="QwertySyndrome.html">QwertySyndrome</a>.
      </p>
      <hr/>
      <p>
        Discussion moved from <a href="GreatLispWar.html">GreatLispWar</a>:
      </p>
      <p>
        As far as your UI statements, that's only true because we are stuck with <a href="JavaScript.html">JavaScript</a> in a <a href="QwertySyndrome.html">QwertySyndrome</a> kind of way, NOT because people love <a href="JavaScript.html">JavaScript</a>. True, we sometimes have to learn ugly tools/techniques because of problem standards. I'll give you that one. But, it may not last long because people are hungry for a better client GUI standard than the <a href="HtmlStack.html">HtmlStack</a> and would run with joy from it if there was a viable alternative that was more like say Delphi. -t
      </p>
      <p>
        [We aren't stuck with <a href="JavaScript.html">JavaScript</a> at all. <a href="GoogleWebToolkit.html">GoogleWebToolkit</a> has been around forever, then there's newer stuff like Dart, <a href="CoffeeScript.html">CoffeeScript</a> (and friends, like Coco and <a href="LiveScript.html">LiveScript</a>), TypeScript, and Roy, to name just a few of the most popular. Yet <a href="JavaScript.html">JavaScript</a>, and alternate languages that preserve its semantics (the <a href="CoffeeScript.html">CoffeeScript</a> family in particular), are still exceedingly popular both in-browser and elsewhere thanks to Node. It's unlikely that we'll be replacing the <a href="HtmlStack.html">HtmlStack</a> with some new standard any time soon, but we don't need to; HTML, especially considering all the HTML5 additions, is absolutely expressive enough, and going forward we're almost certainly going to keep extending the <a href="HtmlStack.html">HtmlStack</a> standards rather then throw them out in favour of a totally new standard. -DavidMcLean] {Off-topic: I'd love to see AmberSelf in the spirit of <a href="AmberSmalltalk.html">AmberSmalltalk</a>}
      </p>
      <p>
        My sense of the industry is that a good many people don't like JS for <a href="SystemsSoftware.html">SystemsSoftware</a> or <a href="SystemsSoftware.html">SystemsSoftware</a>-like uses, such as GUI kits. If that differs from your experience, we'll just have to call it an <a href="AnecdoteImpasse.html">AnecdoteImpasse</a> and <a href="LetTheReaderDecide.html">LetTheReaderDecide</a>.
      </p>
      <p>
        [Well, one of the primary use cases for <a href="JavaScript.html">JavaScript</a> is manipulating the DOM to build more complicated UI widgets, and considering the huge proliferation of jQuery plugins (among other things) it seems to be rather competent at this. There's also things like Angular, Knockout.js, and Ember.js which all build powerful (and very popular) GUI kits on a JS base. In addition, <a href="JavaScript.html">JavaScript</a> is used to build a <em>lot</em> of compilers; it's especially popular for that purpose because you can then easily make "try" pages for your language, like <a href="http://learnboost.github.io/stylus/try.html">http://learnboost.github.io/stylus/try.html</a> <a href="http://jade-lang.com/">http://jade-lang.com/</a> <a href="http://js2coffee.org/">http://js2coffee.org/</a> . I believe you'd also consider <a href="http://gruntjs.com/">http://gruntjs.com/</a> something that falls under <a href="SystemsSoftware.html">SystemsSoftware</a>, and it's <em>ridiculously</em> popular. You may be unfamiliar with many recent <a href="JavaScript.html">JavaScript</a> projects, but the forefront of Web design makes heavy use of these things. -DavidMcLean]
      </p>
      <p>
        A large part of this is that because of client-locked <a href="QwertySyndrome.html">QwertySyndrome</a>, people are forcing JS to be a systems language, and embracing the wrong tool for the job because they have no other real choice.
      </p>
      <p>
        [But it's <em>not</em> client-locked. As noted, there're a wide assortment of options on the client, including Dart and <a href="GoogleWebToolkit.html">GoogleWebToolkit</a> which both completely avoid <a href="JavaScript.html">JavaScript</a>. And Grunt, along with the various compilers, is run primarily outside the browser, where there is complete freedom in language choice. -DavidMcLean]
      </p>
      <p>
        If you write a new <a href="SystemsSoftware.html">SystemsSoftware</a>-friendly language interpreter/compiler in JS, then technically you may be right, but it's kind of an <a href="AbstractionInversion.html">AbstractionInversion</a>. Most would agree that's not the ideal. It's an ugly solution to an ugly problem. It's like writing a C compiler in Perl when instead you should be writing Perl in C.
      </p>
      <p>
        [Dart is pretty much a new <a href="SystemsSoftware.html">SystemsSoftware</a>-friendly language that compiles to JS, so yes, that's happened; that wasn't my point anyway, though. My point is that, although there are a wide range of language choices available both in the browser and out, <a href="JavaScript.html">JavaScript</a> itself is still used for widely-used examples of systems software such as Grunt. Surely this is indicative of the language having some actual appeal? If there are no redeeming qualities to <a href="JavaScript.html">JavaScript</a> beyond it being the locked-in choice, why use it for Grunt, or for Jade? Why not use Dart or GWT to build Ember.js, if JS is allegedly so bad at that kind of thing? -DavidMcLean]
      </p>
      <p>
        Some? I'm not sure what your point is here in relation to prior statements. It appears to generally repeat prior points. Perhaps we should start a new topic such as JavaScriptPopularity or the like since we are wondering off topic. However, it will likely be filled with mostly anecdotal info, and our observations and "feeling" for the industry is apparently different. Anecdote-fights are not fun and not welcomed by most <a href="WikiZens.html">WikiZens</a>. Again, I don't sense any general love for <a href="JavaScript.html">JavaScript</a> for systems-software-like uses and any apparent popularity appears to be a direct and indirect result of a form of <a href="QwertySyndrome.html">QwertySyndrome</a> due to its inclusion in web browsers. I suspect if <a href="BrainFsck.html">BrainFsck</a> was the imbedded language of browsers, people would be making Grunt interpreters out of <a href="BrainFsck.html">BrainFsck</a>. Since God denied my grant to fork Earth, we cannot test that theory. (As a "glue" language for relatively light-duty scripting, most are "okay" with JS there.)
      </p>
      <p>
        [<em>When</em> would JS have been subject to <a href="QwertySyndrome.html">QwertySyndrome</a>, in terms of that causing its adoption outside the client environment? The client hasn't been locked in since 2006, when <a href="GoogleWebToolkit.html">GoogleWebToolkit</a> was released - it's older than jQuery, in fact, and hails from the halcyon age of <a href="JavaScriptSucksInBrowsers.html">JavaScriptSucksInBrowsers</a>, when on the whole nobody was using JS except for one-off client hacks. <a href="JavaScript.html">JavaScript</a>'s recent popularity is just that, recent. If it were caused by the <em>old</em> property of client lock-in, it would've happened a lot sooner. It's far more likely that JS's popularity correlates significantly with Douglas Crockford's book, JavaScriptTheGoodParts, published in 2008; it's only after that book's release that JS has become popular for servers and other applications (<a href="NodeJs.html">NodeJs</a>, <a href="CoffeeScript.html">CoffeeScript</a>, and Angular in 2009; Knockout in 2010; Ember in 2011; Grunt in 2012). -DavidMcLean]
      </p>
      <p>
        Are you suggesting users should expect to install special browsers or browser add-ons to have client-side code in a particular language other than JS?
      </p>
      <p>
        [Absolutely not. That may be what AdobeFlash, <a href="MicrosoftSilverlight.html">MicrosoftSilverlight</a>, and Java applets expected of users, but I don't. <a href="GoogleWebToolkit.html">GoogleWebToolkit</a>, <a href="CoffeeScript.html">CoffeeScript</a>, Dart, and so on can all run in-browser without any special extension. -DavidMcLean]
      </p>
      <p>
        Then you have the slowness of an <a href="AbstractionInversion.html">AbstractionInversion</a>, including downloading an entire interpreter for each page/site, which is stupid.
      </p>
      <p>
        [No, you <em>assume</em> that you have the slowness of an <a href="AbstractionInversion.html">AbstractionInversion</a>, including downloading an entire interpreter for each page/site. None of that is necessary. GWT, Dart, and <a href="CoffeeScript.html">CoffeeScript</a> are compiled. -DavidMcLean]
      </p>
      <p>
        How is that different from Java applets?
      </p>
      <p>
        [Java applets require the Java browser plugin to run. Apps written in GWT/Dart/<a href="CoffeeScript.html">CoffeeScript</a> don't require any plugins, nor any other extension to the client's browser. -DavidMcLean]
      </p>
      <p>
        Most browsers shipped with Java, for a while. But at least the Java pluggin was designed to run Java byte-code, unlike JS, which means the approach you suggest is going to be slow. It's often why JS GUI's are so jittery and unresponsive and jam pages.
      </p>
      <p>
        [Whether browsers shipped with Java in the past is immaterial. It's still a plugin that users might not have. In terms of performance, first note that for the most part client-side apps are IO-bound rather than CPU-bound, which for <a href="NodeJsAndHofDiscussion.html">NodeJsAndHofDiscussion</a> reasons means that a small performance overhead in the client is negligible. Next, note that all the languages I mentioned are compiled to <a href="JavaScript.html">JavaScript</a> well before they're delivered to the client; compilation can be slow, but all the client actually deals with is clean, well-optimised JS. Which brings me to my final point: <a href="JavaScript.html">JavaScript</a> isn't slow, at least not any more. The JS engines used in both WebKit and Gecko have <em>phenomenal</em> <a href="JustInTimeCompilation.html">JustInTimeCompilation</a>, and given a little JavaScriptTheGoodParts-style discipline it's easily the fastest interpreted language out there. If you're convinced that <a href="JavaScript.html">JavaScript</a> GUIs are on the whole jittery and unresponsive, would you care to provide examples of this? My experience, especially with Google applications, suggests otherwise. -DavidMcLean]
      </p>
      <p>
        Either way, you are arguing that JS can be treated like a machine language with another compiled language "running" on top of it. But that's not selling JS for JS's abilities in terms of its language features, which was the original reason JS came up. (Any <a href="TuringComplete.html">TuringComplete</a> language can be used to execute other language's machine code or p-code.) -t
      </p>
      <p>
        [My point was that, while JS can be viewed as the assembly language of the Web and alternate languages used (GWT, Dart) in its place for actual development, for the most part <em>it isn't</em>. You got sidetracked by the means whereby these compile-to-JS languages work; the important thing to consider here is that, although GWT or Dart could have been used to develop Angular, Knockout, and Ember, <em>they weren't</em>; <a href="JavaScript.html">JavaScript</a> was still chosen despite the ever-present availability of choice, which surely indicates that <a href="JavaScript.html">JavaScript</a>'s features have merit. -DavidMcLean]
      </p>
      <p>
        How do we know that browser entrenchment didn't play a large role in such decisions?
      </p>
      <ul>
        <li>
           [Because, like I just said, there's no such entrenchment as a range of languages are and were available in the browser? -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           But that's only if you talk about it in terms of an assembler/machine language and not as an application or <a href="SystemsSoftware.html">SystemsSoftware</a> language from language (coding and syntax) standpoint. So, yes, you <em>can</em> use other languages, but then you are not directly using JS. You are merely taking advantage of the fact that the entrenched browser language is <a href="TuringComplete.html">TuringComplete</a> such that it can run other languages also. That's not an advantage <em>specific</em> to <a href="JavaScript.html">JavaScript</a>. One could do the same in COBOL, VB-Script, or <a href="BrainFsck.html">BrainFsck</a>.
        </li>
      </ul>
      <ul>
        <li>
           [Obviously you aren't using JS nor taking advantage of <a href="JavaScript.html">JavaScript</a>'s features if you use it as an assembly language and actually code in something else (I'd argue that if you code in <a href="CoffeeScript.html">CoffeeScript</a> or its descendants, such as Coco, you are in fact still using JS -- <a href="CoffeeScript.html">CoffeeScript</a>'s slogan is "it's just <a href="JavaScript.html">JavaScript</a>", after all -- but GWT and Dart users are definitely avoiding JS itself). That's irrelevant, because my whole point is that people <em>could</em> use not-JS and <em>could</em> not take advantage of its features. But, critically, they don't. People still use <a href="JavaScript.html">JavaScript</a> itself, taking advantage of its features, despite the fact that it is a perfectly valid option not to use it. -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           Using something else besides JS is often <em>not</em> practical because it ties an organization to an uncommon language stack. Companies want <a href="PlugCompatibleInterchangeableEngineers.html">PlugCompatibleInterchangeableEngineers</a>. <a href="QwertySyndrome.html">QwertySyndrome</a>. And to some <a href="CoffeeScript.html">CoffeeScript</a> may be too much like JS to bother to be somewhat different for similar reasons. If you accept the down-sides of having a different tool stack, you want sufficient up-sides to compensate for these down-sides.
        </li>
      </ul>
      <ul>
        <li>
           [An organisation? I'm mostly referring to big open-source projects here -- Angular, Knockout, Ember, Grunt -- since those are clearly-visible examples of JS's popularity; open-source projects don't want <a href="PlugCompatibleInterchangeableEngineers.html">PlugCompatibleInterchangeableEngineers</a>. -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           I'm talking from the perspective of a "typical organization" (corporation, gov't, charity, etc.) They probably have different concern priorities than open-source projects.
        </li>
      </ul>
      <ul>
        <li>
           [Of course they would, but that's irrelevant to my argument. I'm arguing that JS is popular on its own merits because it's used for big open-source projects like Grunt, and on the whole big open-source projects don't have a <a href="PlugCompatibleInterchangeableEngineers.html">PlugCompatibleInterchangeableEngineers</a> consideration when choosing implementation languages. -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           I've considered JS also for open-source projects I've pondered, but it was mostly based on entrenchment. Entrenchment greatly increases the chance of a language being available years down the road.
        </li>
      </ul>
      <ul>
        <li>
           [Would browser entrenchment have been enough to convince you to choose <a href="JavaScript.html">JavaScript</a> for your <em>non-browser</em> open-source projects? -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           Yes! Browser entrenchment helps ensure availability in non-browser-apps also. Although, "convince" is probably too strong a word. It's a "big factor", let's just say, in choosing a language.
        </li>
      </ul>
      <ul>
        <li>
           [How so? A terrible language that's forced on you by a specific environment is not one anyone would want available outside that environment, no? In any case, language choice primarily is rooted in how well the language solves the problem given, isn't it? -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           What "terrible language" are you referring to?
        </li>
      </ul>
      <ul>
        <li>
           [A hypothetical one whose primary "merit" is that one particular environment requires it. Why would it <em>ever</em> be available outside that environment? Why would anyone ever put in the effort to make such a language available outside of the environment that forces it? -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           Sorry, you lost me. Too many pronouns and implied references. Note I never said JS is "terrible" in a general sense. It's just the wrong tool for some jobs.
        </li>
      </ul>
      <ul>
        <li>
           [One pronoun, "it", which in every appearance refers to the "hypothetical [language] whose primary merit is that one particular environment requires it". Of course <a href="JavaScript.html">JavaScript</a> is the wrong tool for some jobs, since no tool is perfect for every application ever, but in previous topics you seemed to be suggesting that the <em>only</em> real justification for the language's use is that a common environment (the browser) is forced to use it; this seems clearly erroneous to me, both because I know <a href="JavaScript.html">JavaScript</a> is a tremendously powerful language and because it's currently quite popular even for server-side and for non-Web-app uses, like shell programs. -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           You seem to be arguing that its (alleged) popularity is evidence of its popularity outside of the browser-embedding issue. I don't see how that follows. It seems to be circular logic. And being "powerful" is not evidence of goodness by itself. Lisp is also powerful; I'd argue ever more powerful than JS. (Abstraction power is rarely a top selling point (favored factor) in the paid field for reasons described in <a href="GreatLispWar.html">GreatLispWar</a>.) Server-side JS usage may likely be a side-effect of browser-entrenchment. You haven't given strong evidence that it's not spill-over. Articles on server-side JS even talk about not having to learn a new/different server-side language for those with client-side experience as one selling point of the idea.  -t
        </li>
      </ul>
      <ul>
        <li>
           [My argument isn't "<a href="JavaScript.html">JavaScript</a> is popular because it has popularity"; that would indeed be circular logic. I argue that, because it has significant recent popularity both for the server-side and for shell programs, its popularity is most likely <em>unrelated</em> to its "browser entrenchment", since there is no such entrenchment in the server and especially in the shell. (Why not use <a href="PerlLanguage.html">PerlLanguage</a>, <a href="PythonLanguage.html">PythonLanguage</a>, or <a href="RubyLanguage.html">RubyLanguage</a> for shell programs, after all?) Use of <a href="JavaScript.html">JavaScript</a> for server-side <em>does</em> have the contributing factor that aspects of your code may be shared between client and server, since both speak a common language, but this by no means a big enough advantage to justify writing an entire server-side <a href="JavaScript.html">JavaScript</a> platform (<a href="NodeJs.html">NodeJs</a>) in the first place. In addition, there is no such justification for JS's use in the shell. As I noted earlier, it's far more likely that the recent boom in <a href="JavaScript.html">JavaScript</a>'s popularity for server-side and shell applications is tied not to its ubiquity in browsers (since that's been the case for a long time, and this popularity boom is critically more recent) but instead to the release of JavaScriptTheGoodParts, which helped many programmers identify the language's many strengths and warded against its comparatively few warts (primarily: with, eval, and certain aspects of the type system), and was followed by a slew of big, widely popular projects applying the good parts of <a href="JavaScript.html">JavaScript</a> to their full extent. (Also, Lisp is indeed more powerful than <a href="JavaScript.html">JavaScript</a>, and that is <strong>definitely</strong> evidence of goodness by itself.) -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           You are not presenting any clear evidence that server-side usage growth is mostly unrelated to the entrenchment. Leveraging the existing knowledge pool is very important to most organizations in my experience. It makes it easier to have <a href="PlugCompatibleInterchangeableEngineers.html">PlugCompatibleInterchangeableEngineers</a>, a big goal of organizations. Further, the existence of JavaScriptTheGoodParts is likely related to the entrenchment. Oreilly is not likely to release "<a href="BrainFsck.html">BrainFsck</a> The Good Parts", because nobody would buy it.
        </li>
      </ul>
      <ul>
        <li>
           [O'Reilly is unlikely to release <a href="BrainFsck.html">BrainFsck</a>: The Good Parts because it doesn't have any. My argument that the server-side growth doesn't correlate with browser entrenchment is a temporal one: Ignoring that there really isn't entrenchment because of GWT and Dart for a moment, <a href="JavaScript.html">JavaScript</a> has been the "only" option in browsers for <em>almost twenty years</em>. It's been an option on the server, as <a href="NodeJs.html">NodeJs</a>, for about five. If the limited options in the browser environment led people to develop similar options on the server, why would it take so long? -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           Substitute <a href="BrainFsck.html">BrainFsck</a> with a language you like but is not popular. And the fact that JS has been around for so long is likely one of the reasons why its use spread to the server-side. If you want to bet your future on the viable existence of a language, then one that's lasted 20 years is good bet. Even if it fell out of favor tomorrow, the 20 years means there's a lot of existing projects and knowledge to keep the support and knowledge base alive for a while. It has a big "legacy spare fuel tank". You can't say that for something that's been visible for about 3 years. All else being roughly equal, a language that's been visible for 20 years has a big leg up to one that's been visible for 3 when choosing your org's tool base.
        </li>
      </ul>
      <ul>
        <li>
           [Hmm. The "bad parts" of <a href="HaskellLanguage.html">HaskellLanguage</a> are almost entirely historical mistakes in designing the standard libraries, rather than any problem with the language itself, and they are exceedingly few (for example, Monad is not defined as a subclass of Applicative, even though mathematically it is one). Moreover, there is no perception in the software community that Haskell is overall a bad language; there have never been <a href="JavaScriptSucksInBrowsers.html">JavaScriptSucksInBrowsers</a>-type problems with it, so there's no need for a HaskellTheGoodParts and I'd be surprised if anyone published one. I'll certainly accept that <a href="JavaScript.html">JavaScript</a>'s long-lived nature has contributed to its increase in popularity for alternative environments, but that doesn't really justify why it took so long for the language to be adopted in such environments, especially when taken as a primary factor. -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           I'm not clear on what you are responding to. I did not mention any "bad parts". As far as "why it takes so long", I already explained it. Once a language shows it has "sticking power" it becomes a de-facto standard. Being visible for 15 to 20 years puts JS in that category, making it a safer choice because enough shops and systems will depend on it to keep a maintenance community of both interpreter coders and app coders viable for a while. Based on existing and historical usage, most would agree that in 2030, one is more likely to find a decent JS interpreter for their new iSpeck portable eye-drop interface dot than for say Ruby. If there were any concern over medium and long-term support, a manager wouldn't select Ruby over JS unless it had some compelling feature that noticeably improves here-and-now projects.
        </li>
      </ul>
      <ul>
        <li>
           [You didn't outright mention any "bad parts", correct, but you did instruct me to "Substitute <a href="BrainFsck.html">BrainFsck</a> with a language you like but is not popular." in the statement that "Oreilly is not likely to release '<a href="BrainFsck.html">BrainFsck</a> The Good Parts', because nobody would buy it.", and it's implicit in a discussion of a book called "the good parts" that it's going to be warding you against the bad parts too, as well as exploring the good parts in depth, as JavaScriptTheGoodParts does. As for your de facto standard claim? Setting aside that <a href="JavaScript.html">JavaScript</a> isn't just a de facto standard but an <em>actual</em> one, <a href="EcmaScript.html">EcmaScript</a>, why would there be any correlation between what language a typical manager would select for its long-term support characteristics and what language <a href="DouglasCrockford.html">DouglasCrockford</a> would select as the subject for his book? There's clear correlation, if not explicitly-established causation, between that book and <a href="JavaScript.html">JavaScript</a>'s generally being recognised as a powerful, competent language – which makes sense, given the prior perception of <a href="JavaScriptSucksInBrowsers.html">JavaScriptSucksInBrowsers</a> – as is outright indicated by (for example) <a href="CoffeeScript.html">CoffeeScript</a>'s self-description as "an attempt to expose <strong>the good parts</strong> of <a href="JavaScript.html">JavaScript</a> in a simple way." There is little to no indication that either JavaScriptTheGoodParts nor <a href="CoffeeScript.html">CoffeeScript</a> were written simply because JS is what we're stuck with in the browser, and plenty to indicate that both relate to the language's actual expressive power and value. -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           We can only speculate on the publisher's motivation for approving book projects. If you have evidence of "explicitly-established causation", please present it. Otherwise, I'm not interested in repetition of your personal opinion.
        </li>
      </ul>
      <ul>
        <li>
           [The publisher's motivation for approving the project is irrelevant; what's more important is <a href="DouglasCrockford.html">DouglasCrockford</a>'s motivation for writing the book in the first place. JeremyAshkenas explicitly describes <a href="CoffeeScript.html">CoffeeScript</a>, as noted, as "an attempt to expose the good parts of <a href="JavaScript.html">JavaScript</a> in a simple way". Off the cuff, I've no similar evidence for <a href="NodeJs.html">NodeJs</a>, but there's pretty obviously a <em>correlation</em>. -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           But if the publisher doesn't accept the idea, nobody sees those words you quote. Thus, the author's motivation is not necessarily the primary cause of the world seeing the book. The publisher may be receiving many drafts of "Why [obscure language X] is So Great!", but <strong>turn most down</strong> because of an insufficient audience. Thus, author enthusiasm and opinions are being <strong>filtered by publishers</strong>, skewing OUR view.
        </li>
      </ul>
      <ul>
        <li>
           [I don't see how publisher-filtering could be in any way meaningful or germane to this subject. The fact of the matter is that <a href="DouglasCrockford.html">DouglasCrockford</a> wrote a book, JavaScriptTheGoodParts, because of the perception that <a href="JavaScriptSucksInBrowsers.html">JavaScriptSucksInBrowsers</a> contrary to his own opinion of the language; after this book's release, many many JS projects have started that follow the design principles presented in the book and in some cases explicitly describe themselves as a a way to get at "the good parts" of JS. If publishers received a similar book earlier and accepted it, we'd probably be seeing <a href="CoffeeScript.html">CoffeeScript</a> and <a href="NodeJs.html">NodeJs</a> a little earlier. Is it really relevant what the publishers' motivations are? -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           Sorry, I'm still not seeing what your point is. A book triggered more JS-related tools? Perhaps. Okay. But, what's that have to do with the <em>general</em> popularity of <a href="JavaScript.html">JavaScript</a>? I contend a given language's entrenchment is more likely to trigger such books. It's kind of "if we are stuck with it, let's leverage it as much as possible".
        </li>
      </ul>
      <ul>
        <li>
           [But a) we aren't stuck with it, because GWT/Dart/blah. b) JavaScriptTheGoodParts was specifically written because of the common perception that <a href="JavaScriptSucks.html">JavaScriptSucks</a>, and presents an alternate, <a href="JavaScriptRocks.html">JavaScriptRocks</a> perspective, on which most subsequent tools are built. -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           I believe it's largely due to browser-entrenchment. That a book helped people "live with it" better is only saying that a book helped people live with it better.
        </li>
      </ul>
      <ul>
        <li>
           [What about the alternatives? We've had GWT much longer than <a href="JavaScript.html">JavaScript</a> has been well-liked. -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           It's not a programming language. Apples to oranges.
        </li>
      </ul>
      <ul>
        <li>
           [<a href="JavaLanguage.html">JavaLanguage</a> is. How's it matter that GWT isn't? -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           I don't know of a many GWT programmers and it's not hard-wired into common browsers.
        </li>
      </ul>
      <ul>
        <li>
           [I'm sure you'd be familiar with Java programmers, but it doesn't particularly matter, because the relevant thing is that it <em>exists</em> as an option, not that it's <em>used</em> as one. And of course it's not wired into browsers. Neither is <a href="CoffeeScript.html">CoffeeScript</a>. Neither is Dart, Dartium notwithstanding. Why would it need to be? -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           Maybe I misunderstood why you mentioned GWT. That JS can be used like a virtual machine language interpreter says very little about JS. Cobol or <a href="BrainFsck.html">BrainFsck</a> could also execute byte-code-like instructions, if they were entrenched in browsers.
        </li>
      </ul>
      <ul>
        <li>
           [Correct, that JS can be treated as a low-level VM for a higher-level or at least more-strictly-typed language says very little about <a href="JavaScript.html">JavaScript</a> itself or its features. All it says is that you don't have to use it, because you could use GWT. The fact that people <em>do</em> use JS, despite there clearly being alternatives, indicates that there are reasons other than browser entrenchment for its use. -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           Are you talking about Java applet-based solutions? Java applets are failing largely because the technology was poorly integrated with the browser DOM. The same can be said about Flash. JS, Java applets, and Flash are pretty much the only browser-entrenched programming environments. Lack of integration with the DOM, and in Flash's case the proprietary fees associated with development tools are dooming the latter two.
        </li>
      </ul>
      <ul>
        <li>
           [No, I'm not talking about Java applets or Flash. As I keep saying, I'm talking about <a href="GoogleWebToolkit.html">GoogleWebToolkit</a>, Dart, and the like. -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           ANY <a href="TuringComplete.html">TuringComplete</a> language can "execute" Java. JS is only used because it's entrenched in browsers. We've been over that already. I don't know what you are trying to get at. I'm growing frustrated with this sub-discussion.
        </li>
      </ul>
      <ul>
        <li>
           [Certainly, any <a href="TuringComplete.html">TuringComplete</a> language can execute Java code, given appropriate infrastructure. GWT is that infrastructure as applied to <a href="JavaScript.html">JavaScript</a>, but that's not the point; I'm not arguing that <a href="JavaScript.html">JavaScript</a> is special or powerful for being <a href="TuringComplete.html">TuringComplete</a>. I'm arguing that, <em>although</em> there are other mature languages available in the browser (such as GWT), for the most part <a href="JavaScript.html">JavaScript</a> itself is still a popular choice, which indicates that there are reasons outside of the platform limiting choice. It's only entrenched in the browser in the same sense x86 assembly is entrenched in x86 processors, and no one codes in x86 assembly directly yet everyone codes in <a href="JavaScript.html">JavaScript</a> directly. -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           Most of the complaints I've seen about GWT is that the API's were poorly designed and awkward to use. It's the "worst of desktop ideas mixed with the worst of web ideas", said one person [paraphrased]. It wasn't easy to use direct Html/CSS coding when it's best and use Java API-controlled Html/CSS when it's best in a mix-and-match way. You were kind of forced to use all of one or other. (There may have been ways to do such, but they were not well-known/familiar among developers.) Further, a good many Java developers were not familiar enough with Html/CSS to use it well, compared to <a href="JavaScript.html">JavaScript</a> programmers. A much higher proportion of Java developers came from a desktop GUI background (Windows-C++, Delphi, VB, Powerbuilder, <a href="FoxPro.html">FoxPro</a>, etc.), and this tended to give GWT apps a bad reputation for not "doing the web right" even though it was caused largely by a background mismatch.
        </li>
      </ul>
      <ul>
        <li>
           [Completely accurate points! Indeed, GWT was not without its flaws, and its attempt to (basically) hide the fact that Web apps differ from desktop apps was ultimately unsuccessful. That's absolutely true. It is, however, only true of GWT. <a href="CoffeeScript.html">CoffeeScript</a> and friends interact with the DOM exactly as JS does, and Dart's got a sophisticated DOM API of its own baked in; all these languages are designed in full awareness of the importance of the standard <a href="HtmlStack.html">HtmlStack</a>. -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           <a href="CoffeeScript.html">CoffeeScript</a> and Dart may have their own shortcomings. Just because they are different than <a href="JavaScript.html">JavaScript</a> does not by itself make them worthy competitors.
        </li>
      </ul>
      <ul>
        <li>
           [Everything has shortcomings. Unless you can identify specific reasons that (say) Dart mightn't be a suitable choice for Web applications, it's just conjecture to suggest it's flawed enough relative to JS that it'd be completely ruled out as an option. -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           Something would have to be noticeably better to unseat JS as the target client language. Specific applications can hide much of JS's ugliness behind custom or specialized API's rather than use a relatively unknown language, creating future support risks.
        </li>
      </ul>
      <ul>
        <li>
           [I was under the impression you thought much of <a href="JavaScript.html">JavaScript</a>'s "ugliness" was either syntactic, or a property of APIs that the language is not powerful enough to abstract out (due to lack of named parameters), as indicated on <a href="BradyBunchGridDiscussion.html">BradyBunchGridDiscussion</a>. Are you now suggesting it indeed <em>can</em> be abstracted out? If so, what problems even exist with JS? -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           My personal opinions on JS don't matter in this case; it's what the industry wants. My preference for (optional) named parameters is unfortunately not as valued by the general industry, I would  note. The industry's main complaint is lack of better compiler-like type and reference checking for non-trivial GUI work.
        </li>
      </ul>
      <ul>
        <li>
           [Then how would you explain the relative unpopularity of Dart and TypeScript, which provide these things? -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           They probably need a "killer" API or framework to kick-start interest, and in the process demonstrate the advantages of static code verification for non-trivial GUI's. JS also has a leg up in that you have plenty of API's/libraries/frameworks to choose from for native JS. It's somewhat comparable to Microsoft's problem competing with Android and Apple in the mobile market: not enough apps. The OS platform is a secondary concern to buyers. You have these main factors competing with each other:
          <ul>
            <li>
               Staffing of developers familiar with the language and related tools
            </li>
            <li>
               Chances that the language will be sufficiently supported 10 or so years from now
            </li>
            <li>
               Available libraries/frameworks/API's (for GUI's, typically)
            </li>
            <li>
               Language features: syntax, <a href="TypeSafety.html">TypeSafety</a>, name-spaces, etc.
            </li>
          </ul>
        </li>
        <li>
           The fourth one (language features) still has to compete with the other 3 factors in a decision-maker's mind. If something like Dart gets a good "score" on #4, it may not be enough to compensate for its poor weighting on the first three. Unless it's <em>extremely</em> better at #4, it will need "help" in at least one <em>other</em> category to get a score higher than entrenchment typically gives JS with decision-makers.
        </li>
      </ul>
      <ul>
        <li>
           [Modulo <a href="TypeScriptInconveniences.html">TypeScriptInconveniences</a>, TypeScript already has "available libraries/frameworks/APIs" for absolutely everything <a href="JavaScript.html">JavaScript</a> does. It's <em>slightly</em> more difficult to access vanilla <a href="JavaScript.html">JavaScript</a> libraries from Dart, but as noted Dart's standard library includes its own expressive interface to the DOM. That's your one-other-category. Since both are relatively new languages, familiarity with these languages <em>specifically</em> isn't particularly widespread yet---however, Dart's similarity to most imperative languages is a major selling point. Future support may be a concern for TypeScript, which is only really supported by Microsoft, but Dart is an ECMA standard. -DavidMcLean]
        </li>
      </ul>
      <ul>
        <li>
           Dart is relatively new. Maybe it or something like it will catch on. We'll just have to wait and see...
        </li>
      </ul>
      <p>
        As far as general "love" of JS, the "community commentators" at <a href="SlashDot.html">SlashDot</a> don't seem to show a general love of JS. There are <strong>far more "haters" than "lovers"</strong> there, as I informally survey the comments:
      </p>
      <p>
        <a href="http://developers.slashdot.org/story/14/02/01/1618226/the-javascript-juggernaut-rolls-on">http://developers.slashdot.org/story/14/02/01/1618226/the-javascript-juggernaut-rolls-on</a>
      </p>
      <p>
        In general, for non-trivial browser-side GUI programming, most seem to want a stronger <a href="TypeSystem.html">TypeSystem</a> and better name-space management. 
      </p>
      <p>
        [Those wanting "better name-space management" are uninformed. Any non-trivial browser-side GUI programming will make use of the CommonJS or AMD module specifications, through <a href="http://browserify.org/">http://browserify.org/</a> or <a href="http://requirejs.org/">http://requirejs.org/</a> respectively, and both module systems are extremely expressive in terms of namespacing. (Adding a stronger type system is a suggestion that has merit and is one of the major motivations behind GWT, Dart, and TypeScript. Barring a few quirks, however, such as the [3, 10, 5].sort() example presented in the aforementioned comments section, the <a href="JavaScript.html">JavaScript</a> type system really is no worse than any other dynamically-typed language's -- and on the flipside, I can confirm the stronger static type system offered by TypeScript makes a lot of common patterns <em>really inconvenient</em>!) -DavidMcLean]
      </p>
      <p>
        Many either don't want a dynamic language for heavy GUI usage, or want something that at least "encourages" explicit types, such as requiring typed parameters. ("Variant" or "object" may still be allowed, but not easier to code than an explicit type.)
      </p>
      <p>
        [My experience is that TypeScript in particular is <em>awful</em> for heavy GUI usage (specifically, for a Knockout-based application -- it's a custom business app, so I'll provide specific examples if desired). But of course experiences differ, and it's entirely possible other statically-typed languages do a much better job. -DavidMcLean]
      </p>
      <p>
        Why is it awful at GUI's? Perhaps the DOM itself is the problem?
      </p>
      <p>
        [No, all my problems were specifically with TypeScript. I've started writing up <a href="TypeScriptInconveniences.html">TypeScriptInconveniences</a> to illustrate a few. -DavidMcLean]
      </p>
      <hr/>
      <p>
        <a href="FebruaryFourteen.html">FebruaryFourteen</a>
      </p>
    </div>
  </body>
</html>