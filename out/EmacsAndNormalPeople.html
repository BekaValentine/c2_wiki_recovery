<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Emacs And Normal People
      </h1>
      <p>
        <a href="EmacsEditor.html">EmacsEditor</a> is a wonderful program for programmers, but what about <a href="NormalPeople.html">NormalPeople</a>?  I like the idea of teaching people to using <a href="TextEditor.html">TextEditor</a>s instead of <a href="WordProcessor.html">WordProcessor</a>s and other specialized editors, but undeniably, emacs is too hard for normal people to use, and that isn't likely to change.  
      </p>
      <p>
        <em>Funny you should pick emacs as an editor especially for programmers.  In my work, normal people use </em><a href="UnixOs.html">UnixOs</a> for much everything and I think emacs is one of the most normal people oriented programs around.  Unless you count recent "slick" projects like KDE (<a href="KayDesktopEnvironment.html">KayDesktopEnvironment</a>) editors etc.<em></em>
      </p>
      <p>
        I think it's time for a new editor.  What might such an editor have?  (contribute here everyone please) <trollmode>[Note: <a href="CodeWright.html">CodeWright</a> is the answer]</trollmode>
      </p>
      <ul>
        <li>
           I think it might be time to dump <a href="EmacsLisp.html">EmacsLisp</a> as the editor's language, and make it easy for programmers to use what ever language they like for programming it.  <a href="GuileScheme.html">GuileScheme</a> is trying to do something like this.
        </li>
        <li>
           Allow new interfaces like richtext editing
        </li>
        <li>
           Better tools for presenting dialog boxes?
        </li>
        <li>
           Object browser.
        </li>
        <li>
           <a href="ObjectOriented.html">ObjectOriented</a> <a href="ApplicationProgrammingInterface.html">ApplicationProgrammingInterface</a>
        </li>
        <li>
           A Macro builder
          <ul>
            <li>
               Easy enough for casual use
            </li>
            <li>
               Extensive enough for "<a href="PowerUser.html">PowerUser</a>s"
            </li>
          </ul>
        </li>
      </ul>
      <p>
        What should be saved from old emacs:
      </p>
      <ul>
        <li>
           Cross-platform compatibility.  
        </li>
        <li>
           Ability to do everything without a mouse.
        </li>
      </ul>
      <hr/>
      <p>
        Most of the tasks above would be better served with dedicated applications
        (possibly sharing common functionality through common classes). You're never
        going to please all the world with one editor; the best you can do is to please
        half the world, and then you have Emacs ;-). Rather:
      </p>
      <ul>
        <li>
           Build a simple editor with reusable code.
        </li>
        <li>
           Write it using a language/platform that allows easy (dynamic) loading of components.
        </li>
        <li>
           Have people extend it using their own components, and make sure <em>your</em> components are usable by other people's simple editors (and <a href="WordProcessor.html">WordProcessor</a>s, and other apps).
        </li>
      </ul>
      <p>
        Why build those big monolithic applications at all? Haven't we learnt anything from <a href="UnixOs.html">UnixOs</a>?
      </p>
      <p>
        -- <a href="StephanHouben.html">StephanHouben</a>
      </p>
      <hr/>
      <p>
        I think if you look at how tightly all the various "applications" which run under emacs interoperate, at a level far more intimate than the clunky pipes of unix, you might revise that opinion and wonder if Unix hasn't learned anything from emacs (or the <a href="LispMachine.html">LispMachine</a> environments).  VM/W3/GNUS/Dired/ange-ftp/etc etc all play with each other <strong>much</strong> more friendly than awk/grep/sed/pipes/bin/sh. (See <a href="UnixShellPatterns.html">UnixShellPatterns</a>.)
      </p>
      <hr/>
      <p>
        Given <a href="MicrosoftWord.html">MicrosoftWord</a>, <a href="WebBrowser.html">WebBrowser</a>s/mail clients/news readers/stock quoters/auction viewers, the popularity of, say, <a href="VimTextEditor.html">VimTextEditor</a>, the gradual expansion in shell capabilities and the general tendency toward do-everything software, I would have to say "no".  It may be that these big monolithic applications have real advantages.
      </p>
      <p>
        The examples given for that kind of distributed software is usually the Unix <a href="CommandLine.html">CommandLine</a>; one might also propose the <a href="AcmeProgrammingEnvironment.html">AcmeProgrammingEnvironment</a>.  Unix heavily promotes tool creation, makes the new tools work just like everything else, and is sharply limited--the shell thinks everything is at best loosely formatted text.  Acme is no different.  When I wanted to write a grep that was restricted to certain columns of a <a href="CommaSeparatedValues.html">CommaSeparatedValues</a> file, I had to write my own in <a href="CeeLanguage.html">CeeLanguage</a>.
      </p>
      <p>
        Now, if we look at Emacs, we find something interesting.  The smarts required to take typical nroff output (which uses backspace characters to simulate bold and underlining) get rewritten a lot--<strong>col</strong> is the standard utility, but it just strips the codes out.  You can't grep the raw output; the formatting codes are sequenced in with the text.  The code to translate these into terminal sequences for bold and underline and whatnot is in among other things less.  Emacs has a function to do this: Man-fontify-manpage.  It is, as the name suggests, most appropriate for viewing man pages, but it served perfectly when I wanted to take my nroff output and make it look sane.  Further, I can search through the formatted output, call up a dictionary on bold-faced words, and do various other things and it all just works.  Partly this is because Emacs has a much saner model of text than the Unix pipeline, but that I could just grab that function and use it is a real benefit of the environment.
      </p>
      <p>
        This is only one data point, but I found it illustrative because nroff-view-as-text didn't exist in my Emacs until I wrote it, and I wouldn't have even attempted to get the fonts right if Man-fontify-manpage didn't exist already.  It may be that environments integrated on the level that Emacs is are the way to go, in the end.
      </p>
      <p>
        -- <a href="GrahamHughes.html">GrahamHughes</a>
      </p>
      <hr/>
      <p>
        As a practical matter, I don't see how you can "make it easy for programmers to use what ever language they like for programming it".
      </p>
      <p>
        First, Emacs is largely <em>written in </em><a href="LispLanguage.html">LispLanguage</a>,<em> and so </em><a href="EmacsLisp.html">EmacsLisp</a> ties together customized modules with the basic Emacs code.  If you want to make an editor that can be programmed in any language, and I want to write some customization module in Lisp, while you want to write a module in <a href="CeePlusPlus.html">CeePlusPlus</a> that calls some function in my module, how will the two interoperate?  You'll end up with one of the following: (a) one language that is, for all practical purposes, the privileged language for extending the editor, in the way that <a href="CeeLanguage.html">CeeLanguage</a> is the privileged language for <a href="UnixOs.html">UnixOs</a>; (b) a nightmarish confusion of cross-language calling conventions; (c) every module restricted to using a lowest-common-denominator subset of its language when calling external functions.
      </p>
      <p>
        Second, if you have minimal programming skill and you want to write extensions to Emacs, your main challenges will be understanding how Emacs "views the world" (e.g., what "mark" and "point" are, and which <a href="DataStructure.html">DataStructure</a>s and functions within Emacs allow you to manipulate them), and then deciding how to map this view onto the task you want to accomplish.  Compared with these challenges, the challenge of learning Lisp syntax (and such cryptic primitives as "car" and "cdr") is trivial.  Giving the programmer a choice of extension languages will deal with the trivial challenge without touching the big ones. -- <a href="SethGordon.html">SethGordon</a>
      </p>
      <p>
        <em>(See...  You just need to use </em><a href="MicroSoft.html">MicroSoft</a>'s <a href="DotNet.html">DotNet</a> architecture: <a href="DotNet.html">DotNet</a> has a common runtime, and all languages are interoperable.  Use ActiveX scripting for access to all available scripting languages. ;-)<em></em>
      </p>
      <p>
        First, this isn't about updating emacs, but rather replacing it with something that not only programmers would like, but that normal people would like also.
      </p>
      <p>
        I know what you mean about learning lisp.  I already knew a fair share of lisp, but I have a terrible time trying to update emacs to work the way I want.
      </p>
      <p>
        Anyway, accomplish the above goals, a more comprehensive API than what emacs provides would be needed.  See that <a href="ObjectOriented.html">ObjectOriented</a> API is on the list.  Hopefully that would help clean up confusion as to how things work, and what relates to what at least a little.  I agree that changing languages doesn't solve everything, but it would be nice.
      </p>
      <p>
        <em>Perhaps someone could say something about why "</em><a href="NormalPeople.html">NormalPeople</a>" need something like emacs.  I'm not saying they don't, but I'm not clear on why they do either.<em></em>
      </p>
      <hr/>
      <p>
        <em>First, this isn't about updating emacs, but rather replacing it with something that not only programmers would like, but that normal people would like also.</em>
      </p>
      <p>
        The two sets of people have markedly different psychologies and radically different needs.  I think it would be a mistake to try to make one tool to fit both types of brain.
      </p>
      <hr/>
      <p>
        Normal users keep expecting us to be experts at their damn tools to help them.
      </p>
      <p>
        <strong>"Help me with Word!"</strong>  <em>"I'm sorry, I haven't used Word in over a year because I do my word processing in Emacs."</em> <strong>"What the hell is Emacs, and I thought you were supposed to be good with computers?"</strong>
      </p>
      <p>
        Is it too much to ask that their tools be good enough for us to use so that we will actually have a reason to be familiar with them?
      </p>
      <p>
        And are they really that different anyway?  Anyone who knows the <a href="PicoEditor.html">PicoEditor</a> is OK in emacs with the help of a cheat sheet at first, and anyone who can use <a href="NotePad.html">NotePad</a> can figure out how to use pico.  And Notepad is actually easier than <a href="MicrosoftWord.html">MicrosoftWord</a>. That said, the average user can't seem to wrap their brains around typing \emp{} in their documents.  Hence the need for a rich text option.  We don't want users to have WYSIWYG (<a href="WhatYouSeeIsWhatYouGet.html">WhatYouSeeIsWhatYouGet</a>) though, since that leads to ugly documents.  And we do want strongly enforced styles that can be hotkey between.
      </p>
      <p>
        <em>Is that what users want, or what we wish they wanted?  From what I've seen, users want </em>exactly<em> the "ugly" documents they're making.</em>
      </p>
      <p>
        Depends who you mean by "users". I suspect that most institutions end up requiring the use of the company stylesheet or whatever, at least for stuff circulated externally (I know we do). For personal use, of course people want the freedom to personalise their documents, and since mainstream use of computers is now entirely fixated upon presentation rather than content, that means picking their own fonts and colours, even though it looks awful.
      </p>
      <hr/>
      <p>
        Emacs is a good tool for writing new editors in. You don't have to present
        all of Emacs to a user. You can just present a tiny editor, or a tiny editor
        and a simple mail and news reader. (Except the executable will be big! Room to grow. Or maybe you just want to do prototypes in Emacs.)
      </p>
      <hr/>
      <p>
        Emacs provides facilities to do everything you are asking for, except you have to do it in Lisp.  However, Lisp is powerful enough to write an interpreter for another language.  <strong>Therefore</strong>: write an interpreter for a "normal"-user-friendly language (let's call it EBasic for arguments sake) in elisp (<a href="EmacsLisp.html">EmacsLisp</a>), allow EBasic to make calls to elisp functions, and only expose "normal" users to EBasic.
      </p>
      <p>
        <em>Sounds like quite a challenge - writing a basic interpreter in Lisp without deciding to abandon BASIC in favour of Lisp in the process.. :-)</em>
      </p>
      <p>
        Hehe... I was being somewhat ironic.  However, it's probably a lot easier than attempting to rewrite Emacs without deciding to abandon the task in the process in favour of Emacs!
      </p>
      <hr/>
      <p>
        For those of you interested in extending Emacs without using <a href="EmacsLisp.html">EmacsLisp</a>,
        <a href="PerlLanguage.html">PerlLanguage</a> is now an option. -- <a href="JohnBeppu.html">JohnBeppu</a>
      </p>
      <ul>
        <li>
           <a href="http://search.cpan.org/search?dist=Emacs-EPL">http://search.cpan.org/search?dist=Emacs-EPL</a>
        </li>
      </ul>
      <p>
        I don't know a whole lot about Emacs::EPL, though. I'm normally a <a href="VimTextEditor.html">VimTextEditor</a>
        user who happens to really like perl.
      </p>
      <hr/>
      <p>
        Same for <a href="PythonLanguage.html">PythonLanguage</a> with PyMacs. I wish someone would write HaMacs for <a href="HaskellLanguage.html">HaskellLanguage</a>. -- <a href="ShaeErisson.html">ShaeErisson</a>
      </p>
      <p>
        The <a href="EmacsWiki.html">EmacsWiki</a> has a page devoted to alternative extension languages for Emacs (<a href="http://www.emacswiki.org/cgi-bin/wiki.pl?CategoryExtensionLanguage).">http://www.emacswiki.org/cgi-bin/wiki.pl?CategoryExtensionLanguage).</a> Also see <a href="EmacsInFooLanguage.html">EmacsInFooLanguage</a>.
      </p>
      <hr/>
      <p>
        <a href="CategoryEmacs.html">CategoryEmacs</a>
      </p>
    </div>
  </body>
</html>