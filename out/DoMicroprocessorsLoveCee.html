<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Do Microprocessors Love Cee
      </h1>
      <p>
        Discussion moved from <a href="SufficientlySmartCompiler.html">SufficientlySmartCompiler</a>
      </p>
      <hr/>
      <p>
        On the one hand it is argued that <a href="CeeLanguage.html">CeeLanguage</a> earns its reputation of speed (<a href="AsFastAsCee.html">AsFastAsCee</a>) from its closeness to assembly and to its maturity, allowing refinement of compiler optimizations. Therefore, it would be hard for any other language to achieve the same level of performance without matching general hardware better. For the purposes this discussion we are talking about "real" compiled C, not <a href="DotNet.html">DotNet</a> C or <a href="CeeSharp.html">CeeSharp</a>.
      </p>
      <p>
        On the other hand it is argued that the above is a self-fulfilling prophecy: <a href="CeeLanguage.html">CeeLanguage</a> is fast because processors are tuned to execute C efficiently. It is noted that "the Intel 8086 line of CPUs are optimized for accessing local variables on the stack, as is common in Algol-derivative languages, like C."  and that "Much of the design philosophy behind RISC is geared towards executing the output of C compilers efficiently.  Many addressing modes that assembly-programmers loved but weren't used in compilers got axed. ". 
      </p>
      <p>
        It is even speculated that C syntax is "so close to the PDP-11 instruction set, it's scary", which implies a relation between the two. However, as told by <a href="DennisRitchie.html">DennisRitchie</a> (<a href="http://cm.bell-labs.com/cm/cs/who/dmr/chist.html):">http://cm.bell-labs.com/cm/cs/who/dmr/chist.html):</a>
      </p>
      <dl>
        <dt> </dt>
        <dd> "People often guess that they were created to use the auto-increment and auto-decrement address modes provided by the DEC PDP-11 on which C and Unix first became popular. This is historically impossible, since there was no PDP-11 when B was developed."</dd>
      </dl>
      <p>
        Even the alleged similarity between PDP-11 assembly and C is apparently "a folk myth, pure and simple, which continues propagating because its a handy sound bite, not because there is any truth to it whatsoever."
      </p>
      <p>
        There is the assumption that <a href="LispMachine.html">LispMachine</a>s or processors tuned to <a href="AplLanguage.html">AplLanguage</a> probably would execute these languages <a href="FasterThanCee.html">FasterThanCee</a>. From the previous discussion:
      </p>
      <dl>
        <dt> </dt>
        <dd> <em>That said, the low-level nature of C (and not just "processors being tuned to execute C") is what makes it fast. Executing C code on a </em><a href="LispMachine.html">LispMachine</a> (or any other architecture designed to efficiently execute code written in a <a href="HighLevelLanguage.html">HighLevelLanguage</a>) would suck; as emulating C in a HLL is an <a href="AbstractionInversion.html">AbstractionInversion</a> and an inefficient one at that.  Emulating a HLL on a low-level language like C, on the other hand, is commonplace and well-known.<em></em></dd>
      </dl>
      <p>
        <em>But "These CPUs are designed to provide direct hardware support for programs written in high-level languages such as Pascal-86 and Intel's PL/M-86"</em> APX 86/88, 186/188 User's Manual, Programmers's Reference, 2-1. <em>Perhaps the 8088 really did not love C? And the jump instructions for the 8x86 family favour -1 for true instead of +1...</em>
      </p>
      <p>
        x86 jumps favor checking either for -1 or for 0, so C's use of +1 and 0 for <a href="BooleanRepresentation.html">BooleanRepresentation</a> doesn't impact performance of branches.  I really do wish that they'd used -1 for true though, so that you can use bitwise-AND to <em>compute</em> various things based on a set of booleans.  For example, in <a href="ForthLanguage.html">ForthLanguage</a>, which does use -1 for true, you can do this:
      </p>
      <code>
        : handleKey ( ch -- )<br/>
        inInsertMode? ['] insertCharacter and inCommandMode? ['] executeCommand and or execute ;<br/>
      </code>
      <p>
        The 80286 and earlier CPUs did have some complex instructions to facilitate block-structured, Algol-ish languages.  However, they had no particularly-obvious-made-for-C instructions like the 80386 and later has.
      </p>
      <hr/>
      <p>
        original contributors included <a href="JeffGrigg.html">JeffGrigg</a> and others.
      </p>
      <hr/>
      <p>
        See <a href="AlternativeMicroprocessorDesign.html">AlternativeMicroprocessorDesign</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryCee.html">CategoryCee</a>
      </p>
    </div>
  </body>
</html>