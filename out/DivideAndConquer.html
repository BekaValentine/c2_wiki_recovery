<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Divide And Conquer
      </h1>
      <p>
        A common <a href="ProblemSolvingHeuristic.html">ProblemSolvingHeuristic</a> in which the problem is split into two or more smaller problems which are solved separately. Often, these sub-problems can further be divided until solving each one is trivial. The sub-solutions are then combined to generate the solution to the original problem.
      </p>
      <p>
        Anyone got a more technical definition?
      </p>
      <p>
        <em>I'd emphasize that you can recursively use the same algorithm on the smaller problems. As the definition above reads, it leaves open the possibility that you can first divide a problem and then apply a different algorithm to those smaller problems.</em>
      </p>
      <hr/>
      <p>
        Actually, the same algorithm is typically not applied all the way down to the base case. For example with
        quicksort once you get down to 2 elements, you do not recursively apply quicksort. Or with efficient matrix
        multiplication, once your matrices are broken down to small (say 2x2) matrices, you use some other
        very efficient method to multiply them. (This is how matrix multiplication got down under O(n^3): Strassen
        figured out how to multiply 2 2x2 matrices using 7 multiplications instead of 8.) This is typical in the
        analysis of algorithms, and in the subsequent implementation. The analysis results in a recurrence relation
        with a known base case. The base case is solved using special purpose knowledge / code, not the logic
        that "solves" the bigger cases (by dividing them).
      </p>
      <p>
        <em>I think there may be a misconception here. The reason Strassen's trick leads to an o(n^3) algorithm is that you use the 7-multiplication 2x2 matmult at every node in the tree, not just at the leaves. In fact, once your matrices get small enough you would certainly not use the 7-multiplication method, because it involves a larger number of additions and subtractions.</em>
      </p>
      <p>
        Also of interest, possibly, is the <a href="MultiplyAndSurrender.html">MultiplyAndSurrender</a> approach, described in a very amusing SIGACT
        article in 1984 by A Broder and J Stolfi
      </p>
      <p>
        <a href="DivideAndConquer.html">DivideAndConquer</a> is more general than just algorithms. There's no need to restrict it to using the same recursive algorithm. <a href="DivideAndConquer.html">DivideAndConquer</a> applies to such things as war and capitalism, for instance, where the notion of 'algorithm' is pretty much moot.
      </p>
      <hr/>
      <p>
        <a href="DivideAndConquer.html">DivideAndConquer</a> may not always result in a correct solution, especially for VeryLargeScale systems -- when the inter-relationships between the subdivided components becomes sufficiently complex.  In this case, the <a href="MetaModel.html">MetaModel</a> comprised of the components must itself be scrutinized as a separate problem.
        --<a href="KirkKitchen.html">KirkKitchen</a>
      </p>
      <hr/>
      <p>
        <a href="DivideAndConquer.html">DivideAndConquer</a> is often misapplied in organizational situations.
        The application results from the fallacious belief that if you break an organization
        into several pieces, and ask each piece to do its part of the whole job as well as
        it can, those requests will automatically result in the whole job being done well.
      </p>
      <p>
        Sometimes, it results in the whole job being done very poorly.  For example,
        I once heard about an engineer in a large electronics manufacturing company
        who developed a chip set that would reduce the cost of making a color TV set
        by a factor of two.  The company ultimately refused to use the new chip set in
        its own products, because it had no second source.
      </p>
      <p>
        In this example, the people who decided that all critical components must be
        multiple sourced were merely trying to minimize the risk to which their actions
        directly exposed the company.  They didn't care about risks of inaction, as those
        risks would fall on other organizations rather than on them.
      </p>
      <p>
        I am looking for a good name for this phenomenon.  The best I've found so far is
        DivideAndBotch.  Other suggestions are welcome.
      </p>
      <p>
        <em></em>BirthInThreeMonths: If you get 3 women instead of one to work on the job of carrying a baby, then you can give birth after only 3 months instead of the usual 9.<em></em>
      </p>
      <p>
        --<a href="AndrewKoenig.html">AndrewKoenig</a>
      </p>
      <p>
        Hmm, I'm on your wavelength. How about DivideAndFalter (has same meter and sorta rhymes), DivideAndSurrender, DivideAndRetreat. <a href="MultiplyAndSurrender.html">MultiplyAndSurrender</a> might be relevant.
      </p>
      <hr/>
      <p>
        Let's not forget <a href="DynamicProgramming.html">DynamicProgramming</a> as another technique where <a href="DivideAndConquer.html">DivideAndConquer</a> fails in algorithm design. -- <a href="RobertField.html">RobertField</a>
      </p>
      <p>
        Still, as a heuristic, <a href="DivideAndConquer.html">DivideAndConquer</a> is very general and often very powerful.
      </p>
      <hr/>
      <p>
        As a simple example, <a href="DivideAndConquer.html">DivideAndConquer</a> is an excellent meta-debugging technique. Imagine you have a large legacy function that is screwing up somewhere, and the only debugging tool you have is print statements. The naive approach is to spend 20 minutes putting in 100 print statements. The <a href="DivideAndConquer.html">DivideAndConquer</a> approach is to put one print statement in the middle of the function and test to see if the code reaches it. If it doesn't, put another print halfway between the beginning and the middle. If it does, put the next print halfway between the middle and the end. Repeat until the section you've narrowed it down to is small enough that you can put print statements between each line. Total time: 3-5 minutes depending on the length of the modify-compile-run cycle.
      </p>
      <p>
        Even if you have more modern debugging tools, you can often apply <a href="DivideAndConquer.html">DivideAndConquer</a> with those (hence meta-debugging). For example, you could replace print statements with breakpoints in the above example. Sometimes, especially with <a href="LegacyCode.html">LegacyCode</a>, I'll resort to commenting out huge chunks of code in an effort to locate a bug via <a href="DivideAndConquer.html">DivideAndConquer</a>. This is surprisingly effective.
      </p>
      <p>
        <a href="BinarySearch.html">BinarySearch</a> is a good example of <a href="DivideAndConquer.html">DivideAndConquer</a>
      </p>
      <hr/>
      <p>
        But see <a href="RefactorLowHangingFruit.html">RefactorLowHangingFruit</a> and <a href="ConquerAndDivide.html">ConquerAndDivide</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryRefactoring.html">CategoryRefactoring</a>
      </p>
    </div>
  </body>
</html>