<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Multi Paradigm Programming Language
      </h1>
      <p>
        <a href="ProgrammingLanguage.html">ProgrammingLanguage</a> with (language) support for multiple <a href="ProgrammingParadigm.html">ProgrammingParadigm</a>s. Examples would be <a href="CommonLisp.html">CommonLisp</a>, RacketScheme, <a href="OzLanguage.html">OzLanguage</a>, <a href="ObjectiveCaml.html">ObjectiveCaml</a>, Delphi, <a href="ScalaLanguage.html">ScalaLanguage</a> and (debatably) <a href="CeePlusPlus.html">CeePlusPlus</a>.
      </p>
      <hr/>
      <p>
        The comment that <a href="CeePlusPlus.html">CeePlusPlus</a> is "less so" a multi-paradigm was deleted. However, this was not meant as a value judgement, but rather as a technical point.
      </p>
      <p>
        C++ supports imperative programming, and it has an OO with good language support. It has very primitive support for genericity (via templates).
      </p>
      <p>
        On the other hand, CL has good support for functional, OO, and even imperative styles. It also has extremely powerful generic constructs, and can be used to build 'mini-languages' with pretty much any semantics you want. Hence strictly speaking it is more "multi-paradigm" than C++.
      </p>
      <p>
        There are trade-offs, of course, which is why the statement was not meant as a condemnation of C++. The <a href="CommonLispObjectSystem.html">CommonLispObjectSystem</a> is one of the most powerful OO approaches existent, however it can leave much to be desired on the performance front. C++ OO may seem a bit strange to someone coming from the OO community, but it is both useful and fast...
      </p>
      <p>
        <em>C++ can be effectively used as a </em><a href="FunctionalProgrammingLanguage.html">FunctionalProgrammingLanguage</a>. The template mechanism is a lazy FPL in its own right (perhaps not a <strong>good</strong> one), and many libraries (parts of <a href="BoostLibraries.html">BoostLibraries</a>, etc.) exist which make functional programming easier in C++. The ability to overload operator () makes <a href="HigherOrderFunction.html">HigherOrderFunction</a>s easy to implement in C++. The standard library consists of most of the "standard" HOFs.<em></em>
      </p>
      <p>
        <em>That said, a few things limit C++'s effectiveness as a FPL.</em>
      </p>
      <ul>
        <li>
           <em>No </em><a href="GarbageCollection.html">GarbageCollection</a>.  Creation of lots of lambdas benefits tremendously from having a <a href="GarbageCollector.html">GarbageCollector</a> around; tracking these manually is a pain.<em></em>
        </li>
        <li>
           <em>No mandatory </em><a href="TailCallOptimization.html">TailCallOptimization</a>, for those who prefer recursive algorithms over iterative algorithms.  Some C++ compilers will perform this optimization; but there is no way to express it in the language.<em></em>
        </li>
        <li>
           <em>Some will say the presence of </em><a href="SideEffect.html">SideEffect</a>s in C++ (variables and data members are mutable by default, unless you declare them const) is a detriment.<em></em>
        </li>
        <li>
           <em>Its type system, while powerful, isn't as powerful as those found in the ML and Haskell families.</em>
        </li>
      </ul>
      <p>
        <em>See also </em><a href="FunctionalProgrammingInCpp.html">FunctionalProgrammingInCpp</a>, <a href="LogicProgrammingInCpp.html">LogicProgrammingInCpp</a><em></em>
      </p>
      <hr/>
      <p>
        Possibly the best example of a multi-paradigm language is <a href="ObjectiveCaml.html">ObjectiveCaml</a>; an <a href="MlLanguage.html">MlLanguage</a> variant that supports object oriented and functional programming. The compiler implementation matches the speed of a typical C++ compiler. <a href="ObjectiveCaml.html">ObjectiveCaml</a> is worth looking at if you think the problem with C++ is the lack of a really thorough static type system - I don't, and given the Wiki's XP emphasis I doubt you will either, but <a href="ObjectiveCaml.html">ObjectiveCaml</a> is still an impressive achievement.
      </p>
      <p>
        -- <a href="JonCoupe.html">JonCoupe</a>
      </p>
      <p>
        The <a href="OzLanguage.html">OzLanguage</a> is another example of a multi-paradigm language.
      </p>
      <hr/>
      <p>
        I always say about the <a href="ToolCommandLanguage.html">ToolCommandLanguage</a> that fundamentally it doesn't support any particular paradigm, you just [package require] the one you like. That is quite obvious from the very wide range of different OO packages, as well as some other paradigms like AOP (I also seem to remember seeing some kind of 'frame' based package somewhere). -- Setok
      </p>
      <hr/>
      <p>
        <a href="PythonLanguage.html">PythonLanguage</a> and <a href="RubyLanguage.html">RubyLanguage</a> seem particularly good at allowing you to mix and match structures within a single language. The "default" (the way we write <a href="HelloWorld.html">HelloWorld</a>) is procedural, but it feels equally natural to write OO or functional or reflective programs.
      </p>
      <hr/>
      <p>
        <a href="LuaLanguage.html">LuaLanguage</a> is also very accommodating of multiple paradigms. A major design principle of the language is to keep it small and flexible by providing a few meta-features that let you build other features into the language, rather than cluttering the core with them. Adding <a href="LazyEvaluation.html">LazyEvaluation</a> or <a href="PrototypeBasedProgramming.html">PrototypeBasedProgramming</a>-style OO to the language can be done in less than a page of code, for example. (It also has <a href="TailCallOptimization.html">TailCallOptimization</a>, unlike Python, which makes it easier to add things via <a href="ContinuationPassingStyle.html">ContinuationPassingStyle</a>.) -- <a href="ScottVokes.html">ScottVokes</a>
      </p>
      <p>
        <em></em><a href="LuaLanguage.html">LuaLanguage</a> is hardly a prototypical example, but I agree that it can support imperative, prototype-based OO, and some functional programming. <a href="JavaScript.html">JavaScript</a> can do the same.<em></em>
      </p>
      <p>
        Right. I think <a href="ObjectiveCaml.html">ObjectiveCaml</a> or <a href="OzLanguage.html">OzLanguage</a> are more overtly multiparadigm, but Lua is both flexible and un-opinionated by design. <a href="JavaScript.html">JavaScript</a> has a lot in common with Lua, but while its design was frozen due to the browser wars, Lua had much longer to mature. I think it's a far better designed language. It seems to me that they were going in the same direction, though. -- <a href="ScottVokes.html">ScottVokes</a>
      </p>
      <p>
        {Being "too meta" may have downsides. See <a href="LispIsTooPowerful.html">LispIsTooPowerful</a>.}
      </p>
      <hr/>
      <p>
        See <a href="MultiParadigmDesign.html">MultiParadigmDesign</a>, <a href="MultiParadigmProgramming.html">MultiParadigmProgramming</a>, <a href="MultiParadigmDatabase.html">MultiParadigmDatabase</a>, <a href="MultiParadigmWeenie.html">MultiParadigmWeenie</a>, <a href="LetsDesignProgrammingLanguage.html">LetsDesignProgrammingLanguage</a>
      </p>
      <p>
        Also see <a href="ObjectFunctional.html">ObjectFunctional</a>.
      </p>
      <hr/>
      <p>
        <a href="CategoryMultiparadigm.html">CategoryMultiparadigm</a>
      </p>
    </div>
  </body>
</html>