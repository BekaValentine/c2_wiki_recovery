<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Document Definitions
      </h1>
      <p>
        <a href="DocumentDefinitions.html">DocumentDefinitions</a> is a simple set of reference definitions (associated with the document-based model for <a href="UserInterface.html">UserInterface</a>s) for use in other pages that reference this one, without introducing a page-per-definition (since <a href="WikiIsNotaDictionary.html">WikiIsNotaDictionary</a>). This page gives reasonably precise <em>working-definitions</em> to several words associated with documents, interfaces, and features associated with them that might otherwise be too fuzzy for distinction. 
      </p>
      <p>
        You are not expected to agree with the following definitions, only to understand them in their context and resist pointless <a href="LaynesLaw.html">LaynesLaw</a> battles. That said, the definitions do attempt to remain reasonably consistent with the common use of words.
      </p>
      <p>
        <strong>document:</strong> a presentation of information and options designed for consumption by humans, with a default bias towards two-dimensional static visual presentations of text and graphics.  The 'document' concept extends in general to the auditory and temporal dimensions (as per: sounds, animations, music, video) designed for consumption by humans, and could presumably be extended to other senses. Documents tend to be composable and decomposable, and as a consequence the boundaries between them are arbitrary and are often chosen for convenience to the discussion at hand. Sensors, actuators, commands, queries, processes, and protocols are examples of things that are not documents, though information about these things can be presented in documents.
      </p>
      <p>
        <strong>active:</strong> A document is <em>active</em> if it presents input options to a human operator. Traditional input options include push-buttons, knobs, sliders, toggles and radio-buttons, text-fields, menus, and drawing canvases. These options are designed largely around the common input devices - mouse and keyboard. However, one can provide activity in other ways: gestures, drag-and-drop, context menus, focus, hooking joysticks and microphones and cameras, command-lines, etc. Degree-of-activeness can be measured in terms of spatial properties (e.g. percentage of document supporting user input) and logic costs (fraction of document definition associated with presenting or providing input options, but not to processing the actual inputs). 
      </p>
      <p>
        <strong>live:</strong> A document may be <em>live</em>, in which case it <em>automatically</em> reflects updates to external systems - specifically excluding user input - over time. Example features include dials, gauges, lights, rolling text, progress bars, alert-icons, changing text, pop-ups. Examples of live documents include RSS feeds, web cameras, stock tickers, etc. Liveness can be measured in degrees in terms of reactivity (e.g. latency between an update to a system and its corresponding update in the document), spatial properties (percentage of document subject to update). 
      </p>
      <p>
        <strong>static:</strong> A document that is neither live nor active is <em>static</em>. Static documents might still be subject to update, but said updates won't be seen automatically. Static documents can still be temporal in nature (such as sounds, movie clips, and animations). A bit stronger than 'static' document is a <strong>dead</strong> document, which will never see updates. Documents tend to become <em>dead</em> through neglect, completion, or versioning.
      </p>
      <p>
        <strong>interactive:</strong> A document is <em>interactive</em> if it is active <em>and</em> there is a causal feedback loop such that activities cause changes to the document. Interactive documents don't need to be live (as evidenced by simple calculators, simple video-games, etc.). 
      </p>
      <p>
        <strong>interface:</strong> A document is an <em>interface</em> if it is active <em>and</em> the activity causes a command to an external system. Doesn't imply live feedback as part of the document. Interfaces without feedback are often applied usefully when the external system being controlled is within visual or auditory range of the operator. The degree to which a document is an interface is determined both by how active it is and how many activity options influence the external system as opposed to modifying the presentation of the document.
      </p>
      <p>
        <strong>live interface:</strong> an interactive interface document such that at least one bit live feedback is causally influenced by external systems that are causally influenced by activities. I.e. there exists a causal interactive loop via influence on external systems, as opposed to 'document local' feedback loops.
      </p>
      <p>
        <strong>document definition:</strong> A complete, serialized representation for a document. Document definitions are immutable, but that fact does not hinder liveness (which may be achieved through keeping a document definition up-to-date relative to its source document-object or through the document composing external data-sources such as other document-objects).
      </p>
      <p>
        <strong>document object:</strong> A service that, upon request, provides a document definition. The traditional example of a document-object is a file, but documents can just as easily be requested from live systems, and it isn't unreasonable to even treat queries to databases as 'document objects'. 'Document object' in the purest sense should be understood as possessing 'universal identity', such that two distinct requests for the document object without any intermediate updates to the object can be guaranteed to return the same document definition. (Caching and other practices relax this purity in order to improve performance, but understanding 'uniqueness' of document objects still remains important to understanding the document-based <a href="UserInterface.html">UserInterface</a> model.) Document objects give <em>identity</em> to documents. For example, concepts such as <em>create, update, delete, history, versioning, difference, </em><a href="DataDeltaIsolation.html">DataDeltaIsolation</a>, and subscription<em> are not relevant for document definitions but are meaningful when applied to a document objects.</em>
      </p>
      <p>
        <strong>document server:</strong> A service that, upon request, provides or creates+provides a document object. That might sound incredibly generic, but this definition is meant to be interpreted in a rather literal sense: (a) the <em>provides "or" creates+provides</em> MUST be a decision that can (at least potentially, unhindered by protocol and semantics) be made <em>"upon request"</em>, (b) it <em>provides a "document object"</em>, as opposed to returning a <em>document definition</em>, which means the return value from this request is an identifier for a document object (generally a URI). With that clarification it might sound too narrow, but it is acceptable to view <em>"returning a document definition with an implicit order to 'clone' with a new 'self' identity"</em> to be a mechanism for creating+providing a document object, at least so long as said document object arguably has independent identity. Under this definition of <em>document server</em>, a traditional <a href="FileSystem.html">FileSystem</a> or FTP server doesn't qualify as a document server (since <a href="FileSystem.html">FileSystem</a>s are traditionally not supposed to create documents upon request), but any modern <a href="WebServer.html">WebServer</a> certainly qualifies (with Dynamic HTML and forms being 'new documents' - <a href="TiddlyWiki.html">TiddlyWiki</a> is an extreme example of how such divergence can occur). This definition for 'document server' makes distinctions that are irrelevant until considering multi-user environments, the possibility of shared forms, and issues of <em>divergence</em> that are more significant than merely being out-of-date with the source.
      </p>
      <p>
        <strong>shell:</strong> a framework and <a href="LayerOfIndirection.html">LayerOfIndirection</a> that mediates between an <em>application</em> and an <em>application platform</em> to produce a <a href="UserInterface.html">UserInterface</a>. Part of the application model of <a href="UserInterface.html">UserInterface</a>s. While "shell" in common vernacular refers to the <a href="CommandLineInterface.html">CommandLineInterface</a>, shells may also be graphical in nature (Windows Shell, Gnome, KDE). The indirection enables a great number of features, such as consistency and stylizations and multiplexing of some user input.
      </p>
      <p>
        <strong>application:</strong> a program that produces a usually interactive <a href="UserInterface.html">UserInterface</a> via interaction with a <em>shell</em>. Applications are often distinguished based on the frameworks against which they were written, such as 'command line application' vs. 'Win32 application' vs. 'MFC application'. However, <em>application</em> is mentioned here to distinguish the application model for <a href="UserInterface.html">UserInterface</a> from the document model for <a href="UserInterface.html">UserInterface</a>. An overview of the most relevant differences (and the reasons for their relevance) is at the bottom of the page.
      </p>
      <p>
        <strong>application platform:</strong> the platform atop which application programs are built. Usually refers to an <a href="OperatingSystem.html">OperatingSystem</a>, a <a href="VirtualMachine.html">VirtualMachine</a>, or a <a href="WebBrowser.html">WebBrowser</a>.
      </p>
      <p>
        <strong>browser:</strong> a browser is a <a href="UserInterface.html">UserInterface</a> service that provides meaningful interaction and navigation within a system of objects. A 'document browser' would be a browser that is targeted to interact with document objects, but there are other sorts of browsers (<a href="ObjectBrowser.html">ObjectBrowser</a>, <a href="FileSystem.html">FileSystem</a> browser). Assuming a document browser, the primary "meaningful interactions" would include display of documents, keeping said display up-to-date, zooming, navigation between documents, support a multi-tasking user by allowing multiple documents to be displayed simultaneously, multiplexing user inputs for activity between and within documents, and sending appropriate command-messages as a consequence of said activity based on object definitions. 
      </p>
      <p>
        In the 'pure' sense, a mere 'document browser' should not have any responsibility for maintaining or hosting document objects. 
      </p>
      <p>
        However, a typical <a href="WebBrowser.html">WebBrowser</a> also shoulders this responsibility due to Dynamic HTML and forms. Hosting document objects introduces a significant amount of complexity. As two examples, one now needs a document object model, there are 'concerns' for such issues as persistence and recovery that simply don't exist if all document objects are hosted externally, and so on. Introducing this extra responsibility essentially to a document browser essentially forces the browser to serve a dual role as an <em>application platform</em>.
      </p>
      <p>
        <strong>document object model:</strong> A language for selectively identifying parts of a document definition. A necessary prerequisite for allowing a language to <em>manipulate</em> parts of a document definition. A document object model (or more than one) is used in <a href="DataDeltaIsolation.html">DataDeltaIsolation</a> and for allowing browsers to act as application platforms (host documents and accept commands to update said document). The 'trivial' document object model is simply to treat each document as the sequence of bits used to serialize the document definition, but this model is rather difficult to program against. '<a href="DocumentObjectModel.html">DocumentObjectModel</a>' with capital letters refers more specifically to the W3C standardized <a href="DocumentObjectModel.html">DocumentObjectModel</a> for XHTML and XML.
      </p>
      <hr/>
      <p>
        Comparison between Application and Document models.
      </p>
      <p>
        Application Model for <a href="UserInterface.html">UserInterface</a>
      </p>
      <p>
        Entities
      </p>
      <ul>
        <li>
           shell: instance of running interaction with shell framework
        </li>
        <li>
           application: program that interacts with shell to produce UI and with platform to provide other service
        </li>
        <li>
           platform: instance of <a href="OperatingSystem.html">OperatingSystem</a>/<a href="VirtualMachine.html">VirtualMachine</a>/<a href="WebBrowser.html">WebBrowser</a> on a particular computer 
        </li>
      </ul>
      <p>
        Relationships:
      </p>
      <ul>
        <li>
           shell---application (1 to M, with rare exceptions)
        </li>
        <li>
           shell---platform (N to M)
        </li>
        <li>
           application---platform (N to 1)
        </li>
        <li>
           application---protocol---application (N to K to M (K usually 1), e.g. RTP, database, filesystem)
        </li>
        <li>
           platform---protocol---platform (N to K to M (K usually small), e.g. TCP/IP, filesystems)
        </li>
      </ul>
      <p>
        Properties:
      </p>
      <ul>
        <li>
           No shell---shell relationships. E.g. no linking, embedding, inheritance, or other composition of UI between applications.
        </li>
        <li>
           Composition of applications and platforms occurs indirectly through protocol stacks, of which there are a <em>great</em> many. Protocols allow hooking applications together when you can figure out their name (capability) and you happen to support common protocols. Name distribution is a challenge. Arbitrary composition of applications is also a big challenge due to the common need for one of the two applications to be upgraded with new protocols. (<a href="PluginArchitecture.html">PluginArchitecture</a> can help greatly with this protocol management.)
        </li>
        <li>
           Retained-mode GUI by default. In particular, the current set of relationships between the shell and the application generally cannot be regenerated and may contain information important to the logic of the program. E.g. whether an alert-box is displayed can be based on a prior event. Retained-mode makes testing, UI rewind and DVR capabilities, etc. a great challenge. It also makes it almost impossible to turn the shell 'off' then turn it back 'on' later and get it to a proper state; instead, the shell needs to be on all the time, which is severely problematic for scalability and <a href="ZoomableUserInterface.html">ZoomableUserInterface</a>. Applications <em>can</em> be made immediate-mode, but it takes <a href="SelfDiscipline.html">SelfDiscipline</a>.
        </li>
        <li>
           Retained-mode composition of applications, by default. That is, applications can't simply be disconnected by the OS then regenerate their connections on the fly as needed. Instead, most connections must remain live all the time. 
        </li>
        <li>
           Composition of applications is indistinguishable from composition of servers. This prevents some automated optimizations that involve running just the server portion, though this can still be done by hand (and often is done by hand).
        </li>
        <li>
           Applications are associated with a specific platform. Distribution and sharing occur only to the degree that the platform can be distributed and shared (or at least virtualized, as per <a href="VirtualNetworkComputing.html">VirtualNetworkComputing</a>). Currently, that degree is pretty small.
        </li>
        <li>
           Input to application comes from two sources: platform, and platform <em>via</em> shell. This means the shells cannot intelligently multiplex <em>all</em> user-input to applications, cannot prevent misinterpretation of inputs based on immediate user focus, and in general couldn't properly map all user-inputs to the application even if shells did happen to be composable. 
        </li>
        <li>
           No clean relationships to inject caching.
        </li>
      </ul>
      <p>
        Document Model for <a href="UserInterface.html">UserInterface</a> (pure, rejecting browser-as-application-platform)
      </p>
      <p>
        Elements:
      </p>
      <ul>
        <li>
           document browser: displays document definitions, keeps them up-to-date with document object
        </li>
        <li>
           document object: provides temporal identity, sharing, and subscription model for document definitions; 
        </li>
        <li>
           document server: any object that creates+provides document objects on request
        </li>
        <li>
           other objects: accept commands, cause behaviors.
        </li>
      </ul>
      <p>
        Relationships:
      </p>
      <ul>
        <li>
           document browser---document object (N to M, browsing and subscriptions, subject to caching)
        </li>
        <li>
           document object---document object (N to M, via embedding, linking, sharing)
        </li>
        <li>
           document object---document server (N to M, via a <em>request</em> commands plus a primitive navigate command)
        </li>
        <li>
           document object---other objects (N to M, via issuing commands, often <em>unidirectional</em>)
        </li>
        <li>
           other relationships between objects outside model (generally object---object is N to M)
        </li>
      </ul>
      <p>
        Properties:
      </p>
      <ul>
        <li>
           Fundamentally a <a href="RestArchitecturalStyle.html">RestArchitecturalStyle</a> (representational state distribution) + <a href="PublishSubscribeModel.html">PublishSubscribeModel</a> (to maintain state).
        </li>
        <li>
           Browsers are far more independent of one another than are typical applications. They do not compose, connect, or even know about one another.
        </li>
        <li>
           Browsers only need document definitions, not the full document object. This allows caching on the interaction between browsers and document objects. Such caching may improve performance and reduce bandwidth costs, and would certainly improve robustness after network failure. Subscriptions may also be cached, allowing many subscriptions to be reduced to one subscription at each network boundary (for up to exponential savings in total bandwidth). 
        </li>
        <li>
           <em>All</em> user-driven inputs to documents go through a browser, which offers much more control to the browser for remapping inputs and multiplexing inputs.
        </li>
        <li>
           All things other than browsers shared and distributed and composable by default. This sharing has a simple semantics: make everyone 'see' the same document at the same time (plus latency). With shared forms, for example, everyone would (eventually) see the same checkboxes marked and the same text in the text fields. With streaming music or video, everyone would be at the same place in the stream at the same time. Sharing by default is sensible for composition (esp. by embedding and inheritance), since composition of objects <em>implies</em> sharing of objects. To avoid sharing requires creating new documents.
        </li>
        <li>
           New documents are always introduced by command (requests to document servers), never by composition or linking. This allows composition to have consistent semantics, and the consistency in turn simplifies many optimizations. Compare HTML, where a (conceptually) 'new form' or 'new browser-application object' or 'new plugin object' can be introduced by use of plain-old-links, composed into iframes or <object></object> field, such that after 'composition' of documents what is actually available is a mishmash of old and new documents where the 'new' components cannot be faithfully shared, recomposed, or regenerated.
        </li>
        <li>
           <a href="ImmediateModeGui.html">ImmediateModeGui</a> for both browser and document composition. This allows the browser to disable and regenerate displays on the fly, as well as recover after a power failure or network disruption, making for a very robust display system. Subscriptions may be disabled and enabled on-demand without fear of missing 'events' and falling out of synch, and may do so without special consideration or design <em>within</em> the documents or servers. The ability to disable subscriptions and display and regenerate them at need is important for scalability and <a href="ZoomableUserInterface.html">ZoomableUserInterface</a>.
        </li>
      </ul>
      <hr/>
      <p>
        <a href="HtmlDomJsCss.html">HtmlDomJsCss</a> and WPF might be considered hybrid models of Application UI and Document UIs. 
      </p>
      <hr/>
      <p>
        Related: <a href="DeclarativeGui.html">DeclarativeGui</a>, <a href="AutomaticVsManualPlacement.html">AutomaticVsManualPlacement</a>, <a href="ObjectBrowser.html">ObjectBrowser</a>, <a href="CapabilityUserInterface.html">CapabilityUserInterface</a>, <a href="ZoomableUserInterface.html">ZoomableUserInterface</a>, <a href="KillerUserInterface.html">KillerUserInterface</a>
      </p>
    </div>
  </body>
</html>