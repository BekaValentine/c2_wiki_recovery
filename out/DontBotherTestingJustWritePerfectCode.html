<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Dont Bother Testing Just Write Perfect Code
      </h1>
      <p>
        A management <a href="AntiPattern.html">AntiPattern</a> wherein it is decreed (due to the usual schedule or budget pressures) that testing of the product will be rather limited in scope (or in the extreme case, not done at all); yet a high-quality product is expected.  The rationale for this apparent disconnect is the belief that quality should be <em>free</em>--a natural byproduct of development methodologies (see <a href="QualityIsNotFree.html">QualityIsNotFree</a> for more on this); and programmers who write buggy code simply are bad programmers.  This is an <a href="AntiPattern.html">AntiPattern</a> because:
      </p>
      <ul>
        <li>
           The main mechanism for programmers to <em>produce</em> quality code is--testing.  Formal methods and <a href="ProofOfCorrectness.html">ProofOfCorrectness</a> techniques have not advanced to the point where they are suitable for use in many programming tasks--and even then, these techniques still require iron-clad requirements specifications to verify the implementation against.  
        </li>
        <li>
           Programmers (good ones, at least) will invariably do testing anyway; they just might not tell you about it.  (A not unreasonable position to take; when I give the <a href="ProjectManager.html">ProjectManager</a> estimates; I don't break it down into time spent editing, compiling, linking, etc... why would I segregate out the <a href="UnitTest.html">UnitTest</a>s?)
          <ul>
            <li>
               However, final acceptance testing (including integration testing) may be compromised.  Some methodologies eschew or minimize this; but in my experience it is still important.  
            </li>
          </ul>
        </li>
        <li>
           Testing may be seen as overhead to be eliminated.  Part of this belief may be carryover from manufacturing, where fellows like <a href="WilliamEdwardsDeming.html">WilliamEdwardsDeming</a> and Crosby have shown that controlling processes to eliminate spoilage from being produced is more efficient in many cases then testing to detect it later (<a href="QualityIsFree.html">QualityIsFree</a>).  How much this observation (made in the context of the controllable and deterministic processes of a factory) applies to the creative and non-operational processes used in software design and implementation, is questionable.
          <ul>
            <li>
               <em>Isn't testing how developers prevent spoilage from being produced? Is there a better way?</em>
              <ul>
                <li>
                   In the manufacturing process, improved process control is used to prevent spoilage.  Many development methodolodies have tried to become an analog to process control in the software development realm, with far less success than we would like.  
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <p>
        In a job interview I was asked how I would respond to a developer that asked "Why do you write tests? Just write code with no bugs."  I floundered and eventually said "I'd need to go away and think about that one." It's a week later, and I knew the answer all along - it just took me a while to come up with it. Here's my answer:
      </p>
      <p>
        Maybe you can write perfect code, but over the lifetime of your code it's going to be looked at, and modified by, and copied by, many far lesser programmers. They will introduce bugs, because they can't write perfect code; your tests will help catch those bugs, and stop them going live. Further than that, you're making an invalid assumption: Testing is not (just) to catch bugs. People who do test-first development are being continually forced to answer the questions "What does this class do", "How will this class be used" and "Do I really need this class anyway". Such questions are extremely valuable to system design and so test first developers end up with more modular code, with better metrics for coupling and coherence, with greater maintainability. Oh, and fewer bugs.
      </p>
      <p>
        Now, can I wind the clock back a week so I can give this answer in my interview..?  --<a href="StuartScott.html">StuartScott</a>
      </p>
      <p>
        I'd reply, "How does one write code with no bugs?"  <em>Well, it's clearly a ridiculous position to take. But when you're trying to win business, and also to build relationships with your customers, then you need to avoid the ego bruising response of "Don't be daft!"</em>'
      </p>
    </div>
  </body>
</html>