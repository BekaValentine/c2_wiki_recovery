<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Come From
      </h1>
      <p>
        The opposite of a <a href="GoTo.html">GoTo</a> statement.
      </p>
      <hr/>
      <p>
        <strong>History</strong>
      </p>
      <p>
        Encountered on a list of joke assembly language instructions around 1971 by <a href="AlistairCockburn.html">AlistairCockburn</a>. (<<a href="http://www.fortran.com/fortran/come_from.html">http://www.fortran.com/fortran/come_from.html</a>>)
      </p>
      <p>
        Published in 1984.  From the C-<a href="InterCal.html">InterCal</a> manual (<<a href="http://www.muppetlabs.com/~breadbox/intercal-man/s04.html#4.14">http://www.muppetlabs.com/~breadbox/intercal-man/s04.html#4.14</a>>):
      </p>
      <dl>
        <dt> </dt>
        <dd>The earliest known description of the COME FROM statement in the computing literature is in R. L. Clark, "A Linguistic contribution to GOTO-less programming," Commun. ACM 27 (1984), pp. 349-350, part of the famous April Fools issue of CACM. The subsequent rush by language designers to include the statement in their languages was underwhelming, one might even say nonexistent. It was therefore decided that COME FROM would be an appropriate addition to C-INTERCAL.</dd>
      </dl>
      <p>
        In Donald Knuth's article 
        <strong>Structured Programming with go to Statements</strong>
        Donald E. Knuth
        December 1974 	  	
        ACM Computing Surveys (CSUR),  Volume 6 Issue 4 
      </p>
      <p>
        he mentions the COME FROM statement, and refers to the article mentioned above as:
      </p>
      <p>
        Clark, R. Lawrence. "A linguistic contribution to GOTO-less programming," <em>Datamation</em> <strong>19</strong>, 12 (December 1973), 62-63
      </p>
      <p>
        Implemented by C-INTERCAL (<<a href="http://www.muppetlabs.com/~breadbox/intercal/home.html">http://www.muppetlabs.com/~breadbox/intercal/home.html</a>>).
      </p>
      <hr/>
      <p>
        It got a wonderful new semantic in Threaded <a href="InterCal.html">InterCal</a>! The original Intercal stated:
      </p>
      <code>
        It is an error for more than one COME FROM <br/>
        to refer to the same (label).<br/>
      </code>
      <p>
        This restriction was suspended in Threaded <a href="InterCal.html">InterCal</a>.
      </p>
      <hr/>
      <p>
        <strong>Is </strong><a href="ComeFrom.html">ComeFrom</a> an <a href="ExceptionPattern.html">ExceptionPattern</a>?<strong></strong>
      </p>
      <p>
        <em>No</em>
      </p>
      <p>
        These references to exceptions as implementing <a href="ComeFrom.html">ComeFrom</a> surprise me.  I first encountered <a href="ComeFrom.html">ComeFrom</a> around 1971 on a list of joke assembler language instructions (along with "move and wrap core", and "move and wrap secretary").  I encountered it occasionally on such joke lists over the years, but never again until <a href="IvarJacobson.html">IvarJacobson</a> brought it up again as a way of implementing his 'extension' mechanism in <a href="UseCases.html">UseCases</a>.  Not everyone  in the room seemed to recognize that he was simultaneously saying extensions are not implementable.
      </p>
      <p>
        At the risk of describing the painfully obvious, exceptions do not say where they are coming from. In fact, that is their purpose in life - to <em>not</em> say where they are coming from.  <a href="ComeFrom.html">ComeFrom</a> has as its purpose in life exactly to state where it is coming from, although the named spot in the program is supposed to be blissfully unaware of it.  So <a href="ComeFrom.html">ComeFrom</a> and <a href="ExceptionHandling.html">ExceptionHandling</a> are about as different as you could ask for, you sure couldn't implement exceptions with <a href="ComeFrom.html">ComeFrom</a>.
      </p>
      <p>
        I just couldn't stand to watch silently any longer. -- <a href="AlistairCockburn.html">AlistairCockburn</a>
      </p>
      <p>
        <em>Very much so. "</em>ComeTo" is probably a more accurate description of an exception handler. To raise an exception, you "<a href="JustSayGo.html">JustSayGo</a>."<em> </em>ComeAgain?
      </p>
      <p>
        Agreed. Don't know about all the roots of <a href="ComeFrom.html">ComeFrom</a>, but it was fairly well
        established (as a joke, at least) by the time I encountered it around 1977
        (consistent with an INTERCAL origin, if that's taken as 1972; this is frankly
        the first I'd heard of INTERCAL as such). At Dartmouth (home of BASIC), this
        was used in structured-programming arguments: <a href="ComeFrom.html">ComeFrom</a> was asserted to be
        isomorphic to <a href="GoTo.html">GoTo</a>, in that the one could be mechanically translated to the
        other (it's true for many cases, but I haven't thought about this since so take
        it with a grain of salt).
      </p>
      <p>
        <em></em><a href="ComeFrom.html">ComeFrom</a> wasn't in the first version of INTERCAL; it is an addition in the C-INTERCAL version. Strangely enough, it turned out to be one of the most useful statements in INTERCAL...<em></em>
      </p>
      <p>
        In any case, exceptions cannot be implemented with either <a href="ComeFrom.html">ComeFrom</a> or <a href="GoTo.html">GoTo</a>, not
        even non-local <a href="GoTo.html">GoTo</a> (by contrast, by the way, to a great many other programming
        constructs of greater political correctness). The equivalent flow control can
        be roughly implemented with label variables or setjmp/longjmp, but the mapping
        of that to a <a href="ComeFrom.html">ComeFrom</a> extension is not something I've thought about. -- <a href="JimPerry.html">JimPerry</a>
      </p>
      <hr/>
      <p>
        <strong>Is there anything else like </strong><a href="ComeFrom.html">ComeFrom</a>?<strong></strong>
      </p>
      <p>
        Setting breakpoints in a debugger implements a <strong>dynamic</strong> <a href="ComeFrom.html">ComeFrom</a>.
      </p>
      <p>
        <a href="AspectOrientedProgramming.html">AspectOrientedProgramming</a> and the Advice systems in some Lisps have been described as "structured <a href="ComeFrom.html">ComeFrom</a>."
      </p>
      <p>
        And then there's the inverted CASE statement. Kind of a "computed" COME FROM.
      </p>
      <p>
        <em>As in "I'm here, so x must have a value of 7"? I've seen a lot code that effectively did that. Very nice when combined with multi-value switches. You get a holographic effect where the information about what the program is doing at any given line of code is spread throughout the entire program.</em>
      </p>
      <p>
        You can do something like that in INTERCAL, since you can use the ABSTAIN/REINSTATE mechanism to enable or disable a specific COME FROM statement.
      </p>
      <p>
        There is now an CLC-INTERCAL compiler that has real computed COME FROM. You can
        COME FROM a variable, then assign to this variable... <em>For example:</em>
      </p>
      <code>
        PLEASE REINSTATE (9)<br/>
        (8) DO .1 <- #8<br/>
        (9) PLEASE COME FROM (1009)<br/>
        DO ABSTAIN (9)<br/>
        (1000) DO COME FROM .1<br/>
        .........<br/>
        (1009) DO .1 <- #0<br/>
      </code>
      <p>
        There is now a new proposed (: term called <a href="GoHere.html">GoHere</a>, which is followed by an expression describing conditions for its execution. Like <strong></strong><a href="GoHere.html">GoHere</a> When Finished<strong>, Finished is Boolean true/false. Other examples at </strong><a href="GoHere.html">GoHere</a> :)
      </p>
      <hr/>
      <p>
        <strong>What if 2 </strong><a href="ComeFrom.html">ComeFrom</a>'s reference the same location?<strong></strong>
      </p>
      <p>
        In C-INTERCAL, it is an error if two COME FROM's point to the same location. But there's also a parallel INTERCAL, which does the <a href="RightThing.html">RightThing</a> and continues execution at <em>both</em> COME FROM's, in parallel.
      </p>
      <p>
        Note that this form of <a href="ComeFrom.html">ComeFrom</a> is strictly more powerful than <a href="GoTo.html">GoTo</a>. <em>One might have a </em><a href="GoTo.html">GoTo</a> which took a list of destinations<em>.</em>
      </p>
      <p>
        How about a COME FROM that takes several sources and implements a thread rendez-vous/termination? That might be an interesting extension to Parallel INTERCAL.
      </p>
      <hr/>
      <p>
        It is said that <a href="CallWithCurrentContinuation.html">CallWithCurrentContinuation</a> is a generalization of <a href="GoTo.html">GoTo</a>. Any ideas how a similar generalization of <a href="ComeFrom.html">ComeFrom</a> would look?
      </p>
      <p>
        I guess a (replace/call/cc cont value) function would be the functional counterpart. Its workings are simple - replace all references to cont (i.e. destructibly change the internal continuation state) so that it refers to the current continuation, then resume the original continuation in cont with the specified value.
        Dynamic redefinition of functions actually gives pretty much the same functionality, but limits the From's to function entry points. Then again, replace/call/cc is also limited in only accepting previously saved continuations.
        If you need to <a href="ComeFrom.html">ComeFrom</a> the middle of functions, modifying the function's source shouldn't be too hard though - decompile, insert <a href="GoTo.html">GoTo</a>, wrap in define, eval at its worst (although that solution uses <a href="GoTo.html">GoTo</a>, not <a href="ComeFrom.html">ComeFrom</a>).
      </p>
      <hr/>
      <p>
        Why can't we have an if statement that works the other way round? As an example:
      </p>
      <code>
        {<br/>
        x := x + 1;<br/>
        } else {<br/>
        x := x - 1;<br/>
        } if (x mod 2 == 0) <br/>
      </code>
      <p>
        This will increase x if it will be odd afterwards; it decreases x if this makes it even. <em>I think you mean the other way round. What do you want to get when x = 2?</em>
      </p>
      <p>
        Basically, what you seem to be looking for is something that will do:
      </p>
      <code>
        doFoo();<br/>
        if !resultOkay {<br/>
        undoFoo();<br/>
        doBar();<br/>
        }<br/>
      </code>
      <p>
        If you want these kind of things, you should use the <a href="PrologLanguage.html">PrologLanguage</a>, or perhaps the <a href="StructuredQueryLanguage.html">StructuredQueryLanguage</a>. An example in both:
      </p>
      <code>
        doStuff :-<br/>
        doFoo,<br/>
        resultOkay.<br/>
      </code>
      <code>
        doStuff :-<br/>
        doBar.<br/>
      </code>
      <code>
        BEGIN<br/>
        SAVEPOINT beforeFoo;<br/>
        doFoo;<br/>
        IF NOT resultOkay THEN<br/>
        ROLLBACK TO SAVEPOINT beforeFoo;<br/>
        doBar;<br/>
        END IF;<br/>
        COMMIT;<br/>
        END;<br/>
      </code>
      <p>
        Of course, the rollback only applies to the contents of your tables.   
      </p>
      <p>
        <em>Don't be silly; SQL doesn't have a IF statements!</em>
      </p>
      <p>
        {Actually, it does.  See, for example, <a href="http://technet.microsoft.com/en-us/library/ms182717.aspx">http://technet.microsoft.com/en-us/library/ms182717.aspx</a> }
      </p>
      <hr/>
      <p>
        Both cases in the above example are equivalent...  If (x mod 2 == 0), then (x + 1) and (x - 1) are both odd.  The same logic holds if the value that x "would have" post-operationally is used.
      </p>
      <p>
        ''No, they're not equivalent. The '<a href="PostCondition.html">PostCondition</a>' is tested only once. I read the above as:<em></em>
      </p>
      <code>
        x++;<br/>
        if (x mod 2 == 0)<br/>
        return x;<br/>
        else<br/>
        x--; // undoing the x++<br/>
        x--; // the wanted effect<br/>
        return x;<br/>
      </code>
      <p>
        <em>So the above should increase odd numbers, making them even, and would decrease even numbers, making them odd (which is not the claimed behaviour, BTW). Of course the simple example given can be redone with a regular if, but I think the requested feature is a valid one. Even though the </em><a href="PerlLanguage.html">PerlLanguage</a> does have its post-ifs and post-unlesses, I don't think they work any different than the regular ones.<em></em>
      </p>
      <hr/>
      <p>
        I just realized that <a href="ComeFrom.html">ComeFrom</a> looks an awful lot as a low-level version of the "cross-cutting" that products like AspectJ ( <a href="http://aspectj.org">http://aspectj.org</a> ) allow. In fact, one could do <a href="AspectOrientedProgramming.html">AspectOrientedProgramming</a> in INTERCAL in this way: by adding a module that COME FROMs labels in the original program, the new module (aspect) can immediately enhance the program without textually changing it. 
      </p>
      <p>
        -- <a href="StephanHouben.html">StephanHouben</a>
      </p>
      <p>
        It's interesting that you should say this, since Todd Proebsting (of Microsoft Research) dismissed AOP as "The Ultimate Come From" at the LL2 Conference at MIT. Actually, I hadn't grokked AOP until I thought about what he said, so it seems to me like a very useful comment. This is why (IMO) you really have to have really good editor support for AOP to be useful.
      </p>
      <p>
        -- Cullen J. O'Neill
      </p>
      <hr/>
      <p>
        A potential use for <a href="ComeFrom.html">ComeFrom</a> is in reversible computing (<a href="http://www.ai.mit.edu/~cvieri/reversible.html">http://www.ai.mit.edu/~cvieri/reversible.html</a> ). In a reversible instruction set it makes sense that the <a href="GoTo.html">GoTo</a> should have a symmetrical partner, the <a href="ComeFrom.html">ComeFrom</a>. <a href="GoTo.html">GoTo</a>s are otherwise messy to handle in a reversible context because <em>any</em> instruction might serve as a target for a jump making it difficult to execute backwards.
      </p>
      <p>
        -- Dan Piponi
      </p>
      <hr/>
      <p>
        A useful extension is the DontComeFrom statement as in:
      </p>
      <code>
        if (x > 7) don't come from 100<br/>
      </code>
      <hr/>
      <p>
        If <a href="ComeFrom.html">ComeFrom</a> is the pendant to <a href="GoTo.html">GoTo</a> then I wonder, how the pendants for GoSub (aka <a href="JumpSubRoutine.html">JumpSubRoutine</a>) and ReturnFromSubRoutine might look like. 
        One might call them ComeFromCaller (placed at the top of a 'subroutine') and ReturningFrom <label> (at the calling site <em>after</em> the call).
        The remaining question then is, how to figure out, where the 'caller' of the ComeFromCaller is. 
        I conjecture, that this can (if at all) only be done by nondeterministically trying all callers and choosing only that (those?) which leads to a valid (i.e. matching) ReturningFrom.
      </p>
      <p>
        -- <a href="GunnarZarncke.html">GunnarZarncke</a>
      </p>
      <p>
        I'd suggest something like this:
      </p>
      <p>
        CALLED FROM lines...
        Yanks control here after any of the lines in <em>lines...</em> have been executed. If more than one CALLED FROM refers to the same line, I suppose you could spawn more threads, or call it an error.
      </p>
      <p>
        RETURN FROM line1 VIA line2
        After line2 has been executed, if a CALLED WITH statement has yanked control after line1, yank control here.
      </p>
      <p>
        A compiler could easily (I think) implement these two by matching RETURN FROM's to CALLED FROM yank points, and just push the correct return address on the return stack and simply COME FROM a line just after the yank point and pushing of the return address, but before the next line in the program.
      </p>
      <p>
        Example (assuming global variables)
      </p>
      <ol>
        <li>
           var1 = 2
        </li>
      </ol>
      <code>
        <--- Here, control is yanked to line 100, CALLED WITH<br/>
      </code>
      <ol>
        <li>
           RETURN FROM 1 VIA 101
        </li>
        <li>
           RETURN FROM 2 VIA 101
        </li>
        <li>
           PRINT var1 // var1 should be 2+42+42 (two applications of the subroutine)
        </li>
      </ol>
      <code>
        ... More code, followed by the subroutine:<br/>
      </code>
      <ol>
        <li>
           CALLED FROM 1, 2
        </li>
        <li>
           var1 = var1 + 42
        </li>
      </ol>
      <code>
        <-- Here control would be yanked back to line 2 or 3, depending on which return point is on the return stack<br/>
      </code>
      <p>
        Optionally, the CALLED WITH statement could implement a multi-threaded rendez-vous mechanism. And obviously, the RETURN FROM can be on any source line. It should be possible to use an inner part of a subroutine as a different subroutine, something like this:
      </p>
      <ol>
        <li>
           var1 = 3
        </li>
        <li>
           RETURN FROM 2 VIA 300
        </li>
        <li>
           PRINT var1, var2 // Should print 3, 7 (2*3+1)
        </li>
        <li>
           var2 = 4
        </li>
        <li>
           RETURN FROM 5 VIA 300
        </li>
        <li>
           PRINT var2 // Should print 5 (4+1)
        </li>
      </ol>
      <code>
        .. Lots of code<br/>
      </code>
      <ol>
        <li>
           CALLED FROM 2
        </li>
        <li>
           var2 = 2*var1
        </li>
        <li>
           CALLED FROM 5
        </li>
        <li>
           var2 = var2 + 1
        </li>
        <li>
          . Do more stuff
        </li>
      </ol>
      <p>
        Which is kind of a cool ability. Not sure how to use it though ;-)
      </p>
      <p>
        --<a href="SimonBrenner.html">SimonBrenner</a> (using a friend's ssh host as socks proxy, since the code word doesn't work from my IP!)
      </p>
      <p>
        Actually, I think it might be more like this:
      </p>
      <code>
        (1) DO NOThing here<br/>
        (2) PRINT (RETURN FROM 101)<br/>
      </code>
      <code>
        (100) COME FROM 1<br/>
        (101) .1 + .2<br/>
      </code>
      <p>
        That is, it inspects the result of the statement, and allows the COME FROM line to access it.
      </p>
      <p>
        <em>Hmmm... Perhaps we should first figure out what call/cc and functions are in terms of gotos, then switch the </em><a href="GoTo.html">GoTo</a>s with <a href="ComeFrom.html">ComeFrom</a>s.<em></em>
      </p>
      <code>
        (1) push (1); goto (1000) // Push the return onto the stack; GOTO the subroutine.<br/>
        ... code code code<br/>
        (1000) code code code<br/>
        ....<br/>
      </code>
      <code>
        if (recursive_case) {<br/>
        (1009) push (1009); goto (1000)<br/>
        }<br/>
        (1010) goto pop() // Pop the stack and go to that address.<br/>
      </code>
      <p>
        I think we could (?) have that become
      </p>
      <code>
        (1) push (1); comefrom (1010) // <br/>
      </code>
      <code>
        (1000) comefrom pop();<br/>
        ... code code code<br/>
        (1009) {push (1009); comefrom (1010)} if that would make the recursive case true.<br/>
        (1010) // whatever<br/>
      </code>
      <p>
        Trouble is, I don't know how this handles multiple subroutines, or even whether it makes sense.  Possibly, we need to make it more along the lines of "Called From", as proposed above.
      </p>
      <p>
        I think that part of the problem is that <a href="ComeFrom.html">ComeFrom</a> is an inherently <em>hypothetical</em> concept, in the sense that a programming language has to figure out a lot of <em>suppose this were the case, then would this happen</em> sort of things.  The simplest being:
      </p>
      <code>
        if (a == b) COME FROM label;<br/>
      </code>
      <p>
        and more complex examples including
      </p>
      <code>
        if (a == b) {<br/>
        COME FROM label1;<br/>
        COME FROM label2;<br/>
        }<br/>
        if (c == d) :label1;<br/>
      </code>
      <p>
        and when mixed with things like the "do this if doing it makes the condition true, otherwise revert it and do this instead" inverted if statement, it becomes just plain confusing.
      </p>
      <hr/>
      <p>
        <strong>[insert obligatory reference(s) to Craps tables and/or the 'three universal lies' joke here]</strong>
      </p>
      <hr/>
      <p>
        An example of <a href="ComeFrom.html">ComeFrom</a>, widely used in wikis, is found in the list of <a href="BackLinks.html">BackLinks</a>. It is an example of the fact that one may arrive at a computing venue from many other venues. <a href="BackLinks.html">BackLinks</a> and its counterpart, <a href="ForwardLinks.html">ForwardLinks</a>, are two structures which tie the current page via hyperlinks to other pages in a NamedRelationship. -- <a href="DonaldNoyes.html">DonaldNoyes</a>.20080729.1106.m06
      </p>
      <hr/>
      <p>
        For an actual useful application, I've seen a "come from" instruction suggested as a security enhancement. These instructions would serve as "landing pads" to ensure that jumps were to valid locations, a jump to an instruction that is not the matched come-from instruction would be an error.
      </p>
      <p>
        Functions would need a landing pad instruction with looser restrictions, but this would still force exploits to use the actual intended function entry points. Exploits that jump into the middle of code would require modifying that code.
      </p>
      <p>
        There are other uses for such a kind of "landing pad", where nothing checks for their presence, but instead assumes them. This can be used by a compiler to perform optimizations involving "inner blocks".
      </p>
      <p>
        <em>Something like this has appeared a couple of times in practice, such as Google </em>NativeClient requiring basic blocks to be aligned on k-byte boundaries and restricting jump instructions to target those boundaries; indirect branching must explicitly mask off the low bits of the branch address or fail verification.<em></em>
      </p>
      <p>
        <em>In a different vein, the @PreviousPageType directive in ASP.Net (</em><a href="http://msdn.microsoft.com/en-us/library/ms228169%28v=vs.100%29.aspx)">http://msdn.microsoft.com/en-us/library/ms228169%28v=vs.100%29.aspx)</a> is used to obtain a statically-typed version of POST data when the page class defining the form and the class receiving the POST are distinct.<em></em>
      </p>
      <hr/>
      <p>
        <a href="CategoryBranchingAndFlow.html">CategoryBranchingAndFlow</a>
      </p>
    </div>
  </body>
</html>