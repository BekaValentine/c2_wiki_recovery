<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Lisp Sucks
      </h1>
      <p>
        It sucks because you really can't build big applications with it unless you want to write a lot of stuff that other languages already have.
      </p>
      <p>
        <em>This is true for any language without industry support.</em>
      </p>
      <p>
        <em>To paraphrase a great bumpersticker: 'Lisp sucks less.' </em>
      </p>
      <p>
        <em>This is only sort of true. You can't build the kind of plug and chug applications as easily as you can in VB or Java by leveraging a huge number of libraries. However, if your problem space doesn't happen to be already substantially solved by these libraries, you can build a big application much faster in Lisp. So I agree, in very mainstream, so-called 'enterprise' business apps, there is a lot of stuff that is harder to leverage (but there are </em><a href="ForeignFunctionInterface.html">ForeignFunctionInterface</a> and even COM capabilities in some lisps), it may take longer. However, your comment certainly doesn't generalize.<em></em>
      </p>
      <p>
        <em>You can interface with C API's easily from any </em><a href="CommonLisp.html">CommonLisp</a> implementation to gain access to the underlying platform and components. Anything you can call from C or <a href="CeePlusPlus.html">CeePlusPlus</a>, you can use from Lisp.<em></em>
      </p>
      <p>
        [Really? Like common commercial libraries?]
      </p>
      <ul>
        <li>
           More to the point--can you invoke methods on C++ objects, instantiate/use C++ templates, catch C++ exceptions, select the correct instance of an overloaded method, or do any other thing beyond calling "simple" C functions?  Very few languages can interface well with <a href="CeePlusPlus.html">CeePlusPlus</a> (and much of the blame here lies with <a href="CeePlusPlus.html">CeePlusPlus</a>); I would be quite surprised if Lisp can seamlessly use C++-specific features.
        </li>
      </ul>
      <ul>
        <li>
           <em>Well, there's the </em><a href="SimplifiedWrapperAndInterfaceGenerator.html">SimplifiedWrapperAndInterfaceGenerator</a>, which supports Common Lisp starting from version 1.3.26. Or do you consider that too much of a kluge (I do, actually...)? --MatthiasBenkard<em></em>
        </li>
      </ul>
      <hr/>
      <p>
        <em>It sucks because you really can't build big applications with it unless...</em>
      </p>
      <p>
        Personally, I think big applications are probably a <a href="DesignSmell.html">DesignSmell</a>. One should find a way to divide it into smaller applications. See <a href="SystemSizeMetrics.html">SystemSizeMetrics</a>
      </p>
      <hr/>
      <p>
        Also, I had trouble with the format of a lot of the macros. They make it so you have to remember exactly how every macro works to understand the code. This is very different from something like Smalltalk, where all the arguments are named and anything that isn't evaluated is in a block. I think this is the main reason people hate Lisp.
      </p>
      <p>
        <em>No, complete ignorance of Lisp is the main reason why people hate Lisp. The individual who has a technical, rational reason for disliking Lisp, based on having a big clue about Lisp, is vanishingly rare.</em>
      </p>
      <p>
        <em>You can run into trouble with macros, but I have never really had the difficulty you describe. The language has very good introspection, and if your code is written sensibly a call to describe should sort out any confusion that was left after your editor told you what the arguments to your macro should be.</em>
      </p>
      <p>
        <em>The standard macros in Common Lisp are quite well designed; they are for the most part seamless abstractions that do not require you to understand a particular implied macroexpansion.</em>
      </p>
      <hr/>
      <p>
        Shouldn't this page be titled "(sucks Lisp)"?
      </p>
      <p>
        <em>No, but rather (sucksp 'lisp).</em>
      </p>
      <p>
        <em>Or perhaps (assert (sucks? 'lisp))</em>
      </p>
      <p>
        No, the Scheme programming practice of using ? character in the names of symbols that designate predicate functions is a bad idea. You may want to use it as a macro dispatch character at some point. You will then be only able to use it as a non-terminating macro character, meaning that when it occurs in the middle of a token, it does not terminate that token but is treated as a constituent. Assuming you didn't ever use it at the start of a symbol, or as the entire symbol.
      </p>
      <p>
        <em>On what occasions have you used "?" as a macro dispatch character?</em>
      </p>
      <p>
        Well, I'm not the original poster, but I've used it to create logic variables (for unifiction), i.e., ?x is a variable. See the languages HORNE and RHET in the University of Rochester CS Dept. TR Archives. As far as I know it's not rare to use it for such (particularly when constructing an embedded language - one of the nice things about Lisp and macro dispatch characters!).
      </p>
      <hr/>
      <p>
        Lisp has its limitations, but anywhere you want an untyped language that isn't blazing fast, Lisp is good.  Examples of this are as the extension language for <a href="AutoCad.html">AutoCad</a> and <a href="TheGimp.html">TheGimp</a>, and a web site driver for Yahoo Shops and one of the big flight reservation systems. [Er, well, actually the big flight reservation system <em>does</em> need to be blazing fast. Fortunately, Lisp is well able to be blazing fast.]
      </p>
      <p>
        <em>GIMP has an unoptimized </em><a href="SchemeLanguage.html">SchemeLanguage</a> (not Lisp) implementation embedded in it. <a href="AutoCad.html">AutoCad</a> contains a Lisp-like scripting language. Not everything that uses parenthesized notation is Lisp! The parentheses don't make something Lisp any more than curly braces make something C.<em>--</em>[comment edited to remove excess bile]<em>  </em>
      </p>
      <p>
        Ah, the beauty of Wiki. When you don't like something someone wrote, making it disappear is just a few clicks and keystrokes away. Hey, freedom of speech should include the freedom to make other people's speech disappear---for the sake of operational completeness! You gotta have the full CRUD: create, retrieve, update, delete. :)
      </p>
      <p>
        Scheme is commonly considered to be a dialect of Lisp, just like there are many different dialects of Basic, Smalltalk, Forth, etc. <a href="AutoCad.html">AutoCad</a> even calls their version <a href="AutoLisp.html">AutoLisp</a>. These are full fledged Lisps, unoptimized because speed in an extension language is not of primary importance. Python and <a href="JavaScript.html">JavaScript</a> also seem to be popular extension languages. I was pointing out that Lisp, being a dynamic language, seems to do well in this area.
      </p>
      <p>
        <em>For the last what, 20 years or so, if you are talking about "Lisp" without specification, it will be assumed you mean "Common Lisp", as defined by the ANSI standard. In certain contexts this will not be true, but that is really beside the point as  the same can be said of "C" or what have you. Common Lisp is and always has been an industrial strength language with efficient compilation and support for large projects. It has some strange warts related to its upbringing, but considering it in the same breath as something like the embedded scripting scheme in GIMP is just silly.</em>
      </p>
      <hr/>
      <p>
        <strong>NOTE:</strong> tons of useless and distracting assembly moved to <a href="LispSucksInAssembly.html">LispSucksInAssembly</a> to reduce clutter.
      </p>
      <hr/>
      <p>
        I don't see any material here that actually supports the thesis that Lisp sucks. Are we reading the same page?
      </p>
      <p>
        There don't appear to be any jokes here either, at least not anymore. This page lacks the charm of <a href="WhyWeHateLisp.html">WhyWeHateLisp</a>. -- <a href="LukeGorrie.html">LukeGorrie</a>
      </p>
      <p>
        That's because <strong>that</strong> page was written by some people who had actually <em>used</em> lisp. Any <em>X sucks</em> page will always be much better if written by someone who knows <em>X</em> intimately; indeed, when this is the case, the whole thing can be marvellously funny (e.g. <a href="TheUnixHatersHandbook.html">TheUnixHatersHandbook</a>). <em>This</em> page, however, seems to be the sort of ignorant whining one normally associates with the slashdot crowd. -- <a href="AlainPicard.html">AlainPicard</a>
      </p>
      <p>
        <em>Ahh, yes. Spoken like a true </em><a href="SmugLispWeenie.html">SmugLispWeenie</a>. (heh)<em></em>
      </p>
      <hr/>
      <p>
        (format t "~a-~2,'0D-~2,'0D ~2,'0D:~2,'0D:~2,'0D UTC" yr month day hr min sec) ; At least printf has a man page...
      </p>
      <p>
        <em></em>'Feh. As <a href="NiklausWirth.html">NiklausWirth</a> rightly pointed out when designing <a href="ModulaTwo.html">ModulaTwo</a>, formatted display is almost always the <a href="WrongThing.html">WrongThing</a>, anyway. - <a href="JayOsako.html">JayOsako</a>, a SmugSchemeWeenie<em></em>'
      </p>
      <p>
        <em>while there are similarities, format is far more capable than printf and the CL hyperspec is vastly superior to man pages.  What was your point?</em>
      </p>
      <p>
        I had a heck of a time finding out how to do that. I have two LISP books on my desk, both of which give examples of things that are not quite what I wanted to do and neither of which gives a complete definition of the format controls.  Meanwhile, most of the links I clicked on in the hyperspec just sent me to the definition of <em>what</em> something is instead of to the part of the spec that explains <em>how</em> to use it. Finally I found the right link, put in the format control, got an error, made a wild guess that I had to quote the zeros, it worked... Then I sat back, looked at the resulting code and said <em>yuck, what an ugly language. </em><a href="LispSucks.html">LispSucks</a>.<em></em>
      </p>
      <p>
        <em>Hmm. Lets see now; the usual way to get to the hyperspec is through your editor, which will lead you to the page for the format command. If don't have a decent lisp editor handy, you might start off at the top level table of contents. In either case, one or two clicks will lead you to the obvious place to start looking: "22.3 Formatted Output". Like man pages, this is not newbie documentation, so I agree it might take a few more clicks if you are completely confused. Of course with your two Lisp books you should know at this point that you are looking for information on printing and formatting, so I assume you found this page. Why did you make a wild guess? Right on the first page is an example:</em>
      </p>
      <p>
        "For example, ~5,'0d can be used to print an integer in decimal radix in five columns with leading zeros, or ~5,'*d to get leading asterisks."
      </p>
      <p>
        <em>It can hardly get easier than that; you don't even have to follow the obvious link to "Examples of Format" at the bottom of the page (which would also have shown you how to do this). Format strings can look a bit ugly, sure, but compared to most languages' I/O they are amazing. Conditional pluralization, flow-control, sane layout control....and you want to dismiss this all out of hand because you can't read a page of hypertext to find the example handed to you on a plate?</em>
      </p>
      <p>
        Please forgive this unwashed C programmer for having started with the index instead of reading from the beginning. It sent me into the circular morass of the glossary, which apparently is the fate that awaits all those who dare to Lisp without a special editor.
      </p>
      <p>
        <em>Ahhh, I see. One of those "I don't need no stinking IDE" programmers, and God forbid you actually </em>'read<em>' a manual.</em>
      </p>
      <p>
        How nostalgic... Reminds me of APL, which needed a special editor because it was written in some Klingon character set.
      </p>
      <p>
        <em>Not a special editor, just a decent programmers' editor. You know, the kind you can add hooks too; like lookups in some set of docs like the hyperspec. Hell, I was an unwashed C programmer when I learned lisp too, but even then I think I would have looked in the table of contents. Indices are for when you know what you are looking for. I certainly wouldn't suggest to someone that they </em>learn<em> lisp from the hyperspec, that isn't what a spec is for in any language. I don't know which 2 lisp books you have, but are you sure you didn't miss an example right in front of you there, like you did the one above?</em>
      </p>
      <p>
        Graham, Section 7.3, "Output," is mute about the D format, but makes the observation "Depending on one's point of view, format is either amazingly powerful or horribly complex. There are a large number of format directives, only a few of which most programmers will ever use." (I'm the only person who needs to print ints?) Ironically, the index has an entry for "printing times" -- exactly what I wanted, but not how I wanted it. He used A instead of D, so it was <em>extra-</em>ugly and didn't make sense to one who just wanted to print some ints.
      </p>
      <p>
        My other book is Winston & Horn... <a href="NuffSaid.html">NuffSaid</a>?
      </p>
      <p>
        <em>You're going to judge an entire language by its formatting controls and by what you think about a couple of books? By that criterion you should love COBOL, which has very friendly formatting.</em>
      </p>
      <hr/>
      <p>
        I think <a href="LispSucks.html">LispSucks</a> because I haven't found anyone that will let me code in it, yet. -- <a href="BobBockholt.html">BobBockholt</a>
        <em>See also: </em><a href="ArmyOfProgrammers.html">ArmyOfProgrammers</a>.<em></em>
      </p>
      <p>
        <em>Now that's the best reason I've seen yet, and quite true.  I'd say the same for </em><a href="SmallTalk.html">SmallTalk</a>. I'd love to try either, but no one will let me.<em></em>
      </p>
      <p>
        Yeah, I'm an OS and language junkie myself. 
      </p>
      <p>
        And let me make that 'let' clear: 
      </p>
      <ul>
        <li>
           Mainstream employers understandably don't want to take the risks of investing in the 'unknown' and/or besmirched lisp
        </li>
        <li>
           I don't know the language well enough to make the leap of faith. I.e. I want someone to pick up the tab for the overhead for me having fun learning a new language while they wait for their project to get done. (Would this make me a _____ weenie?) <em>If it's fun, why not just do it for fun, why wait for somebody to pick up the tab?</em>
        </li>
      </ul>
      <p>
        I've taken stabs at getting a handle on lisp and scheme (and SmallTalk (which actually went better than most, thanks to Squeak!), and ErLang, and Dylan, and ML, and Haskel...) more than a few times. I spend a couple of hours, cltl2 in hand, looking at examples and coding up some simple toys, but end up throwing in the towel because the learning curve is quite steep because of the size of the vocabulary, the body of idiom, and, not least, the paradigm shift. But a month later it still calls to me, "C'mon Bob! You know you want to be a big, bad lisp programmer!"
      </p>
      <p>
        I read on some lisp evangelism page that a company would do better to hire a 'few really smart lisp programmers' than a legion of typical C programmers. Maybe I'm just not smart enough, yet? Maybe stupidity is why lisp sucks?
      </p>
      <p>
        <em>I don't see any substantial support of the thesis on this page... perhaps that has been edited out?</em>
      </p>
      <p>
        Yeah, probably. <a href="SmugLispWeenie.html">SmugLispWeenie</a>s are like that. <em><ahem></em>
      </p>
      <p>
        [Oh, I doubt that. A <a href="SmugLispWeenie.html">SmugLispWeenie</a> may laugh at you, even correct you harshly, for saying something ignorant or stupid about lisp, but she is unlikely to <a href="DisagreeByDeleting.html">DisagreeByDeleting</a>.]
      </p>
      <p>
        [[Actually, they have proven themselves to be pretty bad vandals on the anti-Lisp pages.]]
      </p>
      <p>
        The fact that mainstream employers don't want to take the risks of investing in lisp can be a great advantage to small companies because it lets them undercut the delivery time and price of much larger competitors by using superior development technologies.
      </p>
      <p>
        <em>Excuse me? "Superior development technologies?" Could you name any two, please.</em>
      </p>
      <p>
        Use. Lisp. :P Jokes aside: use what's best and not what's the most popular. Hardly a technology, but still important. -- Baczek
      </p>
      <p>
        <em>What is the best though? That's often a tough decision. I've yet to find, for example, the best relational database tool. There aren't any because they all suck and fail to exist. One problem with smug lisp wheenies is they literally think lisp is the best tool for all tasks, and they think lisp is literally the </em><a href="GoldenHammer.html">GoldenHammer</a>. <a href="PaulGraham.html">PaulGraham</a> strikes me as such a fellow. Paul Graham is the type of naive person that rejects databases and thinks flat files are the way to go. He has written articles advocating using lisp and files instead of an RDBMS, because he literally thinks Lisp is the best tool for all jobs - this strikes me as religious and ideological (not to mention ignorant).  That's why many of  us write off smug lisp wheenies like Paul Graham as quacks/cracks/crankpots.<em></em>
      </p>
      <hr/>
      <p>
        I read on some lisp evangelism page that a company would do better to hire a 'few really smart lisp programmers' than a legion of typical C programmers. Maybe I'm just not smart enough, yet? Maybe stupidity is why lisp sucks?
      </p>
      <p>
        <em>Hiring "really smart programmers" as opposed to a "legion of typical programmers" is often a good thing to do, regardless of the languages involved. Of course, identifying wheat from chaff is frequently very difficult to do; nobody puts on their resume that they are a coder of average capability. I've encountered many poor programmers who nonetheless had impressive resumes, glowing references, and flawless interviews.</em>
      </p>
      <p>
        <em>And no, the claim "really smart programmer := Lisp programmer" will </em>'not<em>' be accepted at face-value.</em>
      </p>
      <p>
        [Of course not, that claim would be silly.  It is (fairly) highly correlated, not causal]
      </p>
      <p>
        What?!?! But the ad said "Learn Lisp! Guaranteed to raise your I.Q. by at least 40 points!" Are you telling me I wasted my $29.95??? :-( [Well, probably not wasted.  I expect most programmers would become better programmers by learning a lisp (if they haven't already) even if they never `use' it. This isn't unique to lisp, of course.]
      </p>
      <p>
        {Why is the really smart programmer being assigned := a value of Lisp programmer? Shouldn't it be checking for equality?}
      </p>
      <hr/>
      <p>
        Lisp (CL) sucks because you can't write very small programs in it. Every available practical environment today (ie not <a href="LispMachine.html">LispMachine</a>) is a humongous thing that has to be started in a separate virtual machine. You always need a separate launcher. It also encourages people to save running images instead of sources.  -- <a href="AnonymousCoward.html">AnonymousCoward</a>, hoping someone will prove it wrong
      </p>
      <ol>
        <li>
           Current Lisp runtimes aren't really any bigger than Java virtual machine runtimes, and is at least in the ballpark of Perl, Python and Ruby. Maybe that's humungous, but it's also normal and acceptable.
        </li>
      </ol>
      <ol>
        <li>
           I'm not sure what to make of <em>You always need a separate launcher</em>. I *think* what you mean is that you need to start the virtual machine process to run the program. See the first point. This has become common for a number of widely used development languages. Also, you *can* make standalone executables which have a small VM stub prepended to the image with most CLs.
        </li>
      </ol>
      <ol>
        <li>
           While you <em>can</em> save running images instead of sources, it's not necessary, and I think it's done mostly for application delivery and not for development. Most people develop CL with an IDE or Emacs and save the sources to text files. They use a defsystem facility (such as asdf) to automate loading source files into a running image. And, saving images has both drawbacks and advantages. Most environments don't even give you the option.
        </li>
      </ol>
      <ol>
        <li>
           Lisp is not C, that's for sure. If you want C, you know where to find it.
        </li>
      </ol>
      <hr/>
      <p>
        Its been a long time (about 8 years) since I've done much Lisp programming. But I still believe that my personal productivity with <a href="CommonLisp.html">CommonLisp</a> and CLOS was *much* higher than with any other environment that I have used (C,C++,Java,<a href="DotNet.html">DotNet</a>). However, balancing that was the horror that I often used to feel having to work with other peoples Lisp code, sometimes it was lovely but it could also be more confusing to me that the worst perl or overloaded C++ code. Somehow I think "With great power comes great responsibility" also applies to (ab)use of overly powerful programming language features.
      </p>
      <p>
        [See <a href="ThreeStarProgramming.html">ThreeStarProgramming</a>. See also <a href="ThwozzThwozzThwozz.html">ThwozzThwozzThwozz</a> and <a href="WorseReallyWasBetter.html">WorseReallyWasBetter</a>, a personal rant in favor of C (honestly).]
      </p>
      <hr/>
      <p>
        <strong>NOTES:</strong>
      </p>
      <ol>
        <li>
           This page originally started out as <a href="CategoryJoke.html">CategoryJoke</a>, but them moved into the mainstream by the addition of much material to actually support the thesis. Hmm. Where there's smoke...  <em>a crowd gathers to see what's going on.</em>
        </li>
      </ol>
      <p>
        Can't we merge it with <a href="WhyWeHateLisp.html">WhyWeHateLisp</a> or the like?
      </p>
      <hr/>
      <p>
        See: <a href="XmlSucks.html">XmlSucks</a>, <a href="WhyWeHateLisp.html">WhyWeHateLisp</a>, <a href="SmugLispWeenie.html">SmugLispWeenie</a>s, <a href="SocialProblemsOfLisp.html">SocialProblemsOfLisp</a>, <a href="SucksSucks.html">SucksSucks</a>, <a href="GreenspunsTenthRuleOfProgramming.html">GreenspunsTenthRuleOfProgramming</a>, <a href="GreatLispWar.html">GreatLispWar</a>
      </p>
      <p>
        <a href="CategorySucks.html">CategorySucks</a>, <a href="CategoryRant.html">CategoryRant</a> <a href="CategoryLisp.html">CategoryLisp</a>
      </p>
    </div>
  </body>
</html>