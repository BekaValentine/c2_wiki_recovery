<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Multi Paradigm Weenie
      </h1>
      <p>
        <strong>Favourite languages:</strong> <a href="ObjectiveCaml.html">ObjectiveCaml</a>, <a href="OzLanguage.html">OzLanguage</a>, <a href="MyFavoriteLanguage.html">MyFavoriteLanguage</a>.  Some will even admit to liking <a href="CeePlusPlus.html">CeePlusPlus</a>. <a href="CommonLisp.html">CommonLisp</a> has its fair share, though not as much as the traditional <a href="SmugLispWeenie.html">SmugLispWeenie</a>
      </p>
      <p>
        <strong>Favourite paradigms:</strong> all of them. The inability of a language to adequately support any one of <a href="ImperativeProgramming.html">ImperativeProgramming</a>, <a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a>, <a href="FunctionalProgramming.html">FunctionalProgramming</a>, <a href="LogicProgramming.html">LogicProgramming</a>, <a href="DataflowProgramming.html">DataflowProgramming</a>, <a href="ConstraintProgramming.html">ConstraintProgramming</a>, <a href="CollectionOrientedProgramming.html">CollectionOrientedProgramming</a>, <a href="ConcurrentProgramming.html">ConcurrentProgramming</a> or the <a href="RelationalModel.html">RelationalModel</a>, is greeted with scowls and muttering.
      </p>
      <p>
        <strong>Favourite books:</strong> <a href="ConceptsTechniquesAndModelsOfComputerProgramming.html">ConceptsTechniquesAndModelsOfComputerProgramming</a>, <a href="AdvancedProgrammingLanguageDesign.html">AdvancedProgrammingLanguageDesign</a>
      </p>
      <p>
        <em></em><a href="CollectionOrientedProgramming.html">CollectionOrientedProgramming</a>?  Is that a "recognized" paradigm?  I can hazard a guess as to what it is, but it smells to me like <a href="TableOrientedProgramming.html">TableOrientedProgramming</a>--a <a href="DesignPattern.html">DesignPattern</a> that someone is itching to promote to full-fledged paradigm. :)<em></em>
      </p>
      <p>
        Yes, it is -- discussion moved to <a href="CollectionOrientedProgramming.html">CollectionOrientedProgramming</a>.
      </p>
      <p>
        <a href="MultiParadigmWeenie.html">MultiParadigmWeenie</a><strong>'s believe that the </strong><a href="ObjectRelationalImpedanceMismatchDoesNotExist.html">ObjectRelationalImpedanceMismatchDoesNotExist</a>. (That page is a mess, so: they think that the libraries and/or language should make it go away.)
      </p>
      <p>
        Has a <a href="StaticTyping.html">StaticTyping</a> subculture who are able to either do bizarre and incomprehensible things with <a href="TemplateMetaprogramming.html">TemplateMetaprogramming</a>, or understand <a href="DependentTypes.html">DependentTypes</a> and <a href="CategoryTheory.html">CategoryTheory</a> -- but rarely both.
      </p>
      <hr/>
      <p>
        Who wants to take a stab at writing a <a href="HelloWorld.html">HelloWorld</a> program that uses <em>all</em> of the above <a href="ProgrammingParadigm.html">ProgrammingParadigm</a>s?  Feel free to use any language you deem appropriate, including making up your own or using multi-paradigm pseudocode.
      </p>
      <p>
        <em>You mean use all of them at the same time? That's a bit much; that only has two parts, print, and a string; there are more paradigms than there are tasks to accomplish. How about 8 queens?</em>
      </p>
      <ul>
        <li>
           One paradigm per queen?  :)  <strong>Great idea!</strong> At any-rate, I'm sure an all-paradigms <a href="HelloWorld.html">HelloWorld</a> could be done.  The set of string objects to be printed could be stored in a <a href="RelationalDatabase.html">RelationalDatabase</a>, which could be queried not directly but via a UnificationAlgorithm, triggered by <a href="LazyEvaluation.html">LazyEvaluation</a> of some <a href="HigherOrderFunction.html">HigherOrderFunction</a>, triggered by invokation of a procedure.  Retrieval of the strings and the actual output could be done in separate threads, with a dataflow variable the interface between 'em.  It could be done.  
        </li>
        <li>
           I ain't gonna do it.  :)
          <ul>
            <li>
               Ha! That's pretty evil minded. I once did a nondeterministic multi-threaded recursive factorial program (one thread per multiply but with random delay to completion) in C++, just to make my teammates scream in agony (it worked ;-), but your idea is much worse. I'm almost tempted...
            </li>
            <li>
               I'm very tempted.  Maybe later. ;) -- <a href="JonathanTang.html">JonathanTang</a>
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <p>
        I was bored last night. :) Here's a multi-paradigm <a href="HelloWorld.html">HelloWorld</a>.  It's written in a <a href="MyFavoriteLanguage.html">MyFavoriteLanguage</a> called Alohomora, which is my spare-time <a href="VaporWare.html">VaporWare</a> and hence doesn't exist yet.  More specifically, it's written in a <a href="LiterateProgramming.html">LiterateProgramming</a> system called Quill, which also doesn't exist.  But the problem description did say it could even be in pseudocode, so I think this is a step up.
      </p>
      <p>
        [File: hello_world.quill]
      </p>
      <p>
        This program creates an exceptionally roundabout solution to the classic "Hello World" problem: write the string "Hello world!" on the screen.  We first generate a collection of Flyweight character objects, stored in a container that manages requests for them.  We then use a non-deterministic choice algorithm to select only those characters that will appear in the final string.  The 'l' and 'o' characters are duplicated, the originals serving as prototypes.  The characters are then mapped into a relational table through a mathematical algorithm that assigns a sequence number to them, using monadic continuation passing style.  A relational query orders the objects and projects them down to the character only.  Then we do a map:as: to convert the result set into a string, and print the result.  We use an aspect to advice print to print a ! after everything.
      </p>
      <p>
        First we need our character objects.  These are simple wrappers, needing no other fields.  There really is no body to this: a default constructor's generated that copies a <char> and then calls (morph c into: <char-wrapper>) to change the copy's type.  The <flyweight> metaclass wraps that to memoize requests, so it doesn't create new objects each time.
      </p>
      <code>
        defclass <char-wrapper> extends: <char> metaclass: <flyweight><br/>
      </code>
      <p>
        We also want a container for them.  Instead of wrapping a collection class, we can lazily generate objects as requests come in, knowing that the <flyweight> metaclass will memoize the actual objects.  We do need to supply a method on <iterator>, though.  This one creates an iterator for the range ASCII_MIN..ASCII_MAX, creates a function that converts an ASCII code into a <char>, and then rebinds the get method on the iterator to the constructor for a <char-wrapper>
      </p>
      <code>
        defconst ASCII-MIN 33<br/>
        defconst ASCII-MAX 127<br/>
        defclass <char-generator> extends: <collection><br/>
        def <iterator> [collection :: <char-generator>]<br/>
        base <- <iterator> ASCII-MIN..ASCII-MAX<br/>
        ascii2char <- bind as <char> base.get<br/>
        set base.get to: compose <char-wrapper> ascii2char<br/>
        base<br/>
      </code>
      <p>
        The next step is to select only those objects that will be in the final string.  The simple solution is simply 'filter <char-generator>() with: (it in "Helowrd!")'.  However, if we wanted this to be simple, we would simply have done 'print "Hello world!", and that would've been no fun.  So we use the non-deterministic 'amb' operator (taken from <a href="StructureAndInterpretationOfComputerPrograms.html">StructureAndInterpretationOfComputerPrograms</a>, which stole it from some Lisp dialect), and choose from alternatives with 'require'.  Amb is a little different in Alohomora than in Scheme: instead of taking a list of arguments, it takes a single iterator, and then non-deterministically tries each.
      </p>
      <code>
        def filter-characters [generator :: <char-generator>]<br/>
        possibilities <- amb (<iterator> generator)<br/>
        require (it in "owl herd")<br/>
        all-values possibilities<br/>
      </code>
      <p>
        filter-characters has now returned a <sequence> (more specifically, a <cons-list>).  So now let's tail-call our way down the list and make copies of the duplicated letters.
      </p>
      <code>
        def maybe-copy-letter [list :: <cons-list>, accumulator :: <cons-list>]<br/>
        maybe-copy-letter list.tail (...<br/>
        case list.head<br/>
        "l": accumulator & repeat list.head 3<br/>
        "o": accumulator & repeat list.head 2<br/>
        else: accumulator<br/>
        )<br/>
      </code>
      <code>
        def copy-letters [selected-chars :: <cons-list>]<br/>
        maybe-copy-letter selected-chars nil<br/>
      </code>
      <p>
        Now comes the tricky part.  We need to assign sequence numbers to each letter.  And we don't know what order they'll be in, as a consequence of the non-deterministic assignment (actually, non-determinism usually means depth-first, but at this stage I'm not going to guarantee that).  We do know that repeated letters will all be in a row.  The simplest thing to do here would be a lookup table, which is exactly why I'm not going to do that.  Instead, lets <a href="QuickSort.html">QuickSort</a> it!
      </p>
      <code>
        def quicksort-chars [letter-set :: <cons-list>]<br/>
        pivot <- letter-set.head<br/>
        quicksort-chars [x | x < pivot] & pivot & quicksort-chars [x | x > pivot]<br/>
      </code>
      <p>
        <em>Now</em> we can define a mapping function that associates a sequence number with each character and returns the resulting tuple.
      </p>
      <code>
        l-seen <- 0<br/>
        o-seen <- 0<br/>
        def char-order [c :: <char-wrapper>]<br/>
        case c<br/>
        "H": 1<br/>
        "e": 2<br/>
        "l": ++l-seen<br/>
        case l-seen<br/>
      </code>
      <ol>
        <li>
          : 3
        </li>
        <li>
          : 4
        </li>
        <li>
          : 10
        </li>
      </ol>
      <code>
        "o": ++o-seen<br/>
        case o-seen<br/>
      </code>
      <ol>
        <li>
          : 5
        </li>
        <li>
          : 8
        </li>
      </ol>
      <code>
        " ": 6<br/>
        "w": 7<br/>
        "r": 9<br/>
        "d": 11<br/>
      </code>
      <p>
        (Yes, the sorting was completely gratuitous.  I stuck it in because <a href="ListComprehension.html">ListComprehension</a>s are monads, and so I can claim <a href="MonadicProgramming.html">MonadicProgramming</a> without actually knowing what it is or how to create one.)
      </p>
      <p>
        We're almost there.  The next step is to create a function to turn a character into <character, sort-order> tuple.
      </p>
      <code>
        def make-tuple [c :: <char-wrapper>]<br/>
        [char: ?c, sort-order: ?(char-order c)]<br/>
      </code>
      <p>
        To create the relation, we just map the tuple-generator over the list of characters.
      </p>
      <code>
        def make-relation [sorted-list :: <sequence>]<br/>
        relvar <- <relation><br/>
        map (make-tuple it) over: sorted-list into: relvar<br/>
        relvar<br/>
      </code>
      <p>
        Then we collapse the relation down into a single list:
      </p>
      <code>
        def collapse-relation [relation :: <relation>]<br/>
        sorter <- bind order relation by: 'sort-order<br/>
        projection <- bind project 'char<br/>
        (compose values <dictionary> projection sorter)()<br/>
      </code>
      <p>
        This returns a <sequence> of the values of the char column, ordered by sort-order.  A <string> is just a sequence of <char>s.  Since <char-wrapper> is a subtype of <char>, we've effectively got the string "Hello world".  We need to add the ! on as an aspect
      </p>
      <code>
        defaspect exclamatize<br/>
        printers <- pointcut [print output]<br/>
        around printers<br/>
        call-next-method output & "!"<br/>
      </code>
      <p>
        The only thing left is to put everything together.
      </p>
      <code>
        program <- compose print collapse-relation make-relation quicksort-chars ...<br/>
        copy-letters filter-characters <char-generator><br/>
        program()<br/>
      </code>
      <p>
        And this concludes the program.
        [end]
      </p>
      <p>
        Yeah.  I believe that's <a href="ImperativeProgramming.html">ImperativeProgramming</a>, <a href="FunctionalProgramming.html">FunctionalProgramming</a>, <a href="LiterateProgramming.html">LiterateProgramming</a>, <a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a>, <a href="TableOrientedProgramming.html">TableOrientedProgramming</a>, <a href="MonadicProgramming.html">MonadicProgramming</a>, <a href="GenericProgramming.html">GenericProgramming</a>, NonDeterministicProgramming, <a href="GenericFunction.html">GenericFunction</a>s, <a href="MetaClass.html">MetaClass</a>es, and <a href="HigherOrderFunctions.html">HigherOrderFunctions</a>.  There're shades of <a href="PrototypeBasedProgramming.html">PrototypeBasedProgramming</a> in the letter-copying too.  And you might be able to consider that massive composition of functions that passes for the main program to be <a href="FlowBasedProgramming.html">FlowBasedProgramming</a>, or maybe <a href="DataflowProgramming.html">DataflowProgramming</a>.  Am I a <a href="MultiParadigmWeenie.html">MultiParadigmWeenie</a> yet?  -- <a href="JonathanTang.html">JonathanTang</a>
      </p>
      <p>
        <em></em>WeenieDom is hereby granted.  [Taps Jonathan on the shoulder with a cordless power screwdriver.]  You now go forth and whine about how your demonstrably superior technology is being oppressed by the entrenched commercial interests who are conspiring to keep programmers 'round the world peddled to their obsolete, archaic junk.  The registrar of our elite society, <a href="PaulGraham.html">PaulGraham</a>, will now add your name to the roster.  Congratulations! -- LordProtectorOfAllWeenies<em></em>
      </p>
      <p>
        [I'm with the LordProtector; you're in!!!! -- dm]
      </p>
      <ul>
        <li>
           You forgot <a href="AspectOrientedProgramming.html">AspectOrientedProgramming</a>; at least you didn't mention it specifically.  :)
          <ul>
            <li>
               Fixed.  The AOP syntax is very much in flux, so this may not be correct code.  Then again, the whole thing is a <a href="MyFavoriteLanguage.html">MyFavoriteLanguage</a>, so it doesn't really matter that much. -- jt
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <p>
        An extreme <a href="MultiParadigmWeenie.html">MultiParadigmWeenie</a> is someone who uses multiple paradigms because they simply get bored using a few. <a href="MentalMasturbation.html">MentalMasturbation</a>. This does not imply that all <a href="MultiParadigmWeenie.html">MultiParadigmWeenie</a>s are like this. It is only an extreme form.
      </p>
      <p>
        <em>You almost sound like you think that's a bad thing. No </em>MultiParadigmWeenieDom for you. MentalMasturbationIsHealthyExercise.<em></em>
      </p>
      <p>
        Only if your employer wants to foot the bill for your learning and experiments and wants to risk limiting the candidates of your replacement if you leave.
      </p>
      <hr/>
      <p>
        See also: <a href="MixingParadigms.html">MixingParadigms</a>, <a href="ProgrammingParadigm.html">ProgrammingParadigm</a>, <a href="MultiParadigmProgrammingLanguage.html">MultiParadigmProgrammingLanguage</a>, <a href="WhenToUseWhatParadigm.html">WhenToUseWhatParadigm</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryWeenie.html">CategoryWeenie</a>
      </p>
    </div>
  </body>
</html>