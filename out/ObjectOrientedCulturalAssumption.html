<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Object Oriented Cultural Assumption
      </h1>
      <p>
        Well, let's start with the obvious:
      </p>
      <ul>
        <li>
          Everything is an object.
        </li>
        <li>
          Whoever complains about OO probably just doesn't get it.
        </li>
        <li>
          Whoever has troubles with OO surely doesn't get it.
        </li>
        <li>
          OO is cool.  The alternatives are all old-fashioned and obsolete.  <em>I get a chuckle from this one, because I found the perfect example of OO is from philosophy:  Plato's Ideals are classes</em>
        </li>
        <li>
          OOP makes "procedural" programming obsolete; C programmers have fallen behind and should upgrade. (Related: <a href="CeeIsNotThePinnacleOfProcedural.html">CeeIsNotThePinnacleOfProcedural</a>)
        </li>
        <li>
          Everybody should be doing OO. We should have OO databases, OO operating systems, OO AI systems, OO safety-critical software, OO toilet paper, etc... There are some who still don't get it and persist in their bad old habits, writing obsolete software systems.
        </li>
        <li>
          "This is not OO." ( translated: "I'm sure it's something wrong with it")
        </li>
        <li>
          We have to find the right <em>abstraction</em>.
        </li>
        <li>
          SQL is low level. We need to <em>abstract</em> the <em>storage access</em> with the CRUD interface: (create 1 object)/(read 1 object)/(update 1 object)/(delete 1 object). Now we got our fancy RDB back to a COBOL file, see how low level and obsolete it is ? 
        </li>
        <li>
          Every table in a relational database needs an OID column, so that we can "identify" our objects. 
        </li>
      </ul>
      <p>
        Please add or comment on the above list.
      </p>
      <p>
        <em>I hope nobody minds that I toned down some comments, trying to preserve the flavor without provoking people. Can we get definitions that both OO detractors and OO supporters agree on?</em>
      </p>
      <hr/>
      <ul>
        <li>
          Everything is an object. And Object Oriented Programming is just the latest hack to get us as close to programming with that insight as is currently possible. - <a href="GeorgeSxCowan.html">GeorgeSxCowan</a>
        </li>
      </ul>
      <hr/>
      <p>
        What is the alternative? When i interview non-OO people and i ask them how do you develop software, they really have no idea. Maybe OO isn't the saviour of the world, but it at least gives you a vocabulary. -- <a href="AnonymousDonor.html">AnonymousDonor</a>
      </p>
      <ul>
        <li>
           I particularly like the design methodology espoused by Abelson and Sussman in <a href="SiCp.html">SiCp</a>. In short, what it comes down to is that you design a programming language in which your problem has a simple solution. For complicated problems, the approach can be layered on top of itself. The problem is that this requires the use of a base programming language that easily lends itself to such an approach, without requiring you to actually go and write a parser, interpreter/compiler &c. In practice, this requires higher-order functions and fully general macros, otherwise you go nuts. The main languages that support such things are the various Lisp dialects (Scheme, Common Lisp, Dylan, &c.). 
        </li>
      </ul>
      <p>
        <em></em><a href="http://geocities.com/tablizer/bizmod.htm">http://geocities.com/tablizer/bizmod.htm</a> - and the author would be happy to answer specifics. See also <a href="ProceduralMethodologies.html">ProceduralMethodologies</a>.<em></em>
      </p>
      <p>
        At a high level, object-oriented programming is one of many interesting ways of designing programs. Here are some ways that work especially well for certain problems, though some (including OO) are much more broadly applicable than these examples:
      </p>
      <ul>
        <li>
           Finite state machines for asynchronous networking
        </li>
        <li>
           Constraint programming for incremental data validation
        </li>
        <li>
           Pattern-action matching for text processing (like AWK)
        </li>
        <li>
           Object-oriented programming for stateful objects with specialized behavior (e.g. GUIs)
        </li>
        <li>
           Processes, streams, and pipes for connectable text-manipulation programs
        </li>
      </ul>
      <p>
        At a lower level, you can implement all of these designs in most languages. Because tastes differ so much, it would be asking for trouble to suggest which is best for what. Instead, let's just acknowledge some fundamental options, each of which some people really love, each of which has many subcategories:
      </p>
      <ul>
        <li>
           Classes, objects, and messages
        </li>
        <li>
           Procedures, pointers, and system calls
        </li>
        <li>
           Monads, structured types, and lazy evaluation
        </li>
        <li>
           Lists, macros, and recursion
        </li>
      </ul>
      <p>
        We all have our own favorites, and most of us won't have time or occasion to learn all the others, but it doesn't hurt to acknowledge each of them. Smart people are writing good programs in each of these ways, and no doubt countless others, every day.
      </p>
      <hr/>
      <p>
        Note that I did NOT create this topic. --top
      </p>
      <hr/>
      <p>
        “Object-oriented programming is an exceptionally bad idea which could only have originated in California.” — Edsger Dijkstra
      </p>
      <p>
        “object-oriented design is the roman numerals of computing.” — Rob Pike
      </p>
      <p>
        “The phrase "object-oriented” means a lot of things. Half are obvious, and the other half are mistakes.“ — Paul Graham
      </p>
      <p>
        “Implementation inheritance causes the same intertwining and brittleness that have been observed when goto statements are overused. As a result, OO systems often suffer from complexity and lack of reuse.” — John Ousterhout Scripting, IEEE Computer, March 1998
      </p>
      <p>
        “90% of the shit that is popular right now wants to rub its object-oriented nutsack all over my code” — kfx
      </p>
      <p>
        “Sometimes, the elegant implementation is just a function. Not a method. Not a class. Not a framework. Just a function.” — John Carmack
      </p>
      <p>
        “The problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.” — Joe Armstrong
      </p>
      <p>
        “I used to be enamored of object-oriented programming. I’m now finding myself leaning toward believing that it is a plot designed to destroy joy.” — Eric Allman
      </p>
      <p>
        <em>quotes stolen from </em><a href="http://harmful.cat-v.org/software/OO_programming/''">http://harmful.cat-v.org/software/OO_programming/''</a>
      </p>
      <hr/>
      <p>
        What's wrong about having to find the right abstraction? And how is that specific to OO?
      </p>
    </div>
  </body>
</html>