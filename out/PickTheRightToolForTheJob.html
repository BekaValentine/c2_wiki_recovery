<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Pick The Right Tool For The Job
      </h1>
      <p>
        Don't try to hammer a nail with a monkey wrench.
      </p>
      <hr/>
      <p>
        Don't use a screwdriver to pound nails. It takes forever and wrecks the screwdriver.
      </p>
      <hr/>
      <p>
        Based on requirements, <strong>always</strong> pick the right tool for the job. -- <a href="DrewMarsh.html">DrewMarsh</a>
      </p>
      <p>
        Yes, always. Identifying your <a href="ProblemFrame.html">ProblemFrame</a> can help with this. -- <a href="KeithBraithwaite.html">KeithBraithwaite</a>
      </p>
      <hr/>
      <p>
        In practice, few people seem to be able to pick the right tool, because they don't know enough different tools. Also, the right tool for a job happens to be highly dependent on who is going to use it. Maybe this leads to PickTheRightProgrammerForTheJob? (or <a href="SpecializationIsForInsects.html">SpecializationIsForInsects</a>)
      </p>
      <p>
        The <a href="LukeGorrie.html">LukeGorrie</a> story on <a href="LanguageAgnostic.html">LanguageAgnostic</a> drives this point home. I'd seek to employ someone like Luke every time, vs someone who can recite the latest Java API verbatim (or, in past days, the ARM). But I'd also take a chance on someone who showed the ability to be trained into a Luke. -- <a href="KeithBraithwaite.html">KeithBraithwaite</a>
      </p>
      <p>
        <em>I feel compelled to admit that, because I'm a beginner Scheme programmer, doing things the way I did took longer than it would have taken me to do everything by hand. :-) I rationalize this by saying that it gave me experience with this </em><a href="KawaScheme.html">KawaScheme</a> -> <a href="JavaLanguage.html">JavaLanguage</a> compiler that I hope to use heavily in the future. -- <a href="LukeGorrie.html">LukeGorrie</a><em></em>
      </p>
      <p>
        Don't underrate yourself Luke, there are few developers around who would even think of proceeding the way you have, let alone do it. -- KB
      </p>
      <hr/>
      <p>
        I'm sure this is better than picking the wrong tool for the job, but it isn't easy to know what the right thing is. It isn't easy to know all the requirements, and it isn't easy to know what tool set those requirements imply, especially as both tool sets and requirements are apt to change.
      </p>
      <p>
        I'm not suggesting it isn't worth some effort, but I suspect a more plausible goal is <a href="PickAnOkToolForTheJob.html">PickAnOkToolForTheJob</a>.
      </p>
      <hr/>
      <p>
        IrreverentDyslexia alert. When scoping out jobs and considering tools, don't forget to also PickTheRightFoolForTheJob, especially if you want it done right.
      </p>
      <hr/>
      <p>
        An alternative could be <a href="PickTheRightJobForTheTool.html">PickTheRightJobForTheTool</a>.
      </p>
      <hr/>
      <p>
        Managers' alternative: PickTheRightFoolForTheJob.
      </p>
      <hr/>
      <p>
        OK, let's face it. The language list (<a href="http://cui.unige.ch/OSG/info/Langlist/intro.html)">http://cui.unige.ch/OSG/info/Langlist/intro.html)</a> contains 2350 programming languages. I bet you didn't evaluate them all before embarking on your current project. This is a typical example of where it is irrational to be fully rational. Everybody uses a shortlist, and this leads automatically to <a href="PickAnOkToolForTheJob.html">PickAnOkToolForTheJob</a>. But why wasn't the <a href="HaskellLanguage.html">HaskellLanguage</a> on your shortlist?
      </p>
      <p>
        [This sort of decision-making is known as in economics theory as 'satisficing' (<a href="http://en.wikipedia.org/wiki/Satisficing),">http://en.wikipedia.org/wiki/Satisficing),</a> and is unavoidable in any situation where there is insufficient information to determine absolute optimality (i.e., any non-trivial real world situation). While it means that it is usually impossible to find an optimal solution, it does not serve as an argument against attempting to find a <em>better</em> solution. - <a href="JayOsako.html">JayOsako</a>]
      </p>
      <p>
        <em>Ok, you have 2350 languages, but how are they related?  I have heard someone claim that they had a "broad" programming background because they knew c,c++,java and a bit of perl (this was a while ago, I am sure that today they would add c# and python, etc.).  While laughable, these sorts of claims are not as rare as one might hope.  Compare to someone who knew, say, smalltalk, lisp, fortran, and a bit of java....or some permutation</em>
      </p>
      <p>
        This sort of decision-making is known as in economics theory as 'satisficing' (<a href="http://en.wikipedia.org/wiki/Satisficing),">http://en.wikipedia.org/wiki/Satisficing),</a> and is unavoidable in any situation where there is insufficient information to determine absolute optimality (i.e., any non-trivial real world situation). - <a href="JayOsako.html">JayOsako</a>
      </p>
      <hr/>
      <p>
        I am not sure how to pick the right (i.e. absolute best) tool for the job.  I can pick an adequate tool for the job.  Isn't that sufficient?
      </p>
      <p>
        <em>If "adequate" means "right," then yes.</em>
      </p>
      <hr/>
      <p>
        RE: [...] <em>languages are simply tools at our disposal, a skilled carpenter could attempt to use his saw to lever out a bent nail but it would take alot more time and lateral thinking, but the claw hammer is just laying there doing nothing.  Every language has its time and place. [...] I dont think it is possible to create a magic-bullet language, </em>'and no one should try<em>'.</em> [emphasis added, originally from <a href="CeePlusPlus.html">CeePlusPlus</a>]
      </p>
      <p>
        It is true that languages are tools and that there is merit in choosing <a href="TheRightToolForTheJob.html">TheRightToolForTheJob</a>. But it isn't often that just one 'tool' is right for every part of a job. Running with your analogy, a typical project may call for both the saw and the claw hammer. Unfortunately, putting too many tools in your toolbox starts making that toolbox very bulky and heavy - difficult to manage, difficult to learn, and difficult to afford. The same is true of software tools... well, they don't have any physical weight, but they do impose a large learning burden, configuration management costs, and so on (different editors/compilers/interpreters; different forms of managed memory; unwieldy, unsafe, and inefficient <a href="ForeignFunctionInterface.html">ForeignFunctionInterface</a>s; challenges supporting optimizatons/safety/security/reliability/debugging/error handling/logging/transactions/MT-safety/and various other <a href="CrossCuttingConcern.html">CrossCuttingConcern</a>s between multilingual components; etc.). 
      </p>
      <p>
        Because there is a hefty price-tag associated with keeping extra languages in your language-toolbox, <a href="PickTheRightToolForTheJob.html">PickTheRightToolForTheJob</a>, no matter how practical it <em>sounds</em>, is not, in practice, always practical. As a result, there is also considerable merit in the idea of a <a href="GeneralPurposeProgrammingLanguage.html">GeneralPurposeProgrammingLanguage</a> that aims to be all things for all projects. Even when such a language does not provide <a href="TheRightTool.html">TheRightTool</a>, it will often be <a href="GoodEnough.html">GoodEnough</a>. But because it isn't possible for language designers to predict all uses of a language it is useful for a <a href="GeneralPurposeProgrammingLanguage.html">GeneralPurposeProgrammingLanguage</a> to have the <a href="MetaProgramming.html">MetaProgramming</a> facilities to extend it as required (much like the <a href="AllPurposeToolKit.html">AllPurposeToolKit</a> contains a $20 bill just in case). Similarly, because it isn't possible for project developers to anticipate or respond to all feature demands, it helps if the language makes easy and <em>relatively</em> efficient support for safe and efficient runtime extensions - <a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a> and <a href="PluginArchitecture.html">PluginArchitecture</a> all within just one language.
      </p>
      <p>
        Unfortunately, while <a href="CeePlusPlus.html">CeePlusPlus</a> does aim to be something of a <a href="GeneralPurposeProgrammingLanguage.html">GeneralPurposeProgrammingLanguage</a>, it is far from ideal for such a purpose. The inability to modularize a new feature in a <a href="GeneralPurposeProgrammingLanguage.html">GeneralPurposeProgrammingLanguage</a> without leaking implementation details or severely compromising <a href="NonFunctionalRequirements.html">NonFunctionalRequirements</a> has been called the <a href="MissingFeatureSmell.html">MissingFeatureSmell</a>, and C++ positively reeks of it. It lacks, among other things, suitably powerful <a href="MetaProgramming.html">MetaProgramming</a> facilities (<a href="TemplateMetaprogramming.html">TemplateMetaprogramming</a> is not <a href="GoodEnough.html">GoodEnough</a>), and is awful at <a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a> (bad enough that people have created dedicated general purpose languages that aren't <a href="CeePlusPlus.html">CeePlusPlus</a> to become the 'soft layer').
      </p>
      <p>
        But, regardless of whether C++ is suitable to the goal, the benefits of having a single language that is <a href="GoodEnough.html">GoodEnough</a> for every task is very appealing, very practical, and well worth pursuing. The dream is enough to inspire such thoughts as the <a href="SingleLanguageOperatingSystem.html">SingleLanguageOperatingSystem</a>. The trick is to avoid the language itself becoming the massive and unwieldy toolbox aforementioned.  We need a single, coherent tool - perhaps related to <a href="SymmetryOfLanguage.html">SymmetryOfLanguage</a>. And even if it is 'impossible' to succeed 100% of the way, coming arbitrarily close is still likely to be a great deal better and more practical than is the situation today.
      </p>
      <p>
        <strong>RE:</strong> [<a href="CeePlusPlus.html">CeePlusPlus</a>] is awful at <a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a> (bad enough that people have created dedicated general purpose languages that aren't <a href="CeePlusPlus.html">CeePlusPlus</a> to become the 'soft layer').
      </p>
      <p>
        <em>Wait ... the whole purpose of </em><a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a> is <em>precisely</em> to get away from lower-level, less-flexible langauges like C/C++ for expressing solutions to problems in their ideal notation.  Your parenthetical qualification, therefore, serves no purpose as stated.  Who <strong>ever</strong> would consider using C++ as a soft layer?  However, many folks <em>have</em> invented new languages (the most famous of which is <a href="JavaLanguage.html">JavaLanguage</a>) to avoid C++ like the plague that it is, for the purpose of serving as a <em>hard</em> layer.  So, shouldn't you have written, ". . ., that aren't <a href="CeePlusPlus.html">CeePlusPlus</a> to be the 'hard layer'" instead?<em></em>
      </p>
      <p>
        A <a href="GeneralPurposeProgrammingLanguage.html">GeneralPurposeProgrammingLanguage</a> <em>should be</em> able to <a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a> <em>without</em> resorting to a different language. I do not believe that there <em>should be</em> a significant dichotomy between 'lower-level, less-flexible languages like C/C++' and 'languages for expressing solutions to problems in their ideal notation'; a <a href="GeneralPurposeProgrammingLanguage.html">GeneralPurposeProgrammingLanguage</a> <em>should be</em> '<a href="GoodEnough.html">GoodEnough</a>' at fulfilling both roles - fulfilling many such roles is what "general purpose" <em>means</em>.  <a href="CeePlusPlus.html">CeePlusPlus</a>'s failure to be good as a soft layer (no language-recognized modularity, safety/sandboxing, general lack of support for parsing or interpreting in its standard library, etc.) and its failure to provide expression of some problems in a <a href="GoodEnough.html">GoodEnough</a> (if not ideal) notation (due to weak <a href="MetaProgramming.html">MetaProgramming</a>) are both failures of <a href="CeePlusPlus.html">CeePlusPlus</a> in its role as a <a href="GeneralPurposeProgrammingLanguage.html">GeneralPurposeProgrammingLanguage</a> - which is significant because <a href="CeePlusPlus.html">CeePlusPlus</a> does not fill any roles as a <a href="DomainSpecificLanguage.html">DomainSpecificLanguage</a>. 
      </p>
      <p>
        Other languages that purport to be <a href="GeneralPurposeProgrammingLanguage.html">GeneralPurposeProgrammingLanguage</a>s often have the same failing. For example, <a href="JavaLanguage.html">JavaLanguage</a> should be the soft layer for <a href="JavaLanguage.html">JavaLanguage</a>. It works for compiled Lisp and Forth. Why not Java and C++?
      </p>
      <p>
        That people feel the need to "avoid C++ like the plague that it is" is <em>because</em> the lack of support for effective <a href="MetaProgramming.html">MetaProgramming</a> and <a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a> are just two among a myriad of failures for <a href="CeePlusPlus.html">CeePlusPlus</a> in its role as a <a href="GeneralPurposeProgrammingLanguage.html">GeneralPurposeProgrammingLanguage</a>. 
      </p>
      <hr/>
      <p>
        See also: <a href="LanguageAgnostic.html">LanguageAgnostic</a>, <a href="MethodAgnostic.html">MethodAgnostic</a>, <a href="MixingParadigms.html">MixingParadigms</a>, <a href="UtahPhillips.html">UtahPhillips</a>, <a href="FallacyOfTheRightTool.html">FallacyOfTheRightTool</a>
      </p>
    </div>
  </body>
</html>