<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Reverse Proxy
      </h1>
      <p>
        <a href="ReverseProxy.html">ReverseProxy</a>, referring specifically to HTTP(S) servers, is a front-end server 
        that passes requests on to one or more backend servers that actually serve the 
        content, much as a NAT packet filter with port forwarding. 
        In doing so, the server will often implement some kind of load balancing 
        among servers that may be just scripts deployed as in <a href="RunScriptAsDaemon.html">RunScriptAsDaemon</a>.
      </p>
      <p>
        <a href="PoundReverseProxy.html">PoundReverseProxy</a> is an excellent tool that accepts HTTPS connections and forwards 
        them as HTTP.
      </p>
      <p>
        Apache can do this too.
      </p>
      <p>
        - And of course, Squid: www.squid-cache.org
        In the still-being-developed branch of Squid, ESI is integrated. ESI is really interesting for high-load sites which deliver a mixture of dynamic and (semi)static content. See www.esi.org
      </p>
      <p>
        <a href="FastCgi.html">FastCgi</a> and SCGI are variations on this theme that convert the HTTP protocol 
        to CGI before passing it on.
      </p>
      <p>
        Xitami [<a href="http://xitami.com/]">http://xitami.com/]</a> does this backward in the LRWP module. 
        (The backend servers connect to the proxy as clients, rather than the proxy 
        connecting to the servers. This results in and increased security risk and 
        a drastic reduction in scalability.).....
      </p>
    </div>
  </body>
</html>