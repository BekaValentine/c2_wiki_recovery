<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Build In Pervasive Orthogonal Attributes
      </h1>
      <p>
        One of the most fundamental and general principles of design.
      </p>
      <p>
        Let's say you have some entities (eg, objects, references) and you have some attributes of those entities (eg, security, versioning, persistence) which are <em>pervasive</em> (entities with those attributes breed like maggots) and <em>orthogonal</em> (there isn't any entity that could <em>not</em> have those attributes by virtue of being that entity). So what do you do in that case? You build in the attributes into the definition of the entities.
      </p>
      <p>
        This is as opposed to building the attributes <em>on top of</em> the entities.
      </p>
      <p>
        <strong>Examples</strong>
      </p>
      <p>
        Let's say you've got an object graph. Every reference in that object graph <em>could be</em> a capability (it's orthogonal) and every reference in that object graph <em>should be</em> a capability (it's pervasive). Therefore, build capabilities into the object graph.
      </p>
      <p>
        Let's say you've got a capability object graph. Every capability in that graph <em>could have</em> the set of standard <a href="PermissionFlags.html">PermissionFlags</a> (since the standard permission flags are defined solely with respect to the object graph itself) and every capability <em>should have</em> a set of permission flags. Therefore, build permission flags right into capabilities. See <a href="BuildSecurityAbstractionsIntoCapabilities.html">BuildSecurityAbstractionsIntoCapabilities</a> for more.
      </p>
      <p>
        The same with versioning. The same with <a href="GarbageCollection.html">GarbageCollection</a>.
      </p>
      <p>
        <a href="OrthogonalPersistence.html">OrthogonalPersistence</a>. It's not every process / object graph that should be persistent. In fact, if you make the memory manager orthogonally persistent, you create a <a href="StrangeLoop.html">StrangeLoop</a> in the OS. It's only typical user processes that should be orthogonally persistent. As a consequence, OP shouldn't be built into processes, but it should be built into user processes. (Which turns out to be trivial if you define processes in a sufficiently flexible manner.)
      </p>
      <p>
        <strong>Non-examples</strong>
      </p>
      <p>
        Changesets. Every object in an OS can belong to one or more changesets, but it's not the case that every object <em>is</em> a changeset.
      </p>
      <p>
        Execution. It's not every object that can accept a thread.
      </p>
      <p>
        Process ports. It's not every process that <em>should</em> have access to arbitrary other ports.
      </p>
    </div>
  </body>
</html>