<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Strategy Pattern
      </h1>
      <p>
        <strong>Intent:</strong> Define a family of algorithms, encapsulate each one, and make them interchangeable.  Strategy lets the algorithm vary independently from clients that use it.
      </p>
      <hr/>
      <p>
        When is it a <a href="StrategyPattern.html">StrategyPattern</a> and when is it <a href="StatePattern.html">StatePattern</a>?  I have heard the quote "eventually everything looks like a Strategy" (can't remember the attribution), but I still can't see how a Strategy is distinct from a State.
      </p>
      <p>
        <em>Isn't it active (Strategy) vs. passive (State) ? For instance, you will compare the time, cost or distance estimates for different modes of travel (on foot, by metro, by car, for instance) by passing your parameters to appropriate TravelStrategy objects; whereas a TravelMode could use the </em><a href="StatePattern.html">StatePattern</a> to say of a given Traveler object that she prefers, at various times, to use her car, take the metro, or go on foot.<em></em>
      </p>
      <p>
        Strategy and State are pretty similar.  Both have a "context", an original object that is split into pieces, which are the strategy or the state, and both organize those pieces into a class hierarchy so that instead of having a case statement to choose between the pieces, the context sends a message to the current piece, and the code is selected using polymorphism. However, when I am using them I tend to think differently.  
      </p>
      <p>
        A strategy is an algorithm.  Strategies often have internal variables that record the state of the algorithm.  At the end of the algorithm, the variables might record the result, but in general they are only meaningful during the execution of the algorithm.  A strategy is either selected by an outside agent or by the context.  A strategy tends to have a single "start" method, and it calls all the rest.  There is a lot of cohesion between the methods of a strategy.
      </p>
      <p>
        In contrast, a state usually has no variables.  ("State has no state", is what I say.)  A state usually selects the next state of its context. A state tends to have lots of unrelated methods, so there is little cohesion between the methods of a state.
      </p>
      <p>
        Perhaps this is not enough reason to distinguish between the two patterns. But I find enough uses of pure State and Strategy that I don't mind those times when the design ends up half one and half the other.  --<a href="RalphJohnson.html">RalphJohnson</a>
      </p>
      <hr/>
      <p>
        In visitor pattern the object structure accepts a visitor and performs visit on it.
        In strategy the only difference I could notice was that the composite or object structure composes a strategy object and calls Algorithm. Aren't these two patterns essentially the same? Or rather can I put it like strategy is a cutdown version of visitor or a visitor on a single type of element? -- Praveen
      </p>
      <p>
        In the <a href="StrategyPattern.html">StrategyPattern</a>, the context points to a strategy and delegates to it.  There is no context
        in the <a href="VisitorPattern.html">VisitorPattern</a> and the visitor is often created each time it is used.  The <a href="VisitorPattern.html">VisitorPattern</a> is based
        on DoubleDispatching, and there is none in the <a href="StrategyPattern.html">StrategyPattern</a>.  As far as I can see, these patterns
        have little to do with each other.	--<a href="RalphJohnson.html">RalphJohnson</a>
      </p>
      <hr/>
      <p>
        Both are examples of <a href="ObjectifiedBehavior.html">ObjectifiedBehavior</a>. I try to think of the Strategy as a generalization of the State. State is a specialization of the Strategy where behaviour is based on the state of the object. --<a href="SaurabhBanerjee.html">SaurabhBanerjee</a>
      </p>
      <hr/>
      <p>
        While the structure of the two patterns is the same or similar, I think the intent is what is different.  The <a href="StatePattern.html">StatePattern</a> is a way to vary an object's behavior dynamically, whereas the <a href="StrategyPattern.html">StrategyPattern</a> is a way to vary the implementation.  That's how I see it anyway. -- <a href="JasonArhart.html">JasonArhart</a>
      </p>
      <hr/>
      <p>
        In my opinion, the <a href="StrategyPattern.html">StrategyPattern</a> and the <a href="StatePattern.html">StatePattern</a> are not strongly related as suggested by many. The primary intention of the <a href="StrategyPattern.html">StrategyPattern</a> is [behavioral] parameterization. The <a href="StrategyPattern.html">StrategyPattern</a> allows the client of a software component to parameterize the component by behavior. The primary intention of the <a href="StatePattern.html">StatePattern</a> is the simplification of complex logic related to the implementation of state machines or stateful objects. In my opinion, these are almost completely unrelated issues. In my opinion, the <a href="StrategyPattern.html">StrategyPattern</a> is more closely related to the <a href="TemplateMethodPattern.html">TemplateMethodPattern</a> and very strongly related to the <a href="FunctorObject.html">FunctorObject</a> pattern. -- <a href="VesaKarvonen.html">VesaKarvonen</a>
      </p>
      <hr/>
      <p>
        Are there similarities between <a href="StrategyPattern.html">StrategyPattern</a> and <a href="AbstractFactoryPattern.html">AbstractFactoryPattern</a>?
      </p>
      <p>
        <em>The only similarity I see is that they both use a common interface to abstract a common behaviour. </em><a href="AbstractFactoryPattern.html">AbstractFactoryPattern</a> is in <a href="CategoryCreationalPatterns.html">CategoryCreationalPatterns</a>, as opposed to a <a href="StrategyPattern.html">StrategyPattern</a>, which belongs to <a href="CategoryBehavioralPatterns.html">CategoryBehavioralPatterns</a>. In fact, you can use <a href="AbstractFactoryPattern.html">AbstractFactoryPattern</a> to instantiate your strategies (if it's applicable for your problem, of course).<em></em>
      </p>
      <hr/>
      <p>
        Can you say "plug-in"? --mt
      </p>
      <hr/>
      <p>
        This is my speculation, but I think that from an intent point of view, strategy means "same result, different way to get there." Sorting algorithms are the canonical example. I might be wrong here, but most of the things I used to call strategy is really just abstraction/polymorphism. I guess the real question here is, is strategy: a.) different ways to get the same result or b.) different ways to do the same thing? Actually, the more I think about it, the more I realize that my initial assumption is probably incorrect. It seems that strategy is just different ways to do the same (abstract) thought/thing (e.g. Compressing a file - zip, rar, etc.). So then, maybe (almost) everything IS just a strategy ;)
      </p>
      <p>
        <em>A strategy is an (<- SINGULAR) abstracted plan for getting from an (potentially) abstract set of initial conditions to a (potentially) abstract set of final conditions.  Every piece of imperative code we ever write with a purpose exhibits some sort of strategy - not so much for constraint/logic programming and some functional programming (where the strategy isn't expressed and is instead left to the compiler).  When you instantiate some of the abstract variables in a strategy, you get either a concrete plan (rarely) or another strategy (which will still have 'if' conditions and various other contingencies), which is more likely.  </em><a href="StrategyPattern.html">StrategyPattern</a> is useful when you have many strategies - many plans for getting from the same set of initial conditions to the same set of final conditions; if you abstract based on these initial and final conditions, you can swap out one strategy for another.  At this point you end up with many different strategies and thus 'different ways' <- PLURAL.  Of course, there isn't much point to <a href="StrategyPattern.html">StrategyPattern</a> unless you (a) DO have more than one strategy available to you, and (b) can derive some sort of benefit from the ability to change strategies (e.g. controlling memory costs and processing time, completeness of results, etc.).  One can usefully abstract over search strategies, sorting strategies, etc. - even planning strategies and learning strategies.<em></em>
      </p>
      <p>
        <em>Note that planning systems make plans but don't require strategies - they can come up with a solution 'from scratch' every single time without relying upon any pre-fabricated plans.  But any decent </em>learning<em> system (well, at least those with planning support) would eventually come up with heuristic strategies to be applied in 'common' situations (based on analysis of failure and success of its own prior attempts and the conditions surrounding them).  It might not come up with formal strategies, though.  And it might not come up with 'good' strategies, either - unless you give it both heuristics AND goals for optimizing the strategies themselves (e.g. less cost, less damage, less effort, less energy); without a motivator for efficiency, a system will simply build strategies over what seems to have worked and what hasn't, no matter how inefficient the successes have been.</em>
      </p>
      <hr/>
      <p>
        Possible downsides: <a href="GranularityOfVariation.html">GranularityOfVariation</a>
      </p>
      <hr/>
      <p>
        See also: <a href="FacadeMementoStrategy.html">FacadeMementoStrategy</a>, <a href="DesignPatterns.html">DesignPatterns</a>, <a href="ExplicitStrategyPattern.html">ExplicitStrategyPattern</a>, <a href="StatePattern.html">StatePattern</a>, <a href="TableOrientedProgrammingDiscussion.html">TableOrientedProgrammingDiscussion</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryPattern.html">CategoryPattern</a>, <a href="CategoryPolymorphism.html">CategoryPolymorphism</a>
      </p>
    </div>
  </body>
</html>