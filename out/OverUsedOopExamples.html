<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Over Used Oop Examples
      </h1>
      <p>
        OOP examples that <a href="TopMind.html">TopMind</a> claims are used way too often, but don't seem to extrapolate to realistic business modeling.
      </p>
      <ul>
        <li>
           Device driver
        </li>
        <li>
           GUI 
        </li>
        <li>
           Shapes
        </li>
        <li>
           Stack
        </li>
        <li>
           Animals
        </li>
        <li>
           Employee subtypes (lack multidimensional taxonomies)
        </li>
        <li>
           Car sub-assemblies
        </li>
      </ul>
      <p>
        <em>What do you want to see, then? Why don't they extrapolate to realistic business modeling? What </em>is<em> "realistic business modeling"?</em>
      </p>
      <p>
        Generally the problem with <em>realistic business models</em> is that they vary from business to business.
      </p>
      <p>
        I would personally like to see OO designs that handle something like the <a href="CampusExample.html">CampusExample</a>. Perhaps make it web-based so that we don't have a GUI API war on top of it all.
      </p>
      <p>
        The problem with many OO examples (and HOF also) is that they assume too much regularity. They don't show how to account for the <a href="EightyTwentyRule.html">EightyTwentyRule</a> where the abstraction is too perfect compared to the actual situations. The <a href="EightyTwentyRule.html">EightyTwentyRule</a> is probably the biggest buggaboo for astractors.
      </p>
      <hr/>
      <p>
        [The following moved here from <a href="PrinciplesOfObjectOrientedDesign.html">PrinciplesOfObjectOrientedDesign</a> - no need to have a discussion about this on two different pages, and it fits this topic much better than the principles page. -- <a href="FalkBruegmann.html">FalkBruegmann</a>]
      </p>
      <p>
        Many of these principles or the examples used tend to focus on systems software instead of business or domain modeling. Is there is systems-software bias among the OO community? They are overly heavy with device-driver and embedded device examples, for instance. Some <a href="RelationalWeenie.html">RelationalWeenie</a>s suggest that OO is weak at business modeling because it tends to try to reinvent the database in code without learning from database history's lessons.
      </p>
      <p>
        <em>Which principles or examples focus on systems software?</em>
      </p>
      <p>
        I don't know of any that focus on business modeling. Let me restate the issue. I do not find the above material very applicable to business modeling. Although Robert Martin has a payroll example, I disagree with it on the grounds that its taxonomy of employees is artificial, uses IS-A where HAS-A is more appropriate (<a href="PolymorphismLimits.html">PolymorphismLimits</a>). If we find more, then maybe we can create an OoBusinessModelingMethodologies or something. As it stands, the above favors systems software.
      </p>
      <p>
        <em>The principles above are applicable to software development in any domain.  They guide how code is organized, not what it is used for.  They don't favor system software any more than they favor any other type of software.</em>
      </p>
      <p>
        I tend to disagree. System software tends to deal with dynamic implementations of static interfaces, while business modeling usually only has one implementation, yet has dynamic interfaces. Further, it may be a requirement to implement database-like operations (read, update, delete, list, save, sort, etc.) in system software because that is the pre-designed interface you are given as part of formal standards or de-facto standards of other vendors, but often not appropriate in business software (<a href="ReinventingTheDatabaseInApplication.html">ReinventingTheDatabaseInApplication</a>). IOW, the invariants and things a designer has control over are vastly different between the domains.
      </p>
      <p>
        <em>I've been writing business and system software for the last 17 years and I can't figure out what you're talking about.  What's a "dynamic interface"?</em>
      </p>
      <p>
        An interface that changes a lot. For example, device driver interfaces are not going to change very often because a lot of implementors depend on them, and if you change something, a bunch of implementors have to change something also. How about you pick your favorite example above, and show how it applies to both domains.
      </p>
      <p>
        <em>OK, you mean dynamic APIs.  My experience is that both system and business software need stable APIs that can be expanded.  OO doesn't help much, since most component APIs look procedural from the outside.  Relational query languages provide no way of defining component level APIs, dynamic or otherwise.</em>
      </p>
      <p>
        That generally seems to agree with <a href="WhenToUseWhatParadigm.html">WhenToUseWhatParadigm</a>.
      </p>
      <hr/>
      <p>
        See also: <a href="TopsQueryResultSet.html">TopsQueryResultSet</a> (shapes)
      </p>
      <hr/>
      <p>
        <a href="CategoryExample.html">CategoryExample</a>, <a href="CategoryObjectOrientation.html">CategoryObjectOrientation</a>
      </p>
    </div>
  </body>
</html>