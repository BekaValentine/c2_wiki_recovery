<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        In Memory Impostor For Oracle
      </h1>
      <p>
        Oracle groks SQL, dunnit? The trick is to write the queries you need for <a href="UnitTest.html">UnitTest</a>s, run them once in Oracle, save the results to files or global objects in your test OODB or wherever you like. Then the <a href="InMemoryImpostor.html">InMemoryImpostor</a> just looks up the SQL in a dictionary and answers the query result.
      </p>
      <p>
        Sure, it won't do everything ... but combined with a few tests to make sure the Oracle interface itself works, you can orthogonalize the RDB testing way down to a bunch of small tests giving fast and big results.
      </p>
      <p>
        <em>Sure, recordsets can be written to files and brought back for testing purposes. A pass-through DAL could have a switch to flip on testing mode, in which case it would retrieve the appropriate recordset whenever the associated query was passed in. But this is select-only; if you're testing the ability to make a series of database changes in combination with the selects - typical RDB app behaviour - then I think the </em><a href="InMemoryImpostorForOracle.html">InMemoryImpostorForOracle</a> is going to get heavy faster than the app I'm trying to test. Which takes me back to <a href="ExtremeProgrammingChallengeThirteenPointFive.html">ExtremeProgrammingChallengeThirteenPointFive</a>.<em></em>
      </p>
    </div>
  </body>
</html>