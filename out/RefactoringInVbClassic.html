<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Refactoring In Vb Classic
      </h1>
      <p>
        <a href="CategoryRefactoring.html">CategoryRefactoring</a>:
      </p>
      <dl>
        <dt> </dt>
        <dd><strong>"How can you refactor </strong><a href="VbClassic.html">VbClassic</a> when it's got no such thing as inheritance?"<strong></strong></dd>
      </dl>
      <p>
        See <a href="RefactoringInVisualBasic.html">RefactoringInVisualBasic</a> for refactoring in <a href="VisualBasicDotNet.html">VisualBasicDotNet</a>.
      </p>
      <hr/>
      <p>
        <em>(...a discussion started in </em><a href="ExtremeProgrammingWithVbClassic.html">ExtremeProgrammingWithVbClassic</a>.)<em></em>
      </p>
      <p>
        <strong><em>Answers:</em></strong>
      </p>
      <ul>
        <li>
           See <a href="ExperiencesWithRefactoringInVbClassic.html">ExperiencesWithRefactoringInVbClassic</a>.
        </li>
      </ul>
      <ul>
        <li>
           Use a tool:
          <ul>
            <li>
               CodeShineâ„¢ -- "THE refactoring add-in for Microsoft Visual Basic 6 (VB6)." -- <a href="http://www.wsdesigns.com/CodeShine/default.htm">http://www.wsdesigns.com/CodeShine/default.htm</a>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <em></em>'But there is <a href="InheritanceInVbClassic.html">InheritanceInVbClassic</a>!<strong><em> </em>(...and ways to do </strong><a href="VbClassicImplementationInheritance.html">VbClassicImplementationInheritance</a>.)<em></em>
        </li>
      </ul>
      <hr/>
      <hr/>
      <p>
        <strong><em>Comments:</em></strong>
      </p>
      <p>
        I have usually found that inheritance plays a small role in refactoring.  I find that I use far more containment than inheritance, because the refactored portions often do not need to be exposed for application program use, and containment easily exposes the methods for testing.
      </p>
      <hr/>
      <p>
        Use subroutines!
      </p>
      <p>
        <em>You</em>
        can
        <em>shuffle code around.</em>
      </p>
      <p>
        There is no reason why you can't write good code in VB.
      </p>
      <p>
        <em>"Good Code" isn't the question. To refactor, you usually try to make things </em><a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a>. How do you do that with subroutines?<em></em>
      </p>
      <p>
        <strong>Surely that is the point of a sub-routine?  You have sub-routines that perform a piece of functionality that get called from the places where that code would, otherwise, need to be repeated.</strong>
      </p>
      <p>
        "Bad code" is usually much harder to extract in another sub or function. Especially Exits (Exit For, Exit Sub, etc.) are a real pain, just like gotos. You'll be glad if the code you want to refactor is well structured.  --  <a href="WillemBogaerts.html">WillemBogaerts</a>
      </p>
      <p>
        I routinely practice code re-structuring as a part of refactoring. Building a unified point of exit inside the function (a 'Procedure_Exit' label), and then changing the Exits to 'Goto Procedure_Exit' provides extra structure (as well as an opportunity to clean up for the function before 'Exit Sub') to the function, and enables much refactoring.' -AaronCumming
      </p>
      <p>
        Encapsulation can be used in place of inheritance and most times it it superior to inheritance when refactoring.
      </p>
      <hr/>
      <p>
        It's been my experience that you can do Refactoring in practically any programming language, even if it's not object oriented:
        If you're working on a procedural program in a structured language, for example, it can be quite beneficial to refactor it, making it more Structured or Modular.
        (See <a href="StructuredProgramming.html">StructuredProgramming</a> and <a href="ModularProgramming.html">ModularProgramming</a>.)
        I was quite successful, for a number of years, refactoring C programs, making them more reliable, robust, efficient, and maintainable.
      </p>
      <p>
        So there's every reason to believe that one can successfully refactor <a href="VisualBasic.html">VisualBasic</a> programs:
        <a href="VisualBasic.html">VisualBasic</a> even supports creation of COM classes and objects.
      </p>
      <p>
        Starting in 1999 I had some experience doing <a href="RefactoringInVisualBasic.html">RefactoringInVisualBasic</a> with <a href="VbClassic.html">VbClassic</a>:
      </p>
      <p>
        I applied some of the standard refactorings, as described in <a href="MartinFowler.html">MartinFowler</a>'s <a href="RefactoringImprovingTheDesignOfExistingCode.html">RefactoringImprovingTheDesignOfExistingCode</a> book:
      </p>
      <ul>
        <li>
           <a href="ConsolidateDuplicateConditionalFragments.html">ConsolidateDuplicateConditionalFragments</a> (page 243)
        </li>
        <li>
           <a href="ReplaceMagicNumberWithSymbolicConstant.html">ReplaceMagicNumberWithSymbolicConstant</a> (page 204)
        </li>
      </ul>
      <p>
        And I started these pages to document <a href="VbClassic.html">VbClassic</a> refactorings I was doing at the time:
      </p>
      <ul>
        <li>
           <a href="VbClassicRefactorTypeToClass.html">VbClassicRefactorTypeToClass</a> (like <a href="MartinFowler.html">MartinFowler</a>'s <a href="ReplaceRecordWithDataClass.html">ReplaceRecordWithDataClass</a>, page 217)
        </li>
        <li>
           <a href="ConsolidateDuplicateConditionalFragments.html">ConsolidateDuplicateConditionalFragments</a> 
        </li>
        <li>
           <a href="RefactorIntroduceWith.html">RefactorIntroduceWith</a> / <a href="RefactorEliminateWith.html">RefactorEliminateWith</a>, <a href="RefactorMatchLoopToUsage.html">RefactorMatchLoopToUsage</a>, <a href="RefactorNegateIf.html">RefactorNegateIf</a>, <a href="RefactorDefaultOrElse.html">RefactorDefaultOrElse</a>, <a href="RefactorRenestBlocks.html">RefactorRenestBlocks</a> 
        </li>
        <li>
           <a href="ReduceScopeOfVariable.html">ReduceScopeOfVariable</a>
        </li>
        <li>
           <a href="RenameClassInVbClassic.html">RenameClassInVbClassic</a>
        </li>
        <li>
           <em>and others...</em>
        </li>
      </ul>
      <p>
        -- <a href="JeffGrigg.html">JeffGrigg</a>
      </p>
      <hr/>
      <p>
        I've been working on making VB6 a more OO-Friendly language by exploring some... hmmm... unusual ways to instantiate objects. This has led me to what I call:
      </p>
      <p>
        The <a href="IntroduceCreationObject.html">IntroduceCreationObject</a> Refactoring
      </p>
      <p>
        I've used this in more than 3 different projects and my peers in the company seemed to like the results so they're using it as well. I wonder if it qualifies now as a Pattern? :)
      </p>
      <p>
        -- <a href="AlfredoChavez.html">AlfredoChavez</a>
      </p>
      <hr/>
      <p>
        Refactoring, like <a href="DesignPatterns.html">DesignPatterns</a>, is not applicable only to OOP languages. Likewise the principles laid out by <a href="SteveMcConnell.html">SteveMcConnell</a> in <a href="CodeComplete.html">CodeComplete</a>, while written for procedural/structured programming, are equally applicable to OOP languages. In fact, when presenting the ideas of Refactoring to other developers I use McConnell's discussions of the principles of cohesion and coupling as a way of identifying the most obvious smells that refactoring can address.
        -- <a href="SteveSawyer.html">SteveSawyer</a>
      </p>
      <hr/>
      <p>
        The <a href="MediatorPattern.html">MediatorPattern</a> can be used among a form's subroutines.
        Instead of having complicated, interacting events like cmdFoo_Click and txtBar_Change,
        the GUI update code can be delegated to a shared UpdateGui() subroutine.
        This UpdateGui() routine has the same role as the aFontDialogDirector mediator in the <a href="GangOfFour.html">GangOfFour</a>'s example [GOF:274].  The interacting controls (cmdFoo and txtBar) are the colleagues in the <a href="GangOfFour.html">GangOfFour</a>'s example.
      </p>
      <hr/>
      <p>
        <a href="CategoryVbClassic.html">CategoryVbClassic</a>
      </p>
    </div>
  </body>
</html>