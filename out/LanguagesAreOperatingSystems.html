<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Languages Are Operating Systems
      </h1>
      <p>
        This page presents a powerful ideal. As with any model, it is not the
        only reasonable view; if you are a implementing experimental operating
        system ideas that must work with a variety of languages, then this
        point of view doesn't happen to apply. But if you're evaluating
        or designing languages, then the below may well apply.
      </p>
      <hr/>
      <p>
        Some languages were specifically designed to be operating systems (see <a href="LanguageIsAnOs.html">LanguageIsAnOs</a>). Whether or not that's the case, all [general-purpose] languages should be evaluated on that basis. A language that makes up a bad operating system is simply a bad language.
      </p>
      <code>
        Can we say "...all *general purpose* languages should be evaluated on that basis" here<br/>
        instead? -- <a href="StevenShaw.html">StevenShaw</a>  <em>--Done</em><br/>
      </code>
      <p>
        <em>An operating system is a collection of things that don't fit into a language. There shouldn't be one.</em> --<a href="DanIngalls.html">DanIngalls</a>
      </p>
      <ul>
        <li>
           That's only true until one has made the <a href="PerfectSystem.html">PerfectSystem</a>, where the Application and the <a href="OperatingSystem.html">OperatingSystem</a> are <strong>One</strong>.
        </li>
      </ul>
      <p>
        (from <a href="http://users.ipa.net/~dwighth/smalltalk/byte_aug81/design_principles_behind_smalltalk.html)">http://users.ipa.net/~dwighth/smalltalk/byte_aug81/design_principles_behind_smalltalk.html)</a>
      </p>
      <p>
        The greatest open secret in computer science.
      </p>
      <p>
        The converse, that operating systems are languages is widely known. Where does an OS designer get inspiration from if not from various languages? This is especially true in the case of functional languages. (Damn those bastards, always twenty years ahead of the rest of us.)
      </p>
      <p>
        But how could a language designer get inspiration from an OS? After all, OSes are written <em>in</em> languages! However, they have many features which languages don't attempt to provide. Chief among them is security (don't anyone dare to bring up Java! GRRR).
      </p>
      <p>
        So if languages are operating systems, then what kind of operating system is <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>? Well, Smalltalk has absolutely no security, protection or access control. Smalltalk is DOS. See <a href="SmalltalkSecurity.html">SmalltalkSecurity</a>.
      </p>
      <p>
        And what kind of OS are C/C++ and the other non-interactive languages? The useless clunky batch processing ones!
      </p>
      <p>
        <em>Non-interactive?</em>
      </p>
      <p>
        Non-incremental. Non-interpreted.
      </p>
      <hr/>
      <p>
        While a suitably-capable language might be all the machine abstraction you need, keeping the two concerns separate strikes me as a fundamentally better idea.  Modularity and all that.  And the marketplace seems to agree (for now at least).
      </p>
      <p>
        OSes need the ability to support multiple languages.  On my PC running <a href="LinuxOperatingSystem.html">LinuxOperatingSystem</a> at home (replace with Windows if you prefer) I can run software in any language I like--C/C++, Lisp, Java, Smalltalk, Perl, Python, Fortran, Ruby, whatever.  All languages of importance have been ported to either platform.  What's more, I can mix and match applications written in these different languages as I like--and even have applications with portions written in different languages (<a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a>). Any language that functions as an OS would have to allow free commingling with other languages.
      </p>
      <p>
        The situation which has long existed with C/C++, where the language and standard libraries fail to abstract a reasonable subset of the capabilities of a modern operating system (no networking; no concurrency, multithreading, or synchronization; only rudimentary and simple I/O; no sound, graphics, or multimedia support; minimal user-interface support (no windowing system; no support for input devices other than a "terminal); no inter-process communication; etc.) is deplorable.  However, replacing the current state of affairs with a <a href="PinkyAndTheBrainLanguage.html">PinkyAndTheBrainLanguage</a> is doomed to fail--indeed, the rotting corpses of several such beasts line the highways of computer science.
      </p>
      <p>
        I agree that languages and operating systems <em>could</em> be unified.  They both serve the purpose of abstracting the underlying machine, and a providing a sane(r) programming model.  And maybe in the future, once the body of knowledge in both domains as become static, they will be.  But for now--I see little end user (or developer) benefit for running Java or Lisp or Smalltalk as my operating system.  The beneficiaries of such a notion mostly seem to be the advocates of the language in question.
      </p>
      <p>
        --<a href="ScottJohnson.html">ScottJohnson</a>
      </p>
      <p>
        Being able to run programs in other languages in your language/OS is one of the desiderata described above (<a href="ExoKernel.html">ExoKernel</a> and all that).
      </p>
      <p>
        <em>I can do that today.  </em><a href="ExoKernel.html">ExoKernel</a>s might be a cool way to design an OS.  But I detect a whiff of SuperlativeSmell about the technology.<em></em>
      </p>
      <p>
        As for the "choice of the marketplace", the only disproof I need is to point to Unix and Windows.
      </p>
      <p>
        <em>What's wrong with Unix and Windows?  While they may both suck :), they're both better than a hypothetical OS that doesn't exist, or a prototype OS that fulfills 10% of its requirements.  Producing a list of </em>ThingsAnOperatingSystemShouldDo, and then showing how current OS's don't measure up--is an interesting exercise.  However, until a production-ready OS which <em>does</em> do those things is available, it's not an argument for abandoning what we currently have.<em></em>
      </p>
      <p>
        <em>I'd love to have an OS better than what we have today.</em>
      </p>
      <p>
        Second hand Lisp machines aren't that hard to find.
      </p>
      <p>
        <em></em><a href="QuestForThePerfectLanguage.html">QuestForThePerfectLanguage</a> = QuestForThePerfectOs?<em></em>
      </p>
      <hr/>
      <p>
        I think the idea of Languages Are Operating Systems misses the point of operating systems.
      </p>
      <p>
        Operating systems provide capabilities uses by languages and language libraries.  Operating systems provide such details as drivers and file systems, multitasking and task scheduling, program loaders, and user interfaces.  Try porting a program from MS-Windows to XWindows and see how many OS differences there are despite a common language.
      </p>
      <p>
        A language provides a filter through which parts of the Operating System can be called, but it does not supersede the Operating System.
      </p>
      <hr/>
      <p>
        Drivers are a kludge.  Hardware should directly tell applications how to use them.  File systems aren't so great, either...they're an assumption left over from C and Unix that most accept as mandatory, but are really just a lousy half-attempt at (part of) a database.  Multitasking can be done without a separate OS, as can task scheduling.  Program loaders and user interfaces?  Look at Java.  It doesn't need an OS outside the language to do those things. (Typically it will run on top of another OS, but not necessarily.) Neither does Forth (and it as often as not runs on the bare hardware).  So you see, the idea of LanguagesAre <a href="OperatingSystems.html">OperatingSystems</a> isn't actually missing any points.  It's just that so many of us have lived within certain constraints for so long - the "necessity" of operating systems (separate and distinct from the languages that run on/within them) - that we've come to assume that the cage we've lived in for so long is the whole world, and it's not.  I'm not saying that we should immediately get rid of all OSes as we know them, but we should definitely should toss out the notion that they are something that we cannot live without.
      </p>
      <hr/>
      <p>
        <a href="LanguagesAreOperatingSystems.html">LanguagesAreOperatingSystems</a> is an illusion. Inside a language, you have library calls that call the operating system services. From the programmer perspective, these library calls look like the operating system API, but they aren't. The illusion is even stronger when the langage has features like interactivity and self-compilation.
        But if you consider programming langages themselves, without their libraries, the illusion vanishes, because a langage is just a way to a compiler, not to a computer.
      </p>
      <p>
        <em>I can see where you're coming from with your objection, but I can't fully agree.  It would, perhaps, be more correct to say that </em>LanguageRuntimesAreOperatingSystems; however, your argument seems to hinge upon the fact that implementations for a language to run upon another OS require support from the OS.  It'd be more accurate to say that they require support <em>from the machine</em>, and that the existence of the OS requires communicating through it to get to the machine - an implementation-detail for the library calls, not a requirement.  A library could just as easily be designed to operate upon bare metal, just like native code from the compiler is often built to run upon bare metal.  Whole virtual machines support such things as <a href="JavaLanguage.html">JavaLanguage</a>, MozartLanguage, and <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>, and it isn't too difficult to take these virtual machines and merge them into bare-metal along with their library-provided services.  A virtual machine is certainly an OS.<em></em>
      </p>
      <p>
        <em>Where it grows weak is for some languages, like C/C++, that don't have very good models for multi-process activity or resource management (except memory) as part of the language.  Those are the sorts of thing that make some languages more or less like operating systems than others.</em>
      </p>
      <hr/>
      <p>
        Some languages and their runtimes were designed to be the OS. <a href="OberonOperatingSystem.html">OberonOperatingSystem</a>, <a href="ForthLanguage.html">ForthLanguage</a> and <a href="ColorForth.html">ColorForth</a> spring to mind. Other language runtimes have been adapted to run on the bare metal and provide OS services, such as <a href="HaskellLanguage.html">HaskellLanguage</a>'s House (<a href="http://programatica.cs.pdx.edu/House/).">http://programatica.cs.pdx.edu/House/).</a>
      </p>
      <hr/>
      <p>
        This idea first popped into my mind when I was using Ruby a few years ago, and was coming to terms with how Gems worked.  I was specifically warned in a certain book (I can't remember the name off the top of my head) that I <em>should not</em> use a package management system to install Ruby--and that, indeed, this is even a particular bone of contention with Debian system maintainers--because package managers weren't very good at keeping up with the latest Ruby installments, and they weren't very good at handling multiple versions of Ruby (often necessary to maintain legacy code).  Thus, you have a computer language with its own packaging system!  I later learned how to use <a href="PythonLanguage.html">PythonLanguage</a>'s Pip, and <a href="CommonLisp.html">CommonLisp</a>'s <a href="QuickLisp.html">QuickLisp</a>; the general trend nowadays is for languages to come with their own packaging systems of one form or another...
      </p>
      <p>
        And as I thought about it more, I realized that computer languages are abstractions over the operating system to do what the operating system is supposed to do:  capture input, save or display output, and so forth.  It's not that much of a stretch to imagine writing all those abstractions in the language of your choice, rather than use the OS abstractions...and if you do this, you have a language that can run on bare metal!  Hence, it literally becomes an operating system.  (Admittedly, it's a bit more of a stretch to actually <em>write</em> this abstraction...but that's more an issue of practicality, over possibility.)  I also realized that the Operating Systems we use now are mostly C functions (some of which may be written in Assembler, fully or in part) that handle the bare metal stuff; when you consider that the way to extend <a href="CeeLanguage.html">CeeLanguage</a> is to write functions, it is safe to conclude that our Operating Systems are literally just extensions to C--in other words, <a href="CeeLanguage.html">CeeLanguage</a> (or perhaps a more recent variant, such as <a href="ObjectiveCee.html">ObjectiveCee</a> or <a href="CeePlusPlus.html">CeePlusPlus</a>) is the Operating System of choice these days. --Alpheus
      </p>
      <hr/>
      <p>
        <a href="CategoryOperatingSystem.html">CategoryOperatingSystem</a> <a href="CategoryProgrammingLanguage.html">CategoryProgrammingLanguage</a> <a href="LordOfTheOses.html">LordOfTheOses</a>
      </p>
    </div>
  </body>
</html>