<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Partial Classes
      </h1>
      <p>
        <a href="PartialClasses.html">PartialClasses</a> are an upcoming (2004? 2005? 2006?) mechanism in C# (<a href="CeeSharp.html">CeeSharp</a>) and other <a href="DotNet.html">DotNet</a> languages. See <a href="http://www.developer.com/net/net/article.php/2232061">http://www.developer.com/net/net/article.php/2232061</a>
      </p>
      <p>
        Why does MicrosoftAvalon at once promote composition (<a href="http://microsoft.sitestream.com/PDC2003/CLI/CLI301_files/Botto_files/CLI301_Bogdan.ppt">http://microsoft.sitestream.com/PDC2003/CLI/CLI301_files/Botto_files/CLI301_Bogdan.ppt</a> (PPT)) *and* simultaneously base XAML (<a href="http://notgartner.com/posts/151.aspx)">http://notgartner.com/posts/151.aspx)</a> on partial classes, a new language construct for weaving a single class from multiple sources?
      </p>
      <p>
        Why is composition not good enough? Or if not, why is inheritance not the next best thing? I have yet to see a rationale for introducing another mechanism for organizing object-oriented code.
      </p>
      <p>
        Partial classes are different from open classes in Ruby, at least in the sense that all Ruby classes are open, but only so declared classes are partial in dotnet. Also in Ruby anything can be redefined, whereas, I think, in dotnet, each partial class definition can add something new to the class but not redefine what is in another definition.
      </p>
      <p>
        Partial classes seem kind of like defining a C++ class using #include to include the *.cpp definitions themselves. But it has been a long time since I used C++ and I have never used partial classes in dotnet. (Few have since it is not in production yet.)
      </p>
      <p>
        <em>While C++ allows the implementation of a class to be scattered about however you like (simply omit the implementation of a C++ member function from the class definition), the definition of the class itself can only be in one place.  C++ classes are not "open" in this sense.  (C++ namespaces, on the other hand, are open)</em>
      </p>
      <p>
        (Question originated here <a href="http://patricklogan.blogspot.com/2004_01_25_patricklogan_archive.html#107472433955305867)">http://patricklogan.blogspot.com/2004_01_25_patricklogan_archive.html#107472433955305867)</a>
      </p>
      <p>
        Isn't this like the Smalltalk concept of extending classes? For example, you can add custom methods to String or Integer in Smalltalk (these specific examples might not work in Dotnet) [Steve Wart 2004/05/09]
      </p>
      <p>
        <em>If I recall correctly, the reason for including partial classes is that generated code (e.g. GUI-code) can be separated in another file that you don't need to see when editing code. This way you can also be sure that the builder won't mess with your code because it will only touch the other file.</em>
      </p>
      <p>
        It was already done this way (ASP.NET 1.0), but the generated form inherited from the code behind. This may be a marginal improvement, but the general scheme suffers the usual defeats of <a href="CodeGeneration.html">CodeGeneration</a>, like obscure syntax errors in code you didn't write. -- <a href="JesseMillikan.html">JesseMillikan</a>
      </p>
      <p>
        <em>Many products have bugs initially. Surely </em><a href="CodeGeneration.html">CodeGeneration</a> is not so difficult that the bugs can't be detected and fixed.<em> </em>
      </p>
      <p>
        It isn't a matter of <em>bugs</em>, in this case. Rather, it is that the top layer of the system, the layer that is generated <em>on top</em> of your own code, is undocumented, brittle and inflexible. (This goes at least for 1.0.) I say this from a few years of experience, but I think the latent bad properties can be imagined. It isn't that it <em>doesn't</em> work or can't be made to work, just that it's a poor solution that is difficult to use for non-trivial things. -- <a href="JesseMillikan.html">JesseMillikan</a>
      </p>
      <p>
        A syntax error in the generated code would imply a bug (or at least a lack of validation) in the generator. If the generated code is merely of poor quality, the problem lies in the design of the generator. There's not much excuse for either of these to be typical of <a href="CodeGeneration.html">CodeGeneration</a>. --
      </p>
      <p>
        Er, syntax error is not the right term, I guess. A common example: You add a user control to a page, add it as a member to the code behind page, and then get an error compiling the generated code because the protection level of the control in the code behind is not 'protected'. (Happens often enough; user controls do not by default add the member to the code behind page.) There are more complicated and less obvious problems, though. 
      </p>
      <p>
        Anyway, I would expect partial pages to fix at least <em>that</em> problem, since members can no longer be hidden from the generated code.--<a href="JesseMillikan.html">JesseMillikan</a> <em>(8/31/07 - I was wrong, this does cause problems even with partial classes.)</em>
      </p>
    </div>
  </body>
</html>