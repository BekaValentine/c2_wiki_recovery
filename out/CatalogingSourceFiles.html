<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Cataloging Source Files
      </h1>
      <p>
        In trying to organize and sift large quantities of source code files, I've found that the <a href="LimitsOfHierarchies.html">LimitsOfHierarchies</a> keeps mucking things up. There are multiple aspects to search and/or group or view by, and trees tend to favor one over the others. Plus, moving the files around a source tree to make adjustments tends to break references.
      </p>
      <p>
        Thus, I dream of using <a href="TableOrientedProgramming.html">TableOrientedProgramming</a> to search and organize files. Just keep them all in a flat folder and use a database browser and/or <a href="QueryByExample.html">QueryByExample</a> as the "front end" to find, query, and list source files.
      </p>
      <p>
        To facilitate this, some form of cataloging source and config files is needed. (Doing it at the method/function level is also something to consider, but existing tools are not ready for that yet. See <a href="SeparationAndGroupingAreArchaicConcepts.html">SeparationAndGroupingAreArchaicConcepts</a> for more on that level of cataloging. Doing it at the file level gives us more options with existing tools/IDE's.)
      </p>
      <p>
        Here's a draft form to hint at the kind of info that could be collected:
      </p>
      <code>
        ************************************************************<br/>
        SOURCE FILE CATALOG FORM<br/>
        .<br/>
        File Name: ________________ Extension: ______<br/>
        Description: _______________________________________<br/>
        Primary Purpose:    {// also consider check-boxes instead of radio buttons}<br/>
        (_) Library/Utilities<br/>
        (_) Configuration/System<br/>
        (_) Tabular or Summary Report<br/>
        (_) Detail Report/Screen (read-only)<br/>
        (_) Web-Page (end-user)<br/>
        (_) Data/Content Entry Screen<br/>
        (_) Wizard/Dialog/Picker/Finder/QBE<br/>
        (_) SQL query or procedure<br/>
        (_) Batch processing (little or no UI)<br/>
        (_) Content (image, document, data file, etc.)<br/>
        (_) Other/Mixed UI<br/>
        (_) Other/Mixed Non-UI<br/>
        .<br/>
        Check all that apply:<br/>
        [_] Security-related<br/>
        [_] Admin/Power-User/Back-End Audience<br/>
        [_] Printer/paper/PDF-related<br/>
        [_] User Help or Documentation-Related<br/>
        [_] Internal Documentation-Related<br/>
        Entities Read:<br/>
        {// list of entities/tables that are read from}<br/>
        Entities Changed:<br/>
        {// list of entities/tables added to, changed, and/or deleted.}<br/>
        {// (A fancy version could distinguish between these change kinds, }<br/>
        {// but that may be over-kill in my opinion.)}<br/>
        .<br/>
        Parent File: ______________ . _____  (if applicable)<br/>
        Notes: ___________________________________________________<br/>
        .<br/>
        ************************************************************<br/>
      </code>
      <p>
        (Square brackets are check-boxes and round ones are radio-buttons. Dots to prevent wiki formatting bug.) 
      </p>
      <p>
        The front end would use this info, and perhaps optionally search the source text also for key-words. If it's integrated with source search, then the "read" entities probably shouldn't be formal inputs because searching on table name is perhaps "good enough"; for hand-cataloging each is rather tedious and error-prone.
      </p>
      <p>
        Even if you decide to make the top-most list non-mutually-exclusive, I would still recommend having one and only one primary because it works better for basic listing (directory-like listings). Filtering is still available for multiple secondary categories ("OR").
      </p>
      <p>
        --top
      </p>
      <hr/>
      <p>
        See also: <a href="SeparationAndGroupingAreArchaicConcepts.html">SeparationAndGroupingAreArchaicConcepts</a>, <a href="FileTreesToManageCodeDiscussion.html">FileTreesToManageCodeDiscussion</a>
      </p>
      <hr/>
      <p>
        <a href="CategorySourceManagement.html">CategorySourceManagement</a>, <a href="CategoryInfoPackaging.html">CategoryInfoPackaging</a>
      </p>
    </div>
  </body>
</html>