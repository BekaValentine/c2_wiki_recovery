<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Candy Stripe Syndrome
      </h1>
      <p>
        Don't you just love it when you do a simple memcpy() of one graphic buffer to another and realize that the stride '(aka pitch, bytes per line)' is different? It ends up being off by the delta on every line, causing the whole picture to skew. When you've got a particularly busy graphic, it looks like yummy candy stripes.
      </p>
      <p>
        This is also very fun when one of the buffers is full of patterned data.
      </p>
      <hr/>
      <p>
        I like looking at a display of a mis-registered raster and try and guess what common bug is making it look like that.  X variables swapped with y variables.  Off-by-one in number of rows or number of columns.  Coordinate system inversion.  Fixing them is like tuning an old-fashioned TV.
      </p>
      <hr/>
      <p>
        More recently we're experiencing SparklingSyndrome. You know, when pointers walk over into the great beyond and start putting junk on screen. In this case, however, it's randomly placed, one pixel junk. It causes this neat sparkling effect sometimes when enough of them happen close together.
      </p>
      <hr/>
      <p>
        As near as I can remember, here's a quote from the AmigaDOS Libraries & Devices manual:
      </p>
      <p>
        "If you are so rude as to not Reply to every Message that Intuition sends to your Port before you close it, Intuition will be rude enough to delete every Message in the queue, including ones you've pulled. If you then Reply to one of these Messages, the Amiga will enter FIREWORKS_DISPLAY_MODE."
      </p>
      <p>
        Nothing like a well defined API, huh?
      </p>
      <hr/>
      <p>
        In my assembly days (sentimental sigh), I used to sometimes put the stack on screen memory... you could detect quite a lot of stack bugs this way, by watching the stack and grow and shrink.  It was also a great way to SEE how big your stack was getting.
      </p>
      <p>
        If I was using the screen and so couldn't put the stack on the screen memory, I'd put the stack just ABOVE the screen memory, so that if it overflowed I'd see it start to write over my screen.  There were many times when I'd invoke the program, see it pause for a second, and then see the screen get written over from one end to the other as an accidental recursion grew the stack.  Neat way to debug, very visceral and real.  Blinking lights, anyone?
      </p>
      <hr/>
      <p>
        Take a Commodore 64, and run this:
      </p>
      <ol>
        <li>
           POKE RND * 64000, RND * 256
        </li>
        <li>
           GOTO 10
        </li>
      </ol>
      <p>
        You get to see the most amazing "features" before the inevitable lockup. --PCP
      </p>
      <p>
        <em>Oh don't tease us, give us a screenshot.</em>
      </p>
      <p>
        On the Dragon 32 (and so, therefore, probably the TRS Co<strong>'Co) you could reprogram the SAM to map any page of memory onto the screen. If you did this with page 0 you could see the system clock, keyboard buffer and some other interesting things.</strong>
      </p>
      <hr/>
      <p>
        Also see <a href="GraphicsPatterns.html">GraphicsPatterns</a> (is this an <a href="AntiPattern.html">AntiPattern</a>?)
      </p>
    </div>
  </body>
</html>