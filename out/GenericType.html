<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Generic Type
      </h1>
      <p>
        A <a href="GenericType.html">GenericType</a> is one that is parameterized by a type. E.g. in Eiffel you can declare a variable thus:
      </p>
      <p>
        x : LIST[INTEGER]
        y : LIST[ARRAY[INTEGER]]
      </p>
      <p>
        Often collection types are generic (on their element type).
      </p>
      <p>
        E.g. the array type is generic in Java, or Pascal or even C. Thus one can declare, in Java:
      </p>
      <p>
        int[] myArray;
      </p>
      <p>
        and the Java compiler will guarantee that all the elements of myArray are int's.
      </p>
      <p>
        What you can't write is:
      </p>
      <p>
        Vector of int myVector;
      </p>
      <p>
        and have the compiler guarantee that all the elements of mtVector are int's.
      </p>
      <p>
        - <a href="StephenHutchinson.html">StephenHutchinson</a> 
      </p>
      <hr/>
      <p>
        I just read a paper about how the .NET team wants to add generics to the CLR. Specifically, C# is going to support generics with a C++ template-like syntax. The inner workings appear to be very different, though. While C++ templates are (more or less) code expansion at compile time the CLR supports Generics at instantiation time. As I read on I realized that C# Generics really are generic: if you instantiate a parametrized type with a reference type (class, as opposed to something like int or float) you can only use System.Object members inside your parametrized methods. That's why they added 'constraints' to the language. By adding constraints (kind of like specifying an interface) you can tell the compiler which interfaces the parametrizer has to support.
      </p>
      <p>
        So, it sounds like C++ templates allow us to write code that will work with any type that supports certain functions (name-polymorphism?) while C# do the exact opposite. C# Generics allow us to write parametrizable code that will work only with specific types, moving away from the uglyness of downcasting everything from System.Object.
      </p>
      <p>
        --<a href="AndrewQueisser.html">AndrewQueisser</a>
      </p>
    </div>
  </body>
</html>