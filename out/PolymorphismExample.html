<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Polymorphism Example
      </h1>
      <p>
        (A C++ example, that is)
      </p>
      <code>
        // "Toy" is an abstract base class.<br/>
        class Toy {<br/>
        public: virtual void playWith() = 0; // Note the shiny "= 0".<br/>
        };<br/>
      </code>
      <code>
        // "CapGun" is one of the concrete classes.<br/>
        class CapGun: public Toy {<br/>
        public: virtual void playWith() { /* Pow! */ }<br/>
        };<br/>
      </code>
      <code>
        // "Football" is the other concrete class.<br/>
        class Football: public Toy {<br/>
        public: virtual void playWith() { /* Punt! */ }<br/>
        };<br/>
      </code>
      <code>
        // And "SnotNoseKid::enjoy(Toy&)" is a <a href="PolymorphicFunction.html">PolymorphicFunction</a><br/>
        class SnotNoseKid {<br/>
        // Note how the type used is that of the base class.<br/>
        public: void enjoy(Toy& t) { <br/>
        t.playWith(); <br/>
        }<br/>
        };<br/>
      </code>
      <code>
        void f() {<br/>
        CapGun	gun;<br/>
        Football ball;<br/>
      </code>
      <code>
        SnotNoseKid kid;<br/>
      </code>
      <code>
        kid.enjoy(gun);<br/>
        kid.enjoy(ball);<br/>
        }<br/>
      </code>
      <p>
        The point here is that a "Toy" is just a concept, a certain kind of thingy, not
        a tangible thingy. (Or, in OOP terms, "Toy" is purely abstract, a class of
        objects, not a concrete object.)
      </p>
      <p>
        There is no reasonable implementation for Toy::playWith().  How do you
        "play" with a toy that you know nothing about?  You can look at it... fidget
        with it... but in the end the way you use a CapGun is nothing like the way
        you use a Football, even though they are both Toys.
      </p>
      <p>
        Observe:
      </p>
      <code>
        void g()<br/>
        {<br/>
        Toy toy; // Compile-time error!  You can't instantiate a Toy<br/>
        // directly.<br/>
      </code>
      <code>
        SnotNoseKid kid;<br/>
      </code>
      <code>
        // This kid doesn't know how to play with such a generic toy,<br/>
        // so it's a good thing the compiler didn't let him become <br/>
        // frustrated.<br/>
        kid.enjoy(toy);<br/>
        }<br/>
      </code>
      <p>
        Why not just use some generic mechanism, such as casting or templates?
        Well, consider the following code:
      </p>
      <code>
        // Note that this doesn't inherit from "Toy".<br/>
        class RealGun {<br/>
        public:<br/>
        void<br/>
        playWith() { /* Yikes! */ }<br/>
        };<br/>
      </code>
      <code>
        void h()<br/>
        {<br/>
        RealGun gun;<br/>
      </code>
      <code>
        SnotNoseKid kid;<br/>
      </code>
      <code>
        kid.enjoy(gun); // Compile-time error!  Kid's shouldn't <br/>
        // play with Real Guns!<br/>
        }<br/>
      </code>
      <p>
        So, remember kids:  Every gun is a loaded gun, and tell an adult if you find
        a switch statement.
      </p>
    </div>
  </body>
</html>