<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Proposed Additions To Cee Plus Plus
      </h1>
      <p>
        This page lists proposed additions to <a href="CeePlusPlus.html">CeePlusPlus</a>; both a) what <a href="TheCppStandardsCommittee.html">TheCppStandardsCommittee</a> is discussing (now that 5 years have passed since ANSI/ISO C++ 1998 was issued; the <a href="CppStandard.html">CppStandard</a> is now open for revision), and things that the Wiki community would like to see.
      </p>
      <p>
        First, the goodies that are being discussed by the committee; these are from the document known as <a href="TechnicalReportOne.html">TechnicalReportOne</a> (you can read it at <a href="http://std.dkuug.dk/jtc1/sc22/wg21/docs/library_technical_report.html)">http://std.dkuug.dk/jtc1/sc22/wg21/docs/library_technical_report.html)</a>  Much of this is based on the <a href="BoostLibraries.html">BoostLibraries</a>.
      </p>
      <ul>
        <li>
           The "Polymorphic Function Object Wrapper", a generic function pointer type (library change, based on Boost implementation).  Basically, a class which implements operator () and allows object/method pairs as well as generic function pointers to be called.  <em>[Probably a good thing to put in; lots of people, including me, have rolled our own...--</em><a href="ScottJohnson.html">ScottJohnson</a>]<em></em>
        </li>
      </ul>
      <ul>
        <li>
           Tuple types.  (Proposed as a library addition; though several core language changes that would be beneficial are noted).
        </li>
      </ul>
      <ul>
        <li>
           Additional math functions ("special functions"), present in C99 standard library.
        </li>
      </ul>
      <ul>
        <li>
           Type traits
        </li>
      </ul>
      <ul>
        <li>
           Regular expressions.  
        </li>
      </ul>
      <ul>
        <li>
           Enhanced member pointer adapters
        </li>
      </ul>
      <ul>
        <li>
           General-purpose smart pointers.  (Another thing frequently subject to <a href="RollYourOwn.html">RollYourOwn</a>)
        </li>
      </ul>
      <ul>
        <li>
           Improved random-number generator libraries
        </li>
      </ul>
      <ul>
        <li>
           Reference wrappers (ugh).
        </li>
      </ul>
      <ul>
        <li>
           result_type
        </li>
      </ul>
      <ul>
        <li>
           Enhanced binders (?)
        </li>
      </ul>
      <ul>
        <li>
           Hashtables.  (Most STL implementations implement these anyway...)
        </li>
      </ul>
      <p>
        Now a few other things that would be useful, and "relatively painless" to do.  (Relative is a relative term, of course). 
      </p>
      <ul>
        <li>
           Improved compatibility with C99.  While I don't feel it is necessary for C++ to be a superset of C; they should have a common compatible subset.  <a href="BjarneStroustrup.html">BjarneStroustrup</a> advocates this as well....
        </li>
      </ul>
      <ul>
        <li>
           template typedefs
        </li>
      </ul>
      <ul>
        <li>
           Alternate ctor/dtor syntax, such as allowing a ctor/dtor to be named "this" rather than the name of the class.  Would make it possible to write constructors for anonymous classes.  
        </li>
      </ul>
      <ul>
        <li>
           Class initializers, ala Java, for initializing static class members
        </li>
      </ul>
      <ul>
        <li>
           EffBoundedPolymorphism
        </li>
      </ul>
      <ul>
        <li>
           Template error-checking (see "require" discussion in <a href="StlSucks.html">StlSucks</a>)
        </li>
        <li>
           <em>Now under consideration, see </em><a href="ConceptCpp.html">ConceptCpp</a>. <em></em>
        </li>
      </ul>
      <ul>
        <li>
           An official "object" class, the supertype of all classes with virtual functions.  (For backwards compatibility; existing classes would not be redefined as subclasses of object; however the intent would be that ANY class with a virtual anything would be a subclass of object in the future).
        </li>
      </ul>
      <ul>
        <li>
           Enhancements to the I/O library to support such things as networking, asynchronous or unbuffered I/O, pending on multiple file descriptors (selection), and all sorts of other stuff.
        </li>
      </ul>
      <ul>
        <li>
           Raw string literals, a little like Python's but with flexible delimiters: R"delim[anything here]delim" where delim is optional and can be almost anything.
        </li>
      </ul>
      <p>
        Previously in the "you're dreamin'" category below, but actually being pursued for C++09:
      </p>
      <ul>
        <li>
           Garbage collection.  (Optional of course, this is <a href="CeePlusPlus.html">CeePlusPlus</a>).
          <ul>
            <li>
               <em>I don't see the benefit of having this in the language standard. There's a number of existing implementations available, why would you want to have it be a mandatory part of the standard and the library?</em> 
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           Support for synchronization and multi-threading as part of the language.
        </li>
      </ul>
      <p>
        And in the "you're dreamin'" category
      </p>
      <ul>
        <li>
           Reflection and introspection capabilities
        </li>
      </ul>
      <ul>
        <li>
           Dynamic method/member lookup, similar to a Smalltalk message send.  In other words, in order to call a method "foo" on an object, I don't have to cast the thing to a class which has "foo" in its interface.  I can simply (using a different syntax) invoke foo, and if it succeeds it succeeds, otherwise an exception is thrown.  (See Java for an example of HowNotToDoThis).
          <ul>
            <li>
               <em>This, the previous item, and the Object superclass would all be related and all have the same set of problems, which is how to implement this in a way that preserves the semantics of the language. The extra metadata you'd need to carry around about objects alone would be a huge loss. Sometimes it's a reasonable tradeoff but it's not something you should retrofit into C++. If you really want these features, then you should use a language that has them, not change C++ to be more like that language.</em>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           Something approximating a lexical closure.  C++ comes close with functors (just as Java comes close with inner classes), but closer would be nicer.  To keep this simple, they don't have to be first-class types--if you want a lexical closure to outlive its referencing environment, you probably want an object instead.  Oh, and a nice easy syntax to make these, similar to Smalltalk blocks.  
        </li>
      </ul>
      <ul>
        <li>
           Robust base classes, which use robust lookup techniques (e.g. hashtables) rather than fast-but-brittle ones (computed offsets).  Would fix a lot of instances of the <a href="FragileBinaryInterfaceProblem.html">FragileBinaryInterfaceProblem</a>.
        </li>
        <li>
           <em>This is the same thing as above - you aren't talking about changes to C++, you're talking about making a new language that looks like C++. Use the new language instead.</em>
        </li>
      </ul>
      <hr/>
      <p>
        See also: <a href="ItsTimeToDumpCeeSyntax.html">ItsTimeToDumpCeeSyntax</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryCpp.html">CategoryCpp</a>
      </p>
    </div>
  </body>
</html>