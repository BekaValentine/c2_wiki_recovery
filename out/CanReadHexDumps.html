<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Can Read Hex Dumps
      </h1>
      <p>
        A skill probably only a few <a href="VeteranProgrammer.html">VeteranProgrammer</a>s still possess.
      </p>
      <p>
        I myself have actually tried to figure out <a href="HexDump.html">HexDump</a>s of M68K assembly on <a href="AtariSt.html">AtariSt</a>, but rather not fluently and only small routines (bootloader etc.), but I'm born 1973, so I'm not required to :-) --  <a href="GunnarZarncke.html">GunnarZarncke</a>
      </p>
      <p>
        The skill of reading hex dumps is vanishing for many reasons:
      </p>
      <ul>
        <li>
           Far better tool support.  Computers are <strong>far</strong> better than humans at the rote job of disassembly of binaries; the tools to do this nowadays are ubiquitous.  If you think that your hex dump tool is broken, chances are you can download another one off the net within minutes.
        </li>
        <li>
           Code portability.  Generations ago, programmers had to worry about exactly one architecture (whatever the mainframe in their workplace was).  Nowadays, programmers write code which is frequently targeted to numerous different architectures, some of them virtual.
        </li>
        <li>
           Increased complexity in binary file formats and program loaders.  The bits in your average ELF file are, most assuredly, NOT the bits that will be eventually executed by the processor.  The OS or program loader will naturally have to relocate your code to a fixed address (especially on an x86, where position-independent code is expensive due to that architecture's register poverty), and link in goodness-knows-how-many DLLs/shared libraries.  And many non-trivial programs further invoke the loader at runtime to load in libraries that aren't necessarily known at program load time.
        </li>
        <li>
           The proliferation of libraries and OS calls turns the addresses of thousands of functions into the "opcodes" that must be understood to know what a program does.
        </li>
        <li>
           Quite a few architectures, especially in the embedded world, have compressed instruction sets (such as ThumbCompression)--thus turning an essentially stateless activity (mapping opcodes onto mnenomics) into a highly stateful one.
        </li>
        <li>
           The increased use of higher-level languages, where the mapping of programming constructs to machine constructs is often unspecified and/or complex.
        </li>
        <li>
           The increased use of optimizing compilers in systems-level languages like C/C++ make analysis of generated assembly code (let alone raw binaries) increasingly dicey; optimizing compilers use rare and complex instructions in nonorthodox ways (e.g. LEA to do arithmetic on the x86).
        </li>
        <li>
           The large increase of instruction set size and complexity with wave after wave of SIMD extensions.
        </li>
        <li>
           Figuring out what data goes where is reasonably easy; locating the stalls and interlocks of a superscalar pipeline is better left to tools.
        </li>
        <li>
           <a href="LifesTooShort.html">LifesTooShort</a>.
        </li>
      </ul>
      <hr/>
      <p>
        Huh?  I was born 1981 and have spent a good amount of time looking at sniffer dumps.  Remember that networks are much more important to today's young hackers, and most network protocols are a.) binary and b.) proprietary.  -- <a href="JonathanTang.html">JonathanTang</a>
      </p>
      <p>
        <em>I agree. Seems to depend more on ones special field. -- .gz</em>
      </p>
    </div>
  </body>
</html>