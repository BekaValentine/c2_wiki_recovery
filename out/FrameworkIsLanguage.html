<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Framework Is Language
      </h1>
      <p>
        This is a position statement that frameworks are (in all essential manners) languages. This is intentionally a weaker claim than <a href="ApiIsLanguage.html">ApiIsLanguage</a>. See <a href="ApiIsLanguage.html">ApiIsLanguage</a> for context.
      </p>
      <hr/>
      <p>
        <em>RE: "You don't have to learn new syntax or idioms to use an API. APIs aren't language.  They're vocabulary."</em>
      </p>
      <p>
        I've heard this opinion expressed by many different people, but, in general, I disagree.
      </p>
      <p>
        When the designer of an API has expectations or requirements on how calls to an API are ordered and otherwise synchronized, then the API is not merely a vocabulary; it is a <a href="FrameWork.html">FrameWork</a> that embodies various protocols and imposes behavioral requirements on the user... sometimes these behavioral requirements are fairly shallow (create comes before delete, don't delete the same thing twice, query before you expect a response, etc.), and sometimes they are very pervasive (special protocols for accessing shared resources to avoid <a href="DeadLock.html">DeadLock</a>, communications context for security or compression or <a href="DeltaIsolation.html">DeltaIsolation</a>, contracts with preconditions and postconditions and invariants, temporal and spatial demands to achieve realtime performance or network quality assurance on embedded systems, and so on), but they always exist. 
      </p>
      <p>
        The degree to which an API can be considered a dedicated language is really the degree to which these behavioral concerns are imposed upon the user of the API. Some of these behavioral concerns are derived of <a href="EssentialDifficulty.html">EssentialDifficulty</a> - a <em>necessary evil</em> in order to achieve properties of the protocol that are not provided directly by the language. Some of the behavioral concerns are derived of <a href="AccidentalDifficulty.html">AccidentalDifficulty</a> - an <em>unnecessary evil</em> that exists wherever the API is dodging around or accommodating limitations of the language, or leaking implementation details. 
      </p>
      <p>
        Examples of <a href="EssentialDifficulty.html">EssentialDifficulty</a> include the need to construct a shared key (e.g. DiffieHellman) to participate in secure communications with an unknown remote system, or the need to publish data to a named topic before it can be distributed, or the need to register a service before others can find it. Examples of <a href="AccidentalDifficulty.html">AccidentalDifficulty</a> include working around the sequential programming model of a language to add concurrency and other synchronization patterns, taking extra steps to ensure an object won't be accessed in one part of the code before destroying it in another, demands on code composition to support <a href="PrevalenceLayer.html">PrevalenceLayer</a>, requiring the programmers carefully ensure that the call stack leading to a particular API call not be involved in certain mutexes for risk of deadlock, sandboxing of code to eliminate as much ambient authority as possible before running scripts and such provided remotely, <a href="BoilerPlateCode.html">BoilerPlateCode</a> to 'initialize' a library (as opposed to individual uses of a protocol), and so on. <a href="AccidentalDifficulty.html">AccidentalDifficulty</a> often requires violating <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a> because you need to implement something 'once' in a manner suitable for ABC and 'once' in an incompatible manner suitable for XYZ and so on. Most complexity we experience today is still <a href="AccidentalDifficulty.html">AccidentalDifficulty</a>.
      </p>
      <p>
        This <a href="AccidentalDifficulty.html">AccidentalDifficulty</a> is very problematic. Protocols, services, and contracts are difficult enough to compose based purely on <a href="EssentialDifficulty.html">EssentialDifficulty</a>. When <a href="AccidentalDifficulty.html">AccidentalDifficulty</a> born of various MissingLanguageFeatures is added to the mix, well, there is a reason <a href="FrameworksConsideredHarmful.html">FrameworksConsideredHarmful</a>: <a href="PrimitivesAndMeansOfComposition.html">PrimitivesAndMeansOfComposition</a> is given one very harsh kick to the nads then left crying and whimpering on the floor. So long as you only need the one framework, you'll do well enough, but the framework as a whole is <a href="SecondClass.html">SecondClass</a>: not abstract, not composable, full of gotchas and idioms that you and any <a href="MaintenanceProgrammer.html">MaintenanceProgrammer</a> will need to learn and understand, very little obvious from the API itself, and effectively needing its own <a href="FooOneOhOneInSevenDaysForDummiesInaNutshellSuperBibleUnleashed.html">FooOneOhOneInSevenDaysForDummiesInaNutshellSuperBibleUnleashed</a>.
      </p>
      <p>
        It is in these more extreme cases, where the behavior imposed on the user of the API is pervasive and frustrating, that <a href="ApiIsLanguage.html">ApiIsLanguage</a> is clear and obvious. So what's on the other end of that spectrum? Well, at a guess I would say that the other side is where the API feels like a straightforward extension to the language in which it was written, where each element of the API feels and acts and perhaps even <em>looks</em> (syntactically) like a simple or primitive extension to the language. <a href="SymmetryOfLanguage.html">SymmetryOfLanguage</a> isn't (further) violated: the result is just as <a href="FirstClass.html">FirstClass</a>, abstract, and composable as everything else in the language (which, for some languages, might not be a very impressive claim). Users don't need to know anything about the API that they wouldn't also need to know about other language primitives. Etc.
      </p>
      <p>
        I suspect that, when dealing with APIs at the <a href="FrameWork.html">FrameWork</a> and pervasive <a href="DesignPatterns.html">DesignPatterns</a> end of the API spectrum, use of <a href="TypefulProgramming.html">TypefulProgramming</a>, <a href="ObjectCapabilityModel.html">ObjectCapabilityModel</a>, <a href="RealMacros.html">RealMacros</a>, and other <a href="MetaProgramming.html">MetaProgramming</a> mechanisms to guide proper expression of the API is highly justifiable. I don't have numbers, but I suspect both original developers and <a href="MaintenanceProgrammer.html">MaintenanceProgrammer</a>s will have an easier time learning, reading, writing, and verifying the resulting 'language' after such extension efforts. Further, with the <a href="TypefulProgramming.html">TypefulProgramming</a> approach, or with <a href="FirstClass.html">FirstClass</a> <a href="RealMacros.html">RealMacros</a> (as supported in Scheme), the IDE and compiler can get in on the action by detecting errors statically, providing syntax highlighting for the extended language, allowing one to drill down into expanded views of macros when debugging, etc. (<a href="DrScheme.html">DrScheme</a> provides these mechanisms.) 
      </p>
      <p>
        Still, I do understand the folks who resist such efforts, who want to believe <em>"You don't have to learn new syntax or idioms to use an API. APIs aren't language, they're vocabulary"</em>. It would be nice to believe that, no matter what the problem, it can be solved via an API that tosses a few new vocabulary words at it without any unusual requirements being imposed on the user. 
      </p>
      <p>
        If we ever have a language where 100% of frameworks and protocols and unanticipated <a href="DomainValue.html">DomainValue</a>s and entirely new <a href="DomainModel.html">DomainModel</a>s and ad-hoc <a href="MetaModel.html">MetaModel</a>s with their associated inference engines and <a href="MultiValuedLogic.html">MultiValuedLogic</a>s can all be expressed without any <em>unusual</em> behavioral impositions or gotchas relative to the rest of the language - and we achieve this without <a href="LanguageIdiomClutter.html">LanguageIdiomClutter</a> and with acceptable <a href="EconomyOfExpression.html">EconomyOfExpression</a> (such that it isn't "usual" to jump through hoops) - then <em>maybe</em> people will stop writing APIs that impose behavioral requirements on the user. 
      </p>
      <p>
        But it isn't possible. Even if we captured all the <a href="AccidentalDifficulty.html">AccidentalDifficulty</a> imposed by existing language designs for all known problems, there would still be both <a href="EssentialDifficulty.html">EssentialDifficulty</a> of known problems and <a href="AccidentalDifficulty.html">AccidentalDifficulty</a> of the unknown problems. The theoretical best any <a href="LanguageDesigner.html">LanguageDesigner</a> with intentions towards <a href="MinimalDesign.html">MinimalDesign</a> can do is eliminate individual classes of difficulty (one at a time, in an effort with rising combinatorial complexity) then provide the language with a clear path for upgrade while supporting forward compatibility of existing programs. Useful <a href="ExtensibleProgrammingLanguage.html">ExtensibleProgrammingLanguage</a> mechanisms include: some form of extensible syntax, ability to annotate code (<a href="HotComments.html">HotComments</a>) and modify the PostProcessor to operate over them, support for <a href="TypefulProgramming.html">TypefulProgramming</a>, a standard <a href="HomoiconicLanguage.html">HomoiconicLanguage</a> representation of the AST for reflective operation by said PostProcessor, low-level <a href="DependencyInjection.html">DependencyInjection</a> at the code layer (related to <a href="HyperSpace.html">HyperSpace</a>s and <a href="AspectOrientedProgramming.html">AspectOrientedProgramming</a>), and requiring a clear statement at the top of each page of code describing the exact version of syntax in use. 
      </p>
      <p>
        Once these <a href="ExtensibleProgrammingLanguage.html">ExtensibleProgrammingLanguage</a> mechanisms are in place, they act as a buffer allowing extensions to the language without upgrade to it, and allowing certain classes of upgrades to the language without breaking existing programs or requiring pervasive changes to existing code (since the same <a href="ExtensibleProgrammingLanguage.html">ExtensibleProgrammingLanguage</a> mechanisms can be used to downgrade a syntax to an earlier version). Further, such systems obviate the need for many classes of language upgrade, especially those related to <a href="DomainModelling.html">DomainModelling</a>. If one wants an <a href="InformLanguage.html">InformLanguage</a> style declaration of <a href="FirstClass.html">FirstClass</a> <a href="InteractiveSceneGraph.html">InteractiveSceneGraph</a>s for a VirtualWorldInterconnect, one writes up the appropriate extensions to the set of communications services, adds some new syntax for describing and composing <a href="SceneGraph.html">SceneGraph</a>s and the available interactions, and provides the defaults and assumptions in order to hide semantic noise. (That said, as with all <a href="LanguageDesign.html">LanguageDesign</a> work, it isn't "trivial" to provide composability, flexibility, static verification, avoid boilerplate, etc. - there are huge differences between well designed language extensions and poorly designed ones just as there are huge differences between well designed APIs and poorly designed ones.)
      </p>
      <p>
        <a href="ExtensibleProgrammingLanguage.html">ExtensibleProgrammingLanguage</a> support reduces the need to perform 'actual' language upgrades to features that either must be pervasive to be useful (such as <a href="DistributedTransaction.html">DistributedTransaction</a>s, subscription to mutable state, automatic distribution of code, <a href="ObjectCapabilityModel.html">ObjectCapabilityModel</a>, failover redundancy, system-wide <a href="GarbageCollection.html">GarbageCollection</a>, or end-to-end <a href="ProcessAccounting.html">ProcessAccounting</a> policy via <a href="ExplicitManagementOfImplicitContext.html">ExplicitManagementOfImplicitContext</a> in a distributed system, etc.) and various forms of expression that cannot be optimized through composition of other primitives (such as supporting 'sets' with their disordered communication rather than just 'lists'). 
      </p>
      <p>
        Actually, a greater problem than upgrading a language with new features is upgrading it with <a href="LiberatingConstraint.html">LiberatingConstraint</a>s. I would suggest that any <a href="LanguageDesigner.html">LanguageDesigner</a> consider those at time of <a href="BigDesignUpFront.html">BigDesignUpFront</a> because there is no way to add them after the language becomes popular (that is a penalty of premature success; related is <a href="AlanKayOnMessaging.html">AlanKayOnMessaging</a>). <a href="ObjectCapabilityModel.html">ObjectCapabilityModel</a>, compile-time confinement, removal of AmbientAuthority, some classes of static <a href="TypeSafety.html">TypeSafety</a>, guarantees of Termination (of the sort sought by <a href="TotalFunctionalProgramming.html">TotalFunctionalProgramming</a>), shunning of mutable state (<a href="KillMutableState.html">KillMutableState</a>) and shunning of names (<a href="NominativeAndStructuralTyping.html">NominativeAndStructuralTyping</a>) to support distribution, purity in the lower layers, and much more beside all fall into the whole '<a href="LiberatingConstraint.html">LiberatingConstraint</a>' concept. 
      </p>
      <p>
        Well, it seems I've wandered onto subjects that interest me but aren't entirely topical... so I'll stop there.
      </p>
      <p>
        The point is that <a href="ApiIsLanguage.html">ApiIsLanguage</a> for almost any API that solves a difficult problem. Arguing that one "needs to learn new syntax" may be true but is nonetheless <em>not</em> (in general) a point against use of an extensible syntax mechanism... because, for APIs, one (in general) "needs to learn the gotchas, idioms, <a href="DesignPatterns.html">DesignPatterns</a>, and protocol, that the <a href="RealMacros.html">RealMacros</a> can guide you in avoiding or utilizing respectively." 
      </p>
      <p>
        Those who argue, <em>"oh, this new language feature eliminates the need for macros or extensible syntax,"</em>, should bear in mind that the new feature likely just <em>moves</em> the need for macros a bit further towards the vast language frontier, allowing one to deprecate and transition out some language extensions, and perhaps optimize or improve composition of existing language extensions.
      </p>
    </div>
  </body>
</html>