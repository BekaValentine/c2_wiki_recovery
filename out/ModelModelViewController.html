<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Model Model View Controller
      </h1>
      <p>
        As is evident from the discussion of <a href="WhatsaControllerAnyway.html">WhatsaControllerAnyway</a>, the connotations of the acronym "MVC" and the term "<a href="ModelViewController.html">ModelViewController</a>" have lost precision over the years, as their usage has increased outside the Smalltalk community in which the namesake behavior-partitioning paradigm was invented (see <a href="ModelViewControllerHistory.html">ModelViewControllerHistory</a>).
      </p>
      <p>
        However, even within the original precise Smalltalk connotation of MVC, there is an implication not obviously conveyed by the term, and certainly not appreciated by people that use the terminology so freely today (e.g., people in the J2EE community, describing <a href="JavaServerPages.html">JavaServerPages</a> "Model 2" architectures).
      </p>
      <p>
        The implication is that there have always been two kinds of model: <a href="DomainModel.html">DomainModel</a>, and <a href="ApplicationModel.html">ApplicationModel</a>.  Hence the name of this page.  The evidence is clear, and the documentation plentiful.  Consider the following, from Krasner & Pope's original (August/September 1988) <a href="JournalOfObjectOrientedProgramming.html">JournalOfObjectOrientedProgramming</a> article titled "A Cookbook for Using the Model-View-Controller User Interface Paradigm in Smalltalk-80".
      </p>
      <dl>
        <dt> </dt>
        <dd>The inspectors in the system are implemented as two views. ... An instance of InspectorView serves as their common superview ... The model for these views is an instance of Inspector.  Inspectors can be used to view any object.  A separate class, Inspector, serves as the intermediary ... Using intermediary objects between views and "actual" models is a common way to further isolate the viewing behavior from the modeling application.</dd>
      </dl>
      <p>
        Thus the "actual" model is the object being inspected, and the Inspector is the application model.  The concept of an application model was finally reified by class <a href="ApplicationModel.html">ApplicationModel</a> in the <a href="VisualWorks.html">VisualWorks</a> 1.0 release of Smalltalk-80.
      </p>
      <p>
        For further documentation of the implication and distinction, see p.290 of <a href="KyleBrown.html">KyleBrown</a> and <a href="BobbyWoolf.html">BobbyWoolf</a>'s <a href="DesignPatternsSmalltalkCompanion.html">DesignPatternsSmalltalkCompanion</a>, and the literature reference fanout from that page.  See also <a href="AdeleGoldberg.html">AdeleGoldberg</a>'s foreword to <a href="TimHoward.html">TimHoward</a>'s <a href="TheSmalltalkDevelopersGuideToVisualWorks.html">TheSmalltalkDevelopersGuideToVisualWorks</a>, in which she confirms that <a href="ApplicationModel.html">ApplicationModel</a>s support linking a <a href="DomainModel.html">DomainModel</a> to application logic that uses it.
      </p>
      <p>
        So what, you say.  Well, here's what.  As a point of general principle, people who talk about MVC architecture (such as people in the J2EE and JSP communities) should take it upon themselves to understand the historical meaning and implications of the terms they use, so as to eliminate confusion about <a href="WhatsaControllerAnyway.html">WhatsaControllerAnyway</a>, and to be aware that <a href="ModelViewController.html">ModelViewController</a> often means <a href="ModelModelViewController.html">ModelModelViewController</a> in the original Smalltalk implementation of the paradigm.  In fact, a case could probably be made that many of the responsibilities allocated to the "controller" (in the Jacobsonian connotation of the term) were probably allocated to <a href="ApplicationModel.html">ApplicationModel</a>s in <a href="ModelModelViewController.html">ModelModelViewController</a> architecture.
      </p>
      <p>
        --<a href="RandyStafford.html">RandyStafford</a>
      </p>
      <hr/>
      <p>
        How does this relate to the model interfaces defined for each GUI component in the Java Swing framework?
      </p>
      <p>
        <em>The closest Smalltalk analogy to the Swing component "model interface" is probably the concept of an Adaptor, whose job it is to adapt the interface of a (domain) model to the interface expected by a view component.  In Smalltalk, Adaptors are typically </em><a href="ValueModel.html">ValueModel</a>s.  However an Adaptor or "model interface" is <strong>not</strong> an <a href="ApplicationModel.html">ApplicationModel</a>.  Instead, in Smalltalk, an <a href="ApplicationModel.html">ApplicationModel</a> is usually reponsible for instantiating an Adaptor and binding it to the view component and (domain) model.  In a Swing UI, this responsibility typically falls on a Panel (or Frame).  So, in a Swing UI, Panels (and Frames) form <a href="ApplicationModel.html">ApplicationModel</a>s.  --<a href="RandyStafford.html">RandyStafford</a><em></em>
      </p>
      <hr/>
      <p>
        RichardMacDonald posts on comp.object about MVP: model view presentation, where the presentation sits between the model and view (who don't know about each other).  It sounds similar to application model defined here -- an isolation layer.
      </p>
      <p>
        <em>Yes, it does sound similar.  Is there any literature on the MVP idea?  There seems to be a lot of different terminology in this area - for example, the </em><a href="PartyOfFive.html">PartyOfFive</a> talk about <a href="PresentationAbstractionControl.html">PresentationAbstractionControl</a>, where (roughly) Presentation is View, Abstraction is <a href="DomainModel.html">DomainModel</a>, and Control is <a href="ApplicationModel.html">ApplicationModel</a>.  --<a href="RandyStafford.html">RandyStafford</a><em></em>
      </p>
      <p>
        Yes, Dolphin Smalltalk (at least the free version) uses this paradigm and explains/discusses it at length in the bundled docs, which are with the download and may be available on the web as they are HTML (try poking around at <a href="http://www.object-arts.com/DolphinSmalltalk.htm).">http://www.object-arts.com/DolphinSmalltalk.htm).</a> --<a href="PaulMitchellGears.html">PaulMitchellGears</a>
      </p>
      <p>
        Here is a document on Model-View-Presenter: <a href="http://www.object-arts.com/EducationCentre/Overviews/ModelViewPresenter.htm">http://www.object-arts.com/EducationCentre/Overviews/ModelViewPresenter.htm</a>
        MVC vs MVP:
        <a href="http://www.darronschall.com/weblog/archives/000113.cfm">http://www.darronschall.com/weblog/archives/000113.cfm</a>
        And now, MGM (Model-GUI-Mediator)? I sense some buzz.
        <a href="http://www.atug.com/andypatterns/mgm.htm">http://www.atug.com/andypatterns/mgm.htm</a>
        --LyndonTremblay
      </p>
      <hr/>
      <p>
        "However, even within the original precise Smalltalk connotation of MVC, there is an implication not obviously conveyed by the term, and certainly not appreciated by people that use the terminology so freely today (e.g., people in the J2EE community, describing <a href="JavaServerPages.html">JavaServerPages</a> 'Model 2' architectures)."
      </p>
      <p>
        <em>Definitely an abuse of the term - there are at least two or three antipatterns in JSP/STRUTS/etc. (including </em><a href="WagTheDogAntiPattern.html">WagTheDogAntiPattern</a>) that violate (what I see as) the spirit of MVC.<em> -- </em><a href="TomRossen.html">TomRossen</a>
      </p>
      <hr/>
      <p>
        See also: <a href="MvcInJspModelTwoArchitecture.html">MvcInJspModelTwoArchitecture</a>
      </p>
    </div>
  </body>
</html>