<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Premature Abstraction
      </h1>
      <p>
        Pending a description, see <a href="PrematureGeneralization.html">PrematureGeneralization</a>, <a href="TooMuchAbstraction.html">TooMuchAbstraction</a>, <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a>.
      </p>
      <p>
        <strong>Q: </strong> Just what is premature about abstraction? Is there a time in a process when abstraction is appropriate? Isn't abstraction a precursor to development? Just what is a <a href="PrematureAbstraction.html">PrematureAbstraction</a>? Has it a generally accepted description or is it just a spin-off of <a href="PrematureOptimization.html">PrematureOptimization</a>?
      </p>
      <p>
        Isn't <a href="PrematureAbstraction.html">PrematureAbstraction</a> when you form an abstraction before you understand the problem well enough?  See <a href="ThreeStrikesAndYouRefactor.html">ThreeStrikesAndYouRefactor</a>.
      </p>
      <hr/>
      <p>
        <strong>Why delay Abstraction?</strong>
      </p>
      <ul>
        <li>
           Very often, <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a>. For example, you might have zero or one instances of this abstraction.
        </li>
        <li>
           You probably have something better to do right now. (<a href="FutureDiscounting.html">FutureDiscounting</a>.)
        </li>
        <li>
           With only a few exceptions (such as sharing an API or DSL and thus introducing backwards/forwards compatibility issues) it is no more expensive to introduce the abstraction later than it is to introduce it today.
        </li>
        <li>
           It is easy to introduce overly restrictive abstractions (where you'll need to later work around them) or overly general abstractions (where you'll have difficulty reasoning about or optimizing the resulting program). By delaying abstraction, you can gain a better idea of what you need. 
        </li>
        <li>
           Developers historically have a difficult time grasping simple, powerful abstractions (such as monads, applicatives, monad transformers, arrows, rings, semigroups, monoids, fields) before they, personally, have used multiple examples and seen how the operations and principles broadly apply. There is often an <a href="EurekaMoment.html">EurekaMoment</a>. In a long-lived project, you cannot assume that maintenance developers will grok abstractions that are much higher level than normally offered by the language and existing standards. 
        </li>
        <li>
           Not all languages are abstraction friendly. Many will make you pay through the nose (in terms of time or space) for each abstraction as a <a href="LayerOfIndirection.html">LayerOfIndirection</a>. Many languages fail to adequately support developers in identifying and specializing instances based on context or type. 
        </li>
        <li>
           Parametric abstraction often introduces syntactic overheads that a more concrete implementation might lack. Developers rarely wish to deal with these overheads unless they're getting something out of them, which means having at least two instances.
        </li>
      </ul>
      <hr/>
      <p>
        See also: <a href="AbstractionAddiction.html">AbstractionAddiction</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryAbstraction.html">CategoryAbstraction</a>
      </p>
    </div>
  </body>
</html>