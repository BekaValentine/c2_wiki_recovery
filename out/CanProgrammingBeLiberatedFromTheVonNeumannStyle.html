<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Can Programming Be Liberated From The Von Neumann Style
      </h1>
      <p>
        <a href="JohnBackus.html">JohnBackus</a>'s classic <a href="TuringAwardLecture.html">TuringAwardLecture</a>, introducing the functional programming language FP which <em>has no variables</em>.
      </p>
      <p>
        <a href="http://www.stanford.edu/class/cs242/readings/backus.pdf">http://www.stanford.edu/class/cs242/readings/backus.pdf</a>
      </p>
      <p>
        <em>FP has no variables, but the paper does not propose using FP. It proposes using extensions of it that do have variables.</em>
      </p>
      <p>
        If you can show people how to do their work faster and better
        then it can. But this must be shown. Not argued.
      </p>
      <ul>
        <li>
           Duh. That's why FP languages haven't swept the world yet. The proponents are still working on it. But they're getting better at showing how it improves things, as they improve the languages. For certain things, they've <strong>already</strong> proven their point, and people like you just didn't go to class that day. For the rest, we'll see. (What do you mean, "Not argued"? He shouldn't have written his Turing Award lecture until he could prove that FP was a good replacement for COBOL? If you think things should be shown and not argued, why are you arguing???)
        </li>
      </ul>
      <p>
        Claims made about FP were challenged at <a href="HowCanSomethingBeSuperGreatWithoutProducingExternalEvidence.html">HowCanSomethingBeSuperGreatWithoutProducingExternalEvidence</a>. There was disagreement about the applicability of toy examples to certain domains.
      </p>
      <hr/>
      <p>
        First perhaps we need to ask *why* we need to get away from it.
      </p>
      <p>
        <em>Because it defines its architecture in terms of a bottleneck.</em>
      </p>
      <ul>
        <li>
           <a href="PrematureOptimization.html">PrematureOptimization</a>: get away from bottlenecks! quick! quick! how bad of a bottleneck is it though?
        </li>
      </ul>
      <p>
        But perhaps this also makes it easier for humans <a href="ToGrok.html">ToGrok</a>, especially us men who can only do one thing at a time :-) Actually, some things seem to work well under non-Von, while others don't IMO. Relational notation, which is non-Von is (or can be) quite powerful, going beyond the Von-ish <a href="NavigationalDatabase.html">NavigationalDatabase</a> approach. However, I am not sure everything can be done (or easily learned to be done) that way. If the machine can give us sufficient speed for Von, then why fuss? Overhauling/optimizing the machine to fit our head is usually easier than the other way around in most cases. Now, maybe for things like weather prediction this does not apply.
      </p>
      <p>
        For an excellent introduction to grokking non-Von algorithms, see <a href="GuySteele.html">GuySteele</a> and <a href="DanielHillis.html">DanielHillis</a>'s wonderful paper "Data Parallel Algorithms," <a href="http://cva.stanford.edu/cs99s/papers/hillis-steele-data-parallel-algorithms.pdf.">http://cva.stanford.edu/cs99s/papers/hillis-steele-data-parallel-algorithms.pdf.</a> See also <a href="DanielHillis.html">DanielHillis</a>'s book (thesis) <em>The </em><a href="ConnectionMachine.html">ConnectionMachine</a><em> for a discussion of the performance issues.</em>
      </p>
      <hr/>
      <ul>
        <li>
           SIMD - single instruction multple data -  transputer, MMX, 3DNow, etc)
        </li>
        <li>
           MIMD - multiple instruction multiple data -  multiple cpus/cores/program counters
        </li>
        <li>
           MPMD - multiple program multiple data - MPI, PVM, various data parallel (google can tell you more)
        </li>
      </ul>
      <hr/>
      <p>
        Reading through it, one is struck by a sense of irony. Backus clearly hoped that FP would check the "cancerous" (I think that's his word) growth of programming languages, but given the proliferation of <a href="FunctionalProgramming.html">FunctionalProgramming</a> languages and their associated arcana, it would seem that <em>no</em> programming paradigm is immune from metastasis.
      </p>
      <p>
        <em>There is significantly less unnecessary or frivolous variation in functional and declarative languages than in imperative languages. The variation tends be to due to differences in approach -- for example in how to model state or I/O.</em>
      </p>
      <p>
        Depends what you mean by functional.. Lisp certainly has proven the opposite - there are many ways to redefine lisp to do the same thing many different ways. This does not lead to consistency, it leads to variation.  Usually there are 1 or 2 ways to do I/O in imperative languages (for example in C you do it one way usually) so I don't see what your point is.
      </p>
      <hr/>
      <p>
        How ironic, my computer science teachers always used to criticize me for doing things like:
      </p>
      <code>
        printf("1+2=%u",1+2);, <br/>
      </code>
      <p>
        they would argue it's better to put it in a human readable variable like:
      </p>
      <code>
        result=1+2;<br/>
        printf("1+2=%u",result);<br/>
      </code>
      <p>
        Now I hear we need to get away from named variables?
      </p>
      <p>
        <em>Ha ha ha. The principle in </em><a href="FunctionalProgramming.html">FunctionalProgramming</a> is not to avoid named values, but to avoid <strong>mutable</strong> named values, especially one which cause side-effects (i.e., global variables). In the case you gave, the latter code would be acceptable, <em>so long as you didn't change the value of </em>result<em> later on.</em> (Actually, the printf() function would itself be a problem in a purely function language, as it causes a side effect - it has an output other than the function return - but most purely functional languages have ways around that). Constants and function parameters (including functions themselves as values) are permissible, but not reassignment of variables.<em></em>
      </p>
      <p>
        <em>To put it another way, FP is about modelling program functions after mathematical functions; the goal is for the functions to be stateless (if you run them with a given set of arguments, they will always return the same result) and declarative (they should as much as possible describe a relationship between the arguments and the result, not a series of actions to take to get the result). -- </em><a href="JayOsako.html">JayOsako</a><em></em>
      </p>
      <hr/>
      <p>
        The interesting thing about Backus's paper is the focus on the limitations of von Neumann machines, and how language choices affect this.  First, as noted above, the languages he was railing against were largely the industrial languages of the time, things such as <a href="AlgolLanguage.html">AlgolLanguage</a>, PlOneLanguage, <a href="CobolLanguage.html">CobolLanguage</a>, and Backus's own creation <a href="FortranLanguage.html">FortranLanguage</a>--languages which largely mirrored the von Neumann machines they were executed on.  Backus attacked them on two grounds--one, that they are inherently fragile and poor programming models, and two--that the von Neumann architecture does impose a performance bottleneck (the <a href="VonNeumannBottleneck.html">VonNeumannBottleneck</a>) which has gotten worse over the years.  (The <a href="CellProcessor.html">CellProcessor</a> is the latest in a series of attempts to get around (some) of the limitations of the von Neumann architecture).
      </p>
      <p>
        Of course, one may ask:  "What does the choice of programming language have on the hardware?  A functional language which is compiled to run on a von Neumann machine will still suffer the bottleneck."  The answer, is <a href="ReferentialTransparency.html">ReferentialTransparency</a>--which makes parallel computation <em>much</em> more tractable (and capable of being automated).  Effectively parallelizing imperative languages is still an active research topic.  
      </p>
      <p>
        Granted, we have a long way to go before production-grade compilers capable of efficiently distributing an algorithm across an arbitrary group of processing nodes come into being--so perhaps Backus is invoking the mythical <a href="SufficientlySmartCompiler.html">SufficientlySmartCompiler</a>.  But it still is an interesting thing to consider.
      </p>
      <ul>
        <li>
           Well, no, that's actually looking at it the wrong way around. The mythical <a href="SufficientlySmartCompiler.html">SufficientlySmartCompiler</a> arises if you want to compile e.g. regular old C/C++ without any changes, and have it run optimally on an arbitrary group of parallel processing nodes. The non-mythical approach is in fact to make massive changes to get something to run nicely in parallel, with the most extreme change of all to design a new language from the ground up for that very purpose. A classic example of the latter was Transputers and Occam language.
        </li>
        <li>
           I.e. if you're willing to make arbitrary changes to the language, then no, we don't have a long way to go.
        </li>
      </ul>
      <hr/>
      <p>
        Here you go: "How To Compute Without Numeric Variables in a non-Von Neumann Architecture"  <a href="http://tinyurl.com/indiscretelogic">http://tinyurl.com/indiscretelogic</a>
      </p>
      <hr/>
      <p>
        See <a href="VonNeumannBottleneck.html">VonNeumannBottleneck</a>, <a href="AdvantagesOfFunctionalProgramming.html">AdvantagesOfFunctionalProgramming</a>, <a href="DeclarativeProgramming.html">DeclarativeProgramming</a>, <a href="PurelyFunctionalOperatingSystem.html">PurelyFunctionalOperatingSystem</a>, <a href="KillMutableState.html">KillMutableState</a>, <a href="SemanticsDiscussion.html">SemanticsDiscussion</a>, <a href="AreCurrentLanguagesShapedByHardware.html">AreCurrentLanguagesShapedByHardware</a>, <a href="ProgrammingNotAboutMachines.html">ProgrammingNotAboutMachines</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryPaper.html">CategoryPaper</a>, <a href="CategoryConcurrency.html">CategoryConcurrency</a>
      </p>
    </div>
  </body>
</html>