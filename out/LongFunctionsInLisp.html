<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Long Functions In Lisp
      </h1>
      <p>
        This page will collect some non-random examples of <a href="LongFunctions.html">LongFunctions</a> in <a href="LispLanguage.html">LispLanguage</a>. The examples are chosen to be part of very robust and widely acknowledged as successful open-source projects. The criteria of "longness" is set to dispell the widely held (on Wiki) superstition that 5-9 lines is the ideal everybody should be striving for.
      </p>
      <p>
        Other examples are welcome, until we collect from all major languages and a wide diversity of projects to dispell once and for all that myth. Lisp is particularly interesting as it is maybe <strong>the</strong> most powerful and concise language around, yet Lisp hackers don't seem to shy away from writing <a href="LongFunctions.html">LongFunctions</a> when it makes sense.
      </p>
      <p>
        <em>Have you considered the possibility that it is </em>because<em> Lisp is the most powerful and concise language around that its expert users (and whomever wrote defclass was most certainly no neophite) can get away with functions this long, when in weaker, more verbose languages they wouldn't?</em>
      </p>
      <p>
        You know, you can show all the long functions you want, no one disagrees that long functions are completely normal. You seem to be missing the point entirely. Just because they are normal, doesn't mean they can't be improved. Short functions are easier to understand, period, that can't be argued. It's easier to understand 7 to 10 lines of code than it is to understand 50, you cannot deny that. All we are saying is that, given this fact, one should try and write smaller methods rather than larger ones because it helps developers grasp programs quicker, it makes bugs easier to see, it makes programming faster, etc.. <a href="GrandMasterProgrammer.html">GrandMasterProgrammer</a>s could probably write interpreters in assembly, that doesn't make it right or easy for others to grasp. Long methods may be absolutely brilliant, yet still communicate very little to the reader, small methods communicate much more clearly to the reader, and we think that is eXtremely important. Small methods enable evolutionary development, or at least ease it greatly.
      </p>
      <p>
        <em>But you construct a </em><a href="StrawMan.html">StrawMan</a> by doing the wrong arithmetics. You should not compare the understandability of 50 lines of code versus 7 lines of code. You should compare 50 lines of code versus 7 (procedure calls in the main function ) + 7 * 8 (or >8 lines of definition for the factored out of the current scope functions). So much for your "period, it can't be argued".<em> </em>
      </p>
      <p>
        No, I'm not talking about total size of the code. I'm talking about what you can fit in your head, chunk size. Small methods communicate better, require less mental gymnastics from the reader, and are generally in every way easier to work with. It may take hundreds or thousands of methods to build an application regardless of how big they are, so why not have them just the right size to make them easy to work with. Small bricks are more flexible than 12x12 slabs of concrete, and are easier to work with!
      </p>
      <p>
        <em>And I am talking not about the understandability of every individual little piece, but understandability, and, dare I say provability on occasions, for a conceptual blocks. If I have to fully understand an algorithm and to make sure it's implementation is correct, I'd rather look at 20 functions 50 lines each than 100 functions ten lines each. I don't care how easy is every little tiny piece, if I have to keep 100 pieces in my head (even if only their contracts), I'm rather uneasy. </em>
      </p>
      <p>
        And I'd rather not do that either. You shouldn't have to ever fit it all into your head if you have little pieces and they are properly unit tested. No one can fit the entire program in their head, I don't care how smart they think they are. The large scale picture must, by its very nature, be more abstract so the mind can grasp it. At that level, you aren't thinking about methods, but about objects/packages/modules. To paraphrase <a href="KentBeck.html">KentBeck</a>, a programs like a giant wave, you can't tame it, so just learn to surf.
      </p>
      <p>
        <em>Well, it's your preference to read </em><a href="KentBeck.html">KentBeck</a>, my preferred authors are more like <a href="EwDijkstra.html">EwDijkstra</a>, and dare I say that <strong>they are not very compatible</strong>. But I'm not aware of any instance where <a href="KentBeck.html">KentBeck</a> has publicly displayed his treatment of non-trivial algorithms, nor am I aware of any instance where Kentbeck or any other Agile guru has ever tried even a sketch of <a href="ProofOfCorrectness.html">ProofOfCorrectness</a>. As a matter of fact, his latest books contain really toyish examples, so I wouldn't even remotely assume that his great advices are applicable everywhere, especially where they contradict Dijkstra. See also the discussion below. There are instances where "surfing" is just not good enough and you need a hell of a lot more than that. <em></em>
      </p>
      <p>
        Dijkstra's point has always been that programs should be broken down into manageable units so that the correctness of each unit can be independently proven, thus allowing you to reason about the whole program without keeping all the state in your head. That was the whole reasoning behind <a href="StructuredProgramming.html">StructuredProgramming</a>. This is supported by <a href="LotsOfShortMethods.html">LotsOfShortMethods</a>, not hindered by it. I don't see how you jump from "<a href="ProofOfCorrectness.html">ProofOfCorrectness</a>" to "LongMethods are good" - a long method is harder to reason about or prove than a short one! -- <a href="JonathanTang.html">JonathanTang</a>
      </p>
      <hr/>
      <p>
        <em>You shouldn't have to ever fit it all into your head if you have little pieces and they are properly unit tested.</em>
      </p>
      <p>
        That's called a wave with your hand using a magic precondition. You don't know if the code has been properly unit tested. You don't know what proper unit tests are. You don't know what the code is supposed to do. You don't know if unit tests have been updated. You still must understand the unit tests which is admits to the same errors as any other code. And critically, unit tests mean only about 50% given integration and system tests, especially using heavily mocked tests. -- Anonymous A
      </p>
      <p>
        <em>If I wrote the code, or my team did, I most certainly do know that. Expecting code to be tested isn't a magic precondition, it's a reasonable expectation that anything complex should have a few tests to prove it actually works. There's always the chance they don't cover every condition of course, but when you find one of those conditions, you'd be wise to write a test for it too, it'll save your ass later.</em>
      </p>
      <p>
        Most of the time tests do not actually prove that it actually works, <a href="KentBeck.html">KentBeck</a> should have taught you that much. They only prove that it works on the tested cases. And there's the extra-doubt that the test cases were actually good test cases and not wishy-washy tests for trivial conditions. Most of the code I could see in public from agile gurus or mere programmer, had wishy-washy tests, especially for concurrent behavior, if that was tested at all. -- <a href="CostinCozianu.html">CostinCozianu</a>
      </p>
      <p>
        Most interesting problems happen in system tests, especially given an attitude where a few tests can show something works. You had damn well better read the code to solve those. -- <a href="AnonymousOnPurpose.html">AnonymousOnPurpose</a>
      </p>
      <hr/>
      <p>
        From CLisp CLOS source (the overwhelming majority of definitions in there fail to be 5-9 lines of code, but this macro is particularly big):
      </p>
      <p>
        (defmacro defclass (name superclass-specs slot-specs &rest options)
      </p>
      <code>
        (unless (symbolp name)<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S: class name ~S should be a symbol")<br/>
        'defclass name))<br/>
        (let* ((superclass-forms<br/>
        (progn<br/>
        (unless (listp superclass-specs)<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S: expecting list of superclasses instead of ~S")<br/>
        'defclass name superclass-specs))<br/>
        (mapcar #'(lambda (superclass)<br/>
        (unless (symbolp superclass)<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S: superclass name ~S should be a symbol")<br/>
        'defclass name superclass))<br/>
        `(FIND-CLASS ',superclass))<br/>
        superclass-specs)))<br/>
        (accessor-def-forms '())<br/>
        (slot-forms<br/>
        (let ((slot-names '()))<br/>
        (unless (listp slot-specs)<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S: expecting list of slot specifications instead of ~S")<br/>
        'defclass name slot-specs))<br/>
        (mapcar #'(lambda (slot-spec)<br/>
        (let ((slot-name slot-spec) (slot-options '()))<br/>
        (when (consp slot-spec)<br/>
        (setq slot-name (car slot-spec)<br/>
        slot-options (cdr slot-spec)))<br/>
        (unless (symbolp slot-name)<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S: slot name ~S should be a symbol")<br/>
        'defclass name slot-name))<br/>
        (if (memq slot-name slot-names)<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S: There may be only one direct slot with the name ~S.")<br/>
        'defclass name slot-name)<br/>
        (push slot-name slot-names))<br/>
        (let ((accessors '())<br/>
        (readers '())<br/>
        (writers '())<br/>
        (allocation '())<br/>
        (initargs '())<br/>
        (initform nil) (initer nil)<br/>
        (types '())<br/>
        (documentation nil))<br/>
        (when (oddp (length slot-options))<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S: slot options for slot ~S must come in pairs")<br/>
        'defclass name slot-name))<br/>
        (do ((optionsr slot-options (cddr optionsr)))<br/>
        ((atom optionsr))<br/>
        (let ((optionkey (first optionsr))<br/>
        (argument (second optionsr)))<br/>
        (case optionkey<br/>
        ((:READER :WRITER)<br/>
        (unless (function-name-p argument)<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S, slot option for slot ~S: ~S is not a function name")<br/>
        'defclass name slot-name argument))<br/>
        (case optionkey<br/>
        (:READER (push argument readers))<br/>
        (:WRITER (push argument writers))))<br/>
        (:ACCESSOR<br/>
        (unless (symbolp argument)<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S, slot option for slot ~S: ~S is not a symbol")<br/>
        'defclass name slot-name argument))<br/>
        (push argument accessors)<br/>
        (push argument readers)<br/>
        (push `(SETF ,argument) writers))<br/>
        (:ALLOCATION<br/>
        (when allocation<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S, slot option ~S for slot ~S may only be given once")<br/>
        'defclass name ':allocation slot-name))<br/>
        (case argument<br/>
        ((:INSTANCE :CLASS) (setq allocation argument))<br/>
        (t (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S, slot option for slot ~S must have the value ~S or ~S, not ~S")<br/>
        'defclass name slot-name ':instance ':class argument))))<br/>
        (:INITARG<br/>
        (unless (symbolp argument)<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S, slot option for slot ~S: ~S is not a symbol")<br/>
        'defclass name slot-name argument))<br/>
        (push argument initargs))<br/>
        (:INITFORM<br/>
        (when initform<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S, slot option ~S for slot ~S may only be given once")<br/>
        'defclass name ':initform slot-name))<br/>
        (setq initform `(QUOTE ,argument)<br/>
        initer (make-initer argument)))<br/>
        (:TYPE<br/>
        (when types<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S, slot option ~S for slot ~S may only be given once")<br/>
        'defclass name ':type slot-name))<br/>
        (setq types (list argument)))<br/>
        (:DOCUMENTATION<br/>
        (when documentation<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S, slot option ~S for slot ~S may only be given once")<br/>
        'defclass name ':documentation slot-name))<br/>
        (unless (stringp argument)<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S, slot option for slot ~S: ~S is not a string")<br/>
        'defclass name slot-name argument))<br/>
        (setq documentation argument))<br/>
        (t<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S, slot option for slot ~S: ~S is not a valid slot option")<br/>
        'defclass name slot-name optionkey)))))<br/>
        (setq readers (nreverse readers))<br/>
        (setq writers (nreverse writers))<br/>
        (dolist (funname readers)<br/>
        (push `(DEFMETHOD ,funname ((OBJECT ,name))<br/>
        (SLOT-VALUE OBJECT ',slot-name))<br/>
        accessor-def-forms))<br/>
        (dolist (funname writers)<br/>
        (push `(DEFMETHOD ,funname (NEW-VALUE (OBJECT ,name))<br/>
        (SETF (SLOT-VALUE OBJECT ',slot-name) NEW-VALUE))<br/>
        accessor-def-forms))<br/>
        `(LIST<br/>
        :NAME ',slot-name<br/>
        ,@(when accessors `(:ACCESSORS ',(nreverse accessors)))<br/>
        ,@(when readers `(:READERS ',readers))<br/>
        ,@(when writers `(:WRITERS ',writers))<br/>
        ,@(when (eq allocation ':class) `(:ALLOCATION :CLASS))<br/>
        ,@(when initargs `(:INITARGS ',(nreverse initargs)))<br/>
        ,@(when initform `(#| :INITFORM ,initform |# :INITER ,initer))<br/>
        ,@(when types `(:TYPE ',(first types)))<br/>
        ,@(when documentation `(:DOCUMENTATION ',documentation))))))<br/>
        slot-specs))))<br/>
        `(LET ()<br/>
        (EVAL-WHEN (COMPILE LOAD EVAL)<br/>
        (ENSURE-CLASS<br/>
        ',name<br/>
        :DIRECT-SUPERCLASSES (LIST ,@superclass-forms)<br/>
        :DIRECT-SLOTS (LIST ,@slot-forms)<br/>
        ,@(let ((metaclass nil)<br/>
        (direct-default-initargs nil)<br/>
        (documentation nil))<br/>
        (dolist (option options)<br/>
        (block nil<br/>
        (when (listp option)<br/>
        (let ((optionkey (first option)))<br/>
        (when (case optionkey<br/>
        (:METACLASS metaclass)<br/>
        (:DEFAULT-INITARGS direct-default-initargs)<br/>
        (:DOCUMENTATION documentation))<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S, option ~S may only be given once")<br/>
        'defclass name optionkey))<br/>
        (case optionkey<br/>
        (:METACLASS<br/>
        (when (eql (length option) 2)<br/>
        (let ((argument (second option)))<br/>
        (unless (symbolp argument)<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S, option ~S: ~S is not a symbol")<br/>
        'defclass name option argument))<br/>
        (setq metaclass `(:METACLASS (FIND-CLASS ',argument))))<br/>
        (return)))<br/>
        (:DEFAULT-INITARGS<br/>
        (let ((list (rest option)))<br/>
        (when (and (consp list) (null (cdr list)) (listp (car list)))<br/>
        (setq list (car list))<br/>
        (warn (TEXT "~S ~S: option ~S should be written ~S")<br/>
        'defclass name option (cons ':DEFAULT-INITARGS list)))<br/>
        (when (oddp (length list))<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S, option ~S: arguments must come in pairs")<br/>
        'defclass name option))<br/>
        (setq direct-default-initargs<br/>
        `(:DIRECT-DEFAULT-INITARGS<br/>
        (LIST<br/>
        ,@(let ((arglist nil) (formlist nil))<br/>
        (do ((list list (cddr list)))<br/>
        ((atom list))<br/>
        (unless (symbolp (first list))<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S, option ~S: ~S is not a symbol")<br/>
        'defclass name option (first list)))<br/>
        (when (member (first list) arglist)<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S, option ~S: ~S may only be given once")<br/>
        'defclass name option (first list)))<br/>
        (push (first list) arglist)<br/>
        (push (second list) formlist))<br/>
        (mapcan #'(lambda (arg form)<br/>
        `(',arg ,(make-initer form)))<br/>
        (nreverse arglist) (nreverse formlist)))))))<br/>
        (return))<br/>
        (:DOCUMENTATION<br/>
        (when (eql (length option) 2)<br/>
        (let ((argument (second option)))<br/>
        (unless (stringp argument)<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S, option ~S: ~S is not a string")<br/>
        'defclass name option argument))<br/>
        (setq documentation<br/>
        `(:DOCUMENTATION ',argument)))<br/>
        (return))))))<br/>
        (error-of-type 'sys::source-program-error<br/>
        (TEXT "~S ~S: invalid option ~S")<br/>
        'defclass name option)))<br/>
        `(,@metaclass ,@direct-default-initargs ,@documentation))))<br/>
        ,@(nreverse accessor-def-forms) ; the DEFMETHODs<br/>
        (FIND-CLASS ',name))))<br/>
      </code>
      <p>
        <strong>Comments:</strong>
        Nice try, but no cigar. The longest run at a single level of indentation is the quasi-quote to do with slot kinds, at 10 lines. Lisp is expressive enough, and the indentation conventions well-known and universal enough, that this macro doesn't even read to me as a single thing (and I'm no lisp expert) in the sense that I can <em>by eye</em> identify regions of the code that I can examine in near isolation and think about separately. The injunction agasint writing long functions/methods in C-like languages is to do with the ease with which code can be written in them for which that is impossible.
      </p>
      <p>
        <em>Well, you may want to pay a closer look at the block (do (let (...optionkey ...) (  case optionkey  ... ))) block that surely spans tons of rows by </em><a href="LongFunctions.html">LongFunctions</a> discussion standards, and I almost forgot to mention it also falls under <a href="CaseStatementsConsideredHarmful.html">CaseStatementsConsideredHarmful</a>, SwitchStatementSmell dogma, so would be absolutely verbotten. What do we do, do we declare that the injunction against <a href="LongFunctions.html">LongFunctions</a> makes an exception for any language more powerful than C (i.e. with support for higher order functions)? Well, let's do that, I'm all for it.<em></em>
      </p>
      <p>
        I, as a lisper (<a href="AlainPicard.html">AlainPicard</a>), concur. In fact, I often do this sort of thing (well, maybe not to that extreme, but still) but it is basically a technique of not polluting the global function namespace. Long chains of FLETS, MACROLETS and CASE/COND analysis don't, to me, conceptually lead to difficult to understand programs if each part can be analyzed individually. The only bit you really lose on is the ability to test individually each component; often, however, the gain you get by being able to share lexical variables between these parts makes it a net win nonetheless. REALLY long functions in lisp are normally autogenerated/expanded from a macro; the classical example are FSM generators.
      </p>
      <p>
        <em>I'm using this techniques in Java myself and in OCAML where it is the default style. However somebody on the </em><a href="LotsOfShortMethods.html">LotsOfShortMethods</a> thought police already almost accused me of incompetence in a funny page <a href="JavaStaticClassesIsaTotalMess.html">JavaStaticClassesIsaTotalMess</a>, where I was defending one of the little feature of Java language that enables me to write more modular code and avoid polluting the package namespace. That somebody was considering a language design flaw nevertheless because would "encourage" the creation of long files (!!!). I wished more people on my team would use inner classes in Java more often (static and inner). That's why I think it is important to communicate to these guys to pay a little attention to real code out there.<em></em>
      </p>
      <p>
        I don't mind inner functions used as a scoping mechanism - it's still possible to reason about each inner function independently, so this doesn't increase the cognitive load on my brain. But that's not what's going on in the CLisp example above. The bulk of the code is long chains of WHEN, UNLESS, IF, and COND statements, and a lot of just-plain-sequencing. There's no reason these couldn't be pulled out into inner functions, or dispatched upon a la DataDirectedProgramming. -- <a href="JonathanTang.html">JonathanTang</a>
      </p>
      <p>
        That's what packages are for. You don't need to worry about polluting the namespace. It is the namespace. And I guess if you like long methods it's clear why you don't have a problem with large dense inscrutable classes. I am now waiting for the please go read these books because I am not getting paid and it's too complex for a wiki page post. I have seen real code like yours and that is exactly why I don't like it.
      </p>
      <p>
        <em>Let's not repeat the same arguments over here. At least three other folks agreed that you have not defended your position on that page, so go ahead and do it there. But you may express your undoubtedly opinionated position on the LISP snippet above. </em>
      </p>
      <p>
        I haven't used lisp since college so I won't bore people with my undoubtedly irrelevant opinion
        on something I don't know about. As for defending my opinion, if you don't see the complexity
        and confusion of long methods and classes as a problem (in java), then what can  say? If
        you think recreating another namespace mechanism other than the package is a good idea, then
        what can I say? Both are legitimate takes.
      </p>
      <hr/>
      <p>
        The longest method in my <a href="IbmSmalltalk.html">IbmSmalltalk</a> V3.5 image (by character count) is
      </p>
      <code>
        <strong>WindowsPlatformFramework class >>#_PRAGMA_PlatformConstants</strong><br/>
      </code>
      <p>
        clocking in at 663,973 characters. Eliding most of it (to spare your browser), it looks like this:
      </p>
      <code>
        _PRAGMA_PlatformConstants<br/>
      </code>
      <code>
        "%%PRAGMA DECLARE<br/>
        (name: PlatformConstants isPool: true)<br/>
        (pool: PlatformConstants declarations: (<br/>
        (name: AbeBottom isConstant: true valueExpression: '3')<br/>
        (name: AbeLeft isConstant: true valueExpression: '0')<br/>
        (name: AbeRight isConstant: true valueExpression: '2')<br/>
        (name: AbeTop isConstant: true valueExpression: '1')<br/>
      </code>
      <p>
        <strong>...</strong>
      </p>
      <code>
        (name: WcTreeview isConstant: true valueExpression: <em>'SysTreeView32</em> nullTerminated')<br/>
        (name: WcTreeviewa isConstant: true valueExpression: <em>'SysTreeView32</em> nullTerminated')<br/>
        ))<br/>
        "<br/>
      </code>
      <p>
        What conclusions can we gain from looking at this "particularly big" method in Smalltalk? None. Could it be written any other way? Who knows. Who cares. It doesn't help answer any questions about coding style, the relationship between method length and anything else, or anything else. The defclass macro from the CLisp CLOS source offers approximately as much insight into these questions in Lisp.
      </p>
      <p>
        By the way, the following Smalltalk fragment extracts the longest method in Smalltalk. I think it's easily ported to all dialects.
      </p>
      <code>
        | aSize aSelector |<br/>
        aSize := 0.<br/>
        Object allMethodsDo: [:each | <br/>
        (each sourceString size > aSize) ifTrue:<br/>
        [aSize := each sourceString size.<br/>
        aSelector := each selector]].<br/>
        aSelector<br/>
      </code>
      <p>
        <em>How about getting an average method line count in smalltalk? I don't know how, but I'd be interested in the result. Of course long methods exist, no one deny's that, but I'd bet on average, smalltalks line count is pretty low compared to other languages, C especially.</em>
      </p>
      <p>
        Yeah, I was just thinking about that myself. I can certainly collect the average line count. Even more interesting, but also more time consuming, is a histogram. I think the distribution will be interesting, and I'd like a tool that would let me click through the histogram to see the resulting code. I'll do the average first.
      </p>
      <p>
        <em>Make sure to get method count stats as well. An object with 100 methods is not easy to understand either.</em>
      </p>
      <p>
        [Voice 1: methods don't belong to objects in lisp]
      </p>
      <p>
        [Voice 2: Method count stats address a different (though perhaps related) topic. This topic concerns the length of a <strong>method</strong>.]
      </p>
      <hr/>
      <p>
        Umm, I can only claim to have skimmed the CLisp code above, but IMHO it looks gross. The average functions in <a href="TheArtOfTheMetaObjectProtocol.html">TheArtOfTheMetaObjectProtocol</a> were about 5-9 lines. The parts of CLOCC (mostly networking) I've looked at have had mostly 1-liners. Corman Lisp sources tend to run at a line or two, with rare functions being about 10-20. I think those may be better examples of Lisp code than the CLisp junk above.
      </p>
      <p>
        -- <a href="JonathanTang.html">JonathanTang</a>
      </p>
      <p>
        <em>And why would you qualify the code above as junk ?</em>
      </p>
      <p>
        I don't know why he would qualify it as such, as CLISP is a very high quality implementation. For reference, I checked how CMU does it, and the sources for defclass are embedded in an entire file (429 lines long) of which 101 lines is the DEFCLASS macro (the rest being helper expander functions used in that macro). I still don't think either of these are particularly hard to understand (due to length). After all, DEFCLASS does a helluva lot, in Lisp. -- <a href="AlainPicard.html">AlainPicard</a>
      </p>
      <p>
        I wish I had <a href="TheArtOfTheMetaObjectProtocol.html">TheArtOfTheMetaObjectProtocol</a> with me, as I could swear that defclass was no more than a printed page in that. It's 11 lines in the TinyClos implementation that came with Chicken Scheme, though that is perhaps apples-and-oranges. I <em>think</em> it was about a screenful in CormanLisp, but I don't have the source handy and I don't really want to trust my memory on that.
      </p>
      <p>
        Defclass does a lot, but what it does can generally be broken up into subtasks. I think that's the point that many people arguing for <a href="LotsOfShortMethods.html">LotsOfShortMethods</a> are trying to make. Would it harm readability to pull out a 100-line lambda and give it a name with a flet or labels? Or use a macro to take a table of forms and expand that into the COND? There <em>is</em> a lot of shared context in this example, but it seems like you could make the code a lot more readable by naming the various parts, and not having to trace through the execution and skip over all the when/unless blocks.
      </p>
      <p>
        I should probably retract my comment about it being "junk" above too, now that I've had a chance to read (as opposed to skim) it. It's readable. I just think it could be <em>more</em> readable if it was broken up a bit instead of being one monolithic piece. -- <a href="JonathanTang.html">JonathanTang</a>
      </p>
      <p>
        <em>Here's Gregory Kicczales' Scheme implementation of a </em>'subset<em>' of the functionality of the code above. I refrained to bring it into discussion, because unlike CLisp it is not a professional-level maintained code, but since you mentioned Tiny Clos, here it is:</em>
      </p>
      <p>
        ;
        ; Now we can get down to business.  First, we initialize the braid.
        ;
        ; For Bootstrapping, we define an early version of MAKE.  It will be
        ; changed to the real version later on.  String search for ``set! make<em>.</em>
        ;
      </p>
      <p>
        (define make
      </p>
      <code>
        (lambda (class . initargs)<br/>
        (cond ((or (eq? class <class>)<br/>
        (eq? class <entity-class>))<br/>
        (let* ((new (%allocate-instance<br/>
        class<br/>
        (length the-slots-of-a-class)))<br/>
        (dsupers (getl initargs 'direct-supers '()))<br/>
        (dslots  (map list<br/>
        (getl initargs 'direct-slots  '())))<br/>
        (cpl     (let loop ((sups dsupers)<br/>
        (so-far (list new)))<br/>
        (if (null? sups)<br/>
        (reverse so-far)<br/>
        (loop (class-direct-supers<br/>
        (car sups))<br/>
        (cons (car sups)<br/>
        so-far)))))<br/>
        (slots (apply append<br/>
        (cons dslots<br/>
        (map class-direct-slots<br/>
        (cdr cpl)))))<br/>
        (nfields 0)<br/>
        (field-initializers '())<br/>
        (allocator<br/>
        (lambda (init)<br/>
        (let ((f nfields))<br/>
        (set! nfields (+ nfields 1))<br/>
        (set! field-initializers<br/>
        (cons init field-initializers))<br/>
        (list (lambda (o)   (get-field  o f))<br/>
        (lambda (o n) (set-field! o f n))))))<br/>
        (getters-n-setters<br/>
        (map (lambda (s)<br/>
        (cons (car s)<br/>
        (allocator (lambda () '()))))<br/>
        slots)))<br/>
      </code>
      <code>
        (slot-set! new 'direct-supers      dsupers)<br/>
        (slot-set! new 'direct-slots       dslots)<br/>
        (slot-set! new 'cpl                cpl)<br/>
        (slot-set! new 'slots              slots)<br/>
        (slot-set! new 'nfields            nfields)<br/>
        (slot-set! new 'field-initializers (reverse<br/>
        field-initializers))<br/>
        (slot-set! new 'getters-n-setters  getters-n-setters)<br/>
        new))<br/>
        ((eq? class <generic>)<br/>
        (let ((new (%allocate-entity class<br/>
        (length (class-slots class)))))<br/>
        (slot-set! new 'methods ())<br/>
        new))<br/>
        ((eq? class <method>)<br/>
        (let ((new (%allocate-instance<br/>
        class<br/>
        (length (class-slots class)))))<br/>
        (slot-set! new<br/>
        'specializers<br/>
        (getl initargs 'specializers))<br/>
        (slot-set! new<br/>
        'procedure<br/>
        (getl initargs 'procedure))<br/>
        new)))))<br/>
      </code>
      <p>
        <em>Some 60 lines of code, again for a subset of functionality. Apparently yet another </em><a href="GrandMasterProgrammer.html">GrandMasterProgrammer</a> was not aware that his code may be subsequently victim of the public outrage on wiki about <a href="LongFunctions.html">LongFunctions</a>.<em></em>
      </p>
      <p>
        I saw that code (it's in the TinyClos implementation I'm looking at). I don't find it quite as hard to read as the defclass example above, because about 45 of those 60 (I counted 70ish in my implementation, but eh) are internal definitions that bind a variable to the result of a computation. With a let or flet or define, you can look at the code and then forget about it once it's been bound. With an if, when, unless, or cond, you have to trace through the branches, because the code within them can have multiple effects on the following code.
      </p>
      <p>
        Again, internal functions are not a problem (you won't see me arguing that <a href="JavaStaticClassesIsaTotalMess.html">JavaStaticClassesIsaTotalMess</a>). Long chains of conditional logic are a potential problem. Short methods (where method is a self-contained block, not necessarily at top-level) are more readable, more maintainable, and dare I say, more provable than long ones. -- <a href="JonathanTang.html">JonathanTang</a>
      </p>
      <hr/>
      <p>
        As requested above, the following Smalltalk code finds the method with the highest linecount, along with the linecount, and also calculates the average linecount. Note that methods with no sourcecode (there are a few) are excluded from the statistics.
      </p>
      <code>
        | aMaxLineCount aLineCountSum aMethodCount aLineCount aSelector aString |<br/>
        aMaxLineCount := 0.<br/>
        aLineCountSum := 0.<br/>
        aMethodCount := 0.<br/>
        Object allMethodsDo: [:each | <br/>
        (aString := each sourceString).<br/>
        aString ifNotNilObject:<br/>
        [aMethodCount := aMethodCount + 1.<br/>
        aLineCount :=  aString occurrencesOf: (String platformLineDelimiter at: 1).<br/>
        aLineCountSum := aLineCountSum + aLineCount.<br/>
        (aLineCount > aMaxLineCount) ifTrue:<br/>
        [aMaxLineCount := aLineCount.<br/>
        aSelector := each selector]]].<br/>
        'Longest method selector is #%1 with lineCount: %2, average line count: %3'<br/>
        bindWith: aSelector<br/>
        with: aMaxLineCount printString<br/>
        with: (aLineCountSum/aMethodCount) asFloat printString<br/>
      </code>
      <p>
        The method answered the following, from the IBM Smalltalk V3.5 image:
      </p>
      <ul>
        <li>
           Longest method selector is #_PRAGMA_PlatformConstants with lineCount: 9955, average line count: 8.91135178499799
        </li>
      </ul>
      <p>
        <em>Average 8.9, nice average!</em>
      </p>
    </div>
  </body>
</html>