<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        If It Cant Be Perfect Dont Bother
      </h1>
      <p>
        One of the <a href="FallaciousArgument.html">FallaciousArgument</a>s, wherein it is asserted (often incorrectly) that a solution to a problem that isn't a 100% solution is worthless.  In some cases, this might be true (or seem to be true)--a 99.99% solution may indeed be suboptimal.  In many cases, though, arguments of this type are used by opponents of a technology to discredit the technology which is useful but not perfect.
      </p>
      <p>
        Examples heard on Wiki:
      </p>
      <ul>
        <li>
           "Java isn't 100% portable; therefore Java's portability sucks".  Usually heard from proponents of languages which are much more <em>un</em>-portable than Java, attacking what is widely seen as one of Java's key advantages.  While <a href="WriteOnceRunAnywhere.html">WriteOnceRunAnywhere</a> has been overhyped, and Java portability ain't perfect (and leaves you with a <a href="LowestCommonDenominator.html">LowestCommonDenominator</a> graphics library)--Java is clearly superior in this regard to most of its competitors.  I'm not a huge Java fan, but I'll give it this.
        </li>
      </ul>
      <ul>
        <li>
           <a href="StaticTyping.html">StaticTyping</a> vs <a href="DynamicTyping.html">DynamicTyping</a>--occasionally it is uttered that there are programs for which <a href="TypeInference.html">TypeInference</a> is undecidable (and also, typechecking doesn't catch all programming errors)--therefore we ought to abandon <a href="StaticTyping.html">StaticTyping</a> completely.  (Conversely, many fans of <a href="StaticTyping.html">StaticTyping</a> make arguments in the opposite direction--that we should avoid any type operations which cannot be typechecked at compile-time.)  In some problem domains, this might hold.  In most problems, however, there's little reason not to mix the two.
        </li>
      </ul>
      <ul>
        <li>
           <a href="HttpHttpsSecurityParadox.html">HttpHttpsSecurityParadox</a>: Currently browsers want you to have either all the security of Https and a certificate signed by a trusted third party or all the insecurity of Http, there is no space for self signed certificates that only give encryption but do not offer protection against Man-in-middle attacks. The really bad thing is that the browsers scream "danger!" when you use self signed certificates, but say nothing when you use plain Http that is not only succeptible to Man-in-middle attacks but also to eavesdropping. The problem can be resumed in the sentence: "It is better to have no security in http than to have some security with self signed certificates and https".
        </li>
      </ul>
      <hr/>
      <p>
        This would be a problem if we applied it to our own solutions that we ourselves create. We live in an imperfect world with imperfect understanding, so we do the best we can. <a href="DoWhatYouKnow.html">DoWhatYouKnow</a>.
      </p>
      <hr/>
      <p>
        <a href="CategoryIdealism.html">CategoryIdealism</a>
      </p>
    </div>
  </body>
</html>