<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Coarse Grain Locking
      </h1>
      <p>
        From: <a href="SynchronizationStrategies.html">SynchronizationStrategies</a>
      </p>
      <p>
        Often, because we <a href="AvoidThreadsForOptimizations.html">AvoidThreadsForOptimizations</a>, our threads exist merely as a reflection of the problem environment. However, interactions between threads still require synchronization. In other situations, when we have threads for other reasons, we can still <a href="OptimizeLater.html">OptimizeLater</a> and ignore the <a href="OverHead.html">OverHead</a> of synchronization.
      </p>
      <p>
        Moreover, synchronization is often complex, especially when FineGrainLocking can quickly lead to deadlocks and when it is difficult to determine exactly what should be locked and for what duration. It can get even worse when thread/component interactions become complicated in their own right making it impossible to correctly weave locks throughout the system. In fact, a <a href="ProofOfCorrectness.html">ProofOfCorrectness</a> becomes geometrically more difficult with more locks as well.
      </p>
      <p>
        <strong>Therefore,</strong> use <a href="CoarseGrainLocking.html">CoarseGrainLocking</a>. That is, lock large swathes of program code in one big chunk. That way, you can <em>guarantee</em> that only one path of execution at a time will interact with a complex part of the system. Lock entire classes (ala ApartmentThreading or MonitorLock(s)). Lock entire methods. Lock entire packages (typically through a <a href="FacadePattern.html">FacadePattern</a>).
      </p>
      <p>
        It will be <em>much</em> easier to understand what's going on in your system if you use <a href="CoarseGrainLocking.html">CoarseGrainLocking</a>.
      </p>
      <p>
        <strong>But,</strong> coarse grain locks are slow. Use them sparingly and when necessary. Also, <a href="CoarseGrainLocking.html">CoarseGrainLocking</a> also increases the chance of deadlocking if done wrong. 
      </p>
      <p>
        Consider two threads that each acquire a lock each in two distinct superstructures in the system. Each merrily continues on until they hit the "barn door" of the respective other superstructure. Deadlock. The bigger the locks, the more likely this is.this is help ful in monitoring the process
        See also: <a href="CriticalSectionFusing.html">CriticalSectionFusing</a>, <a href="TrafficCop.html">TrafficCop</a>, <a href="SynchronizedTightGroupsOfClasses.html">SynchronizedTightGroupsOfClasses</a>
      </p>
      <p>
        <a href="CategoryConcurrencyPatterns.html">CategoryConcurrencyPatterns</a>
      </p>
    </div>
  </body>
</html>