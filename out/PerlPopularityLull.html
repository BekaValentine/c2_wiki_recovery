<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Perl Popularity Lull
      </h1>
      <p>
        There's been a recent discussion on <a href="SlashDot.html">SlashDot</a> (<a href="http://developers.slashdot.org/article.pl?sid=08/08/19/2335246)">http://developers.slashdot.org/article.pl?sid=08/08/19/2335246)</a> about <a href="PerlLanguage.html">PerlLanguage</a>'s fall from grace. It's now considered a "legacy" language by many corporations. While I am not a Perl fan, I wonder what this tells us about ANY current language. Perl's shortcomings are either fixable or a matter of personal preference. It's hardly COBOL. 
      </p>
      <p>
        [I think you underestimate how difficult it is to 'fix' shortcomings in any language while under pressure to maintain backwards compatibility.  Be they technical or perceived doesn't much matter; it's difficult either way.]
      </p>
      <p>
        If we let popularity contests dictate which languages come and go, then it just means we have to keep tossing out all our knowledge and built-up libraries every decade or so to starting over yet again. It's an ominous sign for <strong>other languages</strong>.
      </p>
      <p>
        <em>Ominous or not, it's been characteristic of the history of Computing since the beginning, nor is it necessarily a bad thing or we'd all be programming in Plankalk√ºl and machine language.  While it has allowed quite dire languages (some consider Perl to be one of them) to gain popularity or even precedence, it also ensures they'll eventually (mostly) fade away.</em>
      </p>
      <p>
        [Ah, it just means someone will need to come up with a language that can adapt to the fads of the decade while maintaining access to existing libraries.  <a href="DotNet.html">DotNet</a> and Java (with its <a href="OtherLanguagesForTheJavaVm.html">OtherLanguagesForTheJavaVm</a>) and <a href="ExtensibleProgrammingLanguage.html">ExtensibleProgrammingLanguage</a>s are all potential approaches.  But I've a feeling that periodically tossing out everything and starting from scratch is our current mechanism of dealing with <a href="TechnicalDebt.html">TechnicalDebt</a> that can't be paid within the current language or programming environment.  For longevity, we'd probably also benefit from a programming environment that encourages (or at least supports) global-scale refactoring for <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a> (i.e. across a global set of projects). At the moment the pressure to maintain backwards compatibility harms even efforts to refactor library interfaces (which are essentially sub-languages).  Something like a shared <a href="WikiIde.html">WikiIde</a> with a powerful <a href="RefactoringBrowser.html">RefactoringBrowser</a> may be appropriate for this goal, but we're pretty far from having either of those as of yet.]
      </p>
      <p>
        Re: "need to come up with a language that can adapt to the fads" - We already have one: Lisp. But <a href="LispIsTooPowerful.html">LispIsTooPowerful</a>, which hinders its acceptance. Language ugliness enforces cultures and some consistency even if it's ugly consistency. Fads require something to rally around, and the oddities and ugliness become like ritualistic <strong>membership badges</strong>. Typing "self" over and over again makes one feel like they are "doing real OOP", and thus part of the in-crowd for example. (Oop does not necessarily require "self", it's just an artifact of a version of it that can become ritualistic and symbolic.) -t
      </p>
      <hr/>
      <p>
        People are finally starting to realize that Perl isn't a really maintainable language.  What I mean by this is that the language does not help automate the process of writing maintainable code.  I've seen Perl code that ranges from sheer beauty to horrid wickedness the likes of which would drive Cthulu insane.  Considering that most programmers are highly lazy, guess which side of the fence <em>most</em> tend to write.
      </p>
      <p>
        Meanwhile, other languages are becoming more popular because they help automate writing maintainable code.  Some <a href="BondageAndDiscipline.html">BondageAndDiscipline</a> is a good thing, particularly as:
      </p>
      <ol>
        <li>
           the number of engineers contributing to the project increases, and,
        </li>
      </ol>
      <ol>
        <li>
           the scope of the project widens beyond the understanding of a few core engineers.
        </li>
      </ol>
      <p>
        <a href="PythonLanguage.html">PythonLanguage</a> offers this B&D in the form of significant whitespace and providing better core constructs to build reusable code.  Java provides this in the form of a (mostly) unambiguous grammar (as evidenced by the monumental number of refactoring IDEs for Java, versus nearly nothing for C/C++) that, while verbose, is unquestionably supportive of automation.  That is why these languages are more popular today than ever before.
      </p>
      <p>
        In any engineering discipline, <em>personal preference never enters into the picture.</em>  While there are some notational differences between an electronics schematic diagram from USA to EU, the notation is very definitely standardized sufficiently to allow anyone to read and understand anyone else's schematic.  Ditto for mechanical blueprints.  Ditto for chemical formulae.
      </p>
      <p>
        Programming languages, as a system of notation first and foremost, should not succumb to allowing personal preferences in the notation itself.  Doing so introduces ambiguity in the language which results in unmaintainable programs.  This is precisely why macros are frowned upon in most professional engineering circles.
      </p>
      <p>
        Changing a language (system of notation) to something better suited for your programming task should never obsolete legacy code, <em>provided a common </em>ApplicationBinaryInterface is used.<em>  This is why </em><a href="ComponentObjectModel.html">ComponentObjectModel</a> and <a href="CommonObjectRequestBrokerArchitecture.html">CommonObjectRequestBrokerArchitecture</a> have succeeded so well -- they provide a common ABI for components and libraries written in widely disparate languages.  Yes, there is a subtle performance hit, but in practice it's not that big a deal.  This is also one reason why C took off -- its ABI is stupid-simple to support.
      </p>
      <p>
        So, <em>who cares</em> if Perl is considered legacy?  Suck it up and move on.  This doesn't mean you have to discard all your Perl code, but it <em>does</em> mean that you might need to use Perl's FFI if you want to talk to other components written in other languages.  While it might complicate matters some, it <em>is</em> a solved problem, and it <em>should</em> not stop someone from moving forward with new projects in new languages.
      </p>
      <hr/>
      <p>
        While I agree that <a href="BondageAndDiscipline.html">BondageAndDiscipline</a> languages may help when you get large unmotivated teams, personal preference *does* matter if software engineering is mostly about psychology and suffers <a href="DisciplineEnvy.html">DisciplineEnvy</a>. In most cases, good developer(s) will be more productive with a dynamic language than a <a href="BondageAndDiscipline.html">BondageAndDiscipline</a> language <strong>[Source?!]</strong> {countersource? you rude hypocrite <strong>[Asking me to provide a counter-source to your invented statistics about "most cases" is </strong><a href="ShiftingTheBurdenOfProof.html">ShiftingTheBurdenOfProof</a>, and marks you a fraud.]<strong>}. </strong><a href="BondageAndDiscipline.html">BondageAndDiscipline</a> are what you need when stuck with <a href="PlugCompatibleInterchangeableEngineers.html">PlugCompatibleInterchangeableEngineers</a> conditions due to politics and motivation problems. While it does happen and may be beyond one's control, that does not mean that dynamic languages are inherently or globally "bad", just that they don't fit the current social-political environment of an organization. --top
      </p>
      <ul>
        <li>
           [<em>"if software engineering is mostly about psychology"</em> - seems a very big 'if' to me.]
        </li>
        <li>
           <em>It's my personal observation. And </em><a href="PaulGraham.html">PaulGraham</a>'s. If you want to counter it with official double-blind studies, be my guest....<em></em>
          <ul>
            <li>
               [A personal observation about statistical tendencies not made with real numbers in controlled circumstances is just so much hand-wavy speculation, be it from you or <a href="PaulGraham.html">PaulGraham</a>.  Even if you had fair exposure to people of equivalent skill in the different disciplines (which I doubt) <em>and</em> you had some means to personally observe and measure their 'productivity' (which I doubt), such things as confirmation bias (<a href="http://en.wikipedia.org/wiki/Confirmation_bias)">http://en.wikipedia.org/wiki/Confirmation_bias)</a> tends to interfere.  And I count myself a <em>rational person</em> in asserting that there is no need to dignify your hand-wavy speculation with time and resources to counter it.  Expecting or even implying that I should do it is <a href="ShiftingTheBurdenOfProof.html">ShiftingTheBurdenOfProof</a>, and is fallacy.]
            </li>
            <li>
               Your assumptions about how burden of evidence works is totally out of whack. But I'm not going to get into that now because I'm not in the mood for a <a href="ThreadMess.html">ThreadMess</a> today. --top
            </li>
            <li>
               [Riiiight.  If I followed the way YOU assume it works, I could make a claims like <em>"Top is an evil </em><a href="TuringTest.html">TuringTest</a> put on this wiki to frustrate everyone else"<em> or </em>"The universe was shat out fourteen hours ago by a flying swarm of rabid squirrels, complete with dinosaur bones and intact memories"<em> or even </em>"In most cases, good developer(s) will be more productive with a dynamic language than a <a href="BondageAndDiscipline.html">BondageAndDiscipline</a> language."<em>  I wouldn't need to provide </em>any<em> evidence.  Even if asked for evidence or a source, it would be my </em>right<em> to say, </em>"counter-evidence? you rude hypocrite,"<em> as though a demand for a source is the same as a counter-claim.  I agree: my </em>"assumptions about how burden of evidence works [are] totally out of whack"<em> with how YOU assume it should work.  But that is only because your assumptions are irrational.]</em>
            </li>
            <li>
               You are projecting again.
            </li>
            <li>
               [I doubt it.  Care to provide <em>evidence</em>?  Or are you just waving your hands wildly and spewing bullshit through your mouth... again.]
            </li>
          </ul>
        </li>
      </ul>
      <p>
        I happen to be <em>very</em> motivated in my software development work.  And as such, I overwhelmingly prefer strong, static typing.  Why shouldn't I?  I spent the majority of my early coding career using dynamically typed languages of various sorts, Perl included.  I've been a coder for over 20 years now.  Oh, how I adore it when my code runs for hours, only to have it die due to a stupid type mismatch error, something trivially identified by a compiler in mere microseconds.
      </p>
      <ul>
        <li>
           Well, that is not my experience with dynamic techniques. Just because a tool rubs YOU the wrong way (you make more mistakes with it) is NOT a reason to <strong>artificially extrapolate</strong> that to everybody. I agree there are places where "heavily engineered" typing pays off. But it is not everywhere. Just because Bush can't use a Segway right does not necessarily mean everybody cannot. One data point is only one data point. I am not saying that bugs never happen in my dynamic code, but there are many factors which make a project successful; including budget, timeliness, and nimbleness. --top
        </li>
      </ul>
      <p>
        Why shouldn't a computer that already knows a priori if module A is incompatible with module B tell me before I am even allowed to run it?  Indeed, <em>the singularly most motivated software engineers I know </em>'all<em>' prefer strong, static typing.  Every.  Single.  One.</em>  Why?  Because, like me, they too have all gone through the phase where they spent more time debugging type issues than logical issues.  It is not the unmotivated that seek strong typing.  No, they are the ones who not only embrace it, but who <em>invented</em> it.  The <em>motivated</em> are those who said, "Enough is enough!  I've had it with this stupid bull, and I'm not going to do this anymore!  I'm paid to design finite element analysis|jet engine CAD tools|web application X|rover driver software|whatever, <em>not</em> to sit here and solve and resolve the same damn human errors over and over and over and over and over and over again!"  No, we are not the unmotivated.  I can assure you of that.
      </p>
      <ul>
        <li>
           That is anecdotal evidence. Why should I believe your anecdotes over mine?
        </li>
      </ul>
      <p>
        But, does this mean that those who prefer dynamic typing are unmotivated?  No.  The entire basis for top's argument is a fallacy, that there exists only two sides to any issue.
      </p>
      <p>
        It is, in fact, the <em>artistic</em> (note: I didn't call you folks unmotivated!) who prefer dynamic typing.  You have the artsy programmers, and the engineer coders.  I am an engineer.  My notation requires precision and correctness throughout, the same as any mechanical or electrical engineer.  I am designing code to solve a problem <em>unrelated to programming as such</em>, code which will be maintained by others <em>long</em> after I've left the project.
      </p>
      <p>
        Can such things be done with dynamically typed languages too?  Sure they can, via coding standards, mandatory code reviews, and attempts to formally verify a program via HoareTriples (with or without unit tests), et. al.  (After all, there are no enforced checks that states a resistor can only be drawn at 0 or 90 degree angles; that "limitation" is merely common convention!)  But, that's a lot of <em>human</em> investment, and <em>human</em> investment is expensive and error-prone at all levels.  I prefer <em>automated</em> type checking, because it gives me precision and a standard method of communicating <em>broad invariants</em> about the program, which often are all that's needed.
      </p>
      <p>
        Let's now look at the nature of projects we see on the web today.  Compared to the 90s, when Perl was in its heyday, the complexity of software being developed today is so great that <em>no single developer can grasp everything.</em>  Project managers have only the vaguest idea of how their own projects actually work.  Customers who use the products are only aware of, maybe, 20% of the feature set offered.  Etc.
      </p>
      <p>
        Thus, as the number of people who <em>are required</em> to complete a project goes up, the need for <em>precise</em> syntax, <em>precise</em> semantics, <em>precision in notation</em> goes up concomitantly, perhaps even geometrically.  These things are precisely what statically-typed languages like Java and C# provide.  That's why they're gaining in popularity.  They offer all the "write once, run anywhere" convenience that Perl offers, while still affording developers precision of notation that you <em>just</em> can't get in Perl.  Or Python for that matter (much as I love Python!).  BTW, I predict Python will suffer a fate similar to Perl in the not-too-distant future, precisely for similar reasons.
      </p>
      <p>
        Go back to simple systems, where two cowboy coders in PJs on Saturday evenings/early mornings can understand and install a web e-commerce solution doped up on Jolt Cola, and yeah, Perl could be argued superior.  Those days are over.  It's time to grow up and realize the importance of notation, its impact on programmer productivity, and even how it impacts the management of resources from a fiscal point of view.  This has <strong>nothing</strong> to do with interchangable programmers; indeed, the <em>specific choice</em> of language is more to do with that.  I'd go with Java if you're looking for plug-n-play coders, but would choose Haskell or OCaml if I were more interested in the best of the best.
      </p>
      <p>
        <em>Labeling dynamic programmers as "cowboys" is a superficial personal attack.  Cowboy coders are those who use mass copy-and-paste. Well-written dynamic code is like good writing: choose words carefully and compactly that compliment each other so that you have a clean and flexible design. That is not coboy-ing, but </em>'crafting thoughtfully<em>'. --top</em>
      </p>
      <p>
        Please cut and paste the very words where I call dynamic language coders 'cowboys.'  As of 2008 Aug 25, no such text appears in anything I have written.  I did call them <em>artistic,</em> but not cowboy coders.
      </p>
      <p>
        What I did say, however, was this:
      </p>
      <p>
        <strong>Go back to simple systems, where two cowboy coders in PJs on Saturday evenings/early mornings can understand and install a web e-commerce solution doped up on Jolt Cola, and yeah, Perl could be argued superior.</strong>
      </p>
      <p>
        Do you see the difference?  I'm not calling anyone who actually uses a dynamic language a cowboy coder here.  The subject of the sentence refers to <strong>PROJECT COMPLEXITY</strong> as it relates <strong>TO PERL (BY NAME!)</strong>.  The last I checked, Python isn't Perl any more than Smalltalk or Lisp are.  I apologize for the bold-face and yelling, but it appears nothing short of that would get the point across.
      </p>
      <p>
        As you've been caught attempting to deliberately goad me into an argument I never started, I now am obligated to, henceforth, delete anything you say on this page which doesn't directly contribute to the topic at hand.  You've been caught, my friend.
      </p>
      <p>
        <em>Chewing me out instead of fixing your poor writing style. Typical: always deflecting off to somebody else. Without some measure of "complexity", this won't go far anyhow. Web apps can often split big projects up into lots of little ones that feed off the same data set. Whether it has 10 web pages or 1000, each little area can still be relatively independent, sharing libraries where appropriate.</em>
      </p>
      <p>
        I happen to work in such an environment, as you describe, now, with large federations of largely independent services spewed across several hundred servers, all talking to a single database backend.  All of these services were first written in Perl, by the original software engineers who founded the company.  Now, most are written in Java.  Why?
      </p>
      <p>
        Even today, we are finding we need to rewrite the remaining Perl scripts into Java for improved maintenance, exactly as I described, for precisely the reasons I described.  My claims are backed by real-world experience on real-world projects <em>at scale,</em> with real-world software engineers who, frankly, all <em>prefer</em> to use other languages, myself included.  Here's a viable definition of "complexity" for you: when it takes more than one engineer to fully understand the project under maintenance, it's complex.  Thus, it stands to reason, that the <em>greater</em> the number of engineers necessary to maintain it, the <em>more</em> complex it is.  This is something which is tangible and is measurable, and is remarkably accurate.  The codebase I currently work on is fairly well written (it could stand some improvement of course), but yet still requires 20+ engineers to maintain it.  For any desired user-story that someone needs to add code for, it typically involves the effort of 5 engineers, 4 of which are needed to just <em>explain</em> how the affected code works in sufficient detail to complete the task.  Although we <em>do</em> practice the principle of NoCodeOwnership, God help you if an engineer who last worked on some module hasn't looked at the code in more than one release cycle.  Human memory is quite fallible!  Worse, if said engineer no longer works there,  you're right screwed then.  <em>That</em> is complexity.
      </p>
      <p>
        I can't stand Java.  Why would I advocate Java over something else if I don't like it myself?  But, <em>I must remain objective.</em>  The reality is that Java's success in the world stems from a unique combination of features that few other languages have possessed, plus a sizable dash of luck.  We are now finding that maintenance of our Perl scripts is taking more time than actually contributing new functionality to the codebase.  <em>Measurable</em> evidence, based on project velocity, <em>clearly</em> demonstrates that Java development is <em>now</em> (it wasn't always) faster than Perl development (though, something tells me, you'll still find a way to ask WhatIsObjectivity).  Even I have often considered rewriting my Python codebase into Java on more than one occasion.
      </p>
      <p>
        And, you <em>did</em> attempt the first deflection, while I stayed rather explicitly on topic throughout.  Go ahead and blame me for poor writing style, if you wish.  I've certainly made mistakes in my prose before.  But, not this time.  In this case, you've been called on attempting to alter the fundamental thesis of my argument, and attempting a one-sided, skewed debate thereof, <em>twice.</em>  I simply called you on it the second time, is all.
      </p>
      <p>
        <em>How are us, the readers of your anecdotes, going to know if its just poorly written Perl, or there is an *inherent* maintenance defect to the language itself? Maybe you are just not smart/skilled enough to write good Perl. The possible gap in your head is not the fault of the Perl language. We can't rule it out gappy-headed-ness without details. I'd like to see actual representative Perl code samples that are not cleanable without switching languages. Again, I am not a Perl fan nor a Perl expert by any stretch, but I'm highly skeptical it contains inherent flaws of the type you speak of.</em>
      </p>
      <p>
        Look at the facts.  Perl's popularity is waning.  Complexity of services rendered to customers is going up.  While I admit that correlation is not causation, I think the evidence stands on its own merits.  I work in just one company, but the effect is being observed <em>industry-wide.</em>  Any gaps in my head cannot account for that.  I mean, you are essentially asking, "How can us, the readers of your anecdotes, really <em>be sure</em> that I'm typing on a real keyboard?  We can't rule out that its existance is by virtue of the collective will of the Platonic society!  Just because <em>you</em> don't believe in my keyboard's existance doesn't mean others do not!"  The whole premise of your counter-argument just doesn't make any sense.
      </p>
      <p>
        I cannot provide you samples of our Perl code here without breaching NDA, so your question is loaded.  Nice try, though.
      </p>
      <p>
        <em>But it's difficult to separate changes due to fads and hype versus changes due to merit (or lack of). I'd guestimate about 50% of all software-related technology church is related to mere faddism. Further, Perl as a scene lacked a "culture of maintainability" out historical habit. That culture tainted its name dearly. If car brand X is a favorite of teens who abuse it by doing donuts in the desert, that may mean that used X cars are more likely to be beat up. However, it says almost nothing about the original manufacturing quality.</em>
      </p>
      <p>
        Point taken; but, historical evidence provides no other significant correlation that can be traced to draw such a conclusion as I have.  We'll just have to wait and see, I guess.  The problem is, of course, nobody will be able to determine the actual causes.
      </p>
      <p>
        <em>As far as NDA, you don't need to give actual code. Pick 3 common patterns of problems in the code, and then create dummy application portions for a similar but not identical field. If most of the problems are in "computer space" instead of an industry (domain), such as CRUD handling, then the domain won't matter much anyhow.</em>
      </p>
      <p>
        This strikes at the heart of the matter -- <em>I cannot</em> give such a dummy application, because such a dummy application, by necessity, <em>is a dummy application</em> -- a huge gloss-over of the inherent complexity of the problem we are attempting to solve.  In order to properly convey the nature of the problem we're trying to solve, I have to break my NDA.  I'm sorry, I'm not going to do that.  These applications are in no way simple CRUD programs.  CRUD modules can be written in anything with relative ease.  The stuff I work with -- no way.  This is core business logic stuff.
      </p>
      <p>
        <em>I didn't equate "crud" with "simple". Interfaces can potentially be quite involved. But I would say some of the more complex biz logic tends to be "pushed to" the DB in the better larger apps I've seen and/or worked with. About 80% of the computation is done via SQL and the other 20% via imperative code that makes extra adjustments. Anyhow, you are </em>'not offering any usable or dissectable information about why Perl doesn't allegedly scale<em>'. In essence, your anecdotes don't scale. </em>
      </p>
      <p>
        The last I checked, one could not perform a fourier transform of an audio stream, or a wavelet analysis of an image, using any kind of database I'm familiar with.  I'll just leave it at that.
      </p>
      <p>
        <em>That's a solved and mostly isolated problem. Complexity that gums up production systems *generally* comes about from the multiplicity of interactions and interrelationships, not the volume of number chomping per se.</em>
      </p>
      <hr/>
      <p>
        <strong>RE:</strong> <em>"Maybe you are just not smart/skilled enough to write good Perl."</em>
      </p>
      <p>
        [I don't believe the <em>ability</em> to write 'good code' matters on the subject of maintainability as much as you seem to believe does.  Good, maintainable code can probably be written in most <a href="GeneralPurposeProgrammingLanguage.html">GeneralPurposeProgrammingLanguage</a>s.  Of greater relevance is how difficult or easy it is to write maintainable code, and the level of skill and wizardry and insight into the language required to do so.]  
      </p>
      <p>
        [On one extreme, a language can make even tossed-together last-minute one-off programs reasonably maintainable, portable, efficient, etc.  <a href="BadCodeCanBeWrittenInAnyLanguage.html">BadCodeCanBeWrittenInAnyLanguage</a>, of course, so you could still create obtuse, obfuscated, unmaintainable code if you tried... but your typical 'average' code unit would be reasonably maintainable, and you could expect that much from the hypothetical 'average' programmer.  On the other extreme, with such things as many <a href="EsotericProgrammingLanguage.html">EsotericProgrammingLanguage</a>s, the language fights you every step of the way.  To have maintainability, you'll either need to sacrifice other features (portability, performance, runtime modularity, etc.) <em>or</em> you'll be forced to juggle while dancing on a high wire just to keep all the features at the same time.  In such languages an 'average' programmer, even one following <a href="YagNi.html">YagNi</a> and <a href="DoSimpleThings.html">DoSimpleThings</a>, will end up with <a href="WriteOnlyCode.html">WriteOnlyCode</a> or everything <a href="ExtremelyInterstrangled.html">ExtremelyInterstrangled</a> into a <a href="BigBallOfMud.html">BigBallOfMud</a> because the <a href="LanguageInhibitsRefactoring.html">LanguageInhibitsRefactoring</a>, and attempting to come up with something more maintainable (without negatively impacting other features) will require a great deal of care and foresight.]  
      </p>
      <p>
        [<a href="PerlLanguage.html">PerlLanguage</a> isn't quite so bad as <a href="SnuspLanguage.html">SnuspLanguage</a>, but it (and especially its TIMTOWTDI culture, its unusual use of context, and its obtuse regexps) do tend to result in the average programmer writing a great deal of fragile <a href="WriteOnlyCode.html">WriteOnlyCode</a> that isn't comprehensible to maintainers (often even the person who wrote it in the first place).  <a href="PerlLanguage.html">PerlLanguage</a> doesn't make it impossible to write good, maintainable code, but it does unnecessarily make doing so more difficult than it could be.] 
      </p>
      <p>
        [While you can blame people's <em>"gappy-headed-ness"</em> for not being <a href="RealProgrammer.html">RealProgrammer</a>s who can easily juggle performance, portability, modularity, etc. while dancing on a high wire called 'maintainability', doing so improves neither the language nor its popularity nor the maintainability of its actual codebase.  For certain, it wouldn't be a rational way of thinking for a <a href="LanguageDesigner.html">LanguageDesigner</a> looking to improve on a language.]
      </p>
      <p>
        Without specific code to compare, this is merely more anecdotes, of which there is already a glut of on this topic.
      </p>
      <p>
        [Nothing I stated here is an anecdote; it is all logic and reasonable inference.]
      </p>
      <p>
        [As far as proof of the above principles, it is pretty trivial to prove that <a href="SnuspLanguage.html">SnuspLanguage</a> is more difficult to maintain than <a href="PerlLanguage.html">PerlLanguage</a> for a plethora of cases; even a small change (e.g. adding a single operation) can require moving large amounts of code in two dimensions, and there is no support at all for function composition or decomposition.  When it comes to existential statements, such as "some languages are harder to maintain than others", the trivial case is a total and complete logical proof of the statement.] 
      </p>
      <p>
        [Given that the some languages are harder to maintain than others, <em>you cannot logically assume</em> that any two languages have identical maintenance characteristics.  I.e. your current behavior of assuming that Perl has identical maintenance characteristics to other languages until proven otherwise is the irrational, illogical behavior.  The logical behavior is to assume nothing and reject any such assumption.  If you were to observe more pairs of languages and features, you'd even come to the conclusion that the opposite is true: you should assume no two distinct languages have identical maintenance characteristics until evidence for the opposite is true.  However, I'm not going to insist you accept that conclusion.]
      </p>
      <ul>
        <li>
           I never claimed that all language maintenance was equal. I am just saying there is no evidence that that Perl is inherently harder to maintain. The <strong>default assumption</strong> is that the difference in maintenance between Perl and say Java is unknown (null), NOT that they are equal. Thus, I made no logical fallacy.
        </li>
        <li>
           [If you <strong>truly</strong> assumed such (that the 'default value is unknown') then you'd be correct.  But your behavior of <strong>ignoring evidence</strong> because you'd prefer to stick with your 'default assumption' is the unreasonable behavior.  <strong>Assumptions are only good so long as evidence doesn't favor any particular conclusion.</strong>]
        </li>
        <li>
           See below about sole-sourcing of anecdotes.
        </li>
      </ul>
      <p>
        [Anyhow, you can't rationally assume that Perl is as easy to maintain as other languages like Python or Java.  Instead, you must (without cherry-picking) observe the evidence and come to a rational conclusion.  When it comes to Perl, the evidence (instances of which have been mentioned on this page and elsewhere) is almost overwhelmingly against Perl's relative maintainability.  It is true that much of this evidence will be anecdotal, such as people rewriting code in Java because they couldn't add the properties they needed to the Perl code without breaking it... or even because they couldn't read it.  But given a large amount evidence supporting a claim, and a lack of evidence supporting the opposite, and being in a situation where you can't assume either way, the <em>only</em> rational, inductively logical conclusion is to infer in favor of the side with evidence.  This is true even if the evidence isn't guaranteed set-in-stone conclusive.  In this case, the evidence, and therefore logic, says that Perl isn't as easy to maintain as various other languages.]  
      </p>
      <ul>
        <li>
           I'm sorry, but the evidence presented so far is purely anecdotal. I will agree that "popularity" of Perl has waned, but as already described, popularity is a poor metric for merit. (Otherwise, MS is king.)
        </li>
        <li>
           [I'm sorry, but statistics about anecdotes is not "purely anecdotal".  The 'popularity' of Perl has waned and people often give reasons for their deciding against Perl.  Maintenance and readability are generally among those reasons.  Similarly, if you look at popularity, MS is king... but if you study the stories of actual users, you'll find plenty of consistency among the complaints - driver problems, annoying security popups in Vista, etc.  <strong>Individually, these are anecdotes.  Collectively, these are <em>massive</em> observational and empirical evidence.</strong>]
        </li>
        <li>
           You are assuming you are the only source of anecdotes such that the other side of the scale is devoid of counter-anecdotes. And please elaborate on your MS comparison. I don't see your connection to Perl.
        </li>
        <li>
           [I am not assuming that <em>I</em> am the only source of anecdotes.  And I am not assuming the other side of the scale is devoid of counter-anecotes either: what I can say is that, when I looked (and I did) I never found any.  That is <em>not</em> assumption.  Absence of evidence IS evidence of absence insofar as the evidence should be obvious were it to exist.]  
          <ul>
            <li>
               Please clarify. I find too many pronouns and assumed references.
            </li>
            <li>
               [You stated: "You are assuming that <strong>you</strong> are the only source of anecdotes."  This is clearly untrue; the anecdotes are coming mostly from other people.  You also implied: "You are assuming that the other side lacks counter-anecdotes."  This is also untrue.  I looked, and therefore I did not assume.]
            </li>
          </ul>
        </li>
        <li>
           [Expanding on the MS example: one can use <em>consistency among complaints</em> (or statistics over anecdotes) as real evidence of a real problem being observed by real humans.  By using consistency among complaints, you assume only that most humans are partially rational and came to these conclusions based on their own observations; one can confirm this by focusing on complaints embedded in anecdotes of actual use.  MS can be popular but that doesn't obviate the complaints against it, and Perl can be unpopular, but that doesn't mean the complaints against it are baseless either.  These complaints are to a high degree consistent (that is: considerably higher than random) and so you can conclude that the observations are reasonable and have real causes.  It doesn't mean you know what the causes are, but knowing the cause is often irrelevant to whatever conclusion you're attempting to make.]
        </li>
      </ul>
      <p>
        [That isn't to say Perl is worse as a language... it was designed for one-off programming, and it does that pretty well.  It just isn't as maintainable.]
      </p>
      <p>
        [Anyhow, your insistence that code examples be provided doesn't seem very well considered to me.  Your implied belief is: "having specific code to compare will help me make a better conclusion."   But this <em>isn't</em> a logical belief unless you are also <em>assuming</em> (on faith?) that you'll somehow be able to <em>see</em> the emergent maintenance properties <em>of the whole language</em> just by observing a few small point-samples of code.  Given the relative and probabilistic nature of 'ease of maintenance', such an approach would be highly subject to confirmation bias.  What you 'see' can't be trusted.  I trust myself and my language design experience more, and I wouldn't even trust myself to be able to 'see' the difference in just a few code examples.]
      </p>
      <p>
        [Adding to the problem of code samples is the relative strength of hindsight and the lack of context, the former of which would tempt us into picking at the example and blaming the programmer for 'gappy-headed-ness' also known as 'lack of perfect foresight', and the latter of which would essentially be us failing to recognize all the forces influencing the programmer (time constraints, interfacing with other people's code, etc.).  The issue of context, especially, is important; the 'maintainability' of code in a language depends heavily upon the code with which it interacts and the other desired emergent features and <a href="NonFunctionalRequirements.html">NonFunctionalRequirements</a>, none of which are visible when looking at a code sample.]
      </p>
      <p>
        "Emergent" properties are even more difficult to rely on because they are easy to be tainted by sums of bias and personal preference. This is one reason why economists have difficulty forecasting better than an observant garbage collector. Code analysis isn't perfect, but its much better than merely anecdotes. And it may answer "why" instead of just "what". 
      </p>
      <p>
        [You over-generalize.  <em>Some</em> emergent properties are difficult to measure, and doubly so with only partial information.  Others are not so difficult.  Some of them I'm even sure you know well enough by maxim: a chain is only as strong as its weakest link, and armor is only as good as the biggest hole in its mesh.  In any case, language analysis is a better approach to discovering properties about a language than is code analysis.  Not only do you have access to the whole language definition, but it will answer "why" instead of just being a meaningless point of code in an infinite space.]
      </p>
      <p>
        By the way, if you had to assign a percent of problems caused by lack of compiler-time-checking and caused by difficulty in reading/grokking code, what percent would you assign to the mix, based on your anecdotal observations?
      </p>
      <p>
        --top
      </p>
      <p>
        [I suppose you're really not grokking me.  I told you before that <em>"a personal observation about statistical tendencies not made with real numbers in controlled circumstances is just so much hand-wavy speculation"</em>.  Not only is the scope of one person's anecdotes too limited to make conclusions, but such things as confirmation bias also tends to interfere.  It's even worse when the anecdotes haven't been recorded in a journal.  You may be happy with waving your hands and inventing statistics on a public, intellectual forum like <a href="WikiWiki.html">WikiWiki</a>, but I am not.]
      </p>
      <p>
        [In any case, your question is nonsense.  How do you, percentage-wise, compare two entirely different kinds of problems?  Problems caused by lack of compiler-time-checking are of a kind generally known as 'bugs'.  Problems caused by difficulty in reading/grokking code are more often of the kind known as 'I can't figure out how to fix the bug without rewriting the whole piece of code'.  It isn't as though I could rationally attribute a bug that just happens to be found in ungrokkable code as being <em>"caused by"</em> the code not being readable.]
      </p>
      <p>
        You seem more interested in arguing about who is the least rational instead of shedding light on "what's wrong with Perl". I don't want to argue about arguing, I want something more *specific* about "what's wrong with Perl", and I'm sure most readers do also (all one of them :-) If what you have presented so far is the sum of your evidence, we can call it a day and move on and let stand what's here.
      </p>
      <p>
        [The information you want and the information that you can logically and rationally infer from the data are often two different things.  If I tell you that a vehicle has been in a severe accident and is totaled, you can't tell me about the condition of its headlights.  If I tell you a ship is sinking, you can't tell me whether it is doing so because it struck a glacier or a coral reef.  If I tell you Michael Phelps is losing, you can't tell me it's because he's ill.  Nonetheless, all of these can be observed - an inductive approach to information gathering that takes lots of small clues (light, shadow, tilt against horizon, texture, timing) to infer a reasonable and rational conclusion.  <strong>The clues are not the problem. They are only symptoms of it.</strong>  The reason I call you <em>irrational</em> is that you <em>illogically</em> argue that you must know the *specific* problem before you'll acknowledge there is one.  Logic doesn't demand it. <em>Why do you?</em>  Based on collective anecdotes I can say with a <em>great deal</em> of confidence that people find Perl to be relatively unmaintainable compared to competitor languages.  Still reasonably, based on consistency among complaints, I can say that the reason for this maintenance problem <em>likely</em> has something to do with the dense regexps (which seem to be difficult for most humans to parse), unusual use of context, and maybe the heavy use of sigils.  But an inability to be *specific* happens to be completely irrelevant to my argument.  All that matters in the above discussion is <em>that</em> evidence shows Perl more difficult to maintain and that 'gappy-headedness' of individuals doesn't seem a likely cause (not given the vast array of intelligent people who have worked with Perl and still acknowledge the problem).]
      </p>
      <p>
        One does not have to use things like reg-ex in most of their Perl code. Wouldn't it make sense to stop using the problematic features of Perl in existing code for new parts rather than starting over from scratch? Java has bad features or styles also. And why couldn't you give examples of "unusual context" and sigils causing problems?
      </p>
      <p>
        [See <a href="ContextSensitivity.html">ContextSensitivity</a> for a discussion on unusual use of context.  A common saying to those learning Perl is that "until you learn context, your life will be miserable".  And if you want examples of overuse of sigils causing <a href="WriteOnlyCode.html">WriteOnlyCode</a>, you need only look at APL or <a href="InterCal.html">InterCal</a>; see <a href="TheProblemWithSigils.html">TheProblemWithSigils</a> for discussion.  In any case, it seems you are once again asking for examples immediately after I got through discussing why they aren't nearly as useful (for making good conclusions) as you seem to think they are.  Obviously I am not getting through to you.]
      </p>
      <ul>
        <li>
           Sigils are mostly a personal preference and a minor issue. It might be a form of hungarian notation, which itself is controversial. but its a very compact form of HN and thus not a real real-estate waster. As far as the value of code examples, more on that below.
        </li>
      </ul>
      <p>
        [Your idea of "stop using problematic features" of a language has some merit, but is something that (a) requires advanced foresight or insight into the language with regards to the emergent properties of using certain features, and (b) you can only do for your own code.  It doesn't make other peoples' code any more maintainable.  Keep in mind that a maintainers often enter the field years down the road.  Item (a) can be answered somewhat by use of culture and community and education, but both (a) and (b) are easier to resolve universally by putting the burden of foresight on a small group of individuals with significantly greater expertise at making good predictions with regards to language design based on their having studied other languages... i.e. <a href="LanguageDesigner.html">LanguageDesigner</a>s.]
      </p>
      <ul>
        <li>
           You seem to be suggesting that the "culture" of Perl is "bad", and that allows riff-raff code to sneak in. I tend to agree, but it seems easier to <strong>enforce coding standards</strong> than to overhaul all existing code to Java. Java can be made atrocious also.
        </li>
        <li>
           [Enforcing coding standards is a good idea, but it still doesn't eliminate the need to overhaul existing code the moment you need to start interfacing with it in ways that require maintenance or modifications.  It isn't as though this is an exclusive-or operation, so the issue of whether one is 'easier' than the other is somewhat irrelevant.]
        </li>
        <li>
           Please clarify. Of course maintenance involves modification.
        </li>
      </ul>
      <p>
        Re: "The reason I call you irrational is that you illogically argue that you must know the *specific* problem before you'll acknowledge there is one." - Other than your anecdotes, why should I acknowledge there is one? I never said code is the ONLY way I'd change my mind. If I had said that "I will only accept code examples as evidence", that would indeed be irrational and you'd have something real against ol' toppie to complain about. I'll indeed accept OTHER evidence; it's just that you haven't presenting anything beyond your anecdotes. You are a one-trick evidence pony so far.
      </p>
      <p>
        You insist very very hard that I accept your anecdotes at face value. I am sorry, but I won't. If that makes me a bad person, then I am guilty and shall fry in anecdote-rejection hell. Anecdotes are evidence, but weak evidence.
      </p>
      <p>
        [I insist very hard that you accept collective anecdotes (not <strong>my</strong> anecdotes) as being more than 'mere' anecdotes.  You're sorry, but you won't.  It seems you don't even comprehend the distinction.  You'll probably be condemned to being an ignorant stick in the mud who is incapable of sensory synthesis.  Anecdotes are individually weak evidence in the same sense that individual pieces of a jigsaw puzzle are weak evidence for the whole picture.  The more you put together, the clearer and more obvious the picture becomes.  Anecdotes collectively are very powerful evidence for whatever common substance they possess.  Neither our eyes nor collective anecdotes are completely reliable - you can't immediately rule out conspiracy or illusion, though you can look for evidence of such things should you have reason to believe them likely - but they are both <em>completely rational</em> sources for building high-confidence information for making useful conclusions.  Heck, we <strong>define</strong> "empirical" and "science" based on observations made ultimately through sensory synthesis.  If you accept science at all, you cannot <em>rationally</em> reject the idea of synthesizing weak evidence into strong evidence.]
      </p>
      <p>
        Your presentation your anecdotes is also weak. Beyond the anecdotes themselves, you offer very little *supporting* evidence around them. I only know what you type on the page, I cannot read your mind. If you don't communicate your experiences well, there is not much I can do.
      </p>
      <p>
        [I suppose self-education and doing your own research <em>never occurs to you</em>.  I <strong>expect</strong> you to come into any argument having already educated yourself on modern state of affairs; to do anything less is negligent of your duty to provide reasonable argument.  I don't plan to present the anecdotes to you; they are readily available should you do a little research of your own.]
      </p>
      <p>
        For one, it's not my job to provide evidence for YOUR claims. Second, I do talk to others, and their anecdotes often don't match yours.
      </p>
      <p>
        [It <strong>is</strong> your job to know what you're talking about.  This entire discussion you've been waving your hands and saying stuff like "maybe the other guys have counter-anecdotes" and "often other people's anecdotes don't match the ones you've read".  You say this <em>without actually looking.</em>  Look.  Your 'hypothetical' evidence ain't worth crap, and your tendency to present it is proof of your negligent ignorance.]
      </p>
      <p>
        When writing on this wiki, you need to *assume* there are multiple readers (even if we scared them off in practice). The readers want to see your evidence. All you have offered is militant anecdotes. That is all the reader sees here. <strong>What have you offered the reader</strong> beyond personal anecdotes?
      </p>
      <p>
        [All you've done is wave your hands and said I've only offered anecdotes.  Since you're not paying attention, I haven't actually offered any.  I've told the people I think the evidence stands for itself... all they need to do is go look at the anecdotes (e.g. run a few google searches) and examine consistencies between them. I'm confident in this in the same way that I wouldn't present a massive amount of evidence to show the sky to be blue.  The answers are out there; you don't need to look hard to find them.  If you actually cared, you'd have <em>already</em> looked.  Since you don't actually care, you're just trolling.]
      </p>
      <p>
        You are hand-waving your "evidence" off to Google. Thanks for nothing. I do see a lot of complaints about the <em>culture</em> of Perl, but nothing concrete inherently wrong with the language. If you wish to claim that the culture problem <em>alone</em> is sufficient to discontinue Perl, I won't necessarily disagree. 
      </p>
      <p>
        [As usual you "see" what you choose to see.  If you want to see a lot of complaints about the <strong>maintenance issues</strong> of Perl, go look.  If not, then stop trolling.  It isn't as though you actually understand what other people are saying anyway; I've certainly not said anything about discontinuing Perl.  It has strengths to go with those weaknesses.  In your favored sense, it matters how the customer 'weights' maintenance vs. rapid one-off string and shell operations.]
      </p>
      <p>
        Your proof is on Google, and mine is on Alpha Centauri. If you reach A.C. and my evidence is not there, I will give you $5,000. (Offer expires on 1/1/2030.) 
      </p>
      <p>
        [I see some difference in accessibility, there.  How's about you just give me the money to reach AlphaCentauri and bring your proof back to us Earthlings.  Can't promise I'll get it, though.  ;-]
      </p>
      <hr/>
      <p>
        [I also insist that code examples are overrated.  They're too easy to pick apart with our advanced hindsight and lack of context.  When presented in a situation such as this one (regarding such relative issues as 'difficulty' to make 'more maintainable') they're likely to be either too contrived or too simplistic (since you can't fit a <a href="LargeApplication.html">LargeApplication</a> into a <a href="WikiWiki.html">WikiWiki</a> example).  Your dependence on them isn't irrational so much as ill considered.]
      </p>
      <p>
        Yes, they are overrated. But so are anecdotes.  If I had to grade them evidence-wise, I'd give anecdotes a "D" and code examples a "C+". A's and B's would be nice, but none have come yet. --top
      </p>
      <p>
        [Code samples are fine evidence of <em>certain</em> claims (in particular, existential claims... i.e. "it is possible to do XYZ in language L").  So, while you continue to invent grading systems along with your invented statistics, you should keep in mind that grading code examples across the board is stupid and that grading them in this situation without demonstrating or proving them useful is hand-wavy and baseless.]
      </p>
      <p>
        Anecdotes are even hand-wavier and baseless-ier than code examples. I am tempted to use the "H" word.
      </p>
      <p>
        [Individually, perhaps.  Collectively, no.  Make a distinction.]
      </p>
      <p>
        You and yourself = collectively?
      </p>
      <p>
        [The user stories I looked up and the people I interviewed = collectively.  Damn if that doesn't prove you aren't listening.]
      </p>
      <p>
        Indirection doesn't improve the value of anecdotes much. Evidence-wise, you are still the bottleneck. If you want a lesson on "proper" survey techniques...
      </p>
      <p>
        [Indirection does not improve value.  Quantity and independent opinions, however, is a different matter.]  
      </p>
      <p>
        [And evidence-wise, I'm telling you it's readily available for you to get your own.  I'm not stopping you <strong>therefore</strong> I'm no bottleneck; you're free to make progress without waiting on me.]
      </p>
      <hr/>
      <p>
        RE: <em>"Some </em><a href="BondageAndDiscipline.html">BondageAndDiscipline</a> is a good thing . . . In any engineering discipline, personal preference never enters into the picture."<em> </em>
      </p>
      <p>
        [Your assumption that eliminating "personal preference" in notation and syntax somehow equates to or requires <a href="BondageAndDiscipline.html">BondageAndDiscipline</a> languages doesn't seem readily justifiable.] 
      </p>
      <ul>
        <li>
           <em>(In the express context of Perl, which this page is expressly above, it does, thanks to Perl's TIMTOWTDI principle.)</em>
        </li>
        <li>
           [I don't believe so.  For two reasons:
          <ul>
            <li>
               [First, even for a highly mutable language (with <a href="RealMacros.html">RealMacros</a> and such) the culture can reject mutations just for "personal preference" and thus restrict it to objectively justifiable new short forms.  I.e. a language that allows the creation of more than one way to do it doesn't need to be used that way.]
              <ul>
                <li>
                   Correct; however, empirical observations made by me in real-world organizations suggests this <em>rarely happens.</em>  Google is the <em>sole</em> exception, where they <em>very strictly</em> enforce coding conventions with gestapo-like regularity.  However, even Google has decided to shun various features of C++ and Java in the interests of a more semantically consistent coding style.  I've recognized, in the past, that conventions will provide a necessary framework for properly exploiting these kinds of features.  But, again, <em>it takes human intervention,</em> which is both fallible and energy-intensive.  That is why most people don't bother.
                </li>
                <li>
                   [It takes 'human intervention' to write the code in the first place.  Humans can write <a href="BadCodeCanBeWrittenInAnyLanguage.html">BadCodeCanBeWrittenInAnyLanguage</a>, so one doesn't escape the need for human intervention to repair the code after it has been mauled.  I guess one is trading in extremes.  I happen to believe the freedom to refactor complex syntax patterns into simpler, more obvious data languages is worth the price of allowing humans who write bad code to write even worse code.]
                </li>
              </ul>
            </li>
            <li>
               [Second, It is my impression that <a href="BondageAndDisciplineLanguage.html">BondageAndDisciplineLanguage</a> has more to do with (Bondage) how the language restricts you from combining certain features (e.g. second-class types or functions, having primitive value-objects (int, float) that can't be used like other types, etc. - 'bondage' ~= 'violations of <a href="SymmetryOfLanguage.html">SymmetryOfLanguage</a>') and (Discipline) how the language (and its common libraries) forces you to jump through hoops (e.g. being forced to write a bunch of boiler-plate code to have a usable program; the 'main' function; console overhead; framework initialization and destruction; explicit memory management; etc.).  Freedom to manipulate notation hasn't ever been a requirement to avoid <a href="BondageAndDiscipline.html">BondageAndDiscipline</a>.  E.g. Assembly language is rating pretty low on the B&D in people's opinions, and it doesn't offer much recourse towards changing the syntax or providing macros.]
              <ul>
                <li>
                   Haskell doesn't suffer from your concerns about (bondage) above, so instead of attributing C and its entire inbred family of languages' failures to <em>all</em> statically typed languages, it's best to qualify your concerns explicitly.  Your concerns regarding discipline, however, confuses me utterly.  In the first few sentences, you set yourself up to attack my position, but the latter half of your argument actually agrees with it.  I'm very confused.
                </li>
                <li>
                   [The above isn't strictly an attack on your position, so much as an attack on your <em>usage</em> of the phrase '<a href="BondageAndDiscipline.html">BondageAndDiscipline</a>'.  This is because restricting syntax manipulations is not '<a href="BondageAndDiscipline.html">BondageAndDiscipline</a>'.  If you aren't tracking it, your implicit position above is that such things as semantic whitespace and lack of macro features are <a href="BondageAndDiscipline.html">BondageAndDiscipline</a>, and I don't believe they are.  I attempted (apparently unsuccessfully) to clarify this by describing what <a href="BondageAndDiscipline.html">BondageAndDiscipline</a> really implies as I see it based on how it is described under <a href="BondageAndDisciplineLanguage.html">BondageAndDisciplineLanguage</a>.] 
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <p>
        External Links
      </p>
      <ul>
        <li>
           <a href="http://www.cio.com/article/446829/PHP_JavaScript_Ruby_Perl_Python_and_Tcl_Today_The_State_of_the_Scripting_Universe?contentId=446829">http://www.cio.com/article/446829/PHP_JavaScript_Ruby_Perl_Python_and_Tcl_Today_The_State_of_the_Scripting_Universe?contentId=446829</a>
        </li>
      </ul>
      <hr/>
      <p>
        See Also: <a href="DynamicLanguagesAndLargeApps.html">DynamicLanguagesAndLargeApps</a>
      </p>
      <hr/>
      <p>
        <a href="AugustZeroEight.html">AugustZeroEight</a>
      </p>
    </div>
  </body>
</html>