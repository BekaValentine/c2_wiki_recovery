<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Distributed Software Development
      </h1>
      <p>
        Software development when the participants are geographically separated most of the time. Some think this is key to being a competitive organization; others think that this can quickly turn into an <a href="AntiPattern.html">AntiPattern</a> if you're not careful.
      </p>
      <p>
        <em>Not to be confused with </em><a href="DistributedProgramming.html">DistributedProgramming</a>, where the final home of the application(s) is the issue rather than how it is developed. Sometimes called "Dispersed Working" to make the distinction clear.<em></em>
      </p>
      <hr/>
      <p>
        <strong>Distributed Teams vs Outsourcing vs </strong><a href="TeleCommuting.html">TeleCommuting</a><strong></strong>
      </p>
      <p>
        These three situations are different and need to be approached with different patterns:
      </p>
      <ul>
        <li>
           <a href="TeleCommuting.html">TeleCommuting</a> can sometimes mean you're at home, and everyone else is in an office. This is an asymmetrical and experience that puts you at a disadvantage.
        </li>
        <li>
           Outsourcing is about getting teams in different places to work together; but each team is formed from co-located people.
        </li>
        <li>
           <a href="DistributedTeams.html">DistributedTeams</a> are about getting a set of geographically-separated individuals to work together as a team. <em>There's a series of workshops about this --- see </em><a href="http://www.fastnloose.com/dad.''">http://www.fastnloose.com/dad.''</a> (<em>...but this link seems dead.</em>)
        </li>
      </ul>
      <p>
        -<a href="AlanWills.html">AlanWills</a>
      </p>
      <hr/>
      <p>
        <strong>Opposition View</strong>
      </p>
      <p>
        Separation of developers from users often leads to poor developer understanding of system needs. It is usually best to have developers and users colocated.
      </p>
      <p>
        <em>I agree.</em>
      </p>
      <p>
        This is a functional, not geographic, problem! The geographic location of users and developers is not the main problem, the main problem in this area is communication and collaboration, which can take place over great distances as well as across the table, and with the emergence of virtual conferencing, there will be little difference. There are time differential problems to be worked out to schedule such virtual face to face conferences if the parties are widely separated. But there are even advantages in this respect in that in properly configured arrangements, development can take place 24 hours a day with no one having to work during the night time.
      </p>
      <p>
        <em>Actually it is a geographic problem. The effort to communicate increases with geographic separation (and time). There is no more powerful means of communicating the needs of the end users to the developers than to have the developers sit alongside the users. Site visits can have a similar effect, but the effect fades over time. Far too much information is filtered out when it is reduced to written or verbal language and the sense of importance of issues can be completely lost.</em>
      </p>
      <p>
        <em>An interesting off shoot of this line of thinking is that if the users are geographically dispersed, collocating developers and users may require that the developers be dispersed as well. This may lead to developer conflict as local work preferences are identified and need to be resolved.</em>
      </p>
      <p>
        <em>Whether this is a geographic or a functional problem depends on the rest of the development model as well. Well modularized projects are easier (but not trivial) to distribute, even across geographical and temporal boundaries. Most important though is the presence of a strong product vision and "flag bearers" who can champion this at each site. In my experience the single most hindering hinderance(...) in cross-site development is the lack of such a strong guiding vision. Note that this might seem at odds with point 1 below but only if one makes the mistake of equating architecture with product.</em>
      </p>
      <hr/>
      <p>
        <strong>What it requires to make </strong><a href="DistributedSoftwareDevelopment.html">DistributedSoftwareDevelopment</a> work is<strong></strong>
      </p>
      <p>
        (1) A development process that fosters independent thinking and doesn't "sweat the small stuff".	This includes letting developers be their own designers -- it won't work if an architect or manager wants to control the whole process at a micro-level.
      </p>
      <p>
        (2) A basic design that is truly modular and extensible (i.e. proper use of encapsulation, well-structured inheritance hierarchies -- usually this means being chock-full of <a href="DesignPatterns.html">DesignPatterns</a>).
      </p>
      <p>
        (3) An EXCELLENT code-management systems (ENVY from OTI/IBM comes to mind)
      </p>
      <p>
        I can think of three projects ranging from small to pretty large that have made this work that I'm familiar with.
      </p>
      <p>
        (1) The biggest is probably the development of IBM Smalltalk and <a href="VisualAge.html">VisualAge</a>. There are at least three groups that I know of. There is the group in RTP that actually builds the <a href="VisualAge.html">VisualAge</a> classes, there is the base IBM Smalltalk group in Ottowa, and then there is another group in Raleigh that does extensions to the base image. They have well-defined roles, use ENVY to keep their code in sync, and seem to do pretty well.
      </p>
      <p>
        (2) I was on a Geographically distributed project with KSC under contract to Cold Spring Harbor Labs and Genomica. We would meet about once a month for design meetings, and the rest of the time we would just trade design information by email, and code through ENVY. The key to this one working was that the parts of the system we were working on were more or less independent, and that we enforced class ownership.
      </p>
      <p>
        (3) KSC and Texas Instruments did a Geographically distributed project on part of the ControlWORKS system last year. Again, the keys to the success were what has been mentioned above.
      </p>
      <p>
        (4) see quovix.com. they are building software apps for businesses using a network of 1,500 developers around the world. the whole thing is coordinated by a small group of quovix engineers...
      </p>
      <p>
        My guess is that if you violate any of the above three assumptions, then this does become an anti-solution.
      </p>
      <p>
        <a href="KyleBrown.html">KyleBrown</a>
      </p>
      <hr/>
      <p>
        Most <a href="OpenSource.html">OpenSource</a> projects are <a href="DistributedSoftwareDevelopment.html">DistributedSoftwareDevelopment</a> efforts, so those experiences might be instructive. See <a href="OpenSourceProjectOrganization.html">OpenSourceProjectOrganization</a> for more.
      </p>
      <hr/>
      <p>
        As far as other tools besides ENVY that are up to the task of geographically distributed code management, CVS (the <a href="ConcurrentVersionsSystem.html">ConcurrentVersionsSystem</a>) is commonly used. The makers of <a href="ClearCase.html">ClearCase</a> have an add-on called <a href="MultiSite.html">MultiSite</a> which is specifically for geographically distributed development. Perforce has an underlying client-server model which, combined with its blinding speed, is also well suited for this particular task. 
      </p>
      <p>
        The code repository management solutions pretty much come in two varieties: a <em>centralized repository</em> accessed by remote clients over a network, and <em>mirrored repositories</em> or <em>replicated repositories</em> where each site has their own replica of the master repository (sometimes there can be more than one master) and one repository "syncs-up" with another at planned times and intervals.
      </p>
      <p>
        The centralized model assumes less risk, but is often slower for doing checkouts and checkins over the internet, and there can be reliability and availability issues if the central site goes down (all the remote sites can't do any checkins or checkouts during that time).
      </p>
      <p>
        The mirrored-model may be done with a strict master-slave relationship between repositories. Also, some notion of site-mastership has to be applied either to various directory-trees, or else to various branches of the system-wide version tree (or both).
      </p>
      <p>
        For directories, what this means is that, a given directory and its contents (possibly including subdirectories) are granted exclusive write-access to only one site. That site is the "master" for that subtree. Other sites have read-only access to elements not "mastered" by their site. It's not quite <a href="CodeOwnership.html">CodeOwnership</a>, more like CodeSiteOwnership.
      </p>
      <p>
        Alternatively (or perhaps additionally) certain branches of the version tree may need to be "site-mastered" (something <a href="MultiSite.html">MultiSite</a> refers to as "branch-mastership") such that versions on a given branch or codeline may only be created at the site that is the master for that branch/codeline.
      </p>
      <p>
        Site-mastering of elements and directories helps ensure that a given file is added or removed at only one site. If both sites added a file of the same name in the same directory during the interval between "sync-ups", one of them would be a doppleganger and would probably need to be renamed.
      </p>
      <p>
        Similarly, site-mastering of branches/codelines helps ensure that a given version on a given branch is created (or removed) at only one site. This allows parallel development between sites on the same file if desired, so long as each uses a separate codeline from the other, mastered to the local site.
      </p>
      <p>
        Both of these site-mastering strategies are very common among distributed teams that have a genuine need for parallel development on a common set of elements. The main advantages of the mirroring approach are that access for checkin/checkout tends to be faster since it is always from the local repository, and other sites can continue working when one site has a network glitch that might otherwise stop work for a few hours, or a few days.
      </p>
      <p>
        The main issues are finding the right frequency and time to sync-up repositories, deciding whether one-way or two-way mirroring is needed, enforcing site-mastering strategies (<a href="MultiSite.html">MultiSite</a> supports this directly), and coping with the fact that the sites in question may never all have the exact same versions of the source at the exact same time, but instead within a tolerably short time-difference at any given time (which turns out not to be as bad as it sounds, so long as only one site is used for cutting and configuring the official release version for any given release).
      </p>
      <p>
        These repository patterns are just a few of the many SCM "patlets" we mined in the "SCM Hot Topic" at ChiliPLOP97. Some of them are written up under my ACME pages (see <a href="TopicalPatternLanguageWebSites.html">TopicalPatternLanguageWebSites</a>).
      </p>
      <p>
        -- <a href="BradAppleton.html">BradAppleton</a>
      </p>
      <hr/>
      <p>
        One important factor is people-related, rather than process-related:
      </p>
      <ul>
        <li>
           Act Like Colleagues. If the distributed teams perceive the people who are far away as enemies, or as competitors for the ";fun parts", distributed development fails. If the distributed teams treat the far-away members as co-workers who happen not to be physically present, distribution may succeed.
        </li>
      </ul>
      <p>
        Important tricks toward meeting this goal: 
        (see also <a href="InterTeamCommunication.html">InterTeamCommunication</a>)
      </p>
      <ul>
        <li>
           Meetings by phone. If there's a weekly staff meeting, both teams should be included, by speakerphone if necessary. This helps make sure that gossip-swapping occurs.
        </li>
      </ul>
      <ul>
        <li>
           Inclusive E-mail lists. Make sure everybody knows what's going on. A lively E-mail list can take over the functions of the water cooler.
        </li>
      </ul>
      <ul>
        <li>
           Occasional on-site visits help.
        </li>
      </ul>
      <ul>
        <li>
           <em>We use all of the above, but IRC mostly. -- </em><a href="AalbertTorsius.html">AalbertTorsius</a><em></em>
        </li>
      </ul>
      <ul>
        <li>
           Set up a wiki.
        </li>
      </ul>
      <p>
        Anybody got more?
      </p>
      <p>
        -- <a href="BetsyHanesPerry.html">BetsyHanesPerry</a>
      </p>
      <ul>
        <li>
           With regard to using CVS; recently a crop of new <a href="DistributedVersionControl.html">DistributedVersionControl</a> systems started becoming relatively stable, like <a href="DarcsRevisionControl.html">DarcsRevisionControl</a>, <a href="MonoTone.html">MonoTone</a>, and <a href="GitVersionControl.html">GitVersionControl</a> that handle distributed development much better than CVS, especially in regard to merges. JackLloyd
        </li>
      </ul>
      <p>
        <em>Occasional off-site visits might help. My last distributed project had a small group (2 people) in an office in Portland, with the rest of the team (2 of us) at the larger main office in Sunnyvale. We rotated visits. (I enjoyed that part. Downtown Portland is a fun place to spend a few days.)</em>
      </p>
      <p>
        <em>However, our VP never made the trip--a fact that didn't go unnoticed by the Portland folks, and which was often mentioned when discussing morale. -- </em><a href="DaveSmith.html">DaveSmith</a><em></em>
      </p>
      <hr/>
      <p>
        One other factor is the fear of outsourcing. When my employer started doing distributed development with our Indian subsidiary; many here viewed it with suspicion, thinking that the collaboration was a training exercise that would eventually result in us being laid off and the team in India doing <em>all</em> the work. Fortunately, that hasn't come to pass. Five years later (with our development team being spread across <em>four</em> different nations), those fears seem to have subsided quite a bit - each site gets interesting work to do, and we've learned to collaborate more effectively. At any rate, effective collaboration cannot occur if one site views the other as competition for their jobs.
      </p>
      <p>
        This page contains a lot of insights that are inherited by general distributed development of any objects or processes, so I <a href="DiiGo.html">DiiGo</a> this page and add it to the <a href="WikiTrail.html">WikiTrail</a> <a href="ExtremeOpenBusiness.html">ExtremeOpenBusiness</a> for further refinement. -- <a href="FridemarPache.html">FridemarPache</a> [<a href="http://trailfire.com/fridemar/marks/224279]">http://trailfire.com/fridemar/marks/224279]</a>
      </p>
      <hr/>
      <p>
        One assumption made in the discussion so far is that all the developers actually belong to the same organisation (or maybe subcontractors thereof).
      </p>
      <p>
        Several of my major projects were research consortia, where the software (proof-of-concept, demonstrator, not production code thank goodness) is developed by several teams (typically a mix of government, industry and academia). There is no hard contractual relationship between the organisations, so you can't hold anybody to anything much. There is no central code repository. There isn't a single development methodology (though each organisation has its own internal processes it must obey). I'm still unsure how _any_ development methodology can cope with this sort of situation, though it is quite common in certain areas.
      </p>
      <p>
        Waterfall development is largely impossible since the requirements are unclear (it's research, after all). Time-boxed iterations don't really work either, since you can spend an entire iteration sitting around because you have unfulfilled dependencies on another partner. This means you either waste developer-hours, or you have to 'pause' and reschedule so everyone is just working a few hours a week keeping up with email, meetings etc, waiting until they can get some real work done.
      </p>
      <p>
        One of the projects of this style actually went very well, another less so. It seems to largely come down to the culture of the teams and the individuals concerned. If everybody involved has an Agile mindset, then it all seems to 'just work'.  If the mindsets are mixed, and include bureaucratic traditional managers, then it is very painful.
      </p>
      <p>
        <em> "Organi</em>'S<strong>ation" (popular UK) WTF?, Blech!... -vs- "Organi</strong>Z<em>'ation" (Traditional Oxford English, USA & Canada).</em>
      </p>
      <p>
        Well, pardon me for being English. Did you have any comments on the substance rather than the spelling?
      </p>
      <hr/>
      <p>
        See also: <a href="PairProgrammingAtHome.html">PairProgrammingAtHome</a>, <a href="VirtualPairProgramming.html">VirtualPairProgramming</a>, <a href="ProgrammingInsideTheHome.html">ProgrammingInsideTheHome</a>, <a href="TeleCommuting.html">TeleCommuting</a>, <a href="DistributedTeams.html">DistributedTeams</a>, <a href="OpenSourceProjectOrganization.html">OpenSourceProjectOrganization</a>, <a href="ExtremeOpenBusiness.html">ExtremeOpenBusiness</a>
      </p>
    </div>
  </body>
</html>