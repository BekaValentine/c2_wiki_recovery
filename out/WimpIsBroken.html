<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Wimp Is Broken
      </h1>
      <p>
        The <a href="WimpInterface.html">WimpInterface</a> (WIMP = Windows, Icons, Menu, Pointer) is a broken concept.
      </p>
      <p>
        Contrary to popular opinion, it is extremely user-unfriendly, hard to learn for beginning computer users, once mastered hard to use. It's a slow and non-intuitive way to interface with a computer. If you think that you prefer keyboard shortcuts just because you're an experienced computer-user, wait until you see a complete computer novice approach the mouse (a.k.a. the "foot-pedal"). Especially when you try to explain them how to "double-click" on some vaguely Egyptian hieroglyph.
      </p>
      <p>
        This is an attempt to short-circuit a lot of vague and unproductive argument below. If it works, the unproductive argument can be almost entirely refactored away.
      </p>
      <p>
        A <a href="WimpInterface.html">WimpInterface</a> is a lousy substitute for an interface that's systematically designed to be usable in every regard. We shouldn't settle for Wimp; we may have to tolerate it but we certainly shouldn't <em>settle</em> for it even now.
      </p>
      <p>
        -- <a href="RichardKulisz.html">RichardKulisz</a> [more RK opinions follow in italics]
      </p>
      <hr/>
      <ul>
        <li>
           <em>A pointer is a lousy substitute for a hand. See </em><a href="HandVsPointer.html">HandVsPointer</a>.<em></em>
          <ul>
            <li>
               <em>Doubleclicks and modifier-clicks are lousy substitutes for voice commands and </em><a href="MouseKeys.html">MouseKeys</a>.<em></em>
            </li>
            <li>
               <em></em><a href="CutAndPaste.html">CutAndPaste</a> / <a href="DragAndDrop.html">DragAndDrop</a> are lousy substitutes for pick-up and drop.<em></em>
            </li>
          </ul>
        </li>
        <li>
           <em>An icon is a lousy substitute for a miniature of an object you can zoom into. See </em><a href="ZoomableUserInterface.html">ZoomableUserInterface</a>.<em></em>
          <ul>
            <li>
               <em>Images are lousy substitutes for text, colour and position. Everything that can possibly be conveyed by an icon's lousy image can be conveyed infinitely better by judicious use of text, colour and a consistent permanent position.</em>
            </li>
          </ul>
        </li>
        <li>
           <em>Pull down menus are lousy substitutes for context menus.</em>
          <ul>
            <li>
               <em>Freeform freefloating context menus are lousy substitutes for fixed-form (8 menu items arranged in a wheel plus center item) pinnable context </em><a href="WheelMenu.html">WheelMenu</a>s.<em></em>
            </li>
            <li>
               <em>Semantic keyboard shortcuts are lousy substitutes for positioned menu items accessible from ALT/CTRL + QWE-ZXC.</em>
            </li>
            <li>
               <em>Menu items are lousy substitutes for transparent actions (ones whose code you can inspect and modify).</em>
            </li>
            <li>
               But what tiny percentage of computer users would ever <em>do</em> that?
              <ul>
                <li>
                   Perhaps the percentage is tiny only because it's not possible to do with today's interfaces.  Consider the humble spreadsheet -- it is perhaps the ultimate user interface for a dataflow programming language.  And, yet, millions of businessfolk create new spreadsheet formulas every day.
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
           <em>Windows are lousy substitutes for autoplaced autopresented objects. See </em><a href="AutomaticVsManualPlacement.html">AutomaticVsManualPlacement</a>, <a href="AutoPresentation.html">AutoPresentation</a>.<em></em>
          <ul>
            <li>
               <em>Overlapping windows is a lousy replacement for multigeneration presentation and a zoomable interface.</em>
            </li>
            <li>
               What is multigeneration presentation?
            </li>
          </ul>
        </li>
        <li>
           <em></em>FileBrowsers are lousy substitutes for <a href="ObjectBrowser.html">ObjectBrowser</a>s.<em></em>
        </li>
      </ul>
      <hr/>
      <p>
        <em>A human-driven rarely-updated imperative CLI is a lousy substitute for a self-driven continuously updated OO GUI.</em>
      </p>
      <p>
        Many people disagree.
      </p>
      <p>
        <em>{Well, honestly, they ought to admit it's logically true.  If they need a self-driven continuously updated OO GUI, a human-driven rarely-updated imperative CLI would be a lousy substitute.  OTOH, I usually only need a human-driven rarely-updated imperative CLI.  When that's all I need, a self-driven continuously updating OO GUI could easily become a source for bloat and information overload (unless I can tightly control how much it self-updates).}</em>
      </p>
      <hr/>
      <p>
        <em>A programmable CLI is a lousy substitute for a programmable GUI.</em>
      </p>
      <p>
        Out of curiosity, can you name a programmable GUI? As opposed to a GUI that has a textual scripting language like REXX, which is really no better than the CLIs you seem so opposed to.
      </p>
      <p>
        <em>You know, it's not an either or matter. There's nothing wrong with text, just with CLIs.</em>
      </p>
      <p>
        So you can't think of any good examples that aren't just CLIs with lipstick? Quite diagnostic.
      </p>
      <p>
        <em>Hardly. I can't think of any good GUIs, period. And I really haven't studied graphical languages. I don't see what's wrong with a textual language so long as you can </em>DnD live objects into source code.<em></em>
      </p>
      <hr/>
      <p>
        <em>Dialogs are lousy substitutes for tooltips.</em>
      </p>
      <p>
        I think tooltips are annoying. (To be fair, I also think dialogs are annoying.)
      </p>
      <p>
        <em>Tooltips suck but they're useful to demonstrate that clearly superior alternatives to dialogs exist which even idiots can take advantage of. Despite this, tooltips remain vastly underused.</em>
      </p>
      <p>
        And <a href="AmigaOs.html">AmigaOs</a> is underused solely because it's superior.
      </p>
      <p>
        <em>I wouldn't be surprised about </em>AmigaOS.<em></em>
      </p>
      <hr/>
      <p>
        <em>Evolution is a lousy substitute for design.</em>
      </p>
      <p>
        Since some rather interesting programs and electronic circuits have been evolved rather than designed, this seems debatable as currently phrased. Maybe the intended point is that "accident of history is a lousy substitute for design"
      </p>
      <p>
        Design gave us Brasilia, evolution gave us San Francisco. Where would <em>you</em> rather live?
      </p>
      <p>
        <em>You don't know much about urban design. SF was clearly designed, just not in a totalitarian style. The regular, rectilinear streets of SF clearly attest to this fact, which is blatantly obvious.</em>
      </p>
      <p>
        Rectilinear streets that occasionally go up 30% inclines. <em>Great</em> design.
      </p>
      <p>
        <em>Nobody said it was great design. Rectilinear streets are horrible design since they concentrate traffic around a few focal points.</em>
      </p>
      <p>
        <em>If you're going to compare things then compare like with like, not apples and oranges. If you're going to compare a city that was designed without any concern for its users' needs like Brasilia, then compare it with one that evolved without any concern for its users needs, a medieval city like Paris before </em><a href="LeCorbusier.html">LeCorbusier</a>. And if you're going to compare the products of genetic algorithms, compare them with expert systems and artificial intelligence. When you compare like with like, design wins every time.<em></em>
      </p>
      <p>
        I'm not clear what you mean here.  Comparing genetic algorithms with expert systems is not comparing like with like.  Genetic algorithms are used to generate novel solutions to problems where the solution is not known beforehand, and generally cannot be easily or more efficiently derived through other means.  For example, GAs can be used to acceptably (though not necessarily optimally) solve scheduling and routing problems that otherwise might require an exhaustive search of the solution space.  Expert systems are used to select a predefined solution based on inputs that do not map directly to the known solution, but that can be derived from a chain of related rules.  These are very, very different!  Finally, "artificial intelligence" is a term generally used to refer to the field of study that encompasses both genetic algorithms and expert systems.  Unless you intend "artificial intelligence" to refer to some cognitive (or whatever) method that doesn't exist yet, when you write "if you're going to compare the products of genetic algorithms, compare them with expert systems and artificial intelligence," it's a little like writing "if you're going to compare the uses of airplanes, compare them with roller skates and conveyances that have wheels."  In short, your point is meaningful in a sense -- and you're possibly right that design wins out wherever design is possible, but it isn't always possible -- but not the sense you intended, at least to a reader applying the usual meaning of the terms you use.
      </p>
      <p>
        <em>You have a good point. I would rather what can be designed actually be designed so I'd create a general system with tunable parameters and then run the parameters through evolutionary trials. But from your roundabout description of GAs as solving systems where inputs map directly to outputs, it seems that's exactly what happens. Given the hype around GAs a decade ago (and neural nets too) I'd gotten the impression they were trying to do more.</em>
      </p>
      <p>
        <em>Superior knowledge and superior intelligence wins over mere guesswork every time. You can see that here; actual knowledge of urban design and the ability to control variables beats empty rhetoric and cherry-picked unrepresentative cases. The point here is that design wins over evolution because it brings knowledge and intelligence to bear on a problem, not mere guesswork and whatever convenient rhetoric (or slime in the case of biological evolution) happens to be laying at hand.</em>
      </p>
      <p>
        This presupposes that we know what the best solution really is. In <a href="UserInterface.html">UserInterface</a> design, it is painfully obvious that we do not. Thus we need to try things, discard the failures, and improve the successes. That's known as evolution. AllUisSuck.
      </p>
      <p>
        <em>Bzzzt, wrong. There is lots and lots of HCI research that hasn't been applied. And in any case, progress requires design, not mindless evolution as you seem to imply.  For "success" and "failure" to have any non-evolutionary meaning (ie, it actually works or it's actually good, as opposed to it's widespread) then you have to use a designer's mind to analyze and evaluate the outcome. A catastrophic failure may be closer to success than something that's only slightly off. Or you can learn more from catastrophic failure than a mitigated success.</em>
      </p>
      <p>
        What I like about comparisons of evolution and design is when the evolutionist completely glosses over the failure rate of evolutionarily-developed systems. How many species have failed so far? And of the tiny fraction that remain, all you can say of them is that they haven't failed <em>yet</em>.
      </p>
      <hr/>
      <p>
        More specific to what's wrong with Windows, Icons, Menus and Pointers:
      </p>
      <ul>
        <li>
           Windows: Consider the following: a television set has the "feature" that you can view multiple channels all at the same time! Every channel is displayed in a "window" somewhere on the screen. "Windows" can also be collapsed, and they can be resized, so that you can switch instantaneously between two programs and so that you can watch several movies at the same time! Does this sound: a) more or b) less convenient than a simple "next" and "previous" tuner button? I thought so. Windows induce lots of additional complexity. If the user accidentally presses the wrong spot, he is thrown into "another application". Windows have to be rearranged almost every time the user switches applications. A window hidden behind another one is almost impossible to retrieve. Desktop metaphor? If I had a desktop like that, it would <em>really</em> be time for cleaning up the mess.
        </li>
      </ul>
      <p>
        <em>However, watching television or operating a nuclear reactor are primarily monitoring activities where overlap is undesirable. Windows wrestle control away from the machine and put it in the hands of the user. See </em><a href="WindowPerTask.html">WindowPerTask</a>.<em> This is irrelevant. What's relevant is whether the users </em>want<em> that amount of control. They do not. Dealing with windows is overhead which no user wants to deal with, period.</em>
      </p>
      <ul>
        <li>
           <em>You might want to try Linux with a windowmanager like </em><a href="RatPoisonWindowManager.html">RatPoisonWindowManager</a> <em></em>
        </li>
      </ul>
      <ul>
        <li>
           Icons: In one of GulliversTravels, Gulliver visits a land where the scientists have decided that instead of using that clumsy thing called "language", which has to be learned with great pain, communication will henceforth take place by simply showing the listener the object to which one wants to refer. People end up carrying enormous bags containing all kinds of different things, and still cannot understand each other... Sometimes I get reminded to this story when I see today's "button bars". Small icons <em>often without text</em>!. So OK, we have "tooltips". What does that buy me? It was better to replace the icons with the text in the tooltips. Does anyone know one <em>single</em> icon that is "intuitive" to a complete computer newbie? Indeed, does anyone actually <em>use</em> all those buttons on the toolbar, or know what they all do?
        </li>
      </ul>
      <ul>
        <li>
           Menus: First the naming: File, Edit, Options, Preferences, Extra, ... what on earth is the difference between Options, Preferences and Extra? Why is my exit function under File? And why the order? They wanted a standard order so that we can find the right menu item quickly? OK, I will give them a standard order: alphabetically. Just list them alphabetically, <em>in a vertical list</em>. And loose the pseudo-hierarchy. We all know that Options, Preferences, Extras etc. are just meaningless names to group unrelated concepts. If we had an alphabetical list, we would at least easily find a function given its name. Now we first have to look it up in the (alphabetical) index in the "Help" menu, to find which magic menu presses will bring it to love.
        </li>
      </ul>
      <p>
        <em>Menu titles were meant to be verbs. File here is used in the sense of "to file something". The first GUIs had no submenus, and the apps had no preferences.</em>
      </p>
      <p>
        <img src="http://www.guidebookgallery.org/pics/tutorials/macplus1988/gettingdowntowork/075.png" />
      </p>
      <ul>
        <li>
           Pointer: Let's talk about the thing we call "mouse". Have you ever, ever, ever seen something remotely like it in a non-computer situation? In great contrast to the keyboard (everything has buttons nowadays!), the mouse is completely unintuitive to computer newbies. Its operation has to be learned with great pain: the thing is clumsy and big, but has to be operated with extreme precision. It's hard to hold still when you click on it; double-clicking is <em>really</em> difficult. The pointer on the screen apparently corresponds with it, but that pointer is difficult to see, especially when the mouse is not moving. Expert computer users often prefer keyboard strokes over mouse actions, but in fact so do beginning users! It is just that our modern interfaces manage to hide the correct keystrokes in such remote corners of the Help function (Printed manual? What's that?) that it is almost impossible for a non-expert to find them. Moreover, why do all keyboard shortcuts have to be Ctrl-Alt-Cokebottle? To discourage people from using the keyboard?
        </li>
      </ul>
      <p>
        To reiterate: stop designing applications following the Wimp paradigm. Burn all mouses. Go see a <em>real</em> computer newbie before you believe the mantra about WIMP interfaces being <em>user-friendly</em>. 
      </p>
      <p>
        -- <a href="StephanHouben.html">StephanHouben</a>
      </p>
      <p>
        Does it make sense to drag down middlebies in order to better serve newbies? Maybe the next generation will learn enough in grade school to avoid most of the problems you describe. My 4-year-old son has adapted pretty well to WIMP.
      </p>
      <hr/>
      <p>
        [lots of stuff moved to <a href="WimpTestimonials.html">WimpTestimonials</a>]
      </p>
      <p>
        <a href="ChristopherAlexander.html">ChristopherAlexander</a> being a household name around here, we might learn something from cities. After all, these millennial artifacts are optimized for spatial navigation, and navigation is the ostensible purpose of GUIs.
      </p>
      <p>
        Models of cities involve five basic concepts.
      </p>
      <ul>
        <li>
           Paths, channels of movement
        </li>
        <li>
           Edges, boundaries between two areas
        </li>
        <li>
           Districts, two dimensional city sections with distinctive characters
        </li>
        <li>
           Nodes, smaller areas which users mentally enter
        </li>
        <li>
           Landmarks, single objects upon which longtime users depend on
        </li>
      </ul>
      <p>
        In the <a href="WimpInterface.html">WimpInterface</a>,
      </p>
      <ul>
        <li>
           there are no paths. The closest thing to a path is the address bar which only tells you where you are, not even where you've been, never mind where you might be going.
        </li>
        <li>
           there are no edges. Edges are impossible when there are no paths.
        </li>
        <li>
           there are no districts. All directories look precisely alike.
        </li>
        <li>
           nodes are directories. Though nodes without paths between them are surreal.
        </li>
        <li>
           there are no landmarks. Nothing can be seen from afar and no user relies on icons or directories as landmarks.
        </li>
      </ul>
      <p>
        Strip out the text from the <a href="WimpInterface.html">WimpInterface</a> and even the most familiar user will be completely lost. The graphical elements contribute exactly <em>nothing</em> to navigation.
      </p>
      <p>
        <em>Computer interfaces are for task navigation, not for spatial navigation. The vast majority of tasks that people use computers for are not spatial in nature, and a heavy-handed application of the old metaphor onto the new often leads to kludgey things that nobody wants. 3-dimensional desktop, anyone? -- francis</em>
      </p>
      <p>
        I want a 3D desktop. I just don't want to use one with a 2D pointing device.
      </p>
      <p>
        Navigation is spatial by definition. I wonder what it is you think users navigate <strong>in</strong> when you talk about "task navigation". Some abstract mindspace?
      </p>
      <p>
        The vast majority of tasks I perform on my computer have to do with communication, information storage, organization and retrieval. All of those tasks would benefit from an orientational metaphor. Organization might be so much easier that I'd actually get around to doing it, instead of having tons of miscellaneous files cluttered every which way.
      </p>
      <hr/>
      <p>
        Well, most people seem to prefer them for whatever reason. I don't know why, that is just the way it is. 
      </p>
      <p>
        <em>Most users have no choice whatsoever, so who is it that you're referring to by "most people"?</em>
      </p>
      <p>
        I noticed that people tended to prefer WIMP over DOS applications and VT-100 around the time Win3.1 came out. While it was not unanimous, there seemed to be a majority in my observation. Maybe the little pictures (icons) were more stimulating or something. I don't really know.
      </p>
      <p>
        <em>Choosing between a broken GUI and a thirty year old CLI. This isn't exactly giving people a </em>choice<em>.</em>
      </p>
      <p>
        True, it is not an ideal test lab, but they voted based on their existing experience.
      </p>
      <p>
        [People still have a choice. Show them a GUI that's as much of an improvement over what they have now as the Mac was over dumb terminals and they'll switch.]
      </p>
      <p>
        Only if that GUI can be run on a standard Unix machine with standard hardware (one and only one keyboard and 2D pointer). But of course, it can't. Let's look at some of the requirements for a good GUI:
      </p>
      <ul>
        <li>
           multiple parent links
        </li>
        <li>
           all links paired so they're bidirectional
        </li>
        <li>
           arbitrary names for objects, including multiple identical names and no names
        </li>
        <li>
           topology determines ownership (<a href="CapabilitySecurityModel.html">CapabilitySecurityModel</a>)
        </li>
        <li>
           use rate information (different from last access timestamp)
        </li>
        <li>
           all parts of the system accessible, connected in a uniform manner
        </li>
      </ul>
      <p>
        And let's not forget that 3D means 5 degrees of freedom. Can you control 5 independent degrees of freedom with a single 2D mouse pointer in a natural, intuitive, manner? No you cannot.
      </p>
      <dl>
        <dt> </dt>
        <dd><em>No, it's </em>'six<em>' degrees of freedom: yaw, pitch, roll, X, Y, Z. And the segments of the industry that work in full-fledged 3D, such as modellers for computer generated imagery in movies, use hardware and software controls significantly different than those available in e.g. Windows or KDE. I.e. it's not like this is a new discovery; people have evolved solutions for it many times before.</em></dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd>It's 5 degrees of freedom since the third rotation can always be obtained by a combination of the other two. And you only want 5 anyways since roll is confusing and unnecessary. And thank you for pointing out just how wrong francis is above, 3D desktops are nothing new, you just can't rely on a Windows or Unix freak to implement one properly (or usefully).</dd>
      </dl>
      <p>
        So the most "choice" of GUI that people have without incurring the extreme hassle of switching to an incompatible OS, is of a shitty 2D projection of a good GUI.
      </p>
      <p>
        There was a project on <a href="SourceForge.html">SourceForge</a> called 3Dsia that tried to implement a good GUI based on standard Unix hardware. It took me very little time to realize that was a hopeless endeavour. The Unix architecture is broken and having to deal with that architecture created intractable problems. That project is now dead.
      </p>
      <p>
        [I don't consider any of those requirements for a good GUI. Where are you getting them? Why 3D? And what good is any GUI if no one can run it?]
      </p>
      <p>
        Unlike most people, I am prepared to switch to a different OS.
      </p>
      <p>
        Why 3D?
      </p>
      <p>
        First, because it provides more space to play with, so there's less clutter.
      </p>
      <p>
        Second, because it provides elegant symmetries, like the sphere.
      </p>
      <p>
        Third, because it's necessary to model some of the relationships in the system. You can't model a graph in 2D without edges intersecting, causing confusion about what's a node.
      </p>
      <p>
        Fourth, because even Wimp is 3D, it has overlapping windows.
      </p>
      <ul>
        <li>
           Tiled (rather than overlapping) windowing systems have been around forever, in many guises, and you can use them even today under e.g. X11. Some people prefer them. They were not a breakthrough compared with overlapping windows.
        </li>
      </ul>
      <p>
        And how would you know what are and are not requirements for a good GUI? Are you building one? Are you designing one? Are you investigating the subject? Are you or have you ever even contemplated doing any of these?
      </p>
      <p>
        Hell, to the requirements above I could add several dozen others, including such things as <a href="OrthogonalPersistence.html">OrthogonalPersistence</a> and <a href="LoggingFileSystem.html">LoggingFileSystem</a>. Because users need to be able to see into the past and revert to it at any time they wish. Also because LFS is the simplest way to implement orthogonal persistence. And the need for OP? Well, it should be obvious that no decent GUI forces the user to deal with irrelevant trivialities like the difference between RAM and hard disk.
      </p>
      <hr/>
      <p>
        I think anyone that uses a multitasking OS long enough comes to desire some sort of window based interface. Some way to switch visual contexts, at the very least. When the Mac came out I was disappointed that it didn't really multitask, but I dug the GUI. From then on most multitasking OS GUIs looked something like the Mac. They were WIMPs. Windows 3.1 was the first Windows where multitasking sort of almost worked. It was the best I could do at home after Commodore dropped the Amiga. Windows 3.1 was the first Microsoft OS I ever bought. I also bought my first Intel CPU just to run it. It had a Mac clone GUI and I still dig it. It's much better than what I had before. If something that much better comes along I'll use it. -- <a href="EricHodges.html">EricHodges</a>
      </p>
      <p>
        <a href="ScreenMultiplexor.html">ScreenMultiplexor</a>. There are several graphical variants.
      </p>
      <hr/>
      <p>
        I have started to make up CajjuxdySystem (<a href="http://zzo38computer.cjb.net/cajjuxdy.htm),">http://zzo38computer.cjb.net/cajjuxdy.htm),</a> which is a new kind of computer; there is no mouse, only screen-pen for drawing and selecting points on the screen, and keyboard for everything else. And this new kind of computer solves all problems of old kind, including viruses. If it is too hard (like UNIX), of course somebody could make a program that does something like this:
      </p>
      <code>
        Press the number of what you want to work on -<br/>
        (1) Email<br/>
        (2) Typing (word-processor)<br/>
        (3) Game<br/>
        (4) CD-ROM<br/>
      </code>
      <p>
        and to make it so people will not be confused, you make it so that either pressing the number on the keyboard, or putting the screen-pen on the number on the screen, will work.
      </p>
      <p>
        <em>Well, no. This was state of the art in 1962, when </em><a href="IvanSutherland.html">IvanSutherland</a> created the amazing <a href="SketchPad.html">SketchPad</a> system. But light pens had severe usability problems, which is precisely why <a href="DougEngelbart.html">DougEngelbart</a> was even then working on an improved design, released in 1968 as the mouse, which is what you are seeking to replace.<em></em>
      </p>
      <p>
        <em>It is useful to study history in order to avoid reinventing it, thinking that it is new, not noticing that the older history had its own problems, often worse than the ones you are trying to fix.</em>
      </p>
      <p>
        What if the real problem is that the screen is vertical instead of horizontal? The ideal interface may be a drafter-like table, but the table is the screen. Then a pen-like thingy may be less tedious. This wasn't possible with 1960's technology because the CRT bulk would bump into your legs. But now we can try it.
      </p>
      <p>
        <em>That was in fact part of the problem; it is very tiring to hold your arm up unsupported in mid-air all the time. So tablet PCs with stylus may yet prove to work better - but note that they have had mixed reviews since they were seriously introduced a dozen years ago, and then reintroduced just recently. We'll see - but I haven't heard anyone claim that they've been demonstrated to be far better, as yet.</em>
      </p>
      <p>
        <em>Santayana's point about history remains.</em>
      </p>
      <p>
        Well, no this plan is use the keyboard mostly, the pen is hardly used unless you are drawing. I guess you can make the screen flip up and down, so if you are doing a lot of drawing you can put the screen down on the table; if you are doing typing, you can lift up the screen. Then you can use it both ways. Another idea would be if you don't want to use a pen, you can control by keyboard by pressing a key-combination (such as: SubSystem+Numpad/ to toggle mode, then use arrows on the numpad. ',' and '.' can be to enter X and Y numbers).
      </p>
      <hr/>
      <p>
        <strong>Alternatives</strong>
      </p>
      <p>
        To know if something is broken, one generally has to compare it to something that is fixed. The only viable alternative mentioned is the "guided menu system" above. I used to program them extensively back in the DOS and VAX days. A slight variation is that those system often used the teletype "scroll" model, so the above menu would resemble:
      </p>
      <code>
        ----Menu----<br/>
      </code>
      <ol>
        <li>
           Email
        </li>
        <li>
           Typing (word processing)
        </li>
        <li>
           Game
        </li>
        <li>
           Play CD-Rom
        </li>
      </ol>
      <code>
        Enter choice: __<br/>
      </code>
      <p>
        The cursor would be at the bottom. 
      </p>
      <p>
        The GUI equivalent is the "wizard". So it is not a matter of GUI versus CUI, but whether the options are modal or not. I generally agree that model is often better for newbies. However, it is not very productive for those with more experience. The CUI version of non-modal would be commands that jump to other options. Example:
      </p>
      <code>
        ....<br/>
      </code>
      <ol>
        <li>
           Game
        </li>
        <li>
           Play CD-Rom
        </li>
      </ol>
      <code>
        Enter choice: spreadsheet<br/>
      </code>
      <p>
        In this approach, the user can type in something not on the immediate menu ("spreadsheet" in this case) and go there. The drawback is that that it requires more typing. GUI systems allow one to stick more options in the same screen real estate. While this may reduce typing, it can also create chaos.
      </p>
      <p>
        I personally found that a well-designed CUI made me more productive than a GUI. But the problem is that they were often not well-designed, at least not for me. This brings up another issue. I fall into the <a href="EverythingIsRelative.html">EverythingIsRelative</a> camp. If all the options were put into a data structure or database, then one could better tune it to his/her own needs. It is another case of <a href="SeparateMeaningFromPresentation.html">SeparateMeaningFromPresentation</a>. If the options were coded into a standard, then the presentation system can be swapped with different applications. One could use the presentation system that they are most comfortable with even with applications that have not come out yet (as long as they use the same meta standard). This may also be useful for the handicapped.
      </p>
      <p>
        Applications would come with a database (or XML) of all their options. The "browser" for all these options would be built independently of the application (although could be included as a default).
      </p>
      <p>
        For a simplified example, think of keyboard mappings. Every application has its own proprietary keyboard mapping system. If a standard could arise, then one could use the same keyboard mapper on different applications rather than each app reinvent its own. It is basic <a href="InterfaceFactoring.html">InterfaceFactoring</a>.
      </p>
      <hr/>
      <p>
        <strong>Broken and useful</strong>
      </p>
      <p>
        While one might argue about the brokenness of something, it can also be pointed out that most things are broken in one way or another. A real test then is not whether or not it is broken, but rather: Is it <strong>UsefulUsableAndUsed</strong>. When it passes this test of utility, argument about its brokenness can be pointed to the cold, hard reality, that people (millions and millions) have and do use this "broken" thing because <strong></strong><a href="ItWorks.html">ItWorks</a><strong>. When a product is developed so that it provides utility and functionality, it passes a test based on usability. It may fail the test of theorists and concept purists, and lack beautiful and pure structural component integration, and produce many "failing tests" when rigorously tested and subjected to all possible configurations and possible scenarios, but succeed in getting the job done that a user requires, producing a proper and accurate result as a result of proper and accurate inputs and requests. Those who use this "broken" concept do not argue about how correct its internals and its concepts are, they just want something they can use to help them get their job done speedily and correctly. </strong>
      </p>
      <p>
        Those who are concerned with its brokenness and desire to produce something more pure or correct are totally free to do so. But they must remember that for people to "buy into it", it must pass the test of being <strong>UsefulUseableAndUsed</strong> and do so in a manner that its users can say "<a href="ItWorks.html">ItWorks</a>". -- <a href="DonaldNoyes.html">DonaldNoyes</a>
      </p>
      <p>
        I don't really get your point. It's obvious that WIMP works well enough to be in daily use by a couple of billion people these days. However it also has well known flaws, which most people never even think about. A small number of people say "hey, we're all too complacent, come on, let's think of something better!" And your reply is, it's good enough, shut up until when and if you come up with something better? I don't see the logic in that. -- <a href="DougMerritt.html">DougMerritt</a>
      </p>
      <p>
        Personally, my problem is less with people who're addressing or just talking about problems with current interfaces, as it is with people who like to post long, invective filled rants like the ones on this page, without presenting alternatives. Saying "Burn all mouses" without providing an alternative means you're ranting uselessly, not that you're advocating useful discussion on interface design.
      </p>
      <p>
        Interface design is hard, it's highly subjective, and it's a lot more complicated than "CLI good, GUI bad", or even vice versa. Much of the information here is incomplete or wrong - for example, the reason why televisions don't have multiple windows is because people don't multitask with them (except when they do, with picture-in-picture). Icons are used instead of text to conserve space, not because they're necessarily more readable. Menus aren't sorted alphabetically because consistent locations enable the use of spatial memory. That's why menu items are enabled and disabled instead of being dynamically created. One valid point is raised, which is the awkward and confusing naming of menu options, but it's not addressed - probably because it can't be, awkward and confusing naming can and will plague any interface you come up with. There's a disjoin between "power users" and keyboard shortcuts as well. Many power users don't use keyboard shortcuts - in fact, they use the the toolbar. There's a really good reason for this - keyboard shortcuts are optimal for people who can type. You don't need to move your hand off they keyboard to hit one. People who can't type aren't bothered by this and prefer to use the mouse. There are a lot of claims made about what users want or don't want, much of which is both unsupported and contradicts conventional wisdom, which is a good reason to simply discard it - my 4 year old understands the mouse just fine, but since he can't reliably read yet the keyboard makes little sense to him. How much more of a "beginner" user can you be? -- ChrisMellon
      </p>
      <p>
        Good points. But right there at the end, note that basic use of a mouse is one thing; that's just a spatial interface, and we're hardwired to interact spatially with the world. That's not the same thing as the whole WIMP kit and kaboodle. In particular I doubt that he's expert at left versus right click, nor single versus double click (and if he's using a Mac, there are similar issues). As for "beginner", that's part of the point: a common complaint is that too much WIMP design effort is aimed at beginners, yet being a beginner is inherently a temporary state - what about designing for power users? -- <a href="DougMerritt.html">DougMerritt</a>
      </p>
      <p>
        I think, the point of <a href="DonaldNoyes.html">DonaldNoyes</a> is less, to shut up if it is good enough. It is, that if <a href="ItWorks.html">ItWorks</a>, its not enough to say, that is is broken (that's <a href="ShiftingTheBurdenOfProof.html">ShiftingTheBurdenOfProof</a>), even if it is. And its not even enough to point out a better alternative. One <em>also</em> has to provide a way from here to there. That's because Wimp <em>is</em> a local maximum and even if there is some better or even global maximum, people will be resistive to going there, <strong>if there is no smooth transition</strong>. -- <a href="GunnarZarncke.html">GunnarZarncke</a>
      </p>
      <p>
        Assuming that's the point, then I disagree. Those points would apply to a business discussion ("shall we put our money into something Wimp-based, or into something no one has invented yet?").
      </p>
      <p>
        They are irrelevant to purely technical discussions, where frequently one starts with a problem, or even just a hint of a problem, or a desire to improve things, and it frequently takes a long time to arrive at a solution that one can prove is in fact better. If one says "it's not enough to point out something is broken", then one shatters that process right at the start, leaving no possible way to move forward.
      </p>
      <p>
        Some people are interested in processes that will eventually yield something new, others are only interested in final proven results, and that's fine - but the latter should merely <strong>ignore</strong> discussions concerning the former, since they're not interested, <strong>not</strong> critique that process in which they are not interested. -- <a href="DougMerritt.html">DougMerritt</a>
      </p>
      <hr/>
      <p>
        <strong><em>What is the starting point and focus for a design meeting the needs of a "power user"? Can we identify what components, methods or presentation formats would best suit such a user?</em></strong>
      </p>
      <p>
        <strong>First identify users, capabilities and expectations</strong>
      </p>
      <ul>
        <li>
           Novice Users
          <ul>
            <li>
               <em>He doesn't get single vrs right click, although I think that's mostly because he doesn't get menus because they're textual. He does get double click, and he does get that different types of clicks have different actions in context - he knows to double click the dinosaur on the desktop to start his dinosaur game, he knows to single-click navigate his way around the game, and he knows how to click and drag to interact with the game. The physical coordination to reliably doubleclick took him a while.</em>
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <ul>
        <li>
           Transitional Users
          <ul>
            <li>
               <em>The rant above specifically speaks to beginning users, so that's what I was addressing. It's not even that simple, though: my grandmother spent 20 years as a typist in a secretarial pool, and she uses the mouse with both hands like a </em><a href="OuijaBoard.html">OuijaBoard</a> (it's a hoot to watch). It's quite possible that CLI would be better for her.<em></em>
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <ul>
        <li>
           Disciplined or Conditioned Users
          <ul>
            <li>
               <em>There's an old saw about the only intuitive interface being the nipple, and it really does apply. The easiest interface to learn is the one you already know. This makes any sort of unbiased usability information really, really hard to get. And just as there's no single type of beginner, there's no single type of power user either - compare the working habits of experienced 3d modellers vrs long term UNIX programmers, for example. -- </em>ChrisMellon<em></em>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           A friend of mine has just had her first child, and she had to hold the baby <em>just so</em> and move it to the breast <em>just so</em> before the child would suckle. The mid-wife has said this is common, and that contrary to popular belief, the nipple is not intuitive in the way most people think.
        </li>
      </ul>
      <hr/>
      <p>
        Power users expect:
      </p>
      <p>
        Tradeoff Between SimplicityAndPower
      </p>
      <ul>
        <li>
           <em>casual users and power users, expect to face some difficult trade-offs in simplicity vs. power</em>
          <ul>
            <li>
               <a href="http://istrategyconsulting.com/">http://istrategyconsulting.com/</a> documents/BIToolsWhitepaper.pdf
            </li>
          </ul>
        </li>
      </ul>
      <p>
        FunctionalityAndPower
      </p>
      <ul>
        <li>
           <em>software looks to be even easier to use for new users, while offering all the power and functionality that existing users and power users expect</em>
          <ul>
            <li>
               <a href="http://webdesign.about.com/cs/elearning/a/aa_authorware7.htm">http://webdesign.about.com/cs/elearning/a/aa_authorware7.htm</a>
            </li>
          </ul>
        </li>
      </ul>
      <p>
        FamiliarityAndSimilarity
      </p>
      <ul>
        <li>
           Make it do things as easily as VI and EMACS, involve a keyboard in a a <a href="CommandLineInterface.html">CommandLineInterface</a>
        </li>
      </ul>
      <p>
        AdvancedFeatures
      </p>
      <ul>
        <li>
           <em>It delivers all the advanced features power users expect but it?s so easy, even novices are proud of their results. And, cost-effective ...</em>
          <ul>
            <li>
               <a href="http://ntius.com/default.asp?p=news/xnews091603CDDVDM65">http://ntius.com/default.asp?p=news/xnews091603CDDVDM65</a> 
            </li>
          </ul>
        </li>
      </ul>
      <p>
        Aggregation
      </p>
      <ul>
        <li>
           <em>users of the Internet do not browse, they aggregate. High-quality information mandates routine aggregation. Power users expect aggregation </em>
          <ul>
            <li>
               <a href="http://ict.tippinst.ie/~bgoldbach/ws/metanotes/ws131_lecture07.rtf">http://ict.tippinst.ie/~bgoldbach/ws/metanotes/ws131_lecture07.rtf</a> 
            </li>
          </ul>
        </li>
      </ul>
      <p>
        FastResponse
      </p>
      <ul>
        <li>
           <em>Response time: with increasing computing power users expect a quick response to their requirements (</em>RedLightSyndrome). The quicker the response time<em></em>
          <ul>
            <li>
               <a href="http://www.cse.csiro.au/research/aglands/nswrangelands/processes/LUPIS.htm">http://www.cse.csiro.au/research/aglands/nswrangelands/processes/LUPIS.htm</a>
            </li>
          </ul>
        </li>
      </ul>
      <p>
        Interoperability
      </p>
      <ul>
        <li>
           <em>a </em>CrossPlatformTool, QualityDevelopmentApplications will make it possible for all of us computer users to work together.<em></em>
        </li>
      </ul>
      <p>
        **
        DockableControls
      </p>
      <ul>
        <li>
           <em>cool features and most </em>PowerUsers expect a good application to have DockableToolbars<em></em>
          <ul>
            <li>
               <a href="http://cesis.lv/learn/delphi/ch13.htm">http://cesis.lv/learn/delphi/ch13.htm</a>
            </li>
          </ul>
        </li>
      </ul>
      <p>
        CommandComposabilityAndOtherConveniences
      </p>
      <ul>
        <li>
           <em>programmability. all manner of shortcuts. </em>InfiniteConfigurability. autocommands. multiple buffers/registers. folding, CommandComposition<em></em>
          <ul>
            <li>
               <a href="http://gnomedesktop.org/comment/reply/1009/8497">http://gnomedesktop.org/comment/reply/1009/8497</a>
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <p>
        Much of the discussion on this page isn't about WIMP (three GUI widgets and one input device), but about higher-level mechanisms which are (somewhat) orthogonal to WIMP - things like context-sensitive menus, tooltips, what button does what, and other controls/topics that are germane to most if not all modern windowing environments (and thus assumed to be part and parcel of wimp).
      </p>
      <p>
        But what <strong>are</strong> the alternatives to wimp? The <a href="CommandLineInterface.html">CommandLineInterface</a> is one - many programmers like this because the same mechanisms they use to program (the keyboard) are used for other things, allowing a high degree of composability of the interface. A good CLI is a powerful tool indeed in the hands of the experts. But WIMP has largely subsumed the CLI - with the latter <em>augmenting</em> the mouse inside a terminal window, rather than replacing windows and mice and such.
      </p>
      <p>
        Beyond that? Not much. Windowing solves nicely the problem of multiplexing the diverse output of numerous systems into a fixed-resolution viewport (your monitor). Most of the alternatives to windowing (3-d environments, paged/tabbed displays, etc) are just solutions to the same problem - variations on the theme. Yet nothing has shown up to replace the graphical monitor as the primary means of interactive communication from the computer to the human. Printers and paper terminals aren't interactive; sound devices have much lower bandwidth than does the screen, and the other three senses have even lower bandwidth than our ears do. (Plus, effective transducers for taste and smell don't even exist).
      </p>
      <p>
        Going the other way, what do we have? Keyboards. Pointing devices (mice, trackballs, joysticks, etc.). Writing recognition. Speech recognition. The first two are the primary means employed by CLIs and GUIs respectively. The third seems to be limited to PDAs and signature-capture devices (in the latter case, the signature itself is the signal, rather than the channel). The fourth still has lots of problems.
      </p>
      <p>
        Granted, there are lots of things that can be improved about modern user interfaces; however it's important to distinguish the physical devices from the mechanisms and protocols that ride on top of them.
      </p>
      <hr/>
      <p>
        As of November 7, 2007 we now have <a href="PowerShell.html">PowerShell</a>, which is bound to change how people look at this topic.  
      </p>
      <hr/>
      <p>
        Wimp is Broken? Not Mine. And it just keeps on being more and more useful, useable, and used, not only be me, but also by hundreds of millions of <a href="PersonalComputer.html">PersonalComputer</a> users. If something comes along that is  more useful, I'll be one of the first to find out how it can make my computing experience better. -- <a href="DonaldNoyes.html">DonaldNoyes</a>
      </p>
      <hr/>
      <p>
        Apple understands the importance of location.  Microsoft, not so much.  Customizable menus in Office were an abomination mainly for that reason.  So is losing your icon layout when you change screen resolution, I mean that's truly retarded.  Mac folders remember their layout and icon positions, which you can sort of get Windows to do, but not reliably -- which is the other big Apple design skill: if you're going to put in a feature, make it consistent and reliable.  Practice it in secret for a year like RickyJay until you can pull it off invisibly.
      </p>
      <hr/>
      <p>
        Interacting with any modern WIMP system is like having a conversation with an amnesiac schizophrenic, or trying to get results from an oversized bureaucratic department.  See <a href="GuiAsConversation.html">GuiAsConversation</a>.
      </p>
      <hr/>
      <p>
        <yawn> Somebody resuscitated this old beater? Why? This discussion is as dead as text-based menus.
      </p>
      <ol>
        <li>
           - What's This?
        </li>
      </ol>
      <code>
        <img src="http://donaldr.noyes.com/c2/WhatsThis.jpg" /><br/>
      </code>
      <p>
        "THIS" is a disaster.
      </p>
      <p>
        Could this be Wimp?  Except the pointer is touch the screen (you can still use the mouse however)
      </p>
      <p>
        <strong>No</strong>, this is <strong>not</strong> WIMP. This is crap. Specifically, Metro crap from some gang of ditherheads who think a desktop is the same as a smartphone. Can you imagine grabbing your 700mm desktop monitor and using your thumbs to press "buttons" near the sides? Duh, der, dim. Microsoft "engineers" are "learning" from crApple. Dork.
      </p>
      <p>
        No, but I will use a handheld control (remote) which will wirelessly perform all the necessary operations upon and within it whether near it or a thousand miles away. The appearance of that control will utilize fingers and thumbs upon icons and images on phone-like or pad-like devices without buttons switches or mechanical controls. They will use Windows, Icons or Tiles, moving and pointing control actions on menus serving as navigators and actuators.
      </p>
      <p>
        Well, yeah. Just as I will use the icons on the "desktop" of my Galaxy S III (the phone that Apple wishes they had made) to do all kindsa stuff that I'd rather not type or menu to. But these are dedicated applications to do specific tasks on a limited device. The desktop computer is not a limited device aimed at specific tasks. By its very nature it is a broad spectrum solution looking for a problem to solve. The WIMP interface is suited to this nature. Metro is not.
      </p>
      <hr/>
      <p>
        To be fair, a lot of desktop environments have been going toward a similar design and Windows 8 simply has the 'Metro' or 'Modern' UI spin.  Gnome/Unity has the new 'wall of icons' navigation style option, OSx has an ipad-as-a-desktop navigation style option, and now Windows.  OS and UI have to evolve.  Microsoft plays in both the desktop and mobile space and clearly wants to merge the two (see Surface tablet sold as essentially a laptop and Win 8 written for x86 and ARM with Mobile and Desktop same source).  You are operating a windows machine with a 'windows user' mental model of 'oh i need all these advanced features' but what happens to the newer generation who grow up with iPads.  MS must stay relevant.  <strong>-gv</strong>
      </p>
      <p>
        True, but if to stay "relevant" you mean to appeal to the masses who have the "ipad" generation "mental model", are you then saying the part of the masses who make the "buttons" and "tiles" work are <strong>not</strong> relevant? I am interested in what development processes are available which you can use to make old "operational" processes work without requiring a total change of how they work. Is there a SDK available which runs directly using the "Surface" tablet that makes this possible? 
      </p>
      <p>
        <em>Huh?</em>
      </p>
      <p>
        <em>The "Metro style" Start panel is a non-hierarchical menu, with live update of the large icons aka tiles.  It's the same old Start menu, dumbed down for the </em><a href="FondleSlab.html">FondleSlab</a> generation.  In some ways, it harks back to the box-of-icons style of Windows 3.x.  The apps themselves are the same old WIMP interface, with flat-shaded decoration and touch capability.  There's nothing to see here, folks.  Move along.<em> </em>
      </p>
      <p>
        ok  
      </p>
      <hr/>
      <p>
        See: <a href="MetroStyleStartPanel.html">MetroStyleStartPanel</a>, <a href="MiniatureFootprintComputing.html">MiniatureFootprintComputing</a>, <a href="TwoClicks.html">TwoClicks</a>
      </p>
      <p>
        <a href="CategoryComparisons.html">CategoryComparisons</a>, <a href="CategoryInteractionDesign.html">CategoryInteractionDesign</a>, <a href="CategoryUserInterface.html">CategoryUserInterface</a>, <a href="CategoryRant.html">CategoryRant</a>
      </p>
    </div>
  </body>
</html>