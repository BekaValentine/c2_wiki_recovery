<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Forth Portability
      </h1>
      <p>
        Forth has several advantages that make it more portable than some of the alternatives.
      </p>
      <ul>
        <li>
           Forth makes it very easy to abstract away the differences between architectures. You can define a word on two platforms that behaves the same way on either platform, even though the definitions of the word on the different platforms may be quite different. Define a small vocabulary of such words, and you have the foundation for all the portable code you want.
        </li>
      </ul>
      <ul>
        <li>
           It used to be that whenever a new processor came out, Forth was one of the first languages to be implemented on it. Forth is small, and simple to implement, and can itself be used to hide the differences between machines.
        </li>
      </ul>
      <ul>
        <li>
           Forth, being close to the machine like C, is subject to some of the same portability concerns as C, such as the "size of an int" problem. If it has to communicate with system libraries then it also becomes dependent on those libraries, just like C.
        </li>
      </ul>
      <ul>
        <li>
           Forth doesn't lie to you about your machine's architecture as much as some other languages; instead of making your platform look the same as every other platform (while doing a lot of work behind the scenes to create that illusion), it lets you see what you are <em>really</em> dealing with, so you can make intelligent trade-off decisions and wring the maximum performance out of your hardware.
        </li>
      </ul>
      <p>
        Of course, Forth is usually used in environments where the only viable alternative is <a href="AssemblyLanguage.html">AssemblyLanguage</a> -- environments where there isn't room for a C runtime library, where there <em>certainly</em> isn't room for the complete Java class library, and where there isn't time for BASIC interpretation. Forth is a good deal more portable than assembly language in such places.
      </p>
      <ul>
        <li>
           <em>It should be noted that freestanding C implementations are possible (and compliant with the C standard); such implementations need not have a copy of the C runtime library (or can only include those functions that are needed for the application). C can be made quite small if you need to. The place where C implementations run into some difficulty is on architectures with bizarre memory models or very small register sizes - C on an Intel 8051, for example, is a major pain.</em>
        </li>
      </ul>
      <p>
        Various standardization efforts (1977, 1979, 1983, <a href="AnsForth.html">AnsForth</a> in 1994 and possibly amended in 2005) have resulted in mostly compatible definitions.
      </p>
      <hr/>
      <hr/>
      <p>
        <strong>Discussion</strong>
      </p>
      <p>
        If you follow <a href="ChuckMoore.html">ChuckMoore</a> <em>philosophy</em> you don't <strong>port</strong> but you <strong>rewrite</strong> for the real target at hand. <a href="ForthReusability.html">ForthReusability</a> is probably an oxymoron, except within a single project where the <em> </em>'factorize<strong>, then </strong>factorize<strong> and re-</strong>factorize<em>' again</em> mantra leads to highly hierarchical code which some point out as a <a href="GoodThing.html">GoodThing</a>.
      </p>
      <p>
        To be fair, Forth is probably the sole computer language which has more homegrown freestanding complete implementations (including the compiler) than actually useful applications. As a corollary, the Forth <em>meme</em> seems to live well, and spreads quite well into intellectual, esoteric versed enquiring minds, looking for the Tao of Mankind.
      </p>
      <p>
        <em>Forth standards are bloated. Forth is not bloated. Forth users smack their heads in frustration. Forth users buck standards. Forth standards aren't used.</em>
      </p>
      <hr/>
      <p>
        You start saying: <em>Forth has several advantages that make it more portable than some of the alternatives.</em> and at the end, the only thing you finally claim is <em>Forth is a good deal more portable than assembly language in such places.</em> If assembly is the only kind of language less portable than Forth, then Forth is not what I call a portable language.
      </p>
      <p>
        Even the arguments you use are flawed. The first one is true for <em>any</em> language (just replace word with procedure or function). The second just says that the language is simple to implement, which is about the language implementation, and has nothing to do with portability of programs written in Forth (which requires that all these implementations are compatible between them). Finally, the last two are clearly saying that it is not portable. Calling portability 'lying about the machine's architecture' doesn't change anything. You can argue that portability is not always a good thing to look for when one needs performance above all, and I would agree with you, but it doesn't change the point of this page.'
      </p>
      <hr/>
      <p>
        From what I've seen, this page has no point. <strong>Portability is a myth.</strong> Look at most any non-trivial C program and count the #ifdefs in it. Anybody who believes they're writing "portable" C code is living in a dream. When 16-bit machines were all the rage, everyone thought C was portable until 32-bit machines hit the market. I won't even begin to go into what it was like on the PC platform, even between vendors of "standard C." Anyway, each C #ifdef that you find is equivalent to one word that would be factored out in a Forth program; one word which can very easily be changed to suit the new target environment/hardware.
      </p>
      <p>
        Portability simply doesn't exist. It's best to accept that. When you do, you'll suddenly start to find yourself writing more portable software. Funny how that works.
      </p>
      <hr/>
      <p>
        Instead of saying <em>portability simply doesn't exist</em> it is more accurate to say that <em>portability doesn't simply exist</em>. In other words, one can (and many do) write Forth code which runs unmodified on several different kinds of machines. A program I wrote a while ago on the Palm using <a href="QuartusForth.html">QuartusForth</a>, worked perfectly on my desktop machine running Linux and on a Windows based laptop running yet another variant of Forth. It's not impossible or even particularly difficult, but it does require a little bit of thought. Then again, so does every other worthwhile creative activity...
      </p>
      <hr/>
      <p>
        Forth portability isn't about interchangeable parts. It's about being able to move an application from one platform to another (<a href="PlatformPortability.html">PlatformPortability</a>). I moved an entire Forth environment from one platform to another (preserving the applications) by addressing only the lowest level of code.
      </p>
      <p>
        Like saying that fiberglass isn't a generally useful construction material because you can't buy pre-measured pieces and bolt or nail them together. Shocking. Can't even been welded. Disgraceful. I mean, hell, when have you ever seen a fiberglass yard? Ha ha ha. Clearly, fiberglass is dead. Who ever heard of a fiberglass tycoon? Like, hey, go to HomeDepot and try to buy a fiberglass-working tool set.
      </p>
      <p>
        Yup. But I can make you just about anything you want from fiberglass. No, silly, you wouldn't make a balsa wood screwdriver either. You can shape things in fiberglass that exactly fit the application. No, I didn't say "perfect" and I'm not going to follow you there. This is an analogy.
      </p>
      <p>
        Forth can model things in ways that give other languages a headache. What do I use at work? C, mostly. Some assembly language. Some SQL. A little xBase now and then, when the boss isn't looking. Forth is something I do as time allows. It keeps my mind from calcifying.
      </p>
      <p>
        Portability isn't free. You don't get it from the language alone. Portability is deliberate. It's by design. It's something you do, not something you have. If you "know" it's never gonna run on any other platform, you can kiss off portability and go for performance. If you hope to move it, you'd better build that into what you write.
      </p>
      <p>
        Forth makes that possible in a way that few other languages can.
      </p>
      <hr/>
      <p>
        Contributors: <a href="GarryHamilton.html">GarryHamilton</a> ... and whoever started this page ... and those other guys ...
      </p>
      <hr/>
      <p>
        <a href="WritingPortableApplications.html">WritingPortableApplications</a>, <a href="ForthLanguage.html">ForthLanguage</a>, <a href="ForthReadability.html">ForthReadability</a>, <a href="ForthIsDead.html">ForthIsDead</a>, <a href="ForthReusability.html">ForthReusability</a>, <a href="ForthPessimism.html">ForthPessimism</a>
      </p>
    </div>
  </body>
</html>