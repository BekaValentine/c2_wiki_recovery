<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Clean Room
      </h1>
      <p>
        <a href="CleanroomSoftwareEngineering.html">CleanroomSoftwareEngineering</a>:  IBM developed technology for writing bug-free software.
      </p>
      <p>
        The methodology (as I understand it) relies on extensive reviewing and checking of code. To the extent that code will compile correctly, and is only compiled at the end of the development process. It's then extensively tested, using some formal coverage techniques.
      </p>
      <p>
        The space shuttle flight software was created using a variant: contains ~500Klocs and has had something of the order of 17 bugs reported. It's also amongst the most expensive software mankind's ever written... the team has an annual budget of $35 million. I suspect, but don't know, that <a href="CleanRoom.html">CleanRoom</a> is an offshoot of having developed the shuttle software.
      </p>
      <p>
        Any other examples?
      </p>
      <p>
        -- <a href="KatieLucas.html">KatieLucas</a>
      </p>
      <hr/>
      <p>
        As I understand it, <a href="CleanRoom.html">CleanRoom</a> is effectively the AntiProcess of techniques like <a href="ExtremeProgramming.html">ExtremeProgramming</a> as it relies on <a href="BigDesignUpFront.html">BigDesignUpFront</a> backed up by <a href="FormalMethods.html">FormalMethods</a> for verifying the design/implementation, in favour of <a href="UnitTest.html">UnitTest</a>s or <a href="TestDrivenDevelopment.html">TestDrivenDevelopment</a> by change-driven processes.
      </p>
      <p>
        The emphasis in <a href="CleanRoom.html">CleanRoom</a> is IIRC to focus on developing design based on the use of functions and <a href="StructuredProgramming.html">StructuredProgramming</a> principles that at least ensure tractability in formulating a proof for that design. The design is sufficiently detailed and straightforward to be directly proved correct (ideally via <a href="FormalMethods.html">FormalMethods</a> or failing that by extensive and rigorous peer review) that the mapping onto code is not prone to subjective translation error by the programmer. Hence the theory goes: the design is proved correct, the implementation is therefore correct and no faults are present in the software.
      </p>
      <p>
        Advantages of this process are the obvious extreme low tolerance for errors and the scalability of the process itself which make it very useful for large, complex yet safety-critical or real-time systems like (as pointed out above) astronautics or aeronautics.
      </p>
      <p>
        Disadvantages are the large costs involved, rigour (and effort) required and the fact that the process is oriented around "one shot" programming projects, i.e. building a system end-to-end - the process is not naturally iterative but can be adapted to be so.
      </p>
      <p>
        Please feel free to edit the above if I've got anything wrong, I'm a little rusty on this. 
      </p>
      <p>
        <em>The thing that is innovative about this technique is that the </em><a href="FormalSpecification.html">FormalSpecification</a> is not a separate artifact as in, for example, Z. The formal proofs are embedded in the implementation as comments. As far as I know it is still the choice method for developing medical and embedded applications.<em></em>
      </p>
      <p>
        See <a href="CleanRoomSoftwareEngineeringIsNotDead.html">CleanRoomSoftwareEngineeringIsNotDead</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryMethodology.html">CategoryMethodology</a>
      </p>
    </div>
  </body>
</html>