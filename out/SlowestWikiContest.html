<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Slowest Wiki Contest
      </h1>
      <p>
        What's the slowest implementation of a Wiki? Years ago, in a company I once worked for, we had a competition for the slowest implementation of the <a href="AckermannFunction.html">AckermannFunction</a>. I'd like to suggest one for a wiki. Note: this is not a BogoWikiContest in that you're not permitted to make one run slow deliberately; it should be a reasonably "natural" implementation for the language/environment chosen. So this is a call to implement a Wiki in some unlikely technologies...
      </p>
      <p>
        (If I recall correctly, the slowest Ackermann was in a local equivalent of 'troff' - working out how to do recursion was the hardest bit...)
      </p>
      <p>
        It seems to me the slowest wiki, under the definitions given above would be the Wiki with the largest number of pages and links, Or the greatest amount of "feature creep", or one being hit by the most users at the same or nearly same time. 
      </p>
      <p>
        <em>Maybe. Assume (apart from feature creep, maybe) that these are the same for all implementations</em>.
      </p>
      <hr/>
      <p>
        I'm working on one that would qualify called ejwiki for experimental java wiki.  Its a pet project to learn some new technologies.  These include:
      </p>
      <ul>
        <li>
           xml schema
        </li>
        <li>
           xerces
        </li>
        <li>
           xml serialization
        </li>
        <li>
           ant (3 times slower than make)
        </li>
        <li>
           junit (ok, I already knew junit)
        </li>
        <li>
           httpunit and servletunit
        </li>
        <li>
           cocoon
        </li>
        <li>
           jakarta oro regexps
        </li>
        <li>
           log4j
        </li>
        <li>
           tomcat
        </li>
        <li>
           servlets
        </li>
        <li>
           jsps
        </li>
        <li>
           struts
        </li>
        <li>
           java implementations of diff (for revision control) and dbm
        </li>
      </ul>
      <p>
        In some sense, every technology is actually appropriate to the problem.  But put them together and I expect this to be the slowest wiki on the planet.  Particularly since xerces doesn't (yet) support compiling and caching schema definitions.  Who knows, maybe I'll even add a soap service to get the contents of a topic.  -- <a href="HowardFear.html">HowardFear</a>
      </p>
      <hr/>
      <p>
        Implement a Wiki on a <a href="TuringMachine.html">TuringMachine</a> and let First Year <a href="ComputerScience.html">ComputerScience</a> students execute it using <a href="PenAndPaper.html">PenAndPaper</a>. A fresh stack of DIN A4 paper, bought from the nearest stationery shop, can serve as external database. Since students are sometimes considered cheap or unpaid labour for the university, I also submit this entry to the CheapestWikiContest. ;-) -- <a href="ChristianRenz.html">ChristianRenz</a>
      </p>
      <p>
        <em>Hmmm... Here, only second year students know what a turing machine is.  But your idea sounds promising.  Anyone dare to write a </em>TuringMachineCompiler?<em></em>
      </p>
      <p>
        I think this one is approaching being a <a href="BogoWiki.html">BogoWiki</a>.
      </p>
      <p>
        <em> Well, this would mean running a wiki on a real computer instead of a digital one :) </em>
      </p>
      <hr/>
      <p>
        Slowest wiki? Well, that would have to be one that uses Morse code. Here is how it would work (radio jargon in parens) ...
      </p>
      <ul>
        <li>
           Radio wiki server would broadcast wiki pages on short wave to a world wide audience of telegraph operators. Broadcasting would be continuous (qst) unless interrupted by telegrapher input.
        </li>
        <li>
           The server would listen for input between the dits (qsk). The server would recognize two input commands: browse and edit.
        </li>
        <li>
           Should anyone send the server the browse command (..--..) the server will resume sending starting with the most recently cited page. The browse command allows listeners to direct the sequence of pages broadcast by the radio wiki server.
        </li>
        <li>
           Should anyone send the server the edit command (-... -.-) the server will pause waiting for further input from the listener. Listener input will be incorporated into the current page until the listener sends a second edit command (-... -.-).
        </li>
      </ul>
      <p>
        A more user-friendly version of the radio wiki would mimic human behavior such that radio operators would consider it to be just another ham telling stories without realizing that the stories were all recycled from previous conversations. -- <a href="WardCunningham.html">WardCunningham</a>
      </p>
      <p>
        <em>Oh, we can beat that. "BioWiki". Conserved sequences are the pages. Editing is great fun but very slow.</em> -- <a href="GenesShmenes.html">GenesShmenes</a>
      </p>
      <hr/>
      <p>
        Well, <a href="WikiPedia.html">WikiPedia</a> has been awfully slow (April '02) for a while.  That's because the number of users has jumped dramatically all of a sudden.  
      </p>
      <p>
        -- jtnelson
      </p>
      <hr/>
      <p>
        Apologies to <a href="UseModWiki.html">UseModWiki</a>, but it's 3,000 lines of Perl 4 style Perl, and on my
      </p>
      <ol>
        <li>
          MHz PPC, it took a good 10 seconds to load a page before I replaced it with
        </li>
      </ol>
      <p>
        something consisting of 75 lines. -- <a href="ScottWalters.html">ScottWalters</a>
      </p>
      <hr/>
      <p>
        A good old DOS .bat implementation should do. Anybody for using <em>FOR %%1</em> loops and <em>DIR</em> commands to get pages? hmmm could actually be turned into a functional cgi I suppose...
      </p>
      <p>
        Come to think of it, would probably not be that slow ;) -- <a href="SvenNeumann.html">SvenNeumann</a>
      </p>
      <p>
        Seriously? I would love to use something like that on my 486. That's actuly a possibility. It could use copy con and type. Maybe I'll program it... :-) -JamesGecko
        ---
      </p>
      <hr/>
      <p>
        Anyone going to implement one using smoke signals?
      </p>
      <hr/>
      <p>
        How about extending Unlambda Language to allow multiple streams and writing a miniature HTTP server in it?
      </p>
      <hr/>
      <p>
        GraffitiWiki: Each link displays a visible instruction as to where to find the target "page", which could be anywhere in the world.  Of course it's not very reliable, due to constant architectural changes, overwriting by taggers, and erasure by anti-graffiti efforts...
      </p>
    </div>
  </body>
</html>