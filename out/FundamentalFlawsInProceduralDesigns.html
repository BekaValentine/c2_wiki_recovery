<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Fundamental Flaws In Procedural Designs
      </h1>
      <p>
        <em>Some OO developers believe that T+DB (tasks and database) design is riddled with </em>'obvious flaws<em>' and OO helps avoid them.  A database can be viewed as a big global variable and comes with all the problems of global data.  It also allegedly has no decent way of encapsulating varying behavior dynamically. OO allegedly addresses these problems.</em>
      </p>
      <p>
        Possible or alleged flaws:
      </p>
      <ul>
        <li>
           Database is "global" and "naked" -- see <a href="DatabaseNotMoreGlobalThanClasses.html">DatabaseNotMoreGlobalThanClasses</a>
        </li>
        <li>
           Requires passing around too many structures as parameters
        </li>
        <li>
           Lacks encapsulation, or grouping code by entity
        </li>
        <li>
           Does not scale to "large" systems
        </li>
      </ul>
      <p>
        <em>The only possible "flaw" I would see with Procedural Design is qualitative, and that is scalability.  I find OO design tends to provide the ability to write larger programs with less difficulty.  I don't believe that anything written with an OO approach is impossible to write with a procedural approach, merely that the OO approach simplifies the development and maintenance of the program.  Interestingly, as systems scale up to necessitate multiple programs, we tend to have a procedural grouping of OO based programs.  --</em><a href="WayneMack.html">WayneMack</a><em></em>
      </p>
      <ul>
        <li>
           Large apps are a design smell in my opinion. They should be split into sub-apps. We've already discussed this somewhere on this wiki, but I can't re-find at the moment. -t
        </li>
      </ul>
      <ul>
        <li>
           <em>Indeed.  Object-oriented languages are tools for explicitly splitting large apps into sub-apps.  Classes define sub-apps.</em>
        </li>
      </ul>
      <p>
        It should be pointed out that not every OO practitioner agrees that procedural has obvious flaws. Many believe that it has many <strong>subtle flaws</strong> that add up. However, it has proven tough to isolate and communicate these kinds of things, resulting in a fair amount of resentment and confusion.
      </p>
      <hr/>
      <p>
        If OO design relies on mere convention, then one can make conventions for procedural also. Plus, databases have referential integrity, triggers, etc. to enforce data rules. If it is data that is too "small" to be put into a database, then most likely it is not "global" anyhow.
      </p>
      <p>
        <em>It's not about data protection so much as data packaging.  In procedural code, one passes data around in structures or records.  This provides no place to put the code that goes with that data.  So one puts code into modules and passes the data to it, over and over and over.  OO lets one package the code and the data that it's meant to work with into a single entity, the object.  Now one can pass around the object, and no matter where it is, all of its methods are available and easy to find.  With records and structures, one has to know where the functions are and remember them, for example, method(data); with OO, one doesn't, for example, data.method().  Beyond that, OO lets one dynamically change the skin of that data with different versions of those methods, allowing lots of dynamic flexibility.  OO is convenient, plain and simple, it makes things easier.  These things were and are done in procedural code too, by packing function pointers into structures along with the data... but then, that's how OO got invented.  OO is just a formalization of those advanced procedural techniques.</em>
      </p>
      <p>
        Data and operations are generally loosely associated in practice unless one is a fan of multitudes of dedicated structures (I am not). OO designs seem to force this association artificially. Often multiple unrelated operations operate on the same data and visa versa. The relationship between data and operations is generally many-to-many in the longer run (if one factors properly). <em>See below for more on this many-to-many claim.</em>
      </p>
      <p>
        <em>OO allows one to attach functions to recordsets, so one doesn't have to pass the record around so much.</em>
      </p>
      <p>
        One doesn't not need to pass records all around. We may have different experiences.  Perhaps a poor language forces one to do odd things. I had to do funny things in C that I would not ordinarily have to do in other procedural languages. 
      </p>
      <p>
        <em>Ugh, and how pray tell does one pass state around from one procedure to the next?  Whether you pass around a dynamic array as a parameter, or a string, or a record, or whether you map your database to your associative arrays or records.. you still have to pass them arround. Unless, you use a single global variable that all procedures can access - which doesn't scale.</em> -- Structured Programmer
      </p>
      <p>
        Without an example, one cannot demonstrate anything <strong>objective</strong>.  Is there less code, fewer change points, or what?  There is nothing countable.  This might as well be an argument over art or music. There is no "science" in OO computer science. One cannot assert there are "fundamental flaws" unless there is a way to objectively demonstrate them.
      </p>
      <p>
        <em>Equally, please show an example of how you pass your state around from procedure to procedure without using a record parameter or an array parameter or similar. This is not a language issue - this is a theory issue. It's common sense that state somehow has to be passed around from procedure to procedure - no examples need to be provided to understand this basic concept. An object's "self" is a hidden parameter.</em>.
      </p>
      <hr/>
      <p>
        <strong>Having done both Procedural and OO, I do not agree that "T+DB (tasks and database) are riddled with obvious flaws."</strong> 
      </p>
      <p>
        I tend to view OO and Procedural as different ways to organize code rather than anything more significant.  Procedural design tends to have fewer but larger methods than OO and does not really provide a mechanism to help segment methods into smaller parts.  The methods are usually combined into a smaller number of large modules or files.  OO design tends to result in larger numbers of smaller methods combined into larger numbers of smaller classes.
      </p>
      <p>
        <em>Procedures/functions can be as small or large as desired. You can break a task into ever smaller tasks. See </em><a href="StepwiseRefinement.html">StepwiseRefinement</a>. Whether that is helpful or not is another matter. I will agree that perhaps some people think better with smaller methods/functions. We all have different minds that are tripped up and helped by different things. But, we must be careful not to extrapolate our preferences into others.<em>  </em>
      </p>
      <p>
        How does one share context (the data the method can read and/or write) between ever smaller tasks?  Is the context passed to each method or stored as global variables? 
      </p>
      <p>
        <em>See lower part of </em><a href="ProceduralMethodologies.html">ProceduralMethodologies</a><em></em>
      </p>
      <p>
        <em>OO gives some guidance on how and when methods are to broken down, while Procedural does not.  Procedural code tends to be initially written as a few very long methods intended perform a function, while OO tends be initially written with lots of small methods that must be combined to perform a function.</em>
      </p>
      <p>
        Procedural division is usually done by dividing task into subtasks. At the larger scale tasks tend to be (or should be) considered independent, but on a smaller level tasks are often broken-down more or less hierarchically. And, I see nothing which forces one to make small methods in OO. If you could provide an example, that would be helpful. Plus, large functions are not inherently bad, although it appears that what "bothers" people tends to vary per individual. <a href="LongFunctions.html">LongFunctions</a>.
      </p>
      <p>
        <em>The guidance is from encapsulation and cohesion.  Encapsulation basically requires one to work with methods rather than data.  By applying encapsulation, one tends to segregate operations on a more granular level, with a higher level method coordinating the overall operation.  Cohesion helps define a common "home" for all of these newly created methods by centering them around common data elements.  Procedural designs, in general, tend to be more ad hoc in the allocation of methods to modules.</em>
      </p>
      <p>
        <em>The allocation of methods in Procedural design can be considered ad hoc in the sense that it is not supported by the design approach.  Individual designers may use private patterns for self-consistency, but these patterns may only be conveyed by task design documents.  OO provides guidance at a larger scope.</em>
      </p>
      <p>
        One observation I have made is that one often finds OO-like design in Procedural code, particularly in difficult or troublesome areas of the code.  Encapsulation, partial if not full, tends to be a solution applied to handle these situations.  When strange things are happening to some set of data, the natural inclination seems to be to get control of the manipulations on the data.
      </p>
      <p>
        {Examples of both of these claims would be helpful.}
      </p>
      <p>
        By "get control," I am referring to the situation where one sees anomalous data or anomalous operation based on data.  A typical response is to pull at least all operations doing a write to data into a common module and use only the common methods.  Sometimes, operations requiring a read are also consolidated.  Instead of having duplicate inline operations scattered throughout the code, there are a limited number of centralized access.
      </p>
      <p>
        <em>There is no one right grouping. Different groupings help with different kinds of debugging. If one groups behavior around nouns, then debugging that relates to how behavior and nouns interact may indeed be a bit easier. However, it may make other kinds of debugging harder in exchange. Perhaps it depends on the kind of mistakes that individuals tend to make. Different people make different proportions of certain mistakes. The grouping of code is simply a compromise to select what one sees as the least evil.</em>
      </p>
      <p>
        <I think we somewhat concur on "no one right grouping."  The original point I tried to express was that there were differences in method grouping between Procedural and OO, but nothing that could be considered either a fundamental or obvious flaw.  I, personally, find that OO provides an adequate grouping most of the time, but I recognize times where it doesn't seem to work.  I may not always agree with others on exactly when those conditions occur, but I do find it interesting to try to understand why the approach falls short.>
      </p>
      <p>
        On the other hand, when crossing program boundaries (one program to another, or a program to a third party or independent component), it seems more appropriate to revert to a procedural organization.  The methods tend to be organized procedurally, for example, a component that handles the GUI display aspects of a data element, but really provides no "business" functionality.  At these interfaces, we tend to decapsulate the data, pass it across the interface and re-encapsulate it.
      </p>
      <p>
        Given that there are many successful applications that have been built using Procedural Design, I can't agree that those designs are "riddled with obvious flaws."  If these programs have flaws, the flaws are probably not obvious.  Moving to an OO approach will sometimes help to isolate a flaw and help developers correct it.  I would tend to a pragmatic approach of using the design approach that best fits the current skill level, knowledge, needs, and development tool set of one's development team.  Also, recognize that these will certainly change over time, and the code can be moved between a Procedural design and an OO design and vice-versa to reflect those changes.
      </p>
      <hr/>
      <p>
        If OO was <strong>just about encapsulation</strong> of data, than it would be qualitatively no different than procedural.  There's absolutely no fundamental difference between the two alternative examples, one being OO <strong>style</strong> and the other being procedural <strong>style</strong>:
      </p>
      <p>
        Example 1 in Java : 
      </p>
      <code>
        HashTable x= new HashTable(20);<br/>
        x.put("A", "A value"); <br/>
        String value= x.get("A");<br/>
      </code>
      <p>
        Example 2 in <a href="ObjectiveCaml.html">ObjectiveCaml</a>:
      </p>
      <code>
        let x= Hashtbl.create 20;;<br/>
        Hashtbl.add x "A" "A value";;<br/>
        let value v= Hashtbl.get x "A";;<br/>
      </code>
      <p>
        The only difference between the two is in <strong>notation</strong>:
      </p>
      <code>
        data.procedure( <parameters> ) <br/>
      </code>
      <p>
        versus 
      </p>
      <code>
        procedure( object, <parameters> )<br/>
      </code>
      <p>
        {Some might argue that the implementation will look different if one used more than one implementation of a hash-array in a given application.}
      </p>
      <p>
        In the <a href="ObjectiveCaml.html">ObjectiveCaml</a> example the internal data of the hashtable can only be manipulated by the functions in Hashtbl module. The type of the internal data is totally hidden to clients (unlike in C where somebody using stdio.h has access to the definition of FILE structure). So encapsulation is perfect.
      </p>
      <p>
        The essential difference between <a href="ObjectOrientation.html">ObjectOrientation</a> and procedural is something different altogether, and is defined by <a href="KristenNygaard.html">KristenNygaard</a> as per <a href="NygaardClassification.html">NygaardClassification</a>. It is absolutely correct to say that the OO paradigm has no more nor less encapsulation than the procedural paradigm. 
      </p>
      <p>
        What is more essential, is that OO developers should consider the procedural paradigm (for example avoiding such nonsense as FundamentalFlawsInProceduralDesign); there is a lot of good knowledge that should not be lost. Instead OO developers should be studying procedural means of abstraction and composition very carefully, so that they do not get into "all I have is a hammer and everything looks like a thumb". There are lots of procedural tricks that most OO practitioner are blissfully unaware of, and the truth of the matter is that <strong>there are no fundamental flaws whatsoever</strong> that are related to procedural programming. 
      </p>
      <p>
        For better understanding people should consult such fine books like <a href="StructureAndInterpretationOfComputerPrograms.html">StructureAndInterpretationOfComputerPrograms</a> or the more recent <a href="ConceptsTechniquesAndModelsOfComputerProgramming.html">ConceptsTechniquesAndModelsOfComputerProgramming</a> by <a href="PeterVanRoy.html">PeterVanRoy</a> and SeifHaridi, and those will provide an unbiased and very useful exposition of all the major paradigms.  To quote from van Roy and Haridi: <em>We show that multiparadigm programming is natural and that the conventional boundaries between paradigms are artificial and limiting.</em>
      </p>
      <p>
        Please note that neither example shows any sort of class (there are no methods!) nor data encapsulation.  The example shows two different ways to store and retrieve data from a data structure.  
      </p>
      <p>
        <em>The issue seems to be that </em><a href="NobodyAgreesOnWhatOoIs.html">NobodyAgreesOnWhatOoIs</a>.<em></em>
      </p>
      <hr/>
      <p>
        I'm currently working with some code in an OO language that was written in a procedural style.  The primary flaw with this approach is that it forces us to talk about the code in different language than the domain.  As a result, we have to make a mental transition between what our domain expert says and what we put in the code.  That will inevitably lead to defects when we misunderstand the domain expert but don't realize it.  The domain expert won't realize it either, because when we talk about the design, it makes no sense to her.  I'm helping the team refactor the code to a <a href="DomainDrivenDesign.html">DomainDrivenDesign</a> to help resolve this problem.
      </p>
      <p>
        --<a href="JimShore.html">JimShore</a>
      </p>
      <p>
        I think there is/was a debate topic about this somewhere. How exactly OO allegedly better "fits the domain" I don't exactly know.  Traditional Simula-67 type of models don't apply to my domain because it deals mostly with intellectual or virtual property: taxes, money, reports, approval status, etc. One is not emulating things but rather processing and managing them. For example, the physical approach to dealing with accounting is obsolete with transaction-oriented databases. We don't need <a href="DoubleEntryBookkeeping.html">DoubleEntryBookkeeping</a> anymore. And, we can multi-index library books so we don't need to model Dewey Decimal trees or book or card physical proximity anymore. So what are you looking at to compare? Perhaps you really mean <a href="OoBetterModelsHumanThinkingDiscussion.html">OoBetterModelsHumanThinkingDiscussion</a>? -- top
      </p>
      <p>
        I strongly agree that OO is not appropriate for all domains.  OO is particularly bad for math, and it's not so good for database-centric applications either.  I think it is good for domains that have complex rules, particularly if they're non-regular (i.e., typical business rules).  You seem to imply that OO is best for simulating physical objects; while that was its original purpose, I find that it works fine in other domains as well.  In the example above, the domain is very conceptual, not physical at all.  --<a href="JimShore.html">JimShore</a>
      </p>
      <p>
        It seems to me OO would be <em>worse</em> for "non-regular" rules, because linear and hierarchical taxonomies will tend to fail, and OO gets messy outside of those. By "messy" I mean it no longer has the catchy-but-simple code and change patterns found in toy shape, animal, and device-driver examples. I did not mean to imply that OO was about physical modeling, I was just trying to address what I thought you were saying or implying. If I got it wrong, I apologize. It is hard to compare how well something matches to non-physical things. -- top
      </p>
      <p>
        Well, let's be sure to distinguish the way OO is taught and the way experts use it.  OO is taught... poorly... as these rigid inheritance hierarchies.  You're right, it's silly and only works for toy examples.  But experts use OO by creating a mesh.  Each class represents a concept in the domain and encapsulates processing related to that concept.  The classes have relationships to other classes that correspond to how the concepts relate to each other in the domain.  Inheritance is used sparingly.  This approach does map to non-regular domain rules fairly well, not that it's ever easy to unambiguously describe the rules in the first place.  --<a href="JimShore.html">JimShore</a>
      </p>
      <p>
        But the relationship between "concepts" and "processes" is often not one-to-many, but more like many-to-many, especially over the longer run. If the goal is to relate (track) the relationships, then a database beats code in most cases in my opinion. If you get away from mere hierarchies and animal-like code shapes, then OO just reinvents databases the hard way.  -- top
      </p>
      <p>
        Yes, concepts and processes are orthogonal.  That's what makes OO difficult for so many people.  Procedural code is easy because when the customer says, "take this thing that we need done and do it," you go write a routine that does it, probably decomposing [tasks?] along the way.  
      </p>
      <p>
        <em>Well, at least you seem to agree that procedural makes *some* things easy.</em>
      </p>
      <p>
        Object-oriented code is harder because when the customer says, "take this thing that we need done and do it," you say, "what do I add to the various pieces of my domain model to do this thing?" and "how does this change my overall model?"  The procedural scripts get smeared out into bits of little code fragments on various classes in the domain model.
      </p>
      <p>
        <em>This is more or less </em><a href="EventDrivenProgramming.html">EventDrivenProgramming</a>, and it is good. It's all part of <a href="DivideAndConquer.html">DivideAndConquer</a>. -- top<em></em>
      </p>
      <p>
        The first approach is easier and more intuitive, but it becomes difficult to manage when you have lots of things to do <em>and</em> complex domain logic.  Eventually it becomes simpler to manage a domain model [in OO].  
      </p>
      <p>
        <em>"Lots of things", yes. But that is why we have databases. How are lots of event snippets worse than lots of classes and lots of methods anyhow? As far as this not handling "complex" logic, I would sorely like a specific example.</em>
      </p>
      <p>
        For people who do a lot of OO work, like myself, that time comes sooner rather than later, because we've been trained to think in terms of domain models.
      </p>
      <p>
        <em>Well all these years I thought I was dealing with a "domain model" also. How can we objectively see if your head domain model is better than my head domain model?</em>
      </p>
      <p>
        As I look at your other comments, I think you may think that a class corresponds to a <a href="UserStory.html">UserStory</a>/<a href="UseCase.html">UseCase</a>.  That's not at all true... that's the procedural approach.  
      </p>
      <p>
        <em>No, I did not say that nor mean to imply it. However, some OO design philosophies probably propose that. It is all part of the </em><a href="OoLacksConsistencyDiscussion.html">OoLacksConsistencyDiscussion</a> complaints. -- top<em></em>
      </p>
      <p>
        A <a href="DomainDrivenDesign.html">DomainDrivenDesign</a> has a class corresponding to a concept in the domain--what you're calling an entity--and a single <a href="UserStory.html">UserStory</a> may involve multiple classes, just as in your table below.  Although a <a href="UserStory.html">UserStory</a> probably wouldn't be as low-level as your table implies.
      </p>
      <p>
        <em>"Concepts" are multi-faceted by my observation. </em><a href="EverythingIsRelative.html">EverythingIsRelative</a>. They intertwine in the real world. One cannot draw clean *global* circles around "concepts" and have that be sufficient. Thus, I strive for local or ad-hoc "circles". OO's abstractions of concepts tend to try to be global, and that is a flaw in my opinion.<em></em>
      </p>
      <p>
        I can't agree that OO reinvents databases; the goal of OO isn't to track relationships.  A domain model reflects the relationships between concepts, but that's a side-effect, not the goal... and it isn't necessarily a complete or accurate representation.
      </p>
      <p>
        --<a href="JimShore.html">JimShore</a>
      </p>
      <p>
        <em>Polymorphism, inheritance, and composition/aggregation are all about "relationships".</em>
      </p>
      <p>
        (Responding to Top's inline comments): This discussion seems to be veering off into a discussion of databases versus OO which isn't what I'm interested in discussing.  (Although I have to admit that an event-oriented approach using database tables, triggers, and stored procedures, assuming that's what you're suggesting, sounds interesting.)
      </p>
      <p>
        {I believe tables/DB is the *key* to procedural design's success. OO relies too much on code, and that is its main downfall. This seems to be a constant sticking point between us. I learned to stop thinking in code (as much) and quickly started thinking in tables. It felt liberating. It is declarative with code being the low-level detail that carries out orders and request based on data. With regard to GUI's, DB triggers would play little or no role in the designs I tend to follow. The framework already has "outer control", so we don't need triggers. However, that is mostly a framework implementation issue rather than something an application developer has to deal with directly.-- top}
      </p>
      <p>
        To recap my position, there's no such thing as a fundamental flaw in the procedural design approach.  I don't see a fundamental flaw in any mainstream design approach; just <em>fit for a particular purpose</em> or <em>not fit for a particular purpose.</em>  Which, if I had been willing to keep my mouth shut, is exactly the point of the <a href="WhenToUseWhatParadigm.html">WhenToUseWhatParadigm</a> link down at the bottom of the page.
      </p>
      <p>
        <a href="WikiGnome.html">WikiGnome</a>s, please feel free to do anything you like with my end of this discussion.
      </p>
      <p>
        --<a href="JimShore.html">JimShore</a>
      </p>
      <hr/>
      <p>
        <strong>"Fixel" Domain Matching Example</strong>
      </p>
      <p>
        An example might be more clear: In one case, the domain expert says, "you need the first fixel"  We say, "we'll use the fixelFinder on the dataArray to get an array of fixels and then we can get the first fixel from that."  Our domain expert says, "huh?"  We reply, "well, a dataArray is how we represent the data points in the blodget, so using fixelFinder allows us to find all the fixels in the blodget.  Once we have that list of fixels, we can just take the first one."  And the domain expert says, "that doesn't make any sense, but okay... whatever..."
      </p>
      <code>
        firstFixel = fixelFinder.find(dataArray)[0]<br/>
      </code>
      <p>
        After refactoring, we say, "We have the blodget object, so we'll ask the blodget for its first fixel."  Our domain expert says, "yeah, that's right, you want the first fixel from the blodget."
      </p>
      <code>
        firstFixel = blodget.fixel(0)<br/>
      </code>
      <p>
        The new code matches the domain, making it easier for us to talk to the domain expert and reducing the likelihood of errors.
      </p>
      <p>
        This is a real story from last week.  I've just changed the domain terms to keep things mysterious.
      </p>
      <p>
        --<a href="JimShore.html">JimShore</a>
      </p>
      <p>
        Why not just have a function called "getFirstFixel"? I suspect you will argue that OO forces one to group all fixel-related stuff into the same class and that procedural relies on convention only to do that. However, there are at least 2 problems I see with that reasoning. 
      </p>
      <p>
        <Probably an appropriate refactor of the above code would produce Blodget.FirstFixel().  I suspect a more in depth refactoring would replace the FirstFixel() method with one that actually performs an action;	instead of something like Modulate(Blodget.FirstFixel()) one would have Blodget.Modulate().  Remember, there is probably not a need to "get" the first fixel, there is probably a need to take some action that just happens to involve the first fixel.>
      </p>
      <p>
        First, many tasks or scenarios involve multiple nouns. A single <a href="PrimaryNoun.html">PrimaryNoun</a> is artificial. It could involve 2 nouns, 5 nouns, or 1 noun. It may later grow to getFirstFixelThatHasLessQuantityThanRelatedSnarkle. This now involves both fixels and snarkles.
      </p>
      <p>
        Second, as the OO design matures it often involves splitting ever growing classes into multiple smaller classes. At this point any grouping of related classes is now a convention, just like subroutine grouping.
      </p>
      <p>
        Besides, why should the domain expert dictate how the code looks? If you want to track <a href="UserStory.html">UserStory</a><em></em>'s that is fine, but to force them to be associated with just one entity is arbitrary in my observation. There is no Noun Police I know of in the universe that enforces that. At best it is a <a href="UsefulLie.html">UsefulLie</a>.  A better visual way to track might be a grid with <a href="UserStory.html">UserStory</a>/<a href="UseCase.html">UseCase</a> on one axis and entity on another. We may then have something that looks like this:
      </p>
      <code>
        . <a href="UserStory.html">UserStory</a>/<a href="UseCase.html">UseCase</a>	|	  Entity<br/>
        .-----------------------------------------------------------<br/>
        .			| Snargle  Flaggle  Groggle  Etc...<br/>
        . getFirstSnargle	|	X	-	-<br/>
        . removeDuplicateGroggle |	X	-	X<br/>
        . fooTheBar		|	-	X	-<br/>
        . Etc....<br/>
      </code>
      <p>
        --top
      </p>
      <p>
        If the domain has a Snargle, it makes sense that the program has a Snargle, then the domain expert and the programmer can discuss things without having to do a mental translation every time Snargle is mentioned.  That applies even if Snargle is just a concept in the domain.
      </p>
      <p>
        <em>Why can't the Snargle be a DB table?  I see no advantage to make it a global code thing. Database entities and noun attributes are one-to-one, but often not behavior. Behavior and entities tend to be orthogonal enough to avoid hard-wiring a large-scale relationship into code.</em>
      </p>
      <p>
        Simple, because a table isn't code.  Domain models are ways of organizing code, not data. The domain object may be put into a table when it's not being used.  We have to write code, so we need a way to organize it. 
      </p>
      <p>
        <em>Organize it by minimizing it. Factor noun-ness out of its structure and move it into tables so that we are dealing more with tables and less with code because tables are more flexible. You can't query code very well. Plus, limiting code to almost only task-ness makes its organization more consistent so that there is less Picasso-ing going on with different developers. See </em><a href="CodeAvoidance.html">CodeAvoidance</a>.<em></em>
      </p>
      <p>
        We can organize it procedural style, by task, or OO style, by related behavior.  You choose task because you think it's easier, we choose OO style because we think it's easier.
      </p>
      <p>
        <em>Because it is in a style without any objective external evidence. Do you want Software Engineering (and Wiki) to be like science or like marketing?</em>
      </p>
      <p>
        [Programming style preferences are subjective.  I write OO code because I enjoy it.]
      </p>
      <ul>
        <li>
           I don't think anybody disputes this. But this topic is seeking "fundamental flaws". That implies objective or universal problems.
        </li>
      </ul>
      <p>
        {Moved some to <a href="OoVersusTablesRants.html">OoVersusTablesRants</a>}
      </p>
      <p>
        <em>Plus, I am fascinated by OO thinkers. It is like trying to communicate with an alien being with a totally different way of thinking. The problem is that it is hard to convey solid thoughts back and forth. (I don't mean "alien" in a bad way. It is just an analogy to convey the feeling it gives me.)</em>
      </p>
      <p>
        I am not sure I follow the gist of the previous discussion.  Would it not be fair to say that the operations performed on "Snargle" need to go (i.e., be stored) somewhere?  I do not see how use of "tables" reduces the number of operations to be performed; to me the only change would be in the implementation of the operation.
      </p>
      <p>
        <em>I don't think anybody suggested that it reduced total operations. It is about managing them (finding, changing, listing, etc.) However, in my opinion OO designs do tend to re-implement </em><a href="DatabaseVerbs.html">DatabaseVerbs</a> in each class.<em></em>
      </p>
      <p>
        Would we be in agreement that the quantity of operations is the same in either approach?  Also, I would like to confirm the definition of "operation" that I am trying to use, I am using operation to mean a segment of code that could either be implemented as a section of code contained inline within a large method or could be implemented as a stand alone method called by the larger method.  My opinion is that the some basic (though fuzzily defined) operations need to be performed in whatever approach one takes, and the issue is primarily differences in implementation and packaging.  Does this seem acceptable?
      </p>
      <p>
        <em>Yes, I generally agree, except perhaps in cases where the OO version appears to be reinventing things that databases already do out-of-the-box. But, for the sake of argument lets put that issue aside right now. -- top</em>
      </p>
      <hr/>
      <p>
        In addition to the discussion above it is essential for people who perceive that there are fundamental flaws with procedural, to come to terms with <a href="NygaardClassification.html">NygaardClassification</a>, because otherwise they might be programming procedurally without even realizing it.
      </p>
      <p>
        The perception is primarily rooted by the fact that in stock procedural languages (especially C and COBOL ) it was very easy to write spaghetti code, as well as the fact that procedural languages were en vogue in an early period when the maturity of the software engineering work force was a little bit less than it is now when OO is in fashion.  Therefore the flawed perception is that simply by applying good engineering practices (like <a href="InformationHiding.html">InformationHiding</a>, avoiding code redundancy,etc) one made the jump from procedural land into OO land, while in reality they are simply writing good procedural code in Java or whatever OO language. See the vacuous claim that <a href="OoIsJustGoodEngineering.html">OoIsJustGoodEngineering</a>.
      </p>
      <p>
        To illustrate this phenomenon I'll bring the book  <a href="RefactoringImprovingTheDesignOfExistingCode.html">RefactoringImprovingTheDesignOfExistingCode</a>, considered by many a "bible" of good OO programming practice,  where most examples are not <a href="ObjectOriented.html">ObjectOriented</a> as per <a href="NygaardClassification.html">NygaardClassification</a>, but are mostly concerned with better organizing snippets of code, and those really are procedural/functional snippets. The mere fact that they are grouped in classes does not make them <a href="ObjectOriented.html">ObjectOriented</a>. 
      </p>
      <p>
        <em>I completely disagree with the above conclusion.  </em><a href="RefactoringImprovingTheDesignOfExistingCode.html">RefactoringImprovingTheDesignOfExistingCode</a> is full of OO code as per <a href="NygaardClassification.html">NygaardClassification</a>.  Firstly, all OO code is made from procedural functional snippets, putting them into classes and having those snippets work on instance variables of that class is what makes it OO code.  Almost every sample in the book shows you how to improve bad OO code, or procedural code into good OO code.  OO code is after all just better organized procedural code in many many circumstances.<em></em>
      </p>
      <p>
        ["Refactoring..." is full of examples of how to turn procedural-ish code into OO and vice versa - it doesn't explicitly favor a paradigm.  If I read the Fowler book correctly, most of the refactorings worked to make each class responsible for a single responsibility, and so the class would become more Nygaard-like and less C-with-classes-like.  There were also several refactorings to go the other way, to turn a mostly OO class into a more procedural version.
      </p>
      <p>
        And OO code is not just "better organized procedural code" under the Nygaard/Kay definitions.  It's a fundamentally different way of thinking.  -- <a href="JonathanTang.html">JonathanTang</a>]
      </p>
      <ul>
        <li>
           Just because one or other say so doesn't make it so. The thesis that OO code is just "better organized procedural code" is  untenable. It would presume that procedural code is somehow inherently limited, while OO code evolved it. A cursory reading of <a href="SiCp.html">SiCp</a> will let you know that data-oriented abstraction versus procedure-oriented abstraction are largely orthogonal. Again, what makes a code "OO" is the design philosophy behind it, not the mere deployment of OO syntax like classes, methods and objects. You can program FORTRAN in any language. If a class converges towards single responsibility principle, and that responsibility is not to represent a entity in an operational model, but to represent a calculation or an aspect thereof, than that class is no different than a procedure with single responsibility or a module/unit with a single responsibility to perform a part of an algorithm. The design philosophy is than procedural not Object Oriented, and this should not be regarded as a problem with the design. --Costin
        </li>
      </ul>
      <p>
        <em>I am generally not a fan of Fowler's work -- top</em>
      </p>
      <p>
        A nice exercise would be to take some longish example like <a href="http://www.refactoring.com/rejectedExample.pdf,">http://www.refactoring.com/rejectedExample.pdf,</a> and translate that from Java to a good procedural language such as Scheme or <a href="ObjectiveCaml.html">ObjectiveCaml</a> (make sure you don't use the objects in the camel), and I guess even Pascal or Ada without objects (Ada'83) is up to the task. It really is no difference but a small change of notation !!! Of course some may argue the reverse, that on the contrary the Scheme version would be OO programming in Scheme rather than Java version being procedural programming in Java. To resolve this dilemma we'd have to appeal to the wisdom of <a href="KristenNygaard.html">KristenNygaard</a>: Is the design of the system focused on simulating autonomous entities that react to signals by changing their state and sending other signals ? Or is it just focused on how to best organize a series of calculation as a succession of procedure calls (even when those procedures are methods) ? A closer look will show that the later is the case.
      </p>
      <p>
        [Scheme and OCAML are functional languages.  Did you mean "good functional language..." or did you mean to use Pascal/Ada for the example.  -- jt]
      </p>
      <ul>
        <li>
           Where do you draw the distinction between procedural and functional ? Mostly in the scale on which destructive assignment (side effects) are employed. Scheme and OCAML with side effects are perfect procedural languages, of course they are also functional, and programming without side effects is the preferred style. However, the standard calls it "algorithmic language scheme", while <a href="SiCp.html">SiCp</a> talks all about procedures, and procedural abstraction, therefore we can safely say that Scheme and OCAML are both functional and procedural languages. OCAML and Scheme are more advanced than Pascal/ADA but even Pascal and Ada are perfect for the kind of code we talk about. --Costin
        </li>
      </ul>
      <ul>
        <li>
           I think the distinction may not be Boolean in practice. State has to be changed at some point, so nothing practical is pure FP. The more state is changed the more procedural something is. In other words a higher ratio of "procedures" than "functions".
        </li>
      </ul>
      <hr/>
      <p>
        By the way, I have no doubts that <a href="TopMind.html">TopMind</a> is able to produce code at least as good on that [above] example as <a href="MartinFowler.html">MartinFowler</a>. What do you think, Top ?
      </p>
      <p>
        <em>It sounds suspiciously similar to the example analyzed at </em><a href="http://www.geocities.com/tablizer/mellor.htm">http://www.geocities.com/tablizer/mellor.htm</a> . In the end the disagreements circled around the probability of certain change patterns. In my opinion those proposed by the OO debaters were artificially regular in the "shape" of change. <strong>Perhaps polymorphism fans and procedural fans simply perceive change differently</strong>. -- top<em></em>
      </p>
      <hr/>
      <p>
        <strong>Is the design of the system focused on simulating autonomous entities that react to signals by changing their states and sending other signals? Or is it just focused on how to best organize a series of calculations as a succession of procedure calls (even when those procedures are methods)?</strong>
      </p>
      <p>
        What's the criteria used to make this distinction?  A procedure call is a signal.
      </p>
      <p>
        <em>I would say neither.  The design of the system should be focused on automating a manual task.  It should not be an attempt to throw a lot of techno-babble at a client (as was done in the question).</em>
      </p>
      <p>
        Be careful not to project experience from some problem domains onto others.  Many systems do not automate existing manual tasks, and even in systems that do, strict adherence to existing roles and responsibilities can be counter-productive.  I'm still curious how we can tell the difference between simulating autonomous entities signalling each other and organizing a series of calculations as a succession of procedure calls.
      </p>
      <p>
        (moved rest of discussion to <a href="AutomatingExistingProcessVersusImprovingIt.html">AutomatingExistingProcessVersusImprovingIt</a>)
      </p>
      <hr/>
      <p>
        <strong>The relationship between data and operations is generally many-to-many.</strong>
      </p>
      <p>
        Could someone expand upon this statement?  I have a hard time picturing even a one to many relationship between a single operation and multiple data types.  I can only think of a few restricted places where this is even remotely implementable and those involve hidden type changes by the compiler (for example char to int in C).  How can a single operation apply to more than one data type?
      </p>
      <p>
        <em>I generally divide operations into two kinds: </em><a href="DatabaseVerbs.html">DatabaseVerbs</a>, and domain-specific. Keep in mind that the division may be a little fuzzy in some cases, it is just a conceptual classification. But in my opinion <a href="DatabaseVerbs.html">DatabaseVerbs</a> belong to the database for the most part. One should not have to repeat Add, Change, and Delete for each and every entity class, for example. That is poor <a href="InterfaceFactoring.html">InterfaceFactoring</a>. But beyond those, many "operations" do or can involve multiple nouns. For example, printing an invoice involves customer data, invoice data, and line-item data, as well as possible tax data. Thus, at least 4 entities are involved. It is true that at original development time, one particular noun may be the <a href="PrimaryNoun.html">PrimaryNoun</a>, but over time this is far from guaranteed. Thus, the coupling between operations and nouns should be light, and procedural fits well with this policy. Polymorphism is too heavy a coupling statement in my opinion. -- top<em></em>
      </p>
      <p>
        How would one write such shared methods?  For example, how would one create a single Add() method for both a name and a birth date?  The only options I see are to write multiple Add() methods with some means to discriminate between them, or to create an Add() method with a large parameter list and select the particular Add operation one wishes to perform based on the parameters passed.  Is there some alternative to create a shared method I am not aware of?
      </p>
      <p>
        <em>Most database interfaces seem to solve the problem by using data or meta-data instead of a coded approach. Schemas are stored as data, so what an "add" needs for a given entity is calculated/checked as needed. It would be similar to using a </em><a href="DataDictionary.html">DataDictionary</a> for validation and other purposes.<em></em>
      </p>
      <p>
        Could you expand further?  Unfortunately, I still can't see what you are describing.  Are you implying a code generator or something similar (or am I totally in left field)?  For the Add() example, how does the offered data get placed in the correct location?
      </p>
      <p>
        <em>It depends on how you define "location". Your "add a birth-date" text is a bit confusing to me. Generally you "add" a person object or record. If there is already a record, then you "replace" the birth-date in the record/object, not "add" it.</em>
      </p>
      <hr/>
      <p>
        <strong>Why should the domain expert dictate how the code looks?</strong>
      </p>
      <p>
        I think this might be an interesting question to explore.  I, for one, have always just accepted that code organization becomes "better" as it more closely reflects the problem domain.  I also realize that I cannot justify that belief.  I would suggest that what might look at some lower level questions as well.
      </p>
      <ul>
        <li>
           Is code organization improved by closely modeling the problem domain?
        </li>
        <li>
           How does one tell if they are fitting the domain closer?
        </li>
        <li>
           What are alternatives for organizing the code?
        </li>
        <li>
           Is the problem domain best reflected by OO design, Procedural design, a combination, or neither?
        </li>
      </ul>
      <p>
        -- <a href="AnonymousDonor.html">AnonymousDonor</a>
      </p>
      <p>
        When I first learned OO, closely modeling the problem domain was in vogue.  I was told that would facilitate communication with end users.  I've drifted far away from that position over the years.  My users do not care what my code looks like.  I try to use their jargon as much as I can, but I do not try to maintain a one-to-one model of their processes and roles in my code.  They want the code to meet their requirements but (for the most part) they do not care how it does so.
      </p>
      <p>
        <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a> drives most of my code organization decisions.  I often write a new feature in a verbose, repetitive or brute force way ("make it work"), then refactor the common code ("make it small").  The problem domain determines the requirements the code has to satisfy, but the solution domain determines the structure of the code.
      </p>
      <p>
        I have done this in procedural languages, but I still use object oriented techniques.  Object oriented languages make those techniques easier, so I prefer them.
      </p>
      <p>
        -- <a href="EricHodges.html">EricHodges</a>
      </p>
      <p>
        <em>Can you provide an example of OO facilitating </em><a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a>?<em></em>
      </p>
      <ul>
        <li>
           Inheritance is an example of OO facilitating <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a>.  <em>(See below)</em>
        </li>
      </ul>
      <ul>
        <li>
           OO design facilitates reuse more than Procedural design due to finer method granularity and method placement.  High level operations often need to perform common operations on lower level data constructs.  In a procedural design, where one has direct access to the data constructs, the lower level operation will often be implemented as inline code.  If it is separated into a separate method, that method would be contained within the module of the method that first called it.  As an example, an InitializePerson() method may need to also initialize a name, and this operation may be either inline code or included as InitializeName() within an Initialize module.  When an UpdatePerson() is later added in an Update module, it may have to repeat the operation done to initialize a name.  Unless the developer is very familiar with the entire code base, it is unlikely he would know of the existing functionality, particularly if it is done as inline code within the InitializePerson() method.  In OO design, data encapsulation would require that the initialize name operation would be implemented as a method within a Name class.  This facilitates the finer granularity of methods.  When an Update() method is later added to a Person class, the developer only needs to become familiar with the Name class to recognize the operation he requires is already implemented.  OO design facilitates code reuse better than Procedural design because it encourages the use of smaller methods over inline code and it places the resulting methods into a smaller context for searching.
        </li>
      </ul>
      <ul>
        <li>
           I am having difficulty following this. I am not sure what an "update module" or "initialize module" is in your methodology.
        </li>
      </ul>
      <p>
        <em>One alternative to domain driven code organization would be "component driven" organization.  This approach views software as consisting of existing components that are merely "wired together" to create a new application.  I still see occasional references to this "absolutist" belief, but do not feel it will ever be practical.  On a lower level, however, I see there is always a trade-off between using an available generic module and create a domain specific module.  --</em><a href="WayneMack.html">WayneMack</a><em></em>
      </p>
      <hr/>
      <p>
        Re: <em>Database is "global" and "naked"</em>
      </p>
      <p>
        See <a href="GateKeeper.html">GateKeeper</a>
      </p>
      <hr/>
      <p>
        Re: <em>Inheritance is an example of OO facilitating </em><a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a>.<em></em>
      </p>
      <p>
        Yes, but I find problems with using inheritance to factor out duplication:
      </p>
      <ul>
        <li>
           It assumes the duplication is hierarchical, which it is usually not in my observation. See <a href="LimitsOfHierarchies.html">LimitsOfHierarchies</a>.
        </li>
      </ul>
      <ul>
        <li>
           The granularity of difference (sharing) often ends up smaller than a method, requiring a lot of code rework. See <a href="DeltaIsolation.html">DeltaIsolation</a>.
        </li>
      </ul>
      <p>
        Subroutines/functions can also be used to factor out duplication, and appear to be nearly as powerful as inheritance in that regard. I agree that it does require a little bit more code than inheritance, but that is the cost of not buying into a tree-shaped view of change and differences. In other words functions are more change-friendly if the world is not tree-shaped in reality. If the world goes trees, then inheritance pays a bit better than functions in terms of <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a>; if not, functions win.
      </p>
      <hr/>
      <p>
        See also: <a href="WhenToUseWhatParadigm.html">WhenToUseWhatParadigm</a>, <a href="SwitchStatementsSmell.html">SwitchStatementsSmell</a>, <a href="OoLacksConsistencyDiscussion.html">OoLacksConsistencyDiscussion</a>, <a href="ImprovingProceduralLanguages.html">ImprovingProceduralLanguages</a>
      </p>
    </div>
  </body>
</html>