<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Hot Spot Vm
      </h1>
      <p>
        Sun provides a virtual machine for Java which is called Hot Spot
      </p>
      <hr/>
      <p>
        Research into fast Smalltalk led to the SelfProject. A company called Anamorphic (I think) fed this back into a commercial Smalltalk IDE. Sun bought it before it was released, and spent some years adapting the technology to Java. (Some Smalltalkers feel bitter about this.) -- <a href="DaveHarris.html">DaveHarris</a>
      </p>
      <hr/>
      <p>
        <em>What's current VM performance comparison, please? -- rj</em>
      </p>
      <hr/>
      <p>
        As of last week (Nov 1x, 1999), on Windows:
      </p>
      <p>
        JDK1.1.*: Compiling to native code and don't need a GUI ? Use TowerJ (fastest, period). Interpreting, or need a GUI, and want an FCS product? Use IBM's JIT. Interpreting, or need a GUI, and willing to live with a good beta ? Use SUN's JDK1.3 (which is, from my usage, about 20% faster than IBMs product. But, on 
        the other hand, it's beta. And there are incompatibilities between 1.1.x and 1.3). 
      </p>
      <p>
        JDK1.2.* or 1.3.*: The only game in town at this point is <a href="HotSpot.html">HotSpot</a>. There are three versions, though: <a href="HotSpot.html">HotSpot</a> 1.01, <a href="HotSpot.html">HotSpot</a> 2.0, and <a href="HotSpot.html">HotSpot</a> Client. 1.01 is FCS, 2.0 and Client are beta. 2.0 is better for server tasks than Client; Client is better for client tasks than 2.0. Both 2.0 and Client are better than 1.01 for just about anything (1.01 is from a previous release cycle).
      </p>
      <p>
        Microsoft and Symantec (the JIT that ships with the "Classic VM") are nowhere near the leading edge of performance. 
      </p>
      <p>
        -- <a href="WilliamGrosso.html">WilliamGrosso</a>
      </p>
      <hr/>
      <p>
        My knowledge is similar to William's: 
        IBM's JDK is probably the fastest VM available right now, but it's only 1.1.x. <a href="HotSpot.html">HotSpot</a> on 1.2 is close. JDK 1.3, tbd in early 2000, should have very fast GUI speed, faster than what IBM has now.
      </p>
      <p>
        As for native compilation, both Symantec's and IBM's compiler are _slower_ than the leading JIT's. TowerJ is supposed to be very good, though. Has anyone used Instantiation's JOVE?
      </p>
      <p>
        -- <a href="StuCharlton.html">StuCharlton</a>
      </p>
      <hr/>
      <p>
        Oracle claims to have an extremely fast JVM in their new products.
        A technical manager, speaking to the Saint Louis Java User's Group (Java SIG) said a bunch of things, which I took to mean that...
      </p>
      <ul>
        <li>
           They translate ".class" files into C++ at installation time,
        </li>
        <li>
           then compile them into machine code,
        </li>
        <li>
           to be dynamically linked in at run time.
        </li>
      </ul>
      <p>
        That is, compile and optimize to native machine code when installed - not at run time.
      </p>
      <p>
        <em>[Please correct the above if you have better information.  Thanx!]</em>
      </p>
      <p>
        To me, that last arrangement seems unlikely to be the full explanation for blazing performance. Java classfiles (as .class or .jar) can be much more compact than native binaries. There was some work done on disk seek time versus in-memory JIT compile for Oberon slim binaries, and small binaries which 'need some work' turned out better than native code [<a href="http://caesar.ics.uci.edu/oberon/research.html].">http://caesar.ics.uci.edu/oberon/research.html].</a> It seems likely oracle have made some assumptions (like: no roll-yer-own classloader) and applied some global optimizations - something you can't really do with class-at-a-time JIT compilation. BTW, gcc can compile java to native if you link the resulting binaries to glibj. I have no idea of how this performs though.
      </p>
      <hr/>
      <p>
        On April 20, 2001:
      </p>
      <p>
        Classic VM (build 1.3.0, J2RE 1.3.0 IBM build cn130-20010207 (JIT enabled: jitc)
      </p>
      <code>
        C:\tmp>c:\jdk1.3.0_02\bin\java -classic TextFileTest<br/>
        Vector time (secs): 27.299<br/>
        ArrayList time (secs): 25.257<br/>
      </code>
      <p>
        Java <a href="HotSpot.html">HotSpot</a>(TM) Client VM (build 1.3.0_02, mixed mode)
      </p>
      <code>
        C:\tmp>c:\IBMJDK13\bin\java -Xmx256m -Xms256m TextFileTest<br/>
        Vector time (secs): 0.761<br/>
        ArrayList time (secs): 0.711<br/>
      </code>
      <p>
        See <a href="JavaTextFilePerformance.html">JavaTextFilePerformance</a>
      </p>
      <p>
        -- <a href="StevenNewton.html">StevenNewton</a>
      </p>
      <hr/>
      <hr/>
      <p>
        WhitePapers:
      </p>
      <code>
        Html: <a href="http://java.sun.com/products/hotspot/docs/whitepaper/Java_HotSpot_WP_Final_4_30_01.html">http://java.sun.com/products/hotspot/docs/whitepaper/Java_HotSpot_WP_Final_4_30_01.html</a><br/>
        Pdf:  <a href="http://java.sun.com/products/hotspot/docs/whitepaper/Java_HotSpot_WP_Final_4_30_01.pdf">http://java.sun.com/products/hotspot/docs/whitepaper/Java_HotSpot_WP_Final_4_30_01.pdf</a><br/>
      </code>
      <hr/>
      <p>
        <a href="CategoryJava.html">CategoryJava</a>
      </p>
    </div>
  </body>
</html>