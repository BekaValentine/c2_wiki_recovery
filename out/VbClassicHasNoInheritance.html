<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Vb Classic Has No Inheritance
      </h1>
      <p>
        See <a href="InheritanceInVbClassic.html">InheritanceInVbClassic</a>
      </p>
      <hr/>
      <p>
        Often used as a proof of the lack of object-oriented-ness (whatever that means) of <a href="VbClassic.html">VbClassic</a>, and therefore it's unusability as a language for real programmers. The argument is total rubbish of course.
      </p>
      <p>
        - VB6 supports <a href="InterfaceInheritance.html">InterfaceInheritance</a> but not <a href="ImplementationInheritance.html">ImplementationInheritance</a> // Not true. See below.
      </p>
      <p>
        - VB.Net (<a href="VisualBasicDotNet.html">VisualBasicDotNet</a>) supports <a href="InterfaceInheritance.html">InterfaceInheritance</a> and <a href="ImplementationInheritance.html">ImplementationInheritance</a>
      </p>
      <p>
        Since most OO texts never draw a distinction between <a href="ImplementationInheritance.html">ImplementationInheritance</a> and <a href="InterfaceInheritance.html">InterfaceInheritance</a>, we'll just have to keep guessing whether VB6 is OO or not...
      </p>
      <hr/>
      <p>
        In VB5 and VB6, Classes can have several interfaces. If a class implements an interface, it just has an interface more. It is not possible to create a new interface which inherits from another one. It is not possible to create subtypes. Objects can have several types, but there is no hierarchical relation between these types. (Except very few special cases, like: instances of any user-defined form (not UserForm?) are also of type Form.) If you want to use an instance of a class which implements several interfaces, you have to decide which of these interfaces you want to use. VB does not create a new interface which combines the features of the different implemented interfaces.
      </p>
      <p>
        <em>On interface inheritance/extension: You can declare that "every class that implements IX must also implement IY," and thus achieve a similar effect to IX 'inheriting from' IY. In practice, interface inheritance has proven to be a bad thing in COM, and Microsoft discourages its use: IMoniker inherits from IPersistStream, which "seemed like a good idea at the time". But now we have IMoniker implementations that don't implement any IPersistStream methods (returning E_NOTIMPL for all of them). This is bad style; it violates the interface contract. But because interface inheritance was used, this can't be fixed. -- </em><a href="JeffGrigg.html">JeffGrigg</a><em></em>
      </p>
      <p>
        Of course, one might argue that the underlying problem here is with the design of COM...
      </p>
      <p>
        <em>Or not. COM got it right with interface inheritance which influenced the design of Java as well as others...</em>
      </p>
      <hr/>
      <p>
        <em></em><a href="VbClassic.html">VbClassic</a> has had polymorphism via <a href="InterfaceInheritance.html">InterfaceInheritance</a> since VB3. And that's the important part.<em></em>
      </p>
      <p>
        VB before VB7 does not support <a href="ImplementationInheritance.html">ImplementationInheritance</a> (see above). The keyword "implements" works since VB5. VB does support polymorphism via late binding since VB4 and via variants since VB1.
      </p>
      <hr/>
      <p>
        <a href="ImplementationInheritance.html">ImplementationInheritance</a> can be a real convenience, especially when you wish to conditionally override functionality, as is common in frameworks. But one can be quite successful even without some of modern life's conveniences.
      </p>
      <p>
        <em>Undoubtedly it can be useful, but it can also lead to the </em><a href="FragileBaseClassProblem.html">FragileBaseClassProblem</a>, especially at a component level.<em></em>
      </p>
      <p>
        <em>Overriding functionality is often best done via an interface rather than a base class. </em><a href="ImplementationInheritance.html">ImplementationInheritance</a> often introduces a fuzzy contract between base class and deriving class. This can be hard to test; interactions between base and derived can be complex and hard to understand; and it can result in a very hard to change base class.<em></em>
      </p>
      <p>
        I am not sure what you mean by <em>fuzzy contract</em>; the base class has a contract to support all methods that are accessible from the derived class. This applies to variables too, though I have come round to the thinking that variables should be accessible only via accessor methods, even to derived classes. The question <a href="ShouldMemberVariablesBeAccessibleToDerivedClasses.html">ShouldMemberVariablesBeAccessibleToDerivedClasses</a> is debatable.
      </p>
      <p>
        <em>I agree I was being unclear. What I meant is that it may be clear when first written, but can easily become fuzzy over time, i.e. nobody knows what it does or it becomes very complex.</em>
      </p>
      <p>
        Many Java programmers would do well to remember this contract, and use <strong>private</strong> or <strong>final</strong> where they are not certain that future implementations will stick to it.
      </p>
      <hr/>
      <p>
        <a href="CategoryVbClassic.html">CategoryVbClassic</a>
      </p>
    </div>
  </body>
</html>