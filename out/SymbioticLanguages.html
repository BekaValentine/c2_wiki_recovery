<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Symbiotic Languages
      </h1>
      <p>
        The idea that big, evolving systems are best built using two layers, one hard and one soft (see <a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a>), implies that such projects will need two languages, one hard and one soft (where a Hard Language is what we usually call a <a href="ProgrammingLanguage.html">ProgrammingLanguage</a> and a Soft Language is what we often call a <a href="ScriptingLanguage.html">ScriptingLanguage</a>). 
      </p>
      <p>
        This suggests that attempting to invent languages to build big systems is folly; rather, we need to develop pairs of languages, that work well together - <a href="SymbioticLanguages.html">SymbioticLanguages</a>, if you will. 
      </p>
      <p>
        Are there examples of such symbiosis?
      </p>
      <p>
        <em>Perhaps the better requirement is a standard </em><a href="ForeignFunctionInterface.html">ForeignFunctionInterface</a> or protocol (such as Corba or pipes), so that <em>any</em> conforming soft language can interoperate with <em>any</em> conforming hard language.<em></em>
      </p>
      <ul>
        <li>
          A <em></em><a href="HardLanguage.html">HardLanguage</a><em> that supports flexible </em><a href="MetaProgramming.html">MetaProgramming</a><em> should be able to perform both tasks.</em>
        </li>
      </ul>
      <hr/>
      <ul>
        <li>
           Unix has <a href="CeeLanguage.html">CeeLanguage</a> as its "hard" language and the <a href="UnixShell.html">UnixShell</a> language as its "soft" language.
          <ul>
            <li>
               Of course, nowadays there are much more "hard" and "soft" languages available for unix, but this separation used to be pretty clear (and was officially condoned by its designers). Both languages were designed on unix.
              <ul>
                <li>
                   C (including C++) is still pretty much the <em>de facto</em> hard layer for Unix.  You have many more choices for the soft layer; including Java, Perl, Python, the traditional shells, etc.
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           On the <a href="CommodoreSixtyFour.html">CommodoreSixtyFour</a> and the <a href="AppleIi.html">AppleIi</a>, <a href="BasicLanguage.html">BasicLanguage</a> and <a href="AssemblyLanguage.html">AssemblyLanguage</a> were soft and hard layers.
        </li>
      </ul>
      <ul>
        <li>
           This was full recognised with <a href="BbcBasic.html">BbcBasic</a> which as well has using one of the higher level <a href="BasicLanguage.html">BasicLanguage</a> variants of the era had a built in inline assembler. 
        </li>
      </ul>
      <ul>
        <li>
           On OS/8 (PDP-8), RSTS/E (PDP-11), and TOPS-20 (PDP-10), <a href="BasicLanguage.html">BasicLanguage</a> and <a href="AssemblyLanguage.html">AssemblyLanguage</a> were soft and hard layers.
        </li>
      </ul>
      <ul>
        <li>
           In ControlProgramForMicrocomputers (CP/M), <a href="BasicLanguage.html">BasicLanguage</a> and SUB files (like DOS batch files) were soft layers and <a href="AssemblyLanguage.html">AssemblyLanguage</a> was the hard layer.
        </li>
      </ul>
      <ul>
        <li>
           In <a href="MsDos.html">MsDos</a>, <a href="BasicLanguage.html">BasicLanguage</a> and BatchFiles were soft layers while <a href="AssemblyLanguage.html">AssemblyLanguage</a>, <a href="CeeLanguage.html">CeeLanguage</a>, and <a href="PascalLanguage.html">PascalLanguage</a> were hard layers.
        </li>
      </ul>
      <ul>
        <li>
           In the <a href="IncompatibleTimeSharingSystem.html">IncompatibleTimeSharingSystem</a>, <a href="MacLisp.html">MacLisp</a> was the soft layer and <a href="AssemblyLanguage.html">AssemblyLanguage</a> (via the MIDAS assembler) was the hard layer.
        </li>
      </ul>
      <ul>
        <li>
           In MVS, <a href="RexxLanguage.html">RexxLanguage</a> was a soft layer and <a href="AssemblyLanguage.html">AssemblyLanguage</a> was a hard layer.  (Whether JCL was a hard layer or a soft layer is left as an exercise for the reader.)
        </li>
      </ul>
      <ul>
        <li>
           In VMS, soft layers were <a href="BasicLanguage.html">BasicLanguage</a> and DCL while hard layers were <a href="FortranLanguage.html">FortranLanguage</a>, <a href="CobolLanguage.html">CobolLanguage</a>, <a href="CeeLanguage.html">CeeLanguage</a>, <a href="BlissLanguage.html">BlissLanguage</a>, and <a href="AssemblyLanguage.html">AssemblyLanguage</a>.
        </li>
      </ul>
      <ul>
        <li>
           In GNU Emacs, <a href="EmacsLisp.html">EmacsLisp</a> is the soft layer and <a href="CeeLanguage.html">CeeLanguage</a> is the hard layer.
        </li>
      </ul>
      <ul>
        <li>
           In the <a href="LampPlatform.html">LampPlatform</a> <a href="WebDevelopmentToolChain.html">WebDevelopmentToolChain</a>, <a href="PhpLanguage.html">PhpLanguage</a> is the hard layer and <a href="SqlLanguage.html">SqlLanguage</a> is the soft layer. Or vice versa.
        </li>
      </ul>
      <ul>
        <li>
           In the <a href="MicrosoftWindows.html">MicrosoftWindows</a> world...
          <ul>
            <li>
               circa 2005, C/C++ is the hard layer, and <a href="DotNet.html">DotNet</a> (take your pick) the soft layer.  Or, VB.NET & C# are hard; C/C++ very hard; various scripting .Net languages soft -- <a href="JscriptDotNet.html">JscriptDotNet</a>, <a href="PerlLanguage.html">PerlLanguage</a> & <a href="PythonLanguage.html">PythonLanguage</a>.
            </li>
            <li>
               before this:  <a href="VbClassic.html">VbClassic</a> hard, C/C++ very hard, and various ActiveX (COM) scripting languages could be used for soft layers -- typically <a href="JavaScript.html">JavaScript</a> and Visual Basic Scripting.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           In <a href="JavaPython.html">JavaPython</a>, you can use <a href="PythonLanguage.html">PythonLanguage</a> as a soft layer and <a href="JavaLanguage.html">JavaLanguage</a> as a hard layer.
        </li>
      </ul>
      <ul>
        <li>
           The first system I used like this was a Honeywell 316, where the soft layer was in <a href="BasicLanguage.html">BasicLanguage</a> and the hard layer was compiled subroutines in <a href="FortranLanguage.html">FortranLanguage</a>. -- <a href="JohnFletcher.html">JohnFletcher</a>
        </li>
      </ul>
      <ul>
        <li>
           In <a href="JavaServlets.html">JavaServlets</a>, JSP and XML are (sort of) soft layers and <a href="JavaLanguage.html">JavaLanguage</a> is a hard layer.
        </li>
      </ul>
      <ul>
        <li>
           <a href="LispLanguage.html">LispLanguage</a> is a hard layer and application specific syntax implemented using <a href="LispMacros.html">LispMacros</a> is a soft layer.
        </li>
      </ul>
      <ul>
        <li>
           <a href="ForthLanguage.html">ForthLanguage</a> is a hard layer and application specific syntax implemented using <a href="ForthImmediateWords.html">ForthImmediateWords</a> is a soft layer.
        </li>
      </ul>
      <ul>
        <li>
           C and Haskell can work in a very PB&J sort of way, though many would say that's alternating diamonds and granite instead of crust and cheese.
        </li>
      </ul>
      <ul>
        <li>
           C, Python and Guile are an inherently inter-supportive mix, at least on a Unix type styem. C is hard, Python and Guile are both soft with the latter soft enough to be a good user-end scripting interface (particularly if your target audience has any experience with AutoCAD, lispy quest scripting for game engines, Emacs, etc.).
        </li>
      </ul>
      <hr/>
      <p>
        Many scripting languages have well defined C APIs, and are designed either to be embedded into a C program, or extended with dynamically loaded C libraries, or both.  <a href="EmbeddedLanguage.html">EmbeddedLanguage</a>s include <a href="ToolCommandLanguage.html">ToolCommandLanguage</a> and <a href="LuaLanguage.html">LuaLanguage</a>.  Languages designed with dynamic extension APIs include <a href="ToolCommandLanguage.html">ToolCommandLanguage</a>, <a href="PythonLanguage.html">PythonLanguage</a> and <a href="RubyLanguage.html">RubyLanguage</a>.
      </p>
      <p>
        Most, if not all, implementations of <a href="CommonLisp.html">CommonLisp</a> provide a foreign function interface ("FFI") which can be used to call C (and sometimes C++ or Fortran) functions from Lisp, and vice versa.
      </p>
      <p>
        <em>Perhaps </em>EverythingIsSymbioticWithCee?<em></em>
      </p>
      <hr/>
      <p>
        In the Windows world VB + C++/ATL/COM has proved very powerful.  Now C# + ManagedC++ appears to be a great way to mix legacy or performance-sensitive C++ code into the softer .Net world.
      </p>
      <hr/>
      <p>
        <a href="HtagLanguage.html">HtagLanguage</a> paired with <a href="DelphiLanguage.html">DelphiLanguage</a> provides such a pair as well.
      </p>
      <hr/>
      <p>
        <strong>Q:</strong> <em>Are </em><a href="JavaLanguage.html">JavaLanguage</a> and <a href="ExtensibleMarkupLanguage.html">ExtensibleMarkupLanguage</a> symbionts?  Certainly <a href="RelationalWeenie.html">RelationalWeenie</a>s lump them together for abuse.  They seem to travel and propagate together very often.   Why might this be?<em></em>
      </p>
      <p>
        Possible <strong>A:</strong> Symbiotic languages have to live in the same environment and each do things the other doesn't do well.  Java and XML both live in the same target-space: distributed, cross-platform applications.  They both target the <a href="AverageProgrammer.html">AverageProgrammer</a> by building off of known quantities: <a href="CeeLanguage.html">CeeLanguage</a> and <a href="HyperTextMarkupLanguage.html">HyperTextMarkupLanguage</a>.  If it's true that XmlIsAPoorCopyOfEssExpressions, XML makes up for Java's limited <a href="FunctionalProgramming.html">FunctionalProgramming</a> capabilities.  And Java's object model, while perhaps limited, can be a convenient way to wrap XML's structured data together with code.  Thus, symbiotic.  Any thoughts?
      </p>
      <p>
        Another possible <strong>A:</strong> Just a coincidence of timing -- both became popular at about the same time.
      </p>
      <hr/>
      <p>
        I vote for the first bullet above: "A <a href="HardLanguage.html">HardLanguage</a> that supports flexible <a href="MetaProgramming.html">MetaProgramming</a> should be able to perform both tasks." 
      </p>
      <p>
        IMO, there is a widespread opportunity to use two symbiotic languages, partly inspired by <a href="TgpMethodology.html">TgpMethodology</a>. See: <a href="OfficeInfotechSymbiosis.html">OfficeInfotechSymbiosis</a>. 
      </p>
      <p>
        -- <a href="EdwinEarlRoss.html">EdwinEarlRoss</a>
      </p>
    </div>
  </body>
</html>