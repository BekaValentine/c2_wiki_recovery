<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Symbolic Programming
      </h1>
      <p>
        Mathematica does a form of <a href="FunctionalProgramming.html">FunctionalProgramming</a> and does symbolic math. Wolfram chooses to call this "<a href="SymbolicProgramming.html">SymbolicProgramming</a>".
      </p>
      <p>
        Note that it appears that this term differs from <a href="FunctionalProgramming.html">FunctionalProgramming</a> only in its use by <a href="StephenWolfram.html">StephenWolfram</a> and his company, <a href="WolframResearch.html">WolframResearch</a>, in promoting <a href="MathematicaPackage.html">MathematicaPackage</a> (which is indeed a powerful tool), and as such apparently means "whatever cool programming features that Mathematica offers". My understanding based on limited use of Mathematica is that it is a multi-paradigm tool, so the definition probably cannot be made truly concise in any case.
      </p>
      <p>
        That is, "symbolic programming" in the Mathematica sense does not appear to be a term that has caught on in the rest of the world outside Wolfram/Mathematica.
      </p>
      <p>
        <em>Mathematica is a symbolic computer algebra system. They use</em> symbolic <em>in the mathematical sense.</em>
      </p>
      <p>
        I said what I meant. I know Macsyma, I know Mathematica, I know Lisp, and I'm telling you, Wolfram uses the phrase "symbolic programming" as a marketing term, with a meaning specific to Mathematica, not shared by e.g. Macsyma nor the rest of the non-Mathematica world. I know what I'm talking about; you go do your own homework.
      </p>
      <p>
        <em>For example, if you do 1.0/3*3 in, say, C, it divides 1.0 by 3 and then multiplies the result by 3. You get 0.9999999999998. Mathematica (and other symbolic mathematics software, for example Macsyma/Maxima) treats numbers as symbols... Like, 1/3*3 is not a lot different from a/b*b until you need the actual result in numeric form. Since a/b*b is a, 1/3*3 is 1. No</em> computation <em>with actual numeric values needed.</em>
      </p>
      <p>
        Yeah, yeah, yeah. True, and irrelevant.
      </p>
      <p>
        <em>Also, I don't think that </em><a href="SymbolicProgramming.html">SymbolicProgramming</a> is all that new. <a href="LispLanguage.html">LispLanguage</a> is symbolic. The second oldest high level programming language.<em></em>
      </p>
      <p>
        Yeah, yeah, yeah. True, and irrelevant. I'm telling you, that's not the same thing as what Wolfram means by the term
      </p>
      <p>
        <em>Example from Macsyma:</em>
      </p>
      <code>
        C1: expand((a+b)^2);<br/>
        A^2 + 2*A*B + B^2<br/>
      </code>
      <p>
        Yeah, yeah, yeah, been there, done that, got the T-shirt, wrote my own computer algebra system. This is all irrelevant to my point.
      </p>
      <p>
        <em>Isn't this like meta programming? For example a lisp function (or any language) could do exactly above.</em>
      </p>
      <code>
        CL-USER> (expand '(^ (+ a b) 2))<br/>
        ==> (+ (^ a b) (* a b) (^ b 2))<br/>
      </code>
      <p>
        <em>Then combine with Macro and variable binding we could have execute this</em>
      </p>
      <code>
        CL-USER> (let ((a 1) (b 2))<br/>
        (expand-m (^ (+ a b) 2)))  ;expand as above and put it as code.<br/>
        ==> ;return the result of computing.<br/>
      </code>
      <hr/>
      <p>
        "Major new approaches to programming happen rarely and, when they do, they are often absorbed slowly. With the <a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a> approach to software design now widely adopted, the world seems ready for another, even more dramatic change - symbolic programming. This methodology has now reached the point where it can be put to use immediately, enabling a new generation of computing throughout engineering." -- Originally published in IEEE Spectrum, January 1999, excerpt from <a href="http://www.wolfram.com/news/germundsson.html">http://www.wolfram.com/news/germundsson.html</a>
      </p>
      <p>
        "In this paradigm all different kinds of objects - formulas, lists, data, and graphics, to name a few - are represented in a uniform way as expressions. A prototypical example of a Mathematica expression is f[x]. This expression can represent a mathematical function, a graphic, a sound, a program, or even a complete Mathematica notebook. Functions can be both input and output of another function, enabling very concise and simple coding. Also, since algorithms can be parameterized not only by numbers or some fixed number of parameters but also by functions, algorithms are infinitely more flexible."
        <a href="http://www.wolfram.com/products/mathematica/technologies/programming.html">http://www.wolfram.com/products/mathematica/technologies/programming.html</a>
      </p>
      <p>
        Another excerpt: "With all objects represented in a uniform way, computing reduces to just one fundamental operation: transforming one expression into another. Such uniformity makes it possible to mix different programming styles, just as it lets different domains of engineering and mathematics be combined." 
      </p>
      <p>
        So... this "major new approach to computing" wouldn't have been invented by <a href="JohnMcCarthy.html">JohnMcCarthy</a> about forty years ago, then?
      </p>
      <p>
        <em>Pure double-speak, check out the examples.</em> 
      </p>
      <p>
        Which bit is double-speak, and what examples am I to check out? There's nothing mentioned in the article referenced above that can't be done fairly quickly and easily by anyone who cares to using a <a href="LispLanguage.html">LispLanguage</a>. Indeed, a lot of people have already done this sort of thing using a Lisp. If you want symbolic programming to mean stuff that languages like <a href="MercuryLanguage.html">MercuryLanguage</a> make easy, then the article does not well serve your purpose, I think.
      </p>
      <hr/>
      <p>
        "...computing reduces to just one fundamental operation: transforming one expression into another."
      </p>
      <p>
        How is this different from <a href="FunctionalProgramming.html">FunctionalProgramming</a>?
      </p>
      <p>
        There is more to computing than transformations. How would side effects be represented? <a href="FunctionalProgramming.html">FunctionalProgramming</a> and <a href="LogicProgramming.html">LogicProgramming</a> make writing programs with side effects more complicated than most people are willing to put up with. Would <a href="SymbolicProgramming.html">SymbolicProgramming</a> have the same drawback?
      </p>
      <hr/>
      <p>
        As far as I can see, the big difference between a real <a href="FunctionalProgrammingLanguage.html">FunctionalProgrammingLanguage</a> and things like Mathematica is that Mathematica is not confluent, that is, different evaluation orders may lead to different results. For example, in Mathematica F[1+2] can produce something different than F[3]. In Lisp, macros can make such distinctions, but in Mathematica, every function has such capabilities. In interpreting something like F[x], it is not enough to know that x was bound to 1+2, we also need to know if 1+2 was evaluated before being bound to x. All this evaluation-order-dependency allows many new exciting ways to introduce bugs.
      </p>
      <hr/>
      <p>
        Here's a pquestion - how do you combine OO with <a href="SymbolicProgramming.html">SymbolicProgramming</a>? For instance suppose you had Current, Voltage, Resistance, CurrentDensity classes but you wanted to store the equations symbolically in the most compact form, and use a solve() method as needed. I'm thinking you could have an Equation Class to store the formulas, but then how do you chose the most compact set before hand? Obviously for a small set it would be easier to just hard code them without <a href="SymbolicProgramming.html">SymbolicProgramming</a> but what if you wanted to map hundreds of equations to the respective classes of the variables? For example (pseudo-python)
      </p>
      <code>
        class Equation:<br/>
        Eqns =       [Voltage(v)=Current(i)*Resistance(r),      [CurrentDensity(J)=Current(i)/Area(A),    ...]<br/>
        def simplify(self,eqn):<br/>
        ...<br/>
        def solve(self,eqn):<br/>
        ...<br/>
      </code>
      <code>
        class Current:<br/>
        def value(self,Vars):<br/>
        e=Equation()<br/>
        return e.solve(Vars,"i")<br/>
      </code>
      <code>
        class CurrentDensity:<br/>
        def value(self,Vars):<br/>
        e=Equation()<br/>
        return e.solve(Vars,"J")<br/>
      </code>
      <code>
        def Voltage:<br/>
        def value(self,Vars):<br/>
        e=Equation()<br/>
        return e.solve(Vars,"V")<br/>
        ...etc<br/>
      </code>
      <p>
        Is this an instance of the <a href="StrategyPattern.html">StrategyPattern</a>? Would it be better to store the equation in the most "representative" class ie store V=I*R in Voltage and not in an Equation class?
      </p>
      <p>
        <em>I think one way of doing what you want is to use an implementation of a </em><a href="GroebnerBasis.html">GroebnerBasis</a>. There is such a thing included with <a href="SymbolicCpp.html">SymbolicCpp</a>, which implements symbolic expressions in <a href="CeePlusPlus.html">CeePlusPlus</a> using an internal tree representation. I have used that code. There may be other implementations.<em> -- </em><a href="JohnFletcher.html">JohnFletcher</a>
      </p>
      <p>
        The input is appreciated. The notion of basis did occur to me i.e. the smallest set of equations against which others could be referenced. But more than this both representations seem to describe the same thing, there must be a mapping between them. Not trying to build anything in particular right now, just seems to me another type of <a href="ImpedanceMismatch.html">ImpedanceMismatch</a>. Trying to understand what the correct transformer between them would be. Note I'm not saying there is any problem building a <a href="SymbolicProgramming.html">SymbolicProgramming</a> system using OO - <a href="SymbolicCpp.html">SymbolicCpp</a> obviously already is. But once you have generic classes that can solve(),simplify(),expand() etc and you want to build DomainObjects to take advantage of that functionality, what kind of patterns apply?
      </p>
      <hr/>
      <p>
        It's a fine distinction, but with symbolic languages equations can be 
        compared against e axioms and theorems:
      </p>
      <code>
        e(del*'H'='Jc'+d('D')/d(t)).<br/>
        query: e(del*'H'=Q) returns Q='Jc'+d('D')/d(t);<br/>
      </code>
      <p>
        as well as referenced by a label such as:
      </p>
      <code>
        e2(del*'H'='Jc'+d('D')/d(t),amperes_law).<br/>
        ?- e2(E,amperes_law) -> del*'H'='Jc'+d('D')/d(t);<br/>
      </code>
      <hr/>
      <p>
        See also <a href="SymbolicCpp.html">SymbolicCpp</a>, <a href="MathematicaLanguage.html">MathematicaLanguage</a>
      </p>
    </div>
  </body>
</html>