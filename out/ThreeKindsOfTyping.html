<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Three Kinds Of Typing
      </h1>
      <p>
        There are three ways languages deal with types.
      </p>
      <ul>
        <li>
           <strong></strong><a href="StaticTyping.html">StaticTyping</a>.<strong> This is where every variable, function parameter, and function return value has a type which is advertised in the language. This is typically used in compiled languages. The compiler can diagnose incompatible type errors. This is used in </strong><a href="CeeLanguage.html">CeeLanguage</a> and <a href="CeePlusPlus.html">CeePlusPlus</a>.
        </li>
      </ul>
      <ul>
        <li>
           <strong></strong><a href="DynamicTyping.html">DynamicTyping</a>.<strong> This is where values have types and know their own types, but variables, function parameters, and function return values don't have types. In other words, in order to find out whether a function returns an integer or a string, you have to consult the code for that function, or the documentation, or you have to experiment with it -- the language itself doesn't tell you. This is typically used in interpreted languages, like </strong><a href="SchemeLanguage.html">SchemeLanguage</a> and <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>.
        </li>
      </ul>
      <ul>
        <li>
           <strong>No Typing.</strong> This is the typing that is used in <a href="AssemblyLanguage.html">AssemblyLanguage</a> and <a href="ForthLanguage.html">ForthLanguage</a>. A variable does not have a type, and a value does not know its own type. If you pass a Boolean to a function that expects a string, the function will interpret the bits of the Boolean as if they were bits that described a string, with possibly disastrous results. However, languages with no typing are the easiest to implement! (Not necessarily.) Note that not all languages actually <em>have</em> different types: see <a href="LambdaCalculus.html">LambdaCalculus</a>.
        </li>
      </ul>
      <hr/>
      <ul>
        <li>
           <strong>No Typing.</strong>
        </li>
      </ul>
      <p>
        While it's true that <a href="AssemblyLanguage.html">AssemblyLanguage</a> doesn't "have types" in the sense that, say, C does, it does in fact have types -- just not "floats" or "enum" or other artificial constructs.  Bytes and words and bits are very real types in <a href="AssemblyLanguage.html">AssemblyLanguage</a>, and addresses (pointers) are a real thing.  Further, flags (a kind of bit, grouped in a word) are a type.  What <a href="AssemblyLanguage.html">AssemblyLanguage</a> does not have is rules about higher level type abstractions.  These can be crafted in <a href="AssemblyLanguage.html">AssemblyLanguage</a>, and the result is called a "compiler" or an "interpreter."
      </p>
      <p>
        <a href="ForthLanguage.html">ForthLanguage</a> has types when it's convenient, and eschews them when it's not.  Oddly, although <a href="ForthLanguage.html">ForthLanguage</a> is "higher level" than <a href="AssemblyLanguage.html">AssemblyLanguage</a>, its very abstraction can create an effective "typelessness" where data can be either "waves or particles" depending on the programmer's mood.  When a <a href="ForthLanguage.html">ForthLanguage</a> context requires it, a word can be written to enforce typing semantics, but more often the programmer is allowed to be as strict or as loose as he deems appropriate.  Think "stick shift" and "rack-and-pinion" with a machine shop in the back seat to build "cruise control" when needed.
      </p>
      <p>
        -- <a href="GarryHamilton.html">GarryHamilton</a>
      </p>
      <hr/>
      <p>
        <a href="http://perl.plover.com/yak/typing/typing.html">http://perl.plover.com/yak/typing/typing.html</a> is a very good article about type systems. Most of the examples are in C, Pascal and <a href="ObjectiveCaml.html">ObjectiveCaml</a>. It hardly mentions perl.
      </p>
      <p>
        For another typing model, see <a href="TypingQuadrant.html">TypingQuadrant</a>.
      </p>
      <hr/>
      <p>
        The following URL explains all of this much better than I did.
        <a href="http://www.cs.cornell.edu/courses/cs412/2002sp/lectures/lec12.ps">http://www.cs.cornell.edu/courses/cs412/2002sp/lectures/lec12.ps</a>
      </p>
      <p>
        The entire debate about typing seems to be deeply flawed because people are misusing terms like static/dynamic/weak/strong and also because the comparisons are always made between essentially flawed type systems like Pascal/C versus Smalltalk. I'd like to see some comparison of the type systems in OCaml/Haskell versus Smalltalk/Python/Ruby.--<a href="AdewaleOshineye.html">AdewaleOshineye</a>
      </p>
    </div>
  </body>
</html>