<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Proxy Pattern
      </h1>
      <p>
        A rather vague pattern name, which might refer to any of the following:
      </p>
      <ul>
        <li>
           <a href="ProtectionProxy.html">ProtectionProxy</a>
        </li>
        <li>
           <a href="RemoteProxy.html">RemoteProxy</a>
        </li>
        <li>
           <a href="CaretakerPattern.html">CaretakerPattern</a>
        </li>
        <li>
           <a href="LazyInstantiationPattern.html">LazyInstantiationPattern</a>
        </li>
        <li>
           any other <a href="HandleBodyPattern.html">HandleBodyPattern</a>.
        </li>
      </ul>
      <p>
        In the GOF book, <a href="ProxyPattern.html">ProxyPattern</a> is described with the following intent: "Provide a surrogate or placeholder for another object to control access to it."
      </p>
      <p>
        This is a <a href="ProtectionProxy.html">ProtectionProxy</a>, or possibly <a href="CaretakerPattern.html">CaretakerPattern</a>. However, the term "proxy" is more commonly used to refer to <a href="RemoteProxy.html">RemoteProxy</a>, or for handles / wrapper objects (see <a href="HandleBodyPattern.html">HandleBodyPattern</a>).
      </p>
      <hr/>
      <p>
        Simply speaking, a Proxy object is one through which we control access to the actual object on which the functionality lies. Depending on the context in which the Proxy object is used, the Pattern is broadly divided into the following 3 types:
      </p>
      <p>
        <strong>'Virtual Proxy:</strong>' Used for Lazy instantiation of objects or for Lazy processing. Suppose you need to support 'resource-hungry' objects that involve high amount of I/O or one those that involved a database transaction. One need not instantiate these objects until they are really required. The real object would get created only when the client actully requests for some of its functionality. 
      </p>
      <p>
        <em>[This is </em><a href="LazyInstantiationPattern.html">LazyInstantiationPattern</a>.]<em></em>
      </p>
      <p>
        <strong>'Remote Proxy:</strong>' Used to hide the communication mechanisms between remote objects. In RMI, for example, we have the stubs which act as Remote Proxies for the Skeleton.
      </p>
      <p>
        <em>[This is </em><a href="RemoteProxy.html">RemoteProxy</a>.]<em></em>
      </p>
      <p>
        <strong>'Access Proxy:</strong>' Used to provide control over a sensitive master object. This proxy object could check for the client's access permission before allowing methods to be executed on the actual object.
      </p>
      <p>
        <em>[This is </em><a href="ProtectionProxy.html">ProtectionProxy</a>.]<em></em>
      </p>
      <p>
        There are also a proxy type called <strong>'Smart Proxy</strong>'. This could provide additional functionality over that offered by the existing object.
      </p>
      <p>
        <em>[This is </em><a href="DecoratorPattern.html">DecoratorPattern</a>.]<em></em>
      </p>
      <p>
        eg. Suppose an existing class provides a set of non-threadsafe functions. Instead of modifying the existing class to be threadsafe, a smart proxy could be used to synchronize the method calls.
      </p>
      <p>
        <em>[This should probably be given another name; it is in </em><a href="CategoryConcurrencyPatterns.html">CategoryConcurrencyPatterns</a>. The Java collections API uses it.]<em></em>
      </p>
      <p>
        -- <a href="AbhishekGupta.html">AbhishekGupta</a>
      </p>
      <p>
        Could you list some example code for each kind of proxy? -- will.wang
      </p>
      <hr/>
      <p>
        KCS:
        The Proxy Class in Java and C# is the only way I know of to dynamically inherit an already instantiated object, and, in effect, create a sort of "Runtime Multiple Inheritance". More and more at work, I seeing how this can really help my multi-layered applications.
      </p>
      <p>
        <em>Proxies are Dangerous</em>
      </p>
      <p>
        <a href="SamGentile.html">SamGentile</a> noted in his blog that "If the programming model for your distributed technology of choice includes the concept of a proxy, you're being forced into distributed object semantics".
      </p>
      <hr/>
      <p>
        <a href="http://home.earthlink.net/~huston2/dp/proxy.html">http://home.earthlink.net/~huston2/dp/proxy.html</a>
      </p>
      <p>
        <a href="http://wiki.cs.uiuc.edu/patternStories/ProxyPattern">http://wiki.cs.uiuc.edu/patternStories/ProxyPattern</a>
      </p>
      <p>
        <a href="http://delphipatterns.blog.com/2011/02/22/proxy-2/">http://delphipatterns.blog.com/2011/02/22/proxy-2/</a>
      </p>
      <hr/>
      <p>
        <strong>See also:</strong> <a href="CompositePattern.html">CompositePattern</a>, <a href="DecoratorPattern.html">DecoratorPattern</a>, <a href="DesignPatterns.html">DesignPatterns</a>, <a href="LazyProxies.html">LazyProxies</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryPattern.html">CategoryPattern</a> | <a href="CategoryStructuralPatterns.html">CategoryStructuralPatterns</a>
      </p>
    </div>
  </body>
</html>