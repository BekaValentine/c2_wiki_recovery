<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Objections To Working Test First
      </h1>
      <p>
        A savage deceased equine flagellation mosh instigated by the usual instigatrix on the <a href="XpMailingList.html">XpMailingList</a>...
      </p>
      <p>
        Legend: Pro, <em>Con</em>.
      </p>
      <p>
        Ward's Wiki can get its lashes in at <a href="WikiObjectionsToWorkingTestFirst.html">WikiObjectionsToWorkingTestFirst</a>.
      </p>
      <hr/>
      <p>
        <em>I'm working on compiling a list of reasons that people use to object to </em><a href="TestDrivenDevelopment.html">TestDrivenDevelopment</a> and/or <a href="TestFirst.html">TestFirst</a>.<em></em>
      </p>
      <p>
        I'm also interested in any pro Test First arguments that people have used,
        successfully or not.
      </p>
      <p>
        --<a href="KayPentecost.html">KayPentecost</a>
      </p>
      <p>
        <em>But Kay - isn't that a bias to assume none of the Con arguments could have been successful??</em> --<a href="PhlIp.html">PhlIp</a>
      </p>
      <hr/>
      <p>
        A related blog post, titled "The Cost of NOT Doing TDD": <a href="http://christiansepulveda.com/blog/archives/000040.html">http://christiansepulveda.com/blog/archives/000040.html</a>
      </p>
      <hr/>
      <p>
        <em>TDD is "red, green, refactor". If we're under pressure, the refactor bit won't happen, and we'll be left with hacked code.</em>
      </p>
      <p>
        It results in a design that better suits the problem.
      </p>
      <p>
        --TimHaughton
      </p>
      <p>
        <em>It would slow me down.</em>
      </p>
      <p>
        <em>Everyone knows that testing can't prove that a program works.</em>
      </p>
      <p>
        <em>I already know a good design for my program so I don't need TDD.</em>
      </p>
      <p>
        <em>Some things are hard to test.</em>
      </p>
      <p>
        --<a href="RonJeffries.html">RonJeffries</a>
      </p>
      <p>
        <em>Writing tests is boring.</em>
      </p>
      <p>
        <em>I don't know how to write tests.</em>
      </p>
      <p>
        <em>It won't catch the tricky bugs anyway.</em>
      </p>
      <p>
        --Daniel_org
      </p>
      <p>
        <em>One I just was presented with yesterday was, "I never know how to start.  What is the first test I should write?" Or another variation is, "I don't know what test to write until I write the code."</em>
      </p>
      <p>
        Some of my failed attempts to help the developers using the above objections are:
      </p>
      <ul>
        <li>
           If you can write the code first, there must be a test you could have written first.
        </li>
        <li>
           Always start with the *simplest* test first, just to get the rhythm started.
        </li>
      </ul>
      <p>
        Like I said, these haven't worked for me, so my next one is:
      </p>
      <ul>
        <li>
           Let's pair up and try it together.
        </li>
      </ul>
      <p>
        --JeffreyBrekke
      </p>
      <p>
        <em>"Writing tests is additional work; the client won't pay for it."</em>
      </p>
      <p>
        --EdmundSchweppe
      </p>
      <p>
        The client won't pay for bugs, so I test to get more payable code.
      </p>
      <p>
        --Thomas Eyde
      </p>
      <hr/>
      <p>
        <em>"I already test my code by running it!"</em>
      </p>
      <p>
        <em>"Test-driven development unnecessarily creates abstract overhead creating interfaces with only one real implementer."</em>
      </p>
      <p>
        <em>"Test-driven development creates a maintenance nightmare, now I have to maintain twice the code!"</em>
      </p>
      <p>
        <em>"Test-driven development's stressing of many small methods, classes and abstraction produces slow, highly inefficient code."</em>
      </p>
      <p>
        --ChrisWilliams
      </p>
      <p>
        If the client isn't willing to pay for automated tests, why would they agree to pay for manual tests? Perhaps they don't want to pay for any tests at all.
      </p>
      <p>
        Writing tests is "additional work"? Additional to what? Manual testing?
        We're suggesting that you _replace_ manual testing with automated testing.
        So the time lost to automated testing is recovered by not doing manual
        testing.
      </p>
      <p>
        You have to do testing; therefore you may as well automate the tests, so
        that you can run them again and again at marginal cost.
      </p>
      <p>
        When you have some practice with automating tests, it doesn't take any
        longer to write and run an automated test than it does to devise and perform
        the same test manually. Advantages:
      </p>
      <ul>
        <li>
           If it does take longer, the additional cost is incurred only once. Each time you re-run the automated test it costs nothing, while re-running manual tests is just as expensive each time as the first time.
        </li>
        <li>
           Automated tests can be combined with code-coverage tools to ensure that you have explored the boundary cases. You _can_ explore boundary cases with manual testing; it just takes longer.
        </li>
      </ul>
      <p>
        --<a href="AlistairBayley.html">AlistairBayley</a>
      </p>
      <p>
        <em>"I forgot."</em>
      </p>
      <p>
        The following arguments assume the developer is willing to write tests,
        but is resisting test-first techniques...
      </p>
      <p>
        It's more difficult to write tests for code after it's developed. One of
        the side effects of test first is that the code has to be testable as it's
        being written (by definition).
      </p>
      <p>
        With test first / TDD you only write the code you need which is often less
        the the code you think you'll need. It keeps you focused on the simplest
        solution because the effort required to implement a complicated solution
        that's not really needed will be opposed by the the required effort by
        relativey complicated testing.
      </p>
      <p>
        It encourages you to think relatively deeply about the software
        requirements before you start coding. This often results in less
        development backtracking and more development productivity.
      </p>
      <p>
        You are almost guaranteed to have great code testing coverage.
      </p>
      <p>
        --SteveBate
      </p>
      <p>
        <em>"It takes twice as long."</em>
      </p>
      <p>
        <em>"I can write my tests after writing the code."</em>
      </p>
      <p>
        <em>"I don't need to test everything, just the difficult things."</em>
      </p>
      <p>
        <em>"It's too hard to test the difficult things."</em>
      </p>
      <p>
        <em>"It's not a substitute for proper up-front design."</em>
      </p>
      <p>
        <em>"TDD promotes overconfidence in your code."</em>
      </p>
      <p>
        <em>"Maintaining the tests takes longer than maintaining the code."</em>
      </p>
      <p>
        <em>"The tests don't prove anything and are worthless."</em>  (this in a system where almost every test was a bad method-sequencing-based mock test.)
      </p>
      <p>
        <em>"Making a small change breaks lots of tests and takes a long time to fix."</em> (from the same system)
      </p>
      <p>
        <em>"I'm a programmer, not a tester."</em>
      </p>
      <p>
        <em>"My code doesn't need tests."</em> (gotta like this one)
      </p>
      <p>
        Pro: You vill enjoy it!  Or else!
      </p>
      <p>
        Almost no one has done TDD honestly and properly for
        more than a few weeks and come back saying it's a waste
        of time. Most of the time, you can see the lightbulb over
        their head and the glee in what TDD does for them.  A story
        helps here; mine involves seeing this in <a href="JerryJackson.html">JerryJackson</a>, veteran
        coder and one of the first Java authors. It's fun, it's cool, 
        it's a floor wax and dessert topping!
      </p>
      <p>
        Pro: Tests are specs/documentation.
      </p>
      <p>
        You can't write code without first specifying its detailed design.
        TDD is our way of making that a natural part of building the
        code. If you don't want to write tests, then you can choose to
        spend your time writing these nice thick documents with lots
        of pretty pictures, which you'll have to keep up to date
        constantly.
      </p>
      <p>
        --<a href="JeffLangr.html">JeffLangr</a>
      </p>
      <p>
        > "Writing tests is additional work; the client won't pay for it."
      </p>
      <p>
        On a similar note (and similar to the "it will slow me down" objection),
        <em>"If I tell my supervisor in a status report that I have a test written but not the code yet, he'll think I'm wasting time/productivity" or "he'll think I'm crazy (and unproductive) trying to write test for code that doesn't exist yet"</em>
      </p>
      <p>
        In terms of arguments for ... one that I've seen help with folks that have an attachment to waterfall or "V" lifecycle model is ...
      </p>
      <p>
        "Think of the test as an extremely rigorous formal requirement/spec for the code you are about to write - one that is far more precise than english prose."
      </p>
      <p>
        or
      </p>
      <p>
        "Think of the test as the "V" model in its ideal form of getting requirements writers and testers together at the beginning. You're going it one better by making the requirement and the test be the same thing"
      </p>
      <p>
        --EdmundSchweppe
      </p>
      <p>
        Just to expand on this a bit: there's no reason why you should have
        an incomplete unit test at status report time. As far as the acceptance
        test, you can always say that you're nailing down the test plan so
        you can be sure you meet it.
      </p>
      <p>
        --JohnRoth
      </p>
      <hr/>
      <p>
        Objection:
        <em>"We already have a large amount of legacy code in place, and writing new code would require way too much bootstrapping code just to get to the point of writing a test".</em>
      </p>
      <p>
        <em>"We don't have the time"</em>
      </p>
      <p>
        "Try a mock object framework"
      </p>
      <p>
        "Start with simpler code without any dependencies to get your feet wet"
      </p>
      <p>
        "Future code you write in a TDD fashion will naturally lead to code that is more loosely coupled and easier to test"
      </p>
      <p>
        "Try it, you'll never go back once you do -- at least that's my experience"
      </p>
      <p>
        "I'm still amazed at the stupid typos I end up catching even in the simplest code -- stuff that would have had me pulling my hair out with a debugger, but that I now catch immediately without a second thought"
      </p>
      <p>
        --PatrickOshaughnessey
      </p>
      <p>
        > "It's a total waste of time to test simple methods -- like getters
        > and setters"
      </p>
      <p>
        I actually agree with this one.  You shouldn't be testing getters &
        setters.  BUT you shouldn't write them unless they are needed to get a
        test to pass.
      </p>
      <p>
        --<a href="DaveAstels.html">DaveAstels</a>
      </p>
      <hr/>
      <p>
        <em>"But, hey : the tests are also code ! Twice more code, twice more bugs. And who is going to test all those tests ?"</em>
      </p>
      <p>
        -- <a href="ChristopheThibaut.html">ChristopheThibaut</a>
      </p>
      <hr/>
      <code>
        > <em>It would slow me down.</em><br/>
      </code>
      <p>
        Some minor variations on that one:
      </p>
      <p>
        <em>"We need to schedule in a week for writing tests - maybe next month."</em>
      </p>
      <p>
        <em>"Fred wrote some tests but they keep breaking so we don't run them anymore."</em>
      </p>
      <p>
        --<a href="TomCopeland.html">TomCopeland</a>
      </p>
      <p>
        <em>"It's hard to write tests." "It takes long time to write tests." "It is boring to write tests."</em>
      </p>
      <ul>
        <li>
           "The failure frequency will drop in the CSCI-test (acceptance test)" (And it did!)
        </li>
        <li>
           "If a bug occurs it will be easier to pin down, and will take less time to fix."
        </li>
        <li>
           "If a bug is fixed, we will know by regressiontests that no other error is introduced."
        </li>
        <li>
           "The red-to-green-bar-syndrome gets everyone happier."
        </li>
      </ul>
      <p>
        --/Mattias
      </p>
      <p>
        <em>We've already started the project and we didn't include TDD in our estimates.</em>
      </p>
      <p>
        <em>Our application is mostly GUI and we can not do that test first.</em>
      </p>
      <p>
        <em>It breaks my "flow".</em>
      </p>
      <p>
        <em>I lose sight of the big picture when I spend my time writing so many small tests.</em>
      </p>
      <p>
        --pier@nbnet.nb.ca
      </p>
      <p>
        <a href="TestFirstUserInterfaces.html">TestFirstUserInterfaces</a> ;-)
      </p>
      <p>
        --<a href="PhlIp.html">PhlIp</a>
      </p>
      <p>
        That's not an optical illusion; it just looks like one. 
      </p>
      <p>
        --<a href="DaleEmery.html">DaleEmery</a>
      </p>
      <hr/>
      <p>
        See <a href="MoreObjectionsToWorkingTestFirst.html">MoreObjectionsToWorkingTestFirst</a>, <a href="WikiObjectionsToWorkingTestFirst.html">WikiObjectionsToWorkingTestFirst</a>
      </p>
    </div>
  </body>
</html>