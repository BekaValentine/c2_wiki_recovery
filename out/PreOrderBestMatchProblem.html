<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Pre Order Best Match Problem
      </h1>
      <p>
        The <a href="PreOrderBestMatchProblem.html">PreOrderBestMatchProblem</a> is a generalization of a class of problems of the following form:
      </p>
      <p>
        Assume a set <strong>S</strong> and a binary relation <strong><=</strong> over <strong>S</strong> which is a PreOrder:  Now assume an element <em>X</em> in <strong>S</strong>, and a (non-empty) set of elements <strong>Y</strong> such that for all elements <em>Y</em> in <strong>Y</strong>, <em>Y</em> is in <strong>S</strong> and <em>X </em>'<=<strong> Y<em>.  The problem is to find the member of </em>'Y</strong> which is a "best match" for <em>X</em>.  
      </p>
      <p>
        We leave "best" undefined for now, other than to note a couple of trivial cases:
      </p>
      <ul>
        <li>
           If <strong>Y</strong> contains only a single element, than that is defined to be the best match.
        </li>
        <li>
           If <strong>Y</strong> contains <em>X</em>, then the answer is trivially <em>X</em>.  (Any element is it's own best match).
        </li>
      </ul>
      <p>
        Less trivial, but commonly enforced:
      </p>
      <ul>
        <li>
           If there is an element <em>Q</em> in <strong>Y</strong> such that for all <em>Y</em> in <strong>Y</strong>, <em>Q <= Y</em> is true, then <em>Q</em> is the best match.  (The previous rules can be viewed as special cases of this one).  In this case, <em>Q</em> can be said to <em>dominate</em> all other elements of <em>Y</em>.  Note that there are some sets for which the <strong><=</strong> relation might be undecideable or intractable to compute (an example is if the elements of <strong>S</strong> are predicate functions, and the <strong><=</strong> operation is defined to mean that the truth of one function at a particular value implies the truth of the other function at the same point--the <a href="VorherrschaftsProblem.html">VorherrschaftsProblem</a>).
        </li>
      </ul>
      <p>
        Despite these special cases; it frequently arises that the best match is <em>ambiguous</em>--there is no dominant member of <strong>Y</strong>, in which case additional rules may come into play (dependent on the specific application).  Common ways of resolving ambiguities:
      </p>
      <ul>
        <li>
           Declaring them to be erroneous.  
        </li>
        <li>
           Imposing a secondary ordering (usually a <a href="TotalOrder.html">TotalOrder</a>) on elements of <strong>Y</strong> (this ordering may be ad-hoc), used to select between possible best matches.  This secondary ordering may be defined as another relationship over <strong>S</strong>; it can also be imposed by re-defining <strong>Y</strong> to be an (ordered) tuple rather than an (unordered) set, and simply choosing the first (or last) element.
        </li>
        <li>
           In case where the "path length" between <em>X</em> and elements of <strong>Y</strong> can be determined, choosing the "closest" element of <em>Y</em>.
        </li>
      </ul>
      <p>
        This problem is a generalization of several problems found in programming languages, such as:
      </p>
      <ul>
        <li>
           <a href="DynamicDispatch.html">DynamicDispatch</a> / overloading (in the multi-argument case in particular).
        </li>
        <li>
           <a href="MultipleInheritance.html">MultipleInheritance</a>
        </li>
      </ul>
    </div>
  </body>
</html>