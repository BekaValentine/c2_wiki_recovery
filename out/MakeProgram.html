<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Make Program
      </h1>
      <p>
        make(1): the most successful <a href="ArtificialIntelligence.html">ArtificialIntelligence</a> project ever.
      </p>
      <p>
        <strong>Q:</strong> <em>If God had not given us Makefiles, it would have been necessary to invent them.</em>
      </p>
      <p>
        <strong>A:</strong> <em>I guess that is what DNA is.</em>
      </p>
      <hr/>
      <p>
        Make is a program crafted by <a href="StuFeldman.html">StuFeldman</a> which controls the generation of executables and other non-source files of a program from the program's source files.  
      </p>
      <p>
        It first appeared in Version 7 Unix from AT&T <a href="BellLabs.html">BellLabs</a> in 1979, and has since been revised and rewritten many times (see below for a list of implementations) to add features such as including information from other places in makefiles.
      </p>
      <p>
        Make can be used to build and install programs. Make builds your program from an instruction file called the makefile. The makefile lists each of the non-source files and provides instructions on how to create it from other files and commands. In turn, those files are listed, with their production instructions, and so on, and so on, all the way back to the source code. 
      </p>
      <p>
        More generally, make uses rules to determine how to achieve goals (over a limited domain). It has been described (<a href="HaHaOnlySerious.html">HaHaOnlySerious</a>) as the most successful and widely used <a href="ArtificialIntelligence.html">ArtificialIntelligence</a> program around - although most AI experts would consider make's domain and set of possible strategies to be too limited to qualify it as anything more than a toy <a href="ArtificialIntelligence.html">ArtificialIntelligence</a> implementation by today's standards. 
      </p>
      <hr/>
      <p>
        <strong>Books and Tutorials</strong>
      </p>
      <p>
        The fantastically thin O'Reilly book: <a href="ManagingProjectsWithMake.html">ManagingProjectsWithMake</a>
      </p>
      <p>
        A good tutorial is at <a href="http://www.eng.hawaii.edu/Tutor/Make/index.html">http://www.eng.hawaii.edu/Tutor/Make/index.html</a> 
      </p>
      <p>
        <strong>Make Implementations:</strong>
      </p>
      <dl>
        <dt><em></em><a href="GnuMake.html">GnuMake</a><em> </em></dt>
        <dd></dd>
      </dl>
      <dl>
        <dt><em></em><a href="MakeIt.html">MakeIt</a><em> </em></dt>
        <dd></dd>
      </dl>
      <dl>
        <dt><em>BSD make</em> </dt>
        <dd> </dd>
      </dl>
      <dl>
        <dt><em></em><a href="ApacheAnt.html">ApacheAnt</a><em> </em></dt>
        <dd>The Ant build tool is part of the Apache project. It is similar to <em>make</em> but the problem domain is limited to <a href="JavaLanguage.html">JavaLanguage</a> projects, which it manages without recourse to external platform-dependant tools.</dd>
      </dl>
      <code>
        Note: <a href="ApacheAnt.html">ApacheAnt</a> is <em>nothing</em> like make, apart from that it is also used to build software.  It has a different (far inferior -- dare I say it, <em>incorrect</em> -- domain model).<br/>
      </code>
      <dl>
        <dt><em>Openmake</em> </dt>
        <dd>	Openmake (<a href="http://www.openmake.com)">http://www.openmake.com)</a> is a commercial build tool designed to be a make/ANT alternative. Created by Catalyst Systems Corporation in 1995 It was designed to remove the developer from the tedious task of having to write makefiles at all.  Openmake features a knowledgebase and rules engine loaded with thousands of predefined "buildtypes".  It supports enterprise wide builds across all "most" platforms so you only have one tool and one build process to support. Openmake may not be for everyone, but its client server architecture and integrated impact analysis make it simple to standardize builds for the entire company. Openmake has also embedded ANT within the tool so you can take advantage of all the current ANT tasks without any XML scripting or build specific Java classes.</dd>
      </dl>
      <dl>
        <dt><em></em><a href="PerforceJam.html">PerforceJam</a><em> </em></dt>
        <dd>If you find <em>make</em> inscrutable, perhaps you would enjoy JAM <a href="http://freetype.sourceforge.net/jam/.">http://freetype.sourceforge.net/jam/.</a></dd>
      </dl>
      <dl>
        <dt><em></em>AwkBook page 178<em> </em></dt>
        <dd>Has a one page awk program which implements the <a href="StuFeldman.html">StuFeldman</a> algorithm.</dd>
      </dl>
      <dl>
        <dt><em>Other make tools</em> </dt>
        <dd>Andrew Hume's <strong>mk</strong> and Glenn Fowler's <strong>nmake</strong></dd>
      </dl>
      <hr/>
      <p>
        <strong>Testimonials and Comments</strong>
      </p>
      <p>
        I have found make to be the most powerful tool in my arsenal. Make, and cron are my allies. Make isn't just for programs, it is for data flow, <a href="UnitTest.html">UnitTest</a>s, web pages, database queries, and more. I find that the script that make executes for me is ALWAYS (Shout for joy) better than one I could write myself. -- <a href="ChrisGarrod.html">ChrisGarrod</a>
      </p>
      <p>
        I have a small Makefile for my Objective Caml programs, and another one for my C++ programs. I copy them around wherever I go; I only have to edit the list of source files, the rest happens automatically. Once you have the initial Makefile which does what you want, using make is really a joy; however, writing that first Makefile can be a bit painful if you have no prior experience with make. One tip: make has <a href="SyntacticallySignificantWhitespace.html">SyntacticallySignificantWhitespace</a> be sure you begin indented lines with tabs rather than spaces!
        -- <a href="StephanHouben.html">StephanHouben</a>
      </p>
      <p>
        The easiest way to take advantage of multiple processors in your script-driven program is to write it as a makefile and use the <strong>-j</strong> option to make. -- <a href="PanuKalliokoski.html">PanuKalliokoski</a>
      </p>
      <p>
        <strong>Teach your computer well, and it will make things for you.</strong>  -- anon
      </p>
      <p>
        Personally, I'm kind of in two minds about makefiles. Personally, I sat down and learned how to write the things properly. Hence I only have one, it doesn't recurse and by default it does probably what I want.
      </p>
      <p>
        Everyone else's attitude to makefiles scares me. They regard make as among the hardest languages to develop in. Here (this is a fairly major bank) the makefiles were cobbled together from some sort of working ones written by some now departed contractors... and no-one really wants to touch them so they've grown cruft... this is pretty much normal as far as I can tell. Working makefiles are rarer than working C++ code... --<a href="KatieLucas.html">KatieLucas</a>
      </p>
      <p>
        Hmm, let me claim not to be part of "everyone". I've had the pleasure of working on makefiles to do quite complicated builds, working with (other) smart, motivated, developers.  Developers, moreover, that give a damn. And we produced files that were damn near works of art (if I say so myself): well factored, easy to understand, easy to change. On that self-same project, though, I also had to attempt to debug a makefile provided by one of our suppliers that was >20K of recursive spaghetti. It seems as if word has got around that makefiles are hard to write <em>at all</em>, and so very few developers even think to try to write them well. It's a shame, because a good makefile can be a very satisfying thing. I'll even go out on a limb and assert that good recursive makefiles can be even more satisfying. --<a href="KeithBraithwaite.html">KeithBraithwaite</a>
      </p>
      <p>
        In my experience, the reason that many programmers consider makefiles "hard" and that many terrible makefiles exist is a failure to grasp that makefiles are an example of <a href="DeclarativeProgramming.html">DeclarativeProgramming</a>. If you think of a makefile as like a script, and a rule as like a function, you're going to have problems. --HannesReich 
      </p>
      <hr/>
      <p>
        Makefile achieves self-awareness: <a href="http://web.archive.org/web/20011019113616/http://segfault.org/story.phtml?id=3ba7eadc-03cdf340">http://web.archive.org/web/20011019113616/http://segfault.org/story.phtml?id=3ba7eadc-03cdf340</a> [archived site, since segfault.org is sadly no longer with us]
      </p>
      <p>
        See also <a href="RecursiveMakeConsideredHarmful.html">RecursiveMakeConsideredHarmful</a>
      </p>
      <hr/>
      <p>
        <a href="CategorySoftwareTool.html">CategorySoftwareTool</a>
      </p>
    </div>
  </body>
</html>