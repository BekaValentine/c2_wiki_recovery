<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Haskell Language
      </h1>
      <p>
        Haskell is a purely <a href="FunctionalProgrammingLanguage.html">FunctionalProgrammingLanguage</a> using NonStrictSemantics (typically implemented as <a href="LazyEvaluation.html">LazyEvaluation</a>) and a polymorphic type system (an extension of the classical <a href="HindleyMilnerTypeInference.html">HindleyMilnerTypeInference</a> algorithm). It was named after <a href="HaskellCurry.html">HaskellCurry</a>.
      </p>
      <p>
        See <a href="http://www.haskell.org/">http://www.haskell.org/</a> and the <a href="HaskellWiki.html">HaskellWiki</a>.
      </p>
      <p>
        Some nice features:
      </p>
      <ul>
        <li>
           Functions can be defined by <a href="PatternMatching.html">PatternMatching</a>, as in several other functional languages.
        </li>
        <li>
           <a href="ListComprehension.html">ListComprehension</a>s provide a nice way to write mapping and filtering operations.
        </li>
        <li>
           Syntactic support for a simple variety of <a href="LiterateProgramming.html">LiterateProgramming</a>.
        </li>
        <li>
           You can define your own infix operators.
        </li>
        <li>
           <a href="TypeClasses.html">TypeClasses</a> allow the introduction of overloaded functions.
        </li>
        <li>
           Readily available package system, HackageDb (<a href="http://hackage.haskell.org)">http://hackage.haskell.org)</a> and user-side tool 'cabal', with thousands of open-source packages.
        </li>
        <li>
           Indentation-sensitive syntax and curly brace syntax are both possible, depending on your preference.
        </li>
      </ul>
      <p>
        I/O is done via monads (see <a href="OnMonads.html">OnMonads</a>). Monads (which have far wider applications than just I/O) are hard for some to grasp, but there are a lot of good tutorials right now on the net that deal with them. A good place to start is <a href="http://www.haskell.org/learning.html.">http://www.haskell.org/learning.html.</a>
      </p>
      <hr/>
      <p>
        <strong>Implementation</strong>
      </p>
      <ul>
        <li>
           <a href="HaskellPlatform.html">HaskellPlatform</a>
        </li>
        <li>
           <a href="GlasgowHaskellCompiler.html">GlasgowHaskellCompiler</a>
        </li>
      </ul>
      <hr/>
      <p>
        <strong>Books</strong>
      </p>
      <ul>
        <li>
           <a href="RealWorldHaskell.html">RealWorldHaskell</a>
        </li>
        <li>
           <a href="ParallelAndConcurrentProgrammingInHaskell.html">ParallelAndConcurrentProgrammingInHaskell</a>
        </li>
      </ul>
      <hr/>
      <p>
        <a href="DavidMertz.html">DavidMertz</a> has a small tutorial on Haskell (<a href="http://gnosis.cx/publish/programming/Haskell.pdf).">http://gnosis.cx/publish/programming/Haskell.pdf).</a>
      </p>
      <hr/>
      <p>
        <a href="JimBender.html">JimBender</a> maintains a growing "Online Bibliography of Haskell Research" at <a href="http://haskell.readscheme.org/">http://haskell.readscheme.org/</a> that references many research papers about monads and their even more abstract and scary generalization, arrows. <a href="HaskellArrows.html">HaskellArrows</a> were introduced by <a href="JohnHughes.html">JohnHughes</a> and are also explained at <a href="http://www.haskell.org/arrows/.">http://www.haskell.org/arrows/.</a>
      </p>
      <hr/>
      <p>
        In "Wearing the hair shirt: a retrospective on Haskell" (2003, available as a set of <a href="PowerPoint.html">PowerPoint</a> slides at <a href="http://www.research.microsoft.com/~simonpj/papers/haskell-retrospective/)">http://www.research.microsoft.com/~simonpj/papers/haskell-retrospective/)</a> <a href="SimonPeytonJones.html">SimonPeytonJones</a> provides an overview of the (rather short) history of Haskell. He concludes that <a href="LazyEvaluation.html">LazyEvaluation</a> is rather less important than one might think while purity and type classes and monads are essential. "<em>Our biggest mistake: using the scary term 'Monad' rather than 'Warm Fuzzy Thing' </em>"
      </p>
      <hr/>
      <p>
        Haskell now has its very own International Obfuscated Code Contest (see <a href="http://www.ScannedInAvian.org/iohcc/).">http://www.ScannedInAvian.org/iohcc/).</a>
        <em></em><a href="BrokenLink.html">BrokenLink</a> as of 16 February 2010, but available through <a href="WaybackMachine.html">WaybackMachine</a> at <a href="http://web.archive.org/web/20050409013040/www.scannedinavian.org/iohcc/.''">http://web.archive.org/web/20050409013040/www.scannedinavian.org/iohcc/.''</a>
      </p>
      <p>
        And its very own Lambdacats site (see <a href="http://arcanux.org/lambdacats.html).">http://arcanux.org/lambdacats.html).</a>
      </p>
      <hr/>
      <p>
        See <a href="QuickSortInHaskell.html">QuickSortInHaskell</a> for a short example of Haskell code. See <a href="TheEvolutionOfaHaskellProgrammer.html">TheEvolutionOfaHaskellProgrammer</a> for some more examples.
      </p>
      <hr/>
      <p>
        Some people are running the LanguageOfTheYear project over on the Pragmatic Programmer mailing list and chose Haskell as LanguageOfTheYear 2002. Check it out: <a href="http://groups.yahoo.com/group/pragprog.">http://groups.yahoo.com/group/pragprog.</a>
      </p>
      <hr/>
      <p>
        <strong></strong><a href="HaskellLanguage.html">HaskellLanguage</a> <a href="QuickQuestions.html">QuickQuestions</a><strong></strong>
      </p>
      <p>
        <strong>Q</strong> IBM article In 2001 (<a href="http://www-106.ibm.com/developerworks/xml/library/x-matters14.html)">http://www-106.ibm.com/developerworks/xml/library/x-matters14.html)</a> advocated use of <a href="HaskellLanguage.html">HaskellLanguage</a> based <a href="HaXml.html">HaXml</a> to overcome the limitations of XML processing tools. Is his idea a flash in the pan? Are there better alternatives to DOM/SAX/XSLT?
      </p>
      <p>
        <strong>A</strong> The combinators of <a href="HaXml.html">HaXml</a> are designed to do about the same thing as XSLT. However, have you ever tried using XSLT? Anything that does the same will be simpler and easier to use. <a href="HaXml.html">HaXml</a>, being embedded in Haskell gives the full power of a programming language on top of the easy XML transformations. Another popular Haskell XML library is HXT, which is also notable in that one way to use it is through its arrow-based API.
      </p>
      <p>
        <strong>Q</strong> Is there a good IDE usable for Haskell under Windows?
      </p>
      <p>
        <strong>A</strong> <a href="http://www.haskell.org/libraries/#ide">http://www.haskell.org/libraries/#ide</a> (mentions hIDE and jCreator)
      </p>
      <p>
        I've also heard of editor support in jEdit, Eclipse, and some other editors. I'm mostly happy with the haskell-mode in Emacs.
      </p>
      <p>
        <em>See also </em><a href="http://www.haskell.org/visualhaskell/">http://www.haskell.org/visualhaskell/</a> for a Haskell plugin for <a href="VisualStudio.html">VisualStudio</a> (not to be confused with a similar project at <a href="http://www.cin.ufpe.br/~haskell/vhs/index.html).">http://www.cin.ufpe.br/~haskell/vhs/index.html).</a> This plugin ties directly into the GHC compiler, providing all of the usual VS features like syntax highlighting and name completion, but it also goes a step further. If the plugin doesn't squiggly-highlight any code in your program, it is guaranteed to compile with GHC. -- <a href="MichaelSparks.html">MichaelSparks</a><em></em>
      </p>
      <hr/>
      <p>
        I love Haskell mostly for the elegant and beautiful syntax you get when doing PointFreeProgramming. However, Haskell's strict FP discipline and affinity for abstruse concepts like Arrows really hurts when trying to put together quick scripts, or when just hacking for fun. Are there other languages that support the inline . and $ operators or other syntax like it? I just can't go back to (compose #'foo #'bar) after getting used to foo . bar, to say nothing of all the fun with the $ operator in avoiding needless parenthesis.
      </p>
      <ul>
        <li>
           You might find <a href="ConcatenativeLanguage.html">ConcatenativeLanguage</a>s interesting, such as <a href="ForthLanguage.html">ForthLanguage</a>, <a href="JoyLanguage.html">JoyLanguage</a>, or <a href="FactorLanguage.html">FactorLanguage</a>. Unlike ApplicativeLanguages, juxtaposition of symbols indicates a composition operation (e.g., <strong>A B</strong> means to compute A first, then compute B on A's results; this is equivalent to B $ A or B . A in Haskell, depending on your precise context). -- SamuelFalvo
        </li>
      </ul>
      <hr/>
      <ul>
        <li>
           Sounds like it isn't a <a href="RealProgrammingLanguage.html">RealProgrammingLanguage</a>
        </li>
      </ul>
      <p>
        ... I suppose I can't hold my breath on that, since to get point-free programming, I also need automatic currying, which I've only seen in <a href="MlLanguage.html">MlLanguage</a>s. I suppose I can live with <a href="SmlLanguage.html">SmlLanguage</a> and the 'o' operator, but no $ operator I'm aware of.
      </p>
      <p>
        <em>Abstruse concepts? I have a whole book about abstruse concepts sitting on my shelf, only it's imported from that other, backwards world, where functions are only known as methods and abstruse concepts are sold as Design Patterns, where the capital letters apparently enchant them into something desirable... Really, compared to </em>RubeGoldbergDevices like Visitor, Arrows and Monads are astonishingly simple. Perhaps that's why imperative programmers distrust these powerful structures.<em></em>
      </p>
      <ul>
        <li>
           Monads rhymes with..
        </li>
      </ul>
      <p>
        <em>That would make a nice T-shirt:</em> "I have the GONADS to work with MONADS."
      </p>
      <hr/>
      <p>
        With languages with pervasive effects such as C, you need machinery such as Hoare logic to handle proofs about programs. One of the benefits of Haskell's purity is that its expressions are already in the right form for traditional mathematical proof. You can even use Haskell functions in specifications because they are pure.
      </p>
      <hr/>
      <p>
        The <a href="LindowsOs.html">LindowsOs</a> folks have apparently standardized on Haskell for core operating system development. See <a href="http://urchin.earth.li/pipermail/debian-haskell/2006-May/000169.html">http://urchin.earth.li/pipermail/debian-haskell/2006-May/000169.html</a>
      </p>
      <hr/>
      <p>
        A useful reference to details of Haskell is at <a href="http://www.zvon.org/other/haskell/Outputglobal/index.html">http://www.zvon.org/other/haskell/Outputglobal/index.html</a>
      </p>
      <hr/>
      <p>
        See also <a href="TemplateHaskell.html">TemplateHaskell</a>, <a href="IwannaLearnHaskell.html">IwannaLearnHaskell</a>, <a href="HaskellUnit.html">HaskellUnit</a>, <a href="CoMonads.html">CoMonads</a>, <a href="HaskellArrows.html">HaskellArrows</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryProgrammingLanguage.html">CategoryProgrammingLanguage</a> <a href="FunctionalProgrammingLanguage.html">FunctionalProgrammingLanguage</a> <a href="CategoryHaskell.html">CategoryHaskell</a> <a href="CategoryFunctionalProgramming.html">CategoryFunctionalProgramming</a> <a href="CategoryLiterateProgramming.html">CategoryLiterateProgramming</a>
      </p>
    </div>
  </body>
</html>