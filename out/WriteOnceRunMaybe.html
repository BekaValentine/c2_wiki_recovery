<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Write Once Run Maybe
      </h1>
      <p>
        Java was touted as <a href="WriteOnceRunAnywhere.html">WriteOnceRunAnywhere</a>. In truth, you never know whether a java program will run or not. It depends on the JVM, and you never know what release of what JVM is going to kill you. A support nightmare.
      </p>
      <hr/>
      <p>
        This was somewhat true in '97 or so (on the client side), but not anymore. In the five years I've been using Java I've seen very few portability issues that couldn't have very easily been avoided... 95% involve back slashes. One problem did involve different threading models on platforms, but even then it only took about a day to port a 50,000+ LOC application from Wintel to UNIX.
      </p>
      <hr/>
      <p>
        <em>I've had great success with WORA, especially when compared to other prevalent programming systems. Certainly better than </em><a href="CeePlusPlus.html">CeePlusPlus</a>! The only real trick is to ensure your JVM version. Basically, it is WORA for the JVM's your application supports, which is saying a lot more than most devleopment systems.<em></em>
      </p>
      <p>
        It is a matter of control. With <a href="CeePlusPlus.html">CeePlusPlus</a> you control your own link time. If you want your app to run on multiple platforms you need only use a library that runs on multiple platforms - <a href="ObjectSpace.html">ObjectSpace</a> and <a href="RogueWave.html">RogueWave</a> are two good standard ones. If you're delivering a product you will want to set up a lab to <a href="FunctionalTest.html">FunctionalTest</a> the results, sure, but you'll need to do that with Java anyway. But with Java you need to keep testing with every new JVM that comes out - you're never done. With <a href="CeePlusPlus.html">CeePlusPlus</a> you can link, test, and then forget about it. WriteOnceRunDefinitely.
      </p>
      <p>
        <em>Unless you run into DLL hell or want it work in multiple versions of winDOS including whatever version comes next.  Me, I ported an EJB app from NT to Solaris in about a day without recompiling.  Actually the only tweaks were some places in the config and properties files where we'd had DOS paths.  Try that with </em><a href="CeePlusPlus.html">CeePlusPlus</a><em></em>
      </p>
      <p>
        No more so than with every new version of your <a href="CeePlusPlus.html">CeePlusPlus</a> compiler or library.
      </p>
      <hr/>
      <p>
        Concerns about JVM versions largely go away if you're delivering an Enterprise application where you control the server, or where the nature of the application is such that you can dictate the browser version. --<a href="DaveSmith.html">DaveSmith</a>
      </p>
      <p>
        If you control the server you may as well use <a href="CeePlusPlus.html">CeePlusPlus</a>. Then there is no need for <a href="WriteOnceRunAnywhere.html">WriteOnceRunAnywhere</a> anymore. --<a href="MarkoSchulz.html">MarkoSchulz</a>
      </p>
      <hr/>
      <p>
        This argument for C++ over Java is pretty poor. Any time your system--and by system I mean the entire user experience, including the user, the keyboard, the OS, your imaging libraries, your code, the browser, etc.--depends on some third party (or even first party), <em>dynamic</em> module, you will have versioning problems when the module changes. Just look at what happens when a new version of an OS comes out--like Windows--, or with changes in HTML/browsers. The main problem with Java is that Sun <em>markets</em> it. They claim it's <a href="WriteOnceRunAnywhere.html">WriteOnceRunAnywhere</a>, but there are in fact configuration problems as the anonymous poster mentioned above. Or changes to the class libraries between versions. Anyway, there is <em>always</em> work to be done when porting anything significant to a new platform. Except for text-only C programs because ANSI C has been pretty stable for a long time. And even then it takes discipline to know how to write portable code. -- <a href="SunirShah.html">SunirShah</a>
      </p>
      <hr/>
      <p>
        I've been working with Java since 1995 and I can't remember the last time I had a portability issue (I spent three years developing on <a href="MicrosoftWindows.html">MicrosoftWindows</a> and deploying on NT or Solaris with JavaWebServer, ApacheJserv, <a href="ApacheTomcat.html">ApacheTomcat</a>, BeaWeblogic, blah blah). The only time I've come across problems is when people code in platform specific stuff (of course they blame Java :-). --<a href="ChanningWalton.html">ChanningWalton</a>
      </p>
      <p>
        N.B.: Case-sensitive file paths, path seperators, file seperators, 'newlines and carriage returns' are "platform specific stuff." - there must be loads more
      </p>
      <p>
        <em>Almost all of this can be dealt with pretty easily in Java.</em>
      </p>
      <p>
        Yes, perhaps it takes discipline to write portable Java as well. Except Java is humongous and C is tiny. In comparison. Perhaps <em>a lot</em> of discipline. -- <a href="SunirShah.html">SunirShah</a>
      </p>
      <p>
        <em>By humongous, do you mean language or library?  --</em><a href="ChanningWalton.html">ChanningWalton</a><em></em>
      </p>
      <p>
        The threading model is platform dependent. See JavaIsPlatformDependent. 
      </p>
      <p>
        You mean <em>threading models</em> i assume. See <a href="GreenJavaThreads.html">GreenJavaThreads</a> and <a href="NativeJavaThreads.html">NativeJavaThreads</a>.  In my experience these VM implementation differences have always been a killer, even on the same platform (zb. move from ibm to sun vm on linux )
      </p>
      <p>
        Some real-world examples please? I use threading pretty extensively and have not had any problems going between Solaris, <a href="MicrosoftWindows.html">MicrosoftWindows</a>, and Linux. All in all, it's been pretty painless developing for these platforms -- much better than the days of creating platform.h files, different build scripts, compiler options, and so on in C++. But maybe I'm missing something.
      </p>
      <p>
        <em>I'd recommend </em><a href="AllenHolub.html">AllenHolub</a>'s series at <a href="JavaWorld.html">JavaWorld</a> (<a href="http://www.javaworld.com/javaworld/jw-09-1998/jw-09-threads.html)">http://www.javaworld.com/javaworld/jw-09-1998/jw-09-threads.html)</a> called, appropriately enough, "Programming Java threads in the real world".<em>--</em><a href="AdewaleOshineye.html">AdewaleOshineye</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryJava.html">CategoryJava</a> <a href="CategoryJavaPlatform.html">CategoryJavaPlatform</a>
      </p>
    </div>
  </body>
</html>