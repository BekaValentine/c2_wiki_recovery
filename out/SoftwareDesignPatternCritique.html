<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Software Design Pattern Critique
      </h1>
      <p>
        This is a <a href="SoftwareDesignPatternCritique.html">SoftwareDesignPatternCritique</a>.
      </p>
      <p>
        I just finished reading <a href="TheTimelessWayOfBuilding.html">TheTimelessWayOfBuilding</a> of <a href="ChristopherAlexander.html">ChristopherAlexander</a> which introduces A <a href="PatternLanguage.html">PatternLanguage</a>. It puts the <a href="DesignPattern.html">DesignPattern</a> hype into a clear perspective. A critical one. At least for me.
      </p>
      <p>
        With this view I miss the following important points in the usual <a href="SoftwareDesignPattern.html">SoftwareDesignPattern</a> discussions:
      </p>
      <ul>
        <li>
           There aren't patterns for every level of granularity. But to be patterns in Alexanders sense there should be ones for every level from SystemPattern over <a href="ArchitecturalPattern.html">ArchitecturalPattern</a> to LibraryPattern, CollaborationPattern, AlgorithmPattern down to StructuralPattern, Objectpattern and ByteManipulationPattern maybe.
        </li>
        <li>
           The patterns stand too much in isolation. But the key point of Alexander is that they support each other. I don't know if this holds true at all for software patterns.
        </li>
        <li>
           There is no real <a href="PatternLanguage.html">PatternLanguage</a>. The language should tell you which patterns to try and tackle in which order (to ensure that you don't need to backtrack and change larger structures later).
        </li>
        <li>
           There is not enough support for <a href="AmeliorationPattern.html">AmeliorationPattern</a>s to deal with change. Alexander elaborates on continous repair and change especially on the large scale. But maybe the pattern on the large scale is really <a href="ExtremeProgramming.html">ExtremeProgramming</a>.
        </li>
        <li>
           The truth of the patterns is that help you learn to write good software, but they are not good by themself. You can do without them if you really understand the needs of the code. 
        </li>
      </ul>
      <p>
        Maybe this is because there is not yet really a <a href="PatternLanguage.html">PatternLanguage</a> but only a PatternCollection and the real fun hasn't yet begun.
      </p>
      <p>
        <a href="GunnarZarncke.html">GunnarZarncke</a>
      </p>
      <hr/>
      <p>
        I pulled together some more critical views from the design pattern pages on this wiki. To make my point into a <a href="WikiWord.html">WikiWord</a>:
      </p>
      <p>
        See also <a href="PatternsOfSoftware.html">PatternsOfSoftware</a>, where <a href="RichardGabriel.html">RichardGabriel</a> and <a href="ChristopherAlexander.html">ChristopherAlexander</a> himself criticize both software design patterns and also Alexander's original architectural design patterns that inspired the software ones. Alexander believes his earlier efforts failed, and his more recent efforts that he believes have succeeded apparently have yet to influence software design patterns.
      </p>
      <p>
        (In brief, the failure was due to overly-mechanical execution, people deluding themselves into believing they'd succeeded brilliantly when they'd actually failed, and the lack of but need for beauty, liveness, and growth.)
      </p>
      <p>
        <em>Why it is easier to find an </em><a href="AntiPattern.html">AntiPattern</a> than a <a href="DesignPattern.html">DesignPattern</a> or an <a href="AmeliorationPattern.html">AmeliorationPattern</a> in this Wiki?<em></em>
      </p>
      <p>
        [There are design patterns at different levels of granularity.] This is right in line with Alexander's notions, because a <a href="PatternLanguage.html">PatternLanguage</a> is supposed to include patterns for all levels of granularity.  You select one that is fairly general to handle a general problem, then use progressively finer grained patterns as you get to more detailed levels of design.  So what you say indicates that these software design patterns are in fact patterns in the Alexander sense. - TomPassin
      </p>
      <p>
        A different approach has been taken by <a href="ThomasKuehne.html">ThomasKuehne</a> who in <a href="FunctionalPatternSystemForObjectOrientedDesign.html">FunctionalPatternSystemForObjectOrientedDesign</a> analyses the relationships between objects and the patterns which they make. This leads to some similar patterns and some different ones. -- <a href="JohnFletcher.html">JohnFletcher</a>
      </p>
      <hr/>
      <p>
        See also <a href="ArchitecturalPattern.html">ArchitecturalPattern</a>, <a href="DesignPatternsArent.html">DesignPatternsArent</a>, <a href="DesignPatternsConsideredHarmful.html">DesignPatternsConsideredHarmful</a>.
      </p>
      <hr/>
      <p>
        <a href="CategoryDesign.html">CategoryDesign</a>
      </p>
    </div>
  </body>
</html>