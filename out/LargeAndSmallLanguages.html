<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Large And Small Languages
      </h1>
      <p>
        You often see statements like "C++ is a bad language,
        because it's just too big" or "<a href="CommonLisp.html">CommonLisp</a> is big and
        bloated; Scheme is simpler and more elegant". On the
        other hand, you also often see statements like "C++
        lets you program in any paradigm you choose" or
        "Java has a huge range of helpful standard libraries".
      </p>
      <p>
        So, with programming languages, is it true that
        <a href="SmallIsBeautiful.html">SmallIsBeautiful</a> or not?
      </p>
      <hr/>
      <p>
        Some helpful distinctions:
      </p>
      <p>
        <em>Size versus complexity</em>. If there's enough regularity,
        size may not matter as much as you think. (Very small
        example: compare C++'s <em>find_first_of</em> and friends
        with C's <em>strcspn</em> and friends.) Usually it's not
        possible for a <em>language</em> to be large but simple;
        only its <em>library</em>, which brings us to ...
      </p>
      <p>
        <em>Language size versus library size</em>. A small language
        can have a large library. It's generally more practical
        to learn a large library incrementally than to do the same
        with a large language. A large language can have a small
        library, too, though this isn't so common.
      </p>
      <hr/>
      <p>
        So, which is better? One possible answer (feel free to
        disagree; we can un-thread-ify the discussion later)
        is:
      </p>
      <p>
        <em>Large libraries are better, provided they are simple and regular</em>.
        Would C++ be any better if its strings had <em>find_first_of</em> but
        not any of the other related functions? Would <a href="CommonLisp.html">CommonLisp</a> be any
        worse if it gained a standard, well designed, library for handling
        regular expressions? If your library is small, then you have to
        build facilities yourself. (Case in point: every major implementation
        of Scheme includes its own version of a bunch of the facilities
        found as standard in <a href="CommonLisp.html">CommonLisp</a>. Is the smallness of Scheme good
        when this happens?)
      </p>
      <p>
        <em>Size needn't matter much </em>'if<em>' you can afford to know only a subset</em>.
        You <em>can</em> use C++ just like C. This is almost a proof that
        C++ isn't worse than C. There are two problems. Firstly, you
        need to be able to work with other people, and the subset they
        use may be different from the subset you use. Secondly, complexity
        isn't always well enough isolated. C++'s scoping rules are quite
        complicated, and you probably need to know most of them even if
        you're only using a subset of the language.
      </p>
      <p>
        <em>Small languages are better, provided they do what you need</em>.
        This is mostly for psychological reasons; using a language is
        much more comfortable if you feel that you know almost all of it,
        and that there aren't surprises waiting to trip you up.
      </p>
      <p>
        <em>It's good to move size and complexity out of the language and into the libraries, when possible</em>.
        Because then you can learn the language completely, and explore
        the libraries at whatever pace suits you best.
      </p>
      <hr/>
      <p>
        Of course none of this answers questions like "Is C better or
        worse than C++?" and "Is Scheme better or worse than <a href="CommonLisp.html">CommonLisp</a>".
        That's good, because those questions will always lead to
        flame wars even if someone finds a conclusive answer to them.
      </p>
      <hr/>
      <p>
        I like to consider not so much the size of the language but the size
        of the programs for which it scales well.
      </p>
      <p>
        For example Perl5 scales well in the very small to the medium but not well on the very big. 
        The lack of real functions/modules signatures hinders modular programming in Perl
        Also, having only dynamic typing implies overhead in space and time that is not acceptable in many contexts.
        Scaling in size would imply to have the choice between dynamic and static typing within one language.
        It seems that the next generation of scripting languages (Perl6, Python) will provide that choice.
        When that will happen, I expect they will displace application languages.
      </p>
      <p>
        But scaling as a language quality can be seen as detrimental because one can wrongly infer that the style for
        one type of programming is the only style for the language.
        Perl5 is criticized because it supports Perl4 style. This brings us to the next kind of scaling.
      </p>
      <p>
        One can also study how the language scales over time. Starting small and getting bigger.
        It has been said that a language must start small.
        Growing without major discontinuities guarantees to keep a mind share
        but results in ugly languages like Perl5 and C++. Also, like the example of Perl5 shows,
        one must be careful to keep people educated about the evolution of the language.
      </p>
      <hr/>
      <p>
        I've given up completely on the concept of some languages being bad and some being good. It depends on personal taste and purpose. Even badly designed languages like <a href="VisualBasic.html">VisualBasic</a> and PHP have a purpose.
      </p>
      <hr/>
      <p>
        Ideally, the language spec itself should cover only what can't be done effectively (& perhaps we should add, safely) in a library. (Anything that can make libraries more effective is, therefore, a good candidate for a language feature.) This is because writing, maintaining, & updating a library is easier than a compiler or interpreter.
      </p>
      <p>
        (You now ask, "But, what is <em>easier?</em>" I think, however, that you know what I mean. Still, it could be worth expanding on at some point.)
      </p>
      <p>
        Likewise, the general library standard should be allowed to evolve faster than the language standard.
      </p>
      <p>
        Like software version numbers: x.y.z. Increment x when the language spec is changed. Increment Y when the "standard library" is changed. Increment z for bug fixes.
      </p>
      <p>
        And, of course, there should be formal & <em>de facto</em> standards for libraries targeting specific purposes.
      </p>
      <hr/>
      <p>
        See also <a href="LittleLanguage.html">LittleLanguage</a>, <a href="MinimalistLanguage.html">MinimalistLanguage</a>, <a href="OccamsDebugger.html">OccamsDebugger</a>
      </p>
    </div>
  </body>
</html>