<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Implicit Lazy Evaluation
      </h1>
      <p>
        <a href="ImplicitLazyEvaluation.html">ImplicitLazyEvaluation</a> occurs whenever a language provides a mechanism for lazy evaluation which requires no work on the code evaluating a lazy expression (it may require an explicit declaration of laziness/strictness at the point a function or a variable is defined, especially if laziness is not the default semantics). It is found in lazy functional languages like <a href="HaskellLanguage.html">HaskellLanguage</a>, as well as others which have lazy evaluation (or <a href="CallByName.html">CallByName</a>) as a declaration option (e.g., <a href="OzLanguage.html">OzLanguage</a>). In addition, many strict languages have lazy operators/special forms.
      </p>
      <p>
        The primary difference between explicit and implicit lazy evaluation is that the code <em>performing</em> the evaluation has to know the difference in explicit evaluation. If you want to use Smalltalk blocks to perform lazy evaluation, you must send them the "value" message when you want to retrieve the value. In <a href="SchemeLanguage.html">SchemeLanguage</a>, similarly, you must use (force x) to evaluate x when x is a lazy form. Contrast with Haskell or <a href="OzLanguage.html">OzLanguage</a>, where merely mentioning a lazy form in a context which requires its value forces evaluation.
      </p>
      <p>
        Examples:
      </p>
      <ul>
        <li>
           Haskell and its cousins (<a href="MirandaLanguage.html">MirandaLanguage</a>, O'Haskell, etc.) are lazy by default.
        </li>
        <li>
           Most imperative languages have lazy conditional and boolean operators. In C, C++, Java, C#, etc... the && and || operators are lazy in their second argument, the ? : operator is lazy in the second and third arguments. Similarly, the if/else and switch statements in these languages are also lazy. cond in <a href="LispLanguage.html">LispLanguage</a> is also lazy. <a href="VisualBasic.html">VisualBasic</a> has OrElse and AndThen which are lazy (it also has Or and And which are strict). Excluding macros, none of these languages provide ways for the user to write their own lazy forms, other than with <a href="ExplicitLazyEvaluation.html">ExplicitLazyEvaluation</a> (though <a href="CommonLisp.html">CommonLisp</a> might... does it?).
        </li>
        <li>
           Most macro systems implement <a href="NormalOrderEvaluation.html">NormalOrderEvaluation</a>.
        </li>
        <li>
           <a href="CeePlusPlus.html">CeePlusPlus</a> templates are notoriously lazy. (The C++ template system is a <a href="TuringComplete.html">TuringComplete</a> lazy <a href="FunctionalProgrammingLanguage.html">FunctionalProgrammingLanguage</a> in its own right, though not a very good one).
        </li>
        <li>
           <a href="OzLanguage.html">OzLanguage</a> allows variables to be declared lazy.
        </li>
      </ul>
      <hr/>
      <p>
        See also <a href="ExplicitLazyEvaluation.html">ExplicitLazyEvaluation</a>
      </p>
      <p>
        <a href="CategoryLazyPattern.html">CategoryLazyPattern</a>
      </p>
    </div>
  </body>
</html>