<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Turing Tarpit
      </h1>
      <p>
        <em>Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.</em> -- <a href="AlanPerlis.html">AlanPerlis</a>
      </p>
      <p>
        Refers to any language or system that is <a href="TuringComplete.html">TuringComplete</a> but minimalistic, supporting a bare minimum of operations or a very terse notation.  Such a language may be interesting from a theoretical standpoint, but is impractical for use by human programmers. (Although some such languages are good candidates for IntermediateRepresentation like <a href="ByteCode.html">ByteCode</a>.)
      </p>
      <p>
        The first such things were combinatorial logic, lambda calculus, and Turing machines, each of which can compute any computable function, and each of which is equivalent to the others by virtue of being able to simulate each of the others.
      </p>
      <p>
        As a small example of the "tarpit" problem with such things, typically arithmetic is expressed in unary (base 1), which requires exponentially more space, time, and programming effort to deal with than do systems that use more conventional number bases such as base two.
      </p>
      <p>
        Of course, since anything computable can be expressed in them, you can certainly set up a system for doing arithmetic in e.g. binary, but it is a nontrivial exercise to do so.
      </p>
      <p>
        Similarly it can be possible but difficult and WriteOnly to do certain things in certain programming languages. For instance, recursive algorithms in classic dialects of Basic might be simulated "by hand" using arrays to hold temporary values, but the result tends to be bug-ridden and highly opaque compared with the same algorithm expressed in a language with natural native support for functional recursion. Thus recursion is a <a href="TuringTarpit.html">TuringTarpit</a> in classic Basic.
      </p>
      <p>
        On the other hand, Basic always had reasonable string handling, whereas standard Pascal did not (it allowed only fixed length character arrays, for one thing), so Pascal was <a href="TuringTarpit.html">TuringTarpit</a> in that particular area.
      </p>
      <hr/>
      <p>
        One (semi-) popular kind of <a href="TuringTarpit.html">TuringTarpit</a> are the <a href="EsotericProgrammingLanguage.html">EsotericProgrammingLanguage</a>s, which are often designed as a kind of twisted exercise in humor.
      </p>
      <p>
        Such languages demonstrate that, while many programming languages are <a href="TuringEquivalent.html">TuringEquivalent</a>, they are not equivalent for the purpose of expressing the intent of the programmer.  Skilled programming language designers intentionally add <a href="SyntacticSugar.html">SyntacticSugar</a> and some extra verbosity to make their languages useful.
      </p>
      <p>
        They also have their educational value; many of them show just how unusual or minimal a language can be while still remaining <a href="TuringComplete.html">TuringComplete</a>.
      </p>
      <p>
        See <a href="http://www.wikipedia.com/wiki/Turing_tarpit">http://www.wikipedia.com/wiki/Turing_tarpit</a>
      </p>
      <p>
        See also the Turing Tarpit, a catalogue of bad languages: <a href="http://www.geocities.com/ResearchTriangle/Station/2266/tarpit/tarpit.html">http://www.geocities.com/ResearchTriangle/Station/2266/tarpit/tarpit.html</a>
      </p>
      <p>
        Examples: <a href="BefungeLanguage.html">BefungeLanguage</a>, <strong></strong><a href="BrainfuckLanguage.html">BrainfuckLanguage</a><strong>, </strong><a href="SnuspLanguage.html">SnuspLanguage</a>, <a href="InterCal.html">InterCal</a>, <strong></strong><a href="UnLambdaLanguage.html">UnLambdaLanguage</a><strong>, </strong><a href="MalbolgeLanguage.html">MalbolgeLanguage</a>, <strong>URISC</strong>
        (Sidenote: Malbolge is almost certainly not <a href="TuringComplete.html">TuringComplete</a>.  <a href="InterCal.html">InterCal</a> is not minimalistic.  <a href="BefungeLanguage.html">BefungeLanguage</a> is not a "bare minimum" approach either.)  <em>Also, it should be noted that the </em>EsotericProgrammingLanguages have not been peddled, FTMP, as <a href="SilverBullet.html">SilverBullet</a>s.  There are many other <a href="TuringTarpit.html">TuringTarpit</a>s OTOH, that have.<em></em>
      </p>
      <p>
        See also <a href="LambdaCalculus.html">LambdaCalculus</a>, <a href="EssAndKayCombinators.html">EssAndKayCombinators</a>, <a href="LittleLanguage.html">LittleLanguage</a>, <a href="MinimalistLanguage.html">MinimalistLanguage</a>, <a href="EsotericProgrammingLanguage.html">EsotericProgrammingLanguage</a>, <a href="TuringTrap.html">TuringTrap</a>
      </p>
      <p>
        <em>Shouldn't </em><a href="UnLambdaLanguage.html">UnLambdaLanguage</a> and its ilk instead be called a ChurchQuagmire?  While the <a href="ChurchTuringThesis.html">ChurchTuringThesis</a> says the two types of PissPoorProgrammingLanguages are in fact computationally equivalent, calling a <a href="FunctionalProgrammingLanguage.html">FunctionalProgrammingLanguage</a> a TuringAnything is sure to annoy the <a href="FunctionalWeenie.html">FunctionalWeenie</a>s....<em></em>
      </p>
      <p>
        Another kind of <a href="TuringTarpit.html">TuringTarpit</a> is implicit in the claim that "<a href="ThereIsNothingPerlCannotDo.html">ThereIsNothingPerlCannotDo</a>!"
      </p>
      <p>
        Programmers often fall into the Turing tarpit when arguing about how powerful languages are. For example, a common exchange is for a <a href="SmugLispWeenie.html">SmugLispWeenie</a> to go off on how Lisp is more powerful than other languages. Then some SmugFooWeenie will point out that of course Lisp is not more powerful than Foo, you moron, since they are both <a href="TuringEquivalent.html">TuringEquivalent</a>. And then the <a href="SmugLispWeenie.html">SmugLispWeenie</a> will explain for the gazillionth time that what he means by "more powerful" is that there are things you can do in Lisp that you can't do in Foo without <a href="ImplementingLisp.html">ImplementingLisp</a> (or some domain-independent thing of similar complexity) first. (See <a href="GreenspunsTenthRuleOfProgramming.html">GreenspunsTenthRuleOfProgramming</a>.)
      </p>
      <p>
        Here is my example: <a href="http://www.oriontransfer.co.nz/research/register-machine-interpreter/index">http://www.oriontransfer.co.nz/research/register-machine-interpreter/index</a> -- Samuel
      </p>
    </div>
  </body>
</html>