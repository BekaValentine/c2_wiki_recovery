<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Useful Programming Language
      </h1>
      <p>
        A <a href="UsefulProgrammingLanguage.html">UsefulProgrammingLanguage</a> is one that (simultaneously):
      </p>
      <ul>
        <li>
           provides <a href="PrimitivesAndMeansOfComposition.html">PrimitivesAndMeansOfComposition</a>
        </li>
      </ul>
      <ul>
        <li>
           to meet useful functional requirements (as demanded by a domain)
        </li>
      </ul>
      <ul>
        <li>
           while also meeting a variety of pervasive concerns, including:
        </li>
      </ul>
      <ul>
        <li>
           performance
          <ul>
            <li>
               efficiency: ability to achieve high performance with very few resources
            </li>
            <li>
               utilization: ability to use full power of machine to achieve high performance
            </li>
            <li>
               latency: time between a cause and a given effect. There is hardware latency and software latency; a good programming language should allow minimizing total latency, which requires taking full advantage of hardware capabilities.
            </li>
            <li>
               multi-dimensional: space, cpu, power-consumption, bandwidth, latency
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           reliability
          <ul>
            <li>
               <strong>robust:</strong> a system is robust if it keeps working even in adverse conditions. This includes working under contract violations (where programmers mess up). In an open system, robustness is necessary for security - and vice versa - due to malicious coders (denial-of-service attacks, etc.) Robustness for dataflows and event-flows is aided by supporting such techniques as failover, redundancy, caching, and <a href="GracefulDegradation.html">GracefulDegradation</a> - automatically switching to another service, possibly in stages, and even falling back on cached values when the primary services are disabled. 
            </li>
            <li>
               <strong>resilient:</strong> a system is resilient to the degree that it quickly and completely recovers from adverse conditions. Poor resilience requires manual intervention restarting whole applications, maybe the whole computer, or possibly even a whole network of computers (and starting them up in a particular order), to recover from error. It might require reformatting a drive. More resilient systems are self-healing (i.e. quickly recovering from fallbacks or failure), involve resetting the minimum possible. 
            </li>
            <li>
               disruption tolerant
            </li>
            <li>
               graceful degradation: 
            </li>
            <li>
               resilient: recovers quickly, correctly, and automatically once source of problem eliminated
            </li>
            <li>
               available: uptime ratings (how many "nines"?)
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           predictability
          <ul>
            <li>
               temporal: ability to predict temporal properties of a process
              <ul>
                <li>
                   realtime: ability to bind latencies (both upper and lower bounds) for a given process
                </li>
                <li>
                   terminating: weaker than realtime; ability to say that a given process will terminate in certain ways.
                </li>
              </ul>
            </li>
            <li>
               synchronization: ability to ensure two otherwise-independent processes have the same latencies
            </li>
            <li>
               embedded: ability to bind space costs (upper bounds) for a continuous process
            </li>
            <li>
               clueless programming: ability to know the characteristics of a composed system without knowing implementations of the components. (i.e. cannot use locks for concurrency since two components using locks might be independently correct but then deadlock when composed)
            </li>
            <li>
               reliability: ability to prove certain forms of resilience or robustness
            </li>
            <li>
               partial-failure handling: ability to predict how system behaves under partial failures <em>from end-to-end</em>.
            </li>
            <li>
               consistency: ability for different observers to agree on a property. (Implies consensus, not determinism.)
              <ul>
                <li>
                   bounded inconsistency: bounded inconsistency in a distributed observer system. 
                </li>
                <li>
                   eventual consistency: unbounded inconsistency, with the provision that <em>if</em> updates stop <em>then</em> everyone will eventually reach a consensus on what they should be seeing.
                </li>
              </ul>
            </li>
            <li>
               determinism: lack of <em>observable</em> randomness; given inputs and initial state, output and final state are fully specified. Does not preclude non-observable non-determinism.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           modularity
          <ul>
            <li>
               delay of choice: code defined outside module can affect module
            </li>
            <li>
               component packaging: provision of software units 
            </li>
            <li>
               matchmaking and linking: ability to meet logical demands from one software unit to another (i.e. "I need HTTP access" is met by "I provide HTTP access" by examining a repository of software components). 
            </li>
            <li>
               live services: ability to hook into 'real' systems
            </li>
            <li>
               confinement: ability to logically replace or intercept access to 'real' systems without modifying the accessing code.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           maintenance
          <ul>
            <li>
               changing requirements
            </li>
            <li>
               changing environment: new hardware, new OS
            </li>
            <li>
               backwards compatibility
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           system administration
          <ul>
            <li>
               distributed components
            </li>
            <li>
               install: distribution of components
            </li>
            <li>
               uninstall: ability to cleanly remove or eliminate unnecessary components after installing them
            </li>
            <li>
               dependency management (avoiding <a href="DllHell.html">DllHell</a>)
            </li>
            <li>
               <a href="ConfigurationManagement.html">ConfigurationManagement</a>
            </li>
            <li>
               <a href="PolicyInjection.html">PolicyInjection</a>
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           security - a variety of environmental concerns
          <ul>
            <li>
               confinement: limiting the damage from running someone else's code on your machine
            </li>
            <li>
               authority: end-to-end ensuring that operators do no more than they are allowed
            </li>
            <li>
               privacy: protecting secrets of both users and businesses that need to distribute things. two-sided <a href="DigitalRightsManagement.html">DigitalRightsManagement</a>. 
              <ul>
                <li>
                   robust privacy: protects against accidental leaks by programmers and users, i.e. by having well-defined secrecy-violation exceptions, by censuring, by constraining automatic distribution based on secrecy.
                </li>
                <li>
                   resilient privacy: helps patch up after a programmer or user leaks data; doable via auditing, <a href="WebOfTrust.html">WebOfTrust</a>, cutting off unauthorized systems quickly.
                </li>
              </ul>
            </li>
            <li>
               access: ensuring availability of service to authorized users in presence of external attempts at attack or sabotage
            </li>
            <li>
               stealth: limiting noisy communications in case of eavesdropping or military purpose
            </li>
            <li>
               anonymity: resistance to tracking communications between a data-source and a subscription
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           without requiring much <a href="SelfDiscipline.html">SelfDiscipline</a> or foresight
        </li>
      </ul>
      <ul>
        <li>
           composition and reuse of code written originally for some other purpose
        </li>
      </ul>
      <ul>
        <li>
           scales to large numbers of programmers
        </li>
      </ul>
      <ul>
        <li>
           premature abstraction shouldn't hurt performance (i.e. ability to 'flatten' abstractions in a staged compilation)
        </li>
      </ul>
      <ul>
        <li>
           premature optimization shouldn't hurt abstraction (i.e. with compositional gotchas, like deadlocks)
        </li>
      </ul>
      <ul>
        <li>
           'clueless' programming: programmers should be able to remain ignorant of implementation details
        </li>
      </ul>
      <ul>
        <li>
           'iterative' or 'exploratory' programming: programmers must be able to learn and achieve progress with the 'write sloppy then fix' approach
        </li>
      </ul>
      <ul>
        <li>
           stigmergy: programmers make mistakes, so the language (and IDE) would do well to automatically guide a collection of programmers to fixing the mistakes rather than burying them. (May benefit from <a href="FirstClass.html">FirstClass</a> support for <a href="UnitTest.html">UnitTest</a>s to allow <a href="ZeroButtonTesting.html">ZeroButtonTesting</a> and other features)
        </li>
      </ul>
      <ul>
        <li>
           <a href="LazinessImpatienceHubris.html">LazinessImpatienceHubris</a> in programmers 
        </li>
      </ul>
      <ul>
        <li>
           and <em>without</em> requiring a <a href="SufficientlySmartCompiler.html">SufficientlySmartCompiler</a>
        </li>
      </ul>
      <ul>
        <li>
           implementable: no language primitive shall involve any 'magic'; ideally, the implementation of each primitive is simple and straightforward.
        </li>
      </ul>
      <ul>
        <li>
           analyzable: designed for certain analyses to improve reliability, security, performance, etc. <a href="RicesTheorem.html">RicesTheorem</a> suggests delaying <a href="TuringEquivalency.html">TuringEquivalency</a> as far to the edges of the language as possible
        </li>
      </ul>
      <ul>
        <li>
           optimizable: designed to support certain transforms (like <a href="TailCallOptimization.html">TailCallOptimization</a>, <a href="PartialEvaluation.html">PartialEvaluation</a> code elimination, operation reordering) without hurting semantics or modularity. Here it helps if <a href="SideEffect.html">SideEffect</a>s are delayed as far to the edges of the language as feasible (<a href="EventualSideEffects.html">EventualSideEffects</a>).
        </li>
      </ul>
    </div>
  </body>
</html>