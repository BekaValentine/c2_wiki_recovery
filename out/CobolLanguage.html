<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Cobol Language
      </h1>
      <p>
        The <em>C</em><em>o</em>mmon <em>B</em>usiness <em>O</em>riented <em>L</em>anguage, designed by a team lead by <a href="GraceHopper.html">GraceHopper</a>. Designed to be read by managers. Its unverified origin is explained at <a href="CobolCausesBrainDamage.html">CobolCausesBrainDamage</a>.
      </p>
      <ul>
        <li>
           I don't think <a href="GraceHopper.html">GraceHopper</a> was the "official" team leader. However, her earlier work on language design had a lot of influence on COBOL. The way some of the members describe it is basically the committee couldn't agree on anything (massive ego battles), ran out of time, and then fell back on Grace's earlier work as a basis for the language because it had generally worked, was liked, and they needed to produce something fast because they had squandered their time on those ego battles. Nothing like a deadline to inject reality into idealists.
        </li>
      </ul>
      <p>
        <em>I believe COBOL was originally designed to be easier to read than assembly language.  That's pretty much all you can say for it...</em>
      </p>
      <p>
        <em>Don't forget the B in COBOL.</em>
      </p>
      <p>
        See also its spiritual successor <a href="AbapLanguage.html">AbapLanguage</a>, which is basically COBOL for SAP R/3 systems.
      </p>
      <hr/>
      <p>
        A COBOL programmer can say things like:
      </p>
      <code>
        DIVIDE TOTAL BY NUMBER GIVING PRO-RATA REMAINDER RESIDUE.<br/>
      </code>
      <p>
        Cobol also allowed things like
      </p>
      <code>
        SORT PEOPLE-FILE ON KEY SSN.<br/>
      </code>
      <p>
        A COBOL program is divided into divisions, sections, paragraphs and sentences. The sentence above may not be valid, as COBOL has getting on for a thousand keywords, one or more of which I may have used as, well, not variables exactly, as <em>names</em> above.
      </p>
      <p>
        COBOL assumes hierarchical data records. This fitted most of data of the time: Unit Record Systems, Tabulators, Punch Cards, Line Printers, Magnetic Tapes, etc..
      </p>
      <p>
        It was and is one of the few languages that had exact fixed point decimal arithmetic on big numbers.  This is useful
        for a type of data called <em>money</em>.  The <em>B</em> in <em>COBOL</em>.  For example, if you computed WAGES
        you could get the dollars and cents to count how many bills and coin of each denomination
        would be needed to fill the weekly pay packets.  No division was needed, you just had CENTS OF WAGES.
      </p>
      <p>
        Interestingly, there is some attempt to isolate a COBOL program from its environment, placing all the system specific details in one division at the top. Not bad for the 50's.
      </p>
      <p>
        The most fun construct in COBOL is the ALTER verb. COBOL has something like the "computed goto" of FORTRAN. Older dialects have no notion of a procedure or function, all the flow of control is done with named paragraphs and gotos.  Anyway, ALTER lets you change, at runtime, where the branches of a goto go to. As <a href="CharlesWeir.html">CharlesWeir</a> pointed out, one could use this to implement polymorphism. If you had a lot of time on your hands.
      </p>
      <p>
        <em>FORTRAN has (or had) a similar thing called assigned GOTO. -- </em><a href="JohnFletcher.html">JohnFletcher</a><em></em>
      </p>
      <p>
        By 1970, if not earlier, any section or paragraph (or sequence of sections or paragraphs) could be executed as a subprogram with the PERFORM verb.  This also provided structured loops:
      </p>
      <code>
        PERFORM WAGE-CALCULATION UNTIL END-OF-FILE.<br/>
        PERFORM FACTORIAL-MULTIPLICATION VARYING MULT FROM 2 BY 1 UNTIL MULT > 100.<br/>
      </code>
      <p>
        COBOL is still a force in the world, so much so that when I was an unemployable fresh graduate the British employment service thought that having a CityAndGuilds certificate in COBOL programming would help my job prospects enough for them to pay for me to get one.
      </p>
      <p>
        -- <a href="KeithBraithwaite.html">KeithBraithwaite</a>
      </p>
      <p>
        <a href="CobolLanguage.html">CobolLanguage</a>'s market share is the envy, aspiration and Holy Grail of all <a href="FourthGenerationLanguage.html">FourthGenerationLanguage</a> vendors.
      </p>
      <p>
        -- <a href="MattRickard.html">MattRickard</a>
      </p>
      <p>
        Syntax for old COBOL at
      </p>
      <code>
        <a href="http://www.csci.csusb.edu/dick/samples/cobol.syntax.html">http://www.csci.csusb.edu/dick/samples/cobol.syntax.html</a><br/>
      </code>
      <p>
        The readableness of things like
      </p>
      <ol>
        <li>
           PRINT PIC CR********9V.99.
        </li>
      </ol>
      <p>
        was always debatable.
      </p>
      <p>
        -- <a href="DickBotting.html">DickBotting</a>
      </p>
      <p>
        Not if you were working at a financial institute of the time. Leading with asterisks was done to ensure no alteration of counter-checks. Seems pretty obvious in that light, print amount with all leading spaces filled with '*', float a '+' or '-' in front.
        -- CHergerThomann
      </p>
      <p>
        <em>Format templating is a good thing in my opinion. I don't know of a better alternative. I agree that maybe COBOL's templating symbol choices were not always the best, but at least it had a solid set.</em>
      </p>
      <hr/>
      <p>
        There's speculation on <a href="WhatTheYtwokDrivers.html">WhatTheYtwokDrivers</a> that the inflexibility of COBOL, and in particular, the absence of abstract data types (or some other mechanism for information hiding/encapsulation) aggravated the Y2K problem. Had COBOL these features, moving from 2 to 4 digits dates should have been much easier.
      </p>
      <p>
        <em>Many developers said that it was often to save disk, memory space, and card space, which was very expensive at the dawn of computing. ADT's wouldn't help there. Also, standard punched cards had 80 characters. If you went over that, then you had to deal with double stacks. Many interviewed said they would have happily used 4-digit years if not for the hardware-related issues.</em>
      </p>
      <hr/>
      <p>
        And if pigs had wings, they could fly. In those days, compiler writers were still fighting to show that assembler wasn't the Ultimate Language, external storage was magtape and punched cards, and <em>no one</em> had things like ADTs. (Though perhaps it could be faked in Lisp, which is approximately the same age as Cobol.) -- David Wolff.
      </p>
      <p>
        It would seem that the poster on WTYD was not suggesting that COBOL was deficient by not having features that weren't available at the time, but rather that because we all do use ADTs and encapsulation and such these days (right?) any future such problem would be easier to fix. Not that Y2K was such a problem anyway, it turns out. Judge the porcine aviation factor of todays "best practice" for yourself.
      </p>
      <hr/>
      <p>
        COBOL made me think of CodeAsPoetry before I knew much about the <a href="PerlLanguage.html">PerlLanguage</a>. -- <a href="NickBensema.html">NickBensema</a>
        Or perhaps, code-as-folktale?  I present, "The Common Business-Oriented Goldilocks":
      </p>
      <ul>
        <li>
           <a href="http://www-users.cs.york.ac.uk/susan/joke/cblgold.htm">http://www-users.cs.york.ac.uk/susan/joke/cblgold.htm</a>
        </li>
      </ul>
      <p>
        See also <a href="CobolFallacy.html">CobolFallacy</a>, a lesson which <a href="AppleScript.html">AppleScript</a> did not learn.
      </p>
      <hr/>
      <p>
        A Cobol grammar generated from the official Cobol standard is available (in a rather readable format) at 
      </p>
      <dl>
        <dt> </dt>
        <dd><a href="http://www.cwi.nl/~ralf/grammars/vs-cobol-ii/">http://www.cwi.nl/~ralf/grammars/vs-cobol-ii/</a></dd>
      </dl>
      <p>
        Another Cobol grammar, which was actually used for the purpose of <a href="ReverseEngineering.html">ReverseEngineering</a> Cobol <a href="LegacyCode.html">LegacyCode</a>, is available at
      </p>
      <dl>
        <dt> </dt>
        <dd><a href="http://www.cwi.nl/~mdejonge/grammar-base/">http://www.cwi.nl/~mdejonge/grammar-base/</a></dd>
      </dl>
      <p>
        -- <a href="ArieVanDeursen.html">ArieVanDeursen</a>
      </p>
      <hr/>
      <p>
        Apparently, COBOL is now available for the Microsoft .NET framework. See <a href="OtherDotNetLanguages.html">OtherDotNetLanguages</a>.
      </p>
      <p>
        There's also OO-COBOL - see <a href="http://home.swbell.net/mck9/cobol/ooc/overview.html.">http://home.swbell.net/mck9/cobol/ooc/overview.html.</a> <em>Cobol++? Should be called "POSTINCREMENT COBOL BY 1 GIVING COBOL"!</em>
      </p>
      <hr/>
      <p>
        COBOL Standards:
      </p>
      <ul>
        <li>
           1968 = "COBOL Classic"  ;->
        </li>
        <li>
           1974
        </li>
        <li>
           1985 = Adds structured if/else/end-if, perform/end-perform, etc.
          <ul>
            <li>
               1989 addendum = "added intrinsic functions, such as COSINE and TANGENT"
            </li>
            <li>
               1993 addendum = "corrected errors and ambiguities"
            </li>
          </ul>
        </li>
        <li>
           1995 = "Object Oriented" COBOL
        </li>
        <li>
           2002 = "includes object-oriented features, locale support, UNICODE support and data validation."
          <ul>
            <li>
               <a href="http://www.microfocus.com/whitepapers/developmentcobolstandard.asp">http://www.microfocus.com/whitepapers/developmentcobolstandard.asp</a>
            </li>
            <li>
               <a href="http://objectz.com/AnEveningwith/transcript1.html">http://objectz.com/AnEveningwith/transcript1.html</a> = an interview with Don Schricker
            </li>
          </ul>
        </li>
        <li>
           2008 = planned next version
          <ul>
            <li>
               <a href="http://www.cobolstandards.com/">http://www.cobolstandards.com/</a>
            </li>
            <li>
               <a href="http://www.cobolstandards.com/annexf.pdf">http://www.cobolstandards.com/annexf.pdf</a>
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <p>
        I've been tutoring a university student who's taking an intro programming course, and the instruction language is <a href="JavaLanguage.html">JavaLanguage</a>. One day she was asking me some questions about why Java is the way it is, and I forwarded a link to <a href="JavaIsTheNewCobol.html">JavaIsTheNewCobol</a> and some COBOL example program for reference. She came back a few minutes later and asked, "um, so why don't people just use that?" Since this question required an hour of answer or none at all, I changed the subject. Still, it's interesting how the verbosity of COBOL makes it somehow seem less dated than it is.
      </p>
      <hr/>
      <p>
        COBOL User Groups (COBUG)
      </p>
      <p>
        A COBOL programming portal that is a one-stop resource for the COBOL community where you will find references to user groups, compilers, forums, jobs, and other COBOL programming resources.
      </p>
      <p>
        <a href="http://www.cobug.com/">http://www.cobug.com/</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryProgrammingLanguage.html">CategoryProgrammingLanguage</a>
      </p>
    </div>
  </body>
</html>