<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        The Simplest Possible Compiler
      </h1>
      <p>
        See <a href="XpForOptimizingCompilers.html">XpForOptimizingCompilers</a>.
      </p>
      <p>
        The simplest optimizing compilers I've seen are in <a href="PeterNorvig.html">PeterNorvig</a>'s <a href="ParadigmsOfArtificialIntelligenceProgramming.html">ParadigmsOfArtificialIntelligenceProgramming</a> and <a href="ChristianQueinnec.html">ChristianQueinnec</a>'s <a href="LispInSmallPieces.html">LispInSmallPieces</a>. They share several traits:
      </p>
      <ul>
        <li>
           They parasitize off of an existing language runtime.
        </li>
        <li>
           They compile to byte codes.
        </li>
        <li>
           They use an <a href="AbstractSyntaxTree.html">AbstractSyntaxTree</a> to represent programs.
        </li>
      </ul>
      <p>
        All of these compilers were written for instructional purposes, and all were built up from even simpler interpreters. Norvig does an especially spiffy job: he fits a compiler, an assembler, a peephole optimizer, a branch simplifier and a VM all into two chapters.
      </p>
      <p>
        Furthermore, I suspect that any of these compilers could be built using XP and a bit of domain knowledge. Even better, you could improve them further without radical re-design--techniques are known for doing native code generation straight from an <a href="AbstractSyntaxTree.html">AbstractSyntaxTree</a>.
      </p>
      <p>
        <strong>But what about a modern production compiler?</strong>
      </p>
      <p>
        Modern production compilers generally don't rely on ASTs. Typically, they use something like (say) N-address code, possibly in <a href="StaticSingleAssignmentForm.html">StaticSingleAssignmentForm</a>. They use lots of funky algorithms. For an idea of how hairy it can get, compare the algorithms in StevenMuchnick's <a href="AdvancedCompilerDesignAndImplementation.html">AdvancedCompilerDesignAndImplementation</a>, or even <a href="TheDragonBook.html">TheDragonBook</a> (older), to the books above.
      </p>
      <p>
        I don't think you could build one of these beasts without some prior design work. I don't think you could start out with one of the simple compilers above, and transform it into one of these without breaking a lot of test suites for several programmer-weeks. I could be wrong.
      </p>
      <p>
        Or does XP classify this kind of broad-sweeping, hard-won, architectural knowledge as a <a href="SystemMetaphor.html">SystemMetaphor</a>, as was suggested by <a href="RalphJohnson.html">RalphJohnson</a>? -- EricKidd
      </p>
      <hr/>
      <p>
        <a href="AssemblyLanguage.html">AssemblyLanguage</a> fits here in 2 different ways:
      </p>
      <p>
        To get really fast applications, the compiler will, of course, have to compile all the way to <a href="MachineCode.html">MachineCode</a>. (To make it easier to test if it's working right, many compilers have a compiler option to save a ".cod" (<a href="MachineCode.html">MachineCode</a>) file, which shows the raw hex <a href="MachineCode.html">MachineCode</a> bytes, the <a href="AssemblyLanguage.html">AssemblyLanguage</a>, and the high-level source.).
      </p>
      <p>
        If I get to pick the source language, the simplest possible compiler for me to write is an assembler for <a href="AssemblyLanguage.html">AssemblyLanguage</a>.  <em>If you get to pick the source language </em>and<em> don't have to optimize, the simplest possible compiler is the null compiler that performs an identity transformation.  Let the source language be the target runtime format.  Done.</em>
      </p>
      <hr/>
      <p>
        The simplest optimizing compiler I've written was 200 lines of C code, compiling <a href="ForthLanguage.html">ForthLanguage</a> to powerpc <a href="MachineCode.html">MachineCode</a>. Optimizations were limited, but included <a href="TailCallOptimization.html">TailCallOptimization</a>, ConstantFolding, inlining, and a generic PeepholeOptimization mechanism that used something akin to sed's s/foo/bar/ to rewrite short segments of code. Oh, and it was hard <a href="RealTime.html">RealTime</a> in the absense of <a href="ForthMacro.html">ForthMacro</a>s (although, in Forth, macros are rarely absent); the amount of work for a character in the source code was bounded. -- <a href="AdamBerger.html">AdamBerger</a>
      </p>
      <p>
        <a href="ForthSimplicity.html">ForthSimplicity</a> has the complete source code for a (non-optimizing) compiler.
      </p>
      <p>
        <a href="ColorForth.html">ColorForth</a> also has a very small compiler, with limited optimizations. <a href="ForthLanguage.html">ForthLanguage</a> lends itself to simple compilers. It is more of a macro assembler for a virtual machine than a high-level language.
      </p>
      <hr/>
      <p>
        I remember that the compiler (to 68k) for the <a href="FalseLanguage.html">FalseLanguage</a> had only 1K size (written in <a href="AssemblyLanguage.html">AssemblyLanguage</a>). -- <a href="GunnarZarncke.html">GunnarZarncke</a>
      </p>
      <hr/>
      <p>
        The C compiler I wrote for the <a href="BbcMicro.html">BbcMicro</a> while at Acornsoft ran in 20K - code and data. It barely deserved the title "optimizing", though. Paul Fellows also wrote a Pascal compiler for the same machine that also ran in 20K. -- <a href="PaulHudson.html">PaulHudson</a>
      </p>
      <hr/>
      <p>
        See also <a href="StepsTowardTheReinventionOfProgramming.html">StepsTowardTheReinventionOfProgramming</a>
      </p>
      <p>
        <a href="CategoryCompilers.html">CategoryCompilers</a>
      </p>
    </div>
  </body>
</html>