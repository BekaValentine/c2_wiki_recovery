<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        High Performance With Good Design
      </h1>
      <dl>
        <dt>It's often assumed that...</dt>
        <dd><em></em>'"Ohmygod!  We have ambitious and strict performance requirements...  So we'll have to throw out all the 'good design' techniques, and just do a lot of crazy <a href="CowboyCoding.html">CowboyCoding</a> to make it run as fast as possible."<em></em>'</dd>
      </dl>
      <p>
        Now hold it there partner:
        Good design makes it easier to optimize for performance in those places where it really matters.
      </p>
      <hr/>
      <p>
        Case in point -- ACE framework and TAO CORBA server:
      </p>
      <ul>
        <li>
           <a href="http://www.cs.wustl.edu/~schmidt/ACE.html">http://www.cs.wustl.edu/~schmidt/ACE.html</a>
        </li>
        <li>
           <a href="http://www.cs.wustl.edu/~schmidt/TAO.html">http://www.cs.wustl.edu/~schmidt/TAO.html</a>
          <ul>
            <li>
               Performance metrics:  <a href="http://www.cs.wustl.edu/~schmidt/ACE_wrappers/TAO/docs/TAO-metrics.html">http://www.cs.wustl.edu/~schmidt/ACE_wrappers/TAO/docs/TAO-metrics.html</a>
            </li>
          </ul>
        </li>
      </ul>
      <p>
        Highly <a href="ObjectOriented.html">ObjectOriented</a> design with extensive use of <a href="DesignPatterns.html">DesignPatterns</a>.
        It's maker, Douglas Schmidt is widely known for his lectures and articles on the use of <a href="DesignPatterns.html">DesignPatterns</a>.
      </p>
      <p>
        ACE and TAO are used in real-time applications on aircraft.
      </p>
      <hr/>
      <hr/>
      <p>
        [<a href="EditHint.html">EditHint</a>: Feel free to precis this]
      </p>
      <p>
        <em>Verifiable correctness (and therefore good design) are absolutely crucial in this application (aerospace).  Generally the processors should have capacity surplus to requirements, a good safety margin, so possibly the need for extreme optimization is not critical in this application, or only critical in some very localized parts of it?</em>
      </p>
      <p>
        My impression is that the "real time" software above operates under the constraint that its performance be <strong>predictable and very high.</strong>
        For example: Their IDL compiler munges the data until it can get a "perfect hash" on the methods of each interface.
        Thus, it can avoid hash collisions and linear search times for method lookups.
        -- <a href="JeffGrigg.html">JeffGrigg</a>
      </p>
      <hr/>
      <p>
        <em>Now if you think your silly game has to avoid all use of objects and patterns because it "has to go fast," I think you still have a few things to learn. -- </em><a href="AnonymousDonor.html">AnonymousDonor</a><em></em>
      </p>
      <p>
        <em>And Mr </em><a href="AnonymousDonor.html">AnonymousDonor</a>, you have a few things to learn if you think it can be done with widely available tools like C++.  You may need to <a href="ThinkObjectsButWriteAssembler.html">ThinkObjectsButWriteAssembler</a>, at least for some of it.  Have you actually ever written a 'silly game' in C++?<em> -- </em><a href="JamesCrook.html">JamesCrook</a>  <em>Hmm.  Now if I'd actually read what you said I'd see that you were saying just that games coders don't need to abandon ALL objects and patterns.  With which I thoroughly agree.</em>.
      </p>
      <p>
        ACE and TAO are written in C++, with objects and patterns.
        And they exibit high performance.
      </p>
      <p>
        I think Mr. <a href="AnonymousDonor.html">AnonymousDonor</a>
        <em>(</em><a href="AnonymousCoward.html">AnonymousCoward</a>?)<em></em>
        is trying to say that game programmers <strong><em>should</em></strong> use objects and patterns.
        -- <a href="JeffGrigg.html">JeffGrigg</a>
      </p>
      <hr/>
      <p>
        There are usually two contributing causes to poor performance, poor architecture and under powered hardware (either CPU or communications lines).  Improving the design through refactoring will also address performance issues in the first case.  In the second case, you will have to adjust your design to meet the constraints of your hardware.  As a final note, reading source code is absolutely the worst way to predict performance.  You can do some modeling of key areas up front to guide your initial design, but then you will have to rely on full system level tests and measurements to identify performance problems.  Trying to save CPU cycles on an instruction by instruction basis is rarely effective or necessary.  --<a href="WayneMack.html">WayneMack</a>
      </p>
      <hr/>
      <p>
        On my current project we are using all C++ (with small amounts of assembly where absolutely necessary, and/or on the graphics chips), and this is the most well-executed and well-performing game project I have been on so far.
      </p>
      <p>
        In my experience, OO just means more and better organization.  And disorganization and messy code just creates more problems all around, in maintainability, bugginess, and performance.
      </p>
      <p>
        It's all up to the particular programmer(s) in question, of course, and obviously OO "can be done" in C or whatever.  But the time saved in using a made-for-OO language, using OO concepts, is not to be underestimated.
      </p>
      <hr/>
      <p>
        I've been writing games for the last 13 years, starting with pure assembler, moving to C and lately to C++.
      </p>
      <p>
        As with most performance-critical projects though, there are a few core parts that will use up the majority of the available processing power and you have to optimize those parts heavily to compete in today's games industry. That may mean getting rid of class hierarchies, exception handling and similar constructs that create even a little overhead. But it's still possible to do most of the work in C++ and to wrap the nasty parts within good interfaces. In my company we still have to hand-optimize our graphics shaders in assembler and align memory reads/writes to hardware boundaries in order to squeeze the last bits of performance out of the machines, but the engine using those shaders and hard-optimized parts is still written in C/C++.
      </p>
      <p>
        Mind though, we're talking PCs and the latest generation of games hardware (GameCube, PlayStation2, Xbox) here. I would expect a GameBoy game to include a lot more "hardcore" programming as the memory requirements are incredibly tight and performance is crucial. There's always someone who'll throw out any overhead and fine-tune his assembler and get that extra flash in there.
      </p>
      <p>
        Then again. Even on a GameBoy I wouldn't write the HighScore handler in assembler.
      </p>
      <p>
        -- <a href="AndreasAxelsson.html">AndreasAxelsson</a>
      </p>
      <hr/>
      <p>
        <a href="PrematureOptimization.html">PrematureOptimization</a> is the root of all evil!  Write your game in a highish-level language and <a href="OptimizeLater.html">OptimizeLater</a>.  USE A PROFILER to find the 5% of the code that matters; optimize that.  There <strong>might</strong> be as much as 1% that deserves to be optimized right down to assembler.  Until you ProfileTheCode you will <strong>not</strong> know where that 1% is.
      </p>
      <hr/>
      <p>
        [<a href="CategoryGameProgramming.html">CategoryGameProgramming</a>]
      </p>
    </div>
  </body>
</html>