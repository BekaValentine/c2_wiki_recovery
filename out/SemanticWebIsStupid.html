<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Semantic Web Is Stupid
      </h1>
      <p>
        Yes, I'm riding for a fall here. I expect someone will stick that ol' branch in my spokes and I'll be spitting teeth faster than you can say
      </p>
      <code>
        <?xml version="1.0"?><br/>
        <rdf:RDF<br/>
        xmlns:rdf="<a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#">http://www.w3.org/1999/02/22-rdf-syntax-ns#</a>"<br/>
        xmlns:stupid="<a href="http://www.c2.com/cgi/wiki?SemanticWebIsStupid#">http://www.c2.com/cgi/wiki?SemanticWebIsStupid#</a>"><br/>
        <rdf:Description<br/>
        rdf:about="<a href="http://www.c2.com/cgi/wiki?SemanticWebIsStupid#">http://www.c2.com/cgi/wiki?SemanticWebIsStupid#</a>"><br/>
        <stupid:firstname>Jack</stupid:firstname><br/>
        <stupid:secondname>Robinson</stupid:secondname><br/>
        </rdf:Description><br/>
        </rdf:RDF><br/>
      </code>
      <p>
        Um ... so you see I think English <strong>is</strong> semantic markup. I think a thesaurus makes a great folksonomy already. I think all that xmlns crap is about as useful for making a successful query as crutches are useful for making fish walk. In other words, I think this whole super-meta-hypertagged <bs/> is rid.iculo.us.
      </p>
      <p>
        Like I say, I'm riding for a fall. But really, after all this time, I'm sorry, I just don't frickin' get it. Straighten me, someone, 'cause I'm ready. -- Pete
      </p>
      <p>
        <em>RDF is easier for machines to parse, and it can be made non-ambiguous. Those are the only two things that I know of that really differentiate it from English. -- </em><a href="MichaelSparks.html">MichaelSparks</a><em></em>
      </p>
      <p>
        What convinces you it can be made non-ambiguous?
      </p>
      <p>
        <em>I'm no expert on these things, but from what I can tell, English has two types of ambiguity: words can have multiple meanings, and the grammar is itself ambiguous (in the sense of formal grammars). With RDF, you can control the entire vocabulary, eliminating the first type of ambiguity. And RDF doesn't really have a grammar in the same sense as English, so that precludes it having the second type of ambiguity. Note that I don't claim that this prevents you from making ambiguous statements </em>in<em> RDF; only that the representation of the statements doesn't itself necessarily lead to ambiguity. -- </em><a href="MichaelSparks.html">MichaelSparks</a><em></em>
      </p>
      <p>
        As I said, I don't frickin' get it. With regard to the first type of ambiguity, I see that you can control your vocabulary. I see that the words in your vocabulary are human language words, and therefore ambiguous. I see you catching water in a net and squeezing jelly between your fingers.
      </p>
      <p>
        Now, without grammar, I see more ambiguity, not less. <em>Michael Refute Peter</em>. <em>Peter Refute Michael</em>. Oh, they're the same thing? How about <em>If Michael refutes Peter, Peter will stop trying to refute Michael?</em>
      </p>
      <p>
        This may seem like abstract KR stuff, but really there are a whole bunch of magillas trying to make over the <a href="WikiPedia.html">WikiPedia</a> category system, which works fine, into this kind of ambiguous nonsense, which does not, on the grounds that then they can make lists of pages that mention, say [[Location:Venezuela]]. Including, of course, pages that say things about [[Location:Venezuela]] that are about as relevant to [[Location:Venezuela]] as this paragraph I'm writing right here. <em>[Got a link for this making-over?]</em>
      </p>
      <p>
        You can fool <a href="MarkvShaney.html">MarkvShaney</a> like that of course ...
      </p>
      <p>
        How about getting <a href="DeMorgansLaws.html">DeMorgansLaws</a> into RDF ... and if you can do that, then what about the <a href="ExcludedMiddle.html">ExcludedMiddle</a>? Dare I mention the <a href="FrameProblem.html">FrameProblem</a>? Hmm. If I can express these kinds of things in English, but not in RDF, then RDF is (a) ambiguous and (b) not semantic markup.
      </p>
      <p>
        While I'm in mid rant, I suggest that any language which does not, at a minimum, ground its terms in some specific empiricism, can not be semantic. And any language whose atoms are URLs can't do that to begin with. -- Pete
      </p>
      <p>
        <em>I think we may be using the word 'ambiguous' in two different ways. My understanding is that there are two different thoughts that when encoded in a language, have the same encoding, and therefore a reader, when encountering that encoded form, doesn't know which thought it represents. If I'm reading right, you seem to use it to mean that there is one thought that can be encoded more than one way.</em>
      </p>
      <p>
        <em>You said at one point that "words in [an RDF] vocabulary are human language words", but later you said "language whose atoms are URLs". I think you've answered your own question here. The vocabulary is made of these URLs, not English words. An RDF atom that is named after an English word doesn't inherit meaning from it any more than a C++ class would. In both cases, the </em>meaning<em> of the thing is entirely determined by the formal workings of the language, and the use of an English word is coincidental.</em>
      </p>
      <p>
        <em>I would love to see </em><a href="DeMorgansLaws.html">DeMorgansLaws</a> and <a href="ExcludedMiddle.html">ExcludedMiddle</a> worked into the RDF <em>world</em>. But I think it would happen at the browser or query engine level and not necessarily at the language level. Consider the way RDF is supposed to fit in with the existing Internet. The idea is that various web sites will publish RDF about the things they know about. If there are two sites each publishing some RDF about related things, it might be good to somehow put their knowledge together and draw inferences from the combined pool of knowledge. Which of the two sites should do that work? It doesn't really fit at either of them, and it doesn't fit what they signed up to do, which is passively publish descriptions. So the inference rules have to run somewhere else, like the browser or query engine. Browsing and querying don't generate new knowledge; they only process existing knowledge. So there wouldn't be much need for the language to encode their thought process, if the purpose of the language is to describe knowledge. And with the <a href="FrameProblem.html">FrameProblem</a>, RDF itself doesn't need to encode invalidation if it can't encode inference.<em></em>
      </p>
      <p>
        <em>-- </em><a href="MichaelSparks.html">MichaelSparks</a><em></em>
      </p>
      <p>
        There is nothing <em>semantic</em> about RDF (<a href="ResourceDescriptionFramework.html">ResourceDescriptionFramework</a>). All RDF provides is a (cumbersome) way to attach named relations to named entities, where "entity" is that typical meaningless, all-encompassing word you always encounter in conjunction with everything <a href="SemanticWeb.html">SemanticWeb</a>. If you want clean semantics, they need to be defined, i.e., you need a specific RDF vocabulary, defined using an <a href="RdfSchema.html">RdfSchema</a>. If you have that (there are some for specialized purposes, such as <a href="DublinCore.html">DublinCore</a>), you can run queries. See <a href="SemanticWebLayerCake.html">SemanticWebLayerCake</a> for more information.
      </p>
      <p>
        You can completely forget about De Morgan's laws. RDF does not have logical connectives, no "or", no "and", not even "not". If you want logics, you need to go one step further and you get OWL (<a href="WebOntologyLanguage.html">WebOntologyLanguage</a>). Again, OWL is nothing more than a (cumbersome) way to express logical formulas. You still need a controlled vocabulary, but with OWL you can define the semantics of your vocabulary by giving suitable axioms. Such an axiomatized vocabulary would be called an ontology, and given a good inference engine you could run queries against it that obey common sense. Alas, neither good inference engines nor usable ontologies exist at the moment.
      </p>
      <p>
        You still don't "get" it? That's because there is nothing to "get" here. The emperor doesn't wear any clothes.
      </p>
      <hr/>
      <p>
        Well then, Pete, I guess you'll love this. <a href="http://downlode.org/Wiki/Scripts/wikiRDF?page=SemanticWebIsStupid">http://downlode.org/Wiki/Scripts/wikiRDF?page=SemanticWebIsStupid</a> -- EarleMartin
      </p>
      <p>
        <em>Um, yeah. Notice how anyone searching their RSS for disreputable idiocies written by Pete on C2 is SOL? RSS should be based on Google searching, not drop-your-brain-through-the-slot scripts. </em><a href="PutNotThyTrustInProgrammers.html">PutNotThyTrustInProgrammers</a>.<em></em>
      </p>
      <p>
        RSS != RDF. Learn the terms before proffering criticism. In fact, the sentence "RSS should be based on Google searching" doesn't make any sense at all, even if you substitute "RDF" for "RSS", or even "<a href="SemanticWeb.html">SemanticWeb</a>". By the way, <a href="PatchesWelcome.html">PatchesWelcome</a>.
      </p>
      <hr/>
      <p>
        I'm inclined to agree with the title of this page, though for slightly different reasons. If we regard the <a href="SemanticWeb.html">SemanticWeb</a> as a distributed database, then the following holds true:
      </p>
      <ul>
        <li>
           XML is an adequate data exchange representation, but a poor storage format for a dynamic database, especially if the database is relatively large and/or subject to frequent updates.
        </li>
        <li>
           In many respects, XML (as a database representation) resurrects all the problems of navigation-oriented heirarchical and network databases that were addressed over three decades ago with the introduction of the <a href="RelationalModel.html">RelationalModel</a>.
        </li>
      </ul>
      <p>
        <em>But ... RDF is relational ... isn't it?</em>
      </p>
      <p>
        I think this view originates in a rather unclear article by <a href="TimBernersLee.html">TimBernersLee</a> at <a href="http://www.w3.org/DesignIssues/RDB-RDF.html.">http://www.w3.org/DesignIssues/RDB-RDF.html.</a> The presence of relations should not be inferred to mean an implementation of the <a href="RelationalModel.html">RelationalModel</a>. RDF tuples may perhaps be used as the basis for an implementation of the <a href="RelationalModel.html">RelationalModel</a>, but that neither means it is inherently an implementation of the <a href="RelationalModel.html">RelationalModel</a> nor that it is a <em>suitable</em> basis for an implementation of the <a href="RelationalModel.html">RelationalModel</a>. An indirect commentary on this can be found at <a href="http://www.dbdebunk.com/page/page/1114998.htm">http://www.dbdebunk.com/page/page/1114998.htm</a>
      </p>
      <p>
        I believe many of the goals of the <a href="SemanticWeb.html">SemanticWeb</a> could be better accomplished via Internet-wide deployment of publicly-accessible <a href="RelationalDatabase.html">RelationalDatabase</a> management systems or nodes, each employing the following:
      </p>
      <ul>
        <li>
           A standardized meta-data schema format, to allow the meta-data hosted by a node to be queried in a standard fashion.
        </li>
        <li>
           A standardized database browsing interface, obtained via an URL -- e.g. db://mysite.com or http://mysite.com/db 
        </li>
        <li>
           A standardized <a href="RelationalLanguage.html">RelationalLanguage</a>, to allow the content hosted by a node to be queried in a standard fashion. Preferrably <strong>not</strong> SQL (see <a href="SqlFlaws.html">SqlFlaws</a>) but I'll use a SQL-like syntax for examples on this page, as it is familiar.
        </li>
        <li>
           Support for cross-node joins. E.g., something like SELECT * FROM db://mysite.com/myTable, db://yoursite.com/yourTable WHERE myTable.column1 = yourTable.columnA
        </li>
        <li>
           Facilities to express relationship constraints across nodes. E.g., something like CREATE RELATIONSHIP myRelationship ON db://mysite.com/myTable(column1) TO db://yoursite.com/yourTable(columnA) ON UPDATE CASCADE ON DELETE RESTRICT
        </li>
      </ul>
      <p>
        <em>Dude! Brilliant! Still stupid in my sense, but a lot less stupid in your sense than what's done now ...</em>
      </p>
      <p>
        The benefits of this approach over current RDF efforts should be self-evident, and includes leveraging the composability of <a href="RelationalAlgebra.html">RelationalAlgebra</a> via the query language, plus a standard means of updating (e.g., INSERT, UPDATE, DELETE) content subject to security constraints. Of course, this approach does not preclude storing XML documents as column values, should that be deemed appropriate.
      </p>
      <p>
        <em>There was once this thing called XDB that tried to do something like this ... not certain what became of it ...</em> -- Pete
      </p>
      <p>
        I believe you're referring to an XML database component of the Oracle DBMS since version 9i or thereabouts. I'm not aware that it supports distributed database functionality as I've described above, however.
      </p>
      <p>
        -- <a href="DaveVoorhis.html">DaveVoorhis</a>
      </p>
      <hr/>
      <p>
        Maybe it's a solution looking for a problem. <a href="GoldPlating.html">GoldPlating</a>.
      </p>
      <hr/>
      <p>
        Related:
      </p>
      <ul>
        <li>
           <a href="ResourceDescriptionFramework.html">ResourceDescriptionFramework</a>
        </li>
        <li>
           <a href="RdfTriples.html">RdfTriples</a>
        </li>
        <li>
           <a href="XbaseLibrary.html">XbaseLibrary</a>
        </li>
        <li>
           <a href="SemanticWebLayerCake.html">SemanticWebLayerCake</a>
        </li>
      </ul>
      <hr/>
      <p>
        <a href="CategorySemanticWeb.html">CategorySemanticWeb</a>
      </p>
    </div>
  </body>
</html>