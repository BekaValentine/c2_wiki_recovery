<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Commodore Basic
      </h1>
      <p>
        The BASIC included with the <a href="CommodoreSixtyFour.html">CommodoreSixtyFour</a>, <a href="CommodoreVicTwenty.html">CommodoreVicTwenty</a>, and other Commodore machines was more or less the same.  Even programs for the old <a href="CommodorePet.html">CommodorePet</a> machines could often run without modification on the 64.
      </p>
      <p>
        It had some interesting attributes:
      </p>
      <p>
        Variable names were limited to two letters.  Or, specifically, any variable name longer than two characters was truncated, so that MARKUP and MAINTOTAL would both point to a single variable named MA.
      </p>
      <dl>
        <dt> </dt>
        <dd><em>Can somebody confirm this? IIRC, the C64 could handle longer variable names, but it's a long time ago so I could be wrong.</em></dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd><em>Correct, the first two letters of a variable name must be unique. Also, your example variable MA</em>'INT<strong>OTAL contains the reserved word INT which would produce a </strong>?SYNTAX ERROR.<em></em>' --<a href="CarstenKlapp.html">CarstenKlapp</a></dd>
      </dl>
      <p>
        Arrays can have up to 255 dimensions, each with up to 32767 elements. The practical limitation was almost always available RAM or the 80 character logical screen line.
      </p>
      <p>
        However spaces were not necessary between symbols; the tokenizer just grabbed what it could find before passing it to the interpreter.
      </p>
      <ol>
        <li>
           FORX=1TO200:NEXTX
        </li>
        <li>
           GETA$:IFA$=""THEN20
        </li>
        <li>
           PRINTA$:IFX<2THENGOSUB500:SYS49152
        </li>
      </ol>
      <p>
        This was not only common, but encouraged, since whitespace took up valuable memory, and also detracted from the number of statements you could fit on a single line.
      </p>
      <p>
        To save even more memory and time, one could write a "pretokenized" program. Any key word could be specified by its two-letter equivalent. Thus the PRINT statement would be written as "P[SHIFT-R]", LOAD as "L[SHIFT-O]" etc. When working in uppercase display mode, toggled by pressing Commodore-SHIFT (written as C= SHIFT), the second letter of these "shifted" key words would display as boxes, lines and other graphics characters. An experienced programmer would eventually learn to recognize these tokens on sight and could read a program LIST on screen or printed out without shifting into lowercase display mode.
      </p>
      <p>
        <em>Actually, since tokens were stored in memory as single bytes, they were always expanded to their full name.  Therefore, a line would expand beyond 80 characters and the screen editor could no longer be used to modify it.</em>
      </p>
      <p>
        I know of one 3D Labyrinth program in Compute! Gazette, which boasted that it would run on both the Vic-20 and Commodore 64, but in order to get it to run on an unexpanded 3K Vic, you had to type it with no whitespace whatsoever.
      </p>
      <p>
        Magazines also featured a monthly "one liner" and "two liner" contests. In order to fit on one line (80 characters), most one-liner programs were written entirely in shifted notation. Writing this kind of program was especially challenging because it precluded any use of GOTO and GOSUB.
      </p>
      <hr/>
      <p>
        There were some really cool extensions added for the <a href="CommodoreOneTwentyEight.html">CommodoreOneTwentyEight</a>. It had a PLAY statement, where you typed PLAY followed by a string of notes, and it would play those notes.  You could have up to three different "channels" playing simultaneously (I think Commodore called them 'voices'). -- <a href="EddieDeyo.html">EddieDeyo</a>
      </p>
      <p>
        <em>Commands like these were commonly built-in to the BASICs that came with other machines like the </em><a href="AppleIi.html">AppleIi</a> and AtariComputer.  There was a program in ComputeGazette that claimed to enhance <a href="CommodoreBasic.html">CommodoreBasic</a> with commands that resembled those in <a href="AtariBasic.html">AtariBasic</a>, like PLOT, DRAWTO, etc.<em></em>
      </p>
      <p>
        The BASIC that came with my old Tandy 1000 HX (7 MHz 8088 CPU) also had the PLAY statement, and the Tandy had built-in 3 voice sound support.  It was actually pretty good sound, compared to the standard PC speaker shipped with most computers at the time. -- <a href="BrianRogers.html">BrianRogers</a>
      </p>
      <hr/>
      <p>
        Versions of <a href="CommodoreBasic.html">CommodoreBasic</a>:
      </p>
      <dl>
        <dt> </dt>
        <dd><a href="CommodorePet.html">CommodorePet</a>: V1.0, V1.2, V4.0</dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd><a href="CommodoreSixtyFour.html">CommodoreSixtyFour</a>: V2</dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd><a href="CommodoreVicTwenty.html">CommodoreVicTwenty</a>: V2</dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd><a href="CommodorePlusFour.html">CommodorePlusFour</a>: V3.5</dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd><a href="CommodoreOneTwentyEight.html">CommodoreOneTwentyEight</a>: V7.0?</dd>
      </dl>
      <p>
        The 64 and VIC20 got V2 while the PETs had V4.0 because the PET was Commodore's professional line and programming for the lesser machines wasn't expected to be as popular (HA)
      </p>
      <hr/>
      <p>
        There are a number of CommodoreEmulators but my favorite is Power64. It features a complete SID (sound) and MOS 6510 CPU Emulation, including the Illegal Opcodes! --<a href="CarstenKlapp.html">CarstenKlapp</a> <<a href="http://www.salto.at/Power64/index.html">http://www.salto.at/Power64/index.html</a>>
      </p>
      <p>
        <em>There's another emulator called VICE which emulates the C64, 128, Vic-20 and Pet.  </em><a href="http://vice-emu.sourceforge.net/''">http://vice-emu.sourceforge.net/''</a>
      </p>
      <p>
        Project 64 attempts to preserve Commodore64 related documentation. A wide variety of texts about hardware (both original Commodore and third party) and software is available. <<a href="http://project64.c64.org/">http://project64.c64.org/</a>>
      </p>
      <hr/>
      <p>
        The Power 64 docs also contain a guide to the C64's Basic at: <a href="http://www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AA-C64_BASIC.html.">http://www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AA-C64_BASIC.html.</a> So those of us who had almost forgotten it can wallow in nostalgia.--<a href="AdewaleOshineye.html">AdewaleOshineye</a>
      </p>
      <hr/>
      <p>
        Commodore sold two expanded BASIC cartridges for the VIC-20: the Super Expander, which included a 3K RAM expansion, and the Programmer's Aid cartridge.
      </p>
      <p>
        The Super Expander added graphics and sound commands as well as the ability to attach string "macros" to the function keys.  If you look at the design of the VIC-20, it's apparent that the 3K memory bank the Super Expander adds was cut from the production model (which shipped with 5K of relatively expensive static RAM) as a cost-saving measure.  The graphics and sound commands may have also originally been intended to ship with the VIC.
      </p>
      <hr/>
      <p>
        <a href="http://10print.org/">http://10print.org/</a> interesting book on 10 PRINT CHR$(205.5+RND(1)); : GOTO 10 if you are interested in that sort of thing (free to read PDF)
      </p>
      <hr/>
      <p>
        See also <a href="SimonsBasic.html">SimonsBasic</a>, EightBitBasic
      </p>
    </div>
  </body>
</html>