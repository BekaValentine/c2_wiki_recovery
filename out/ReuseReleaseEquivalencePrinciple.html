<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Reuse Release Equivalence Principle
      </h1>
      <p>
        REP:
      </p>
      <dl>
        <dt> </dt>
        <dd>The granule of reuse is the granule of release. Only components that are released through a tracking system can effectively be reused. This granule is the package. (<a href="http://www.objectmentor.com/resources/articles/granularity.pdf)">http://www.objectmentor.com/resources/articles/granularity.pdf)</a></dd>
      </dl>
      <p>
        One of the <a href="PrinciplesOfObjectOrientedDesign.html">PrinciplesOfObjectOrientedDesign</a>. 
      </p>
      <hr/>
      <p>
        This means that in order to effectively reuse code it must arrive in a complete, black-box, package that is to be used but not changed. Users of the code are shielded from changes to it because they can choose when to integrate changes from the package into their own code. While this supports code ownership, and even promotes it, it does not enforce it.
      </p>
      <p>
        <em>Why isn't this just called the '~</em>BlackBoxPrinciple'?<em></em>
      </p>
      <hr/>
      <p>
        I've seen this approach fail many times when used within a single organization.  Is this only appropriate for companies developing a product to be reused outside of their organization? -- <a href="JimLittle.html">JimLittle</a>
      </p>
      <p>
        <em>I've a suspicion that the point is to make smaller packages with explicit dependencies. Rely on some automatic dependency checking system to ensure that your packages are consistent. For example, you could adopt a system like TCL, where each package has a tuple <name, major, minor, patch> and a version-checking function that ensures compatibility with stated requirements. The interface is simple: </em>InstallPackage(tuple) and NeedPackage(dependent_name, known_good_tuple) should suffice. Make your packages small and coherent, use a globally consistent versioning system that knows where each version can be found, and you'll do just fine.<em></em>
      </p>
      <p>
        [Yes, even a code package (e.g., a library) used within an organization cannot be used across multiple projects unless it is "released" as a black box. To release it doesn't necessarily mean an involved procedure. But it does need to be treated as a separate package, separately tested and versioned, and tracked by version in the projects in which it's used.]
      </p>
      <hr/>
      <p>
        See <a href="ObjectOrientedSoftwareConstruction.html">ObjectOrientedSoftwareConstruction</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryModellingLawsAndPrinciples.html">CategoryModellingLawsAndPrinciples</a>
      </p>
    </div>
  </body>
</html>