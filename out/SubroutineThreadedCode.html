<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Subroutine Threaded Code
      </h1>
      <p>
        Subroutine threaded code is, unlike other forms of threaded code representations, directly executable by the CPU itself.  Instead of a vector of addresses (as with <a href="DirectThreadedCode.html">DirectThreadedCode</a> or <a href="IndirectThreadedCode.html">IndirectThreadedCode</a>), you have a vector of JSR- or CALL-instructions (for you RISC types, BAL-instructions.  :D).  <em>Most</em> microprocessors have some symmetry between similar JSR and CALL instructions, and therefore even the simplest of compilers will perform tail-recursion elimination.  This allowed <a href="ChuckMoore.html">ChuckMoore</a>'s <a href="MachineForth.html">MachineForth</a> compilers (and <a href="ColorForth.html">ColorForth</a> for the Pentium, which used the same models) to simplify the traditional Forth language by eliminating a number of control flow constructs commonly found in ANSI Forth.  (Footnote: in some respects, <a href="MachineForth.html">MachineForth</a> is to ANSI Forth as Scheme is to <a href="CommonLisp.html">CommonLisp</a>.)
      </p>
      <hr/>
      <p>
        Contrast with <a href="DirectThreadedCode.html">DirectThreadedCode</a>, <a href="IndirectThreadedCode.html">IndirectThreadedCode</a>, <a href="TokenThreadedCode.html">TokenThreadedCode</a>
      </p>
    </div>
  </body>
</html>