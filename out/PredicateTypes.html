<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Predicate Types
      </h1>
      <p>
        <em>Predicate types</em> is a typing system where the "instance of" property of an object is defined by a <em>predicate</em> (a function returning true or false) rather than be details of the object's construction.  One way of implementing <a href="SetsAndPolymorphism.html">SetsAndPolymorphism</a>.  
      </p>
      <p>
        <a href="CecilLanguage.html">CecilLanguage</a> has such a typing system; with the property that as an object's state changes, so can its type (the set of allowable predicates is not restricted to object invariants).
      </p>
      <hr/>
      <p>
        <em>How does it deal with the "mutually-exclusive" issue? What keeps the answer to "what type am I" from being multiple? If it doesn't, then perhaps it's attributes and not types.</em>
      </p>
      <p>
        <a href="PredicateTypes.html">PredicateTypes</a> aren't mutually exclusive. There are many forms of types in the literature that aren't mutually exclusive (<a href="DependentTyping.html">DependentTyping</a>, <a href="PredicateTypes.html">PredicateTypes</a>, static duck typing, higher level 'kinds' (as reflected in Haskell type-classes and C++ concepts), interfaces, effect typing, etc.). 
      </p>
      <p>
        It seems that you're favoring some personal definitions for "attributes" and "types", and that in your mind "type" implies "mutually exclusive" whereas whatever you're calling "attributes" are not. That's a practitioner's view, I guess. Language designers have been working to integrate higher level and more flexible types into languages (and they've succeeded in a few languages - <a href="ScalaLanguage.html">ScalaLanguage</a> being an especially fine example of a new such "practitioner's language", using static duck typing for flexibility). However, several of the early designs for integrating types into programming were rather rigid and 'mutually exclusive'. 
      </p>
      <p>
        But now you've been informed. Try in the future to not mistake the clumsy nature of the early implementations as defining 'types'. <a href="CeeIsNotThePinnacleOfProcedural.html">CeeIsNotThePinnacleOfProcedural</a>, and mutual exclusion is not the pinnacle of typing. It'd be more productive for you to adopt the language people already use to describe types (such as <a href="PredicateTypes.html">PredicateTypes</a> and <a href="DependentTyping.html">DependentTyping</a>) than for you to walk around trying to tell people that they really should be calling these things "attributes" based on your personal definition of the terms.
      </p>
      <p>
        <em>Without a solid definition of "types", such is hard to avoid. And none of that subjective fuzzy "intention to classify" stuff, please.</em>
      </p>
      <p>
        The only reason you find it "hard to avoid" your particular brand of sophistry is that you're taking an illogical and incorrect position to start with: you're insisting that "type" must be defined prior to definition of <a href="PredicateTypes.html">PredicateTypes</a>. Perhaps you should learn about various forms of definitions (<a href="http://en.wikipedia.org/wiki/Ostensive_definition,">http://en.wikipedia.org/wiki/Ostensive_definition,</a> <a href="http://en.wikipedia.org/wiki/Extensional_definition,">http://en.wikipedia.org/wiki/Extensional_definition,</a> <a href="http://en.wikipedia.org/wiki/Enumerative_definition,">http://en.wikipedia.org/wiki/Enumerative_definition,</a> <a href="http://en.wikipedia.org/wiki/Intensional_definition).">http://en.wikipedia.org/wiki/Intensional_definition).</a> It seems what you're trying to say is that "if there is no intensional definition for type, then it's okay to say ridiculous things about <a href="PredicateTypes.html">PredicateTypes</a>". But it's the other way around. "Type" is defined on a per-<a href="TypeSystem.html">TypeSystem</a> basis, and is on the broader scale of <a href="TypeTheory.html">TypeTheory</a> understood ostensively by examples such as <a href="PredicateTypes.html">PredicateTypes</a>.
      </p>
      <p>
        [<em>An interesting question is: does math have a type system that can be changed/swapped? Or are types in math not a type system, but just widely accepted types?</em>]
      </p>
      <hr/>
      <p>
        See also <a href="PredicateClasses.html">PredicateClasses</a>, <a href="PredicateDispatching.html">PredicateDispatching</a>.
      </p>
    </div>
  </body>
</html>