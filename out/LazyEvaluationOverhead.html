<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Lazy Evaluation Overhead
      </h1>
      <p>
        Wow, this page is strange.  It talks very much about the feasibility of lazy evaluation as an optimisation technique, whereas I deem lazy evaluation mostly a design technique.  And it doesn't even touch the subject where lazy evaluation overhead is really big, namely, memory consumption.  -- <a href="PanuKalliokoski.html">PanuKalliokoski</a>
      </p>
      <hr/>
      <p>
        [From <a href="LazyEvaluation.html">LazyEvaluation</a>]
      </p>
      <p>
        From <a href="TransfoldPattern.html">TransfoldPattern</a>: <em>"Unfortunately, </em><a href="LazyEvaluation.html">LazyEvaluation</a> usually carries a performance penalty."<em> </em>
      </p>
      <p>
        Why is that? I thought that <a href="LazyEvaluation.html">LazyEvaluation</a> was supposed to make things more efficient, not less. -- <a href="PhilGoodwin.html">PhilGoodwin</a>
      </p>
      <p>
        To support <a href="LazyEvaluation.html">LazyEvaluation</a> one has to build suspended calculations (usually implemented with closures). These suspended calculations take time to create, consume memory (i.e., may make garbage collection slower), and have to be detected and evaluated when encountered. If all of this is supported by a your programming language then the penalties can be very small but if you have to emulate some of this you may notice a higher penalty. I have no concrete figures but I am assuming that you still would not care unless you were doing real time stuff. -- <a href="ThomasKuehne.html">ThomasKuehne</a>
      </p>
      <p>
        <em>If you have "no concrete figures," then what is your argument based on?  For any given operation, there are multiple ways to code it, often with trivial differences in the number of machine cycles required; evaluation is no different.  If the time differences between Lazy Evaluation and Full Evaluation are critical to the success of a project, I would suggest the project is already in risk of failure.</em>
      </p>
      <p>
        Actually, for <a href="HardRealTime.html">HardRealTime</a>, you usually care less about average execution time than worst-case execution time.  Any amount of overhead makes the worst-case even worse, so <a href="LazyEvaluation.html">LazyEvaluation</a> will usually be a <a href="BadIdea.html">BadIdea</a> in hard real time projects. -- <a href="DougKing.html">DougKing</a>
      </p>
      <p>
        Modern compilers for LazyLanguages use <a href="StrictnessAnalysis.html">StrictnessAnalysis</a> to determine what code must be executed, and that code is implemented with <a href="StrictEvaluation.html">StrictEvaluation</a>, avoiding the overhead of closure creation.  -- <a href="NoelWelsh.html">NoelWelsh</a>
      </p>
      <p>
        <em>If the calculation is expensive, and you only really need the result some of the time, </em><a href="LazyEvaluation.html">LazyEvaluation</a> is faster.  But if the calculation is relatively cheap (relative to object overhead and flag checking) and all computations must actually be done, then <a href="LazyEvaluation.html">LazyEvaluation</a> is slower -- possibly much slower.  -- <a href="JeffGrigg.html">JeffGrigg</a><em></em>
      </p>
      <p>
        What is the mechanism by which you are envisioning <a href="LazyEvaluation.html">LazyEvaluation</a> being implemented? It doesn't seem like there has to be much if any penalty at all depending on the situation. -- <a href="PhilGoodwin.html">PhilGoodwin</a>
      </p>
      <p>
        It definitely depends. If you have an interpreter anyway, <a href="LazyEvaluation.html">LazyEvaluation</a> is easy to add and will almost certainly speed things up. You'd add result-caching first, of course, and then with recursive descent evaluation, <a href="LazyEvaluation.html">LazyEvaluation</a> is essentially free.  -- <a href="RonJeffries.html">RonJeffries</a>
      </p>
      <p>
        . . . . .
      </p>
      <p>
        Suppose we want to calculate (a + b) + (c + d) + (a + b) using lazy evaluation.
      </p>
      <dl>
        <dt> </dt>
        <dd><em>[See </em><a href="LazyEvaluationExampleInAssembly.html">LazyEvaluationExampleInAssembly</a> for the example code that was extracted from this point.]<em></em></dd>
      </dl>
      <p>
        So the raw interpretation overhead is approximate 10x, as always. The cost of running the code optimizer was saved. Does a code optimizer take more than 10 instructions per instruction generated? Well, quite possibly yes - certainly no less.
      </p>
      <p>
        So if the expression is entered and compiled on the fly, <a href="LazyEvaluation.html">LazyEvaluation</a> is about the same, and much easier to code. If the expression is entered once and used every day, <a href="LazyEvaluation.html">LazyEvaluation</a> probably isn't the way to go.
      </p>
      <p>
        On the other hand, if the expression computes a whole tax form's bottom line and is used twice, <a href="LazyEvaluation.html">LazyEvaluation</a> pays off big time, especially since you probably don't know how to compile a tax form. But that's another story. -- <a href="RonJeffries.html">RonJeffries</a>
      </p>
      <p>
        I never thought about employing interpretation to realize <a href="LazyEvaluation.html">LazyEvaluation</a>. With an object oriented language it is very easy to do by using objects as closures for the suspended calculations. Often Smalltalk dialects already come with a little <a href="LazyEvaluation.html">LazyEvaluation</a> framework, i.e., a class LazyValue or UninitializedObject, which sets you up nicely to use <a href="LazyEvaluation.html">LazyEvaluation</a>. -- <a href="ThomasKuehne.html">ThomasKuehne</a>
      </p>
      <p>
        . . . . .
      </p>
      <p>
        See <a href="LazyEvaluationExampleInVisualBasic.html">LazyEvaluationExampleInVisualBasic</a> for an 
        <em></em>'example of using <a href="LazyEvaluation.html">LazyEvaluation</a> in a <a href="VisualBasic.html">VisualBasic</a> program.<em></em>'
      </p>
      <p>
        <em>(The objective of this exercise is to show that </em><a href="LazyEvaluation.html">LazyEvaluation</a> is complex and slow:  That you shouldn't use it unless the computation is expensive/difficult, and the result won't be needed in many cases.)  -- <a href="JeffGrigg.html">JeffGrigg</a><em></em>
      </p>
      <p>
        i.e.: <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a> - anon
      </p>
      <p>
        What I get from looking at this is that the runtime overhead consists of: allocating and initializing an object, making a method call to trigger the calculation, testing for a cached result and caching the result if needed (assuming <a href="CallByNeedSemantics.html">CallByNeedSemantics</a>). I see that this is not trivial, certainly most calculations won't benefit from this treatment. However, it doesn't seem like a very high price to pay for situations that could make even trivial use of <a href="LazyEvaluation.html">LazyEvaluation</a>. Like when you want to delay a calculation, execute it optionally, or reuse it's result. I think I'm really saying the same thing as Jeff except that I'm excited about the benefits while he's worried about the costs. -- <a href="PhilGoodwin.html">PhilGoodwin</a>
      </p>
      <p>
        Although there are slight performance drawbacks in emulating <a href="LazyEvaluation.html">LazyEvaluation</a>, when it is appropriate (see section Applicability in my thesis) it is just fantastic. You'll be able to avoid huge intermediate data structures, reconcile modularization with calculation speed, and reduce the complexity of algorithms by the way you use them. -- <a href="ThomasKuehne.html">ThomasKuehne</a>
      </p>
      <hr/>
      <p>
        From any language I have used, you can always rewrite code from using Lazy Evaluation to Full Evaluation or vice-versa whenever you wish.  I recommend the following principles.  First, use the natural evaluation method of the language, unless you have a measurable end user performance problem.  Second, never rely on Lazy Evaluation to guarantee operations will not be performed; explicitly code this need.
      </p>
      <hr/>
      <p>
        <a href="CategoryLazyPattern.html">CategoryLazyPattern</a>
      </p>
    </div>
  </body>
</html>