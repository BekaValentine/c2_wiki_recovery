<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Everyday Impossible Task
      </h1>
      <p>
        What's an everyday impossible task? It's an eminently desirable task that should be trivially achievable but is just about impossible in common computer systems.
      </p>
      <hr/>
      <p>
        <strong>Multiplexing audio</strong>
      </p>
      <p>
        For example, listening to two songs or pieces of music at the same time. You double click on one mp3 and it plays. Then you double-click on another mp3 and it stops the first from playing. What the hell is this bullshit? Application-centrism is command-orientation, which is Imperative programming, which is NOT OO.
      </p>
      <p>
        <strong>If I play MP3's using the </strong><a href="QuickTime.html">QuickTime</a> Player, I can play and listen to multiple MP3's at the same time. Maybe because <a href="QuickTime.html">QuickTime</a> *is* object oriented.<strong></strong>
      </p>
      <ul>
        <li>
           Yeah, there's that. Then again there's the fact that quicktime player is crap, with no possibility of enqueuing anything and awkward controls.
        </li>
      </ul>
      <p>
        [I've only one soundcard, and one set of speakers, on my system (not to mention one set of ears).  It's an example of <a href="SingletonPattern.html">SingletonPattern</a>.  Of course, with audio you can mix two streams together (in most cases, the result will sound like crap).  OTOH, there are other things in computer-land which truly are singletons (or which would become utterly useless if multiplexed).]
      </p>
      <p>
        <em>Most users, probably prefer the behavior that only one MP3 plays at a time.</em>
      </p>
      <p>
        Most users should have the option, without needing to resort to workarounds.  I've run into the identical issue with networking, heard exactly the same replies with regards to multiple video monitors before that was common place, etc.  And, for the record, I've seen people start cursing when the internet radio gets cut out when they try to view a training video at work.  And I curse all the time when apps reuse a browser window to display their 'welcome' pages.  Finally, note that most users would expect that double-clicking an mp3 should <em>enqueue</em> it, not replace the one already playing; while expecting a double click on a mpeg to show up in a new window.  --<a href="WilliamUnderwood.html">WilliamUnderwood</a>  (btw, <a href="BlueAbyss.html">BlueAbyss</a>, like Rome, won't be built in a day)
      </p>
      <p>
        <em>Click on "Allow Multiple Instances" in your winamp preferences.  "Problem" solved.</em>  [Problem "solved" you mean --cwillu]
      </p>
      <p>
        <em>Try using Winamp with any of the DJ cross-mixing plugins, you can play up to 16 mp3's simultaneously</em> The fact that you need a tortuous workaround to perform an utterly trivial task is exactly what I call bullshit. The idea of using an application to access basic operating systems functions (multiplexing of hardware and basic queueing) is revolting. And the idea of limiting multiplexing to "up to 16" audio channels is revolting too. What would people think if internet explorer displayed "up to 16" pages simultaneously?
      </p>
      <p>
        <em>ok. how about just running media player and winamp at the same time? Playing multiple songs at once(unless dj'ing) isn't trivial, and usually sounds quite bad. I suppose you think using three mice simultaneously on the same computer should be trivial too?</em> Having multiple pointers that can be controlled by separate mice should be trivial. And running media player and winamp only lets you play 2 things at once. In addition, it focuses your attention on "applications" instead of where it should be, the objects themselves.
      </p>
      <hr/>
      <p>
        <strong>Running tasks securely</strong>
      </p>
      <p>
        Create a subuser to run a task securely. People understood the merits of infinitely extensible hierarchies over flat tables way back in the 70s. Three decades later, no one working on Unix has cottoned on to infinitely extensible hierarchies of users being better than a single flat table of them.
      </p>
      <p>
        <em>Extensible hierarchies are largely unneeded by using groups. It's the middle # in chmod 755</em> Don't bullshit about computer security with me kid. Not only are extensible hierarchies necessary (and groups are complete bullshit since they can no more be defined by users than users can) but extensible hierarchies are simply not good enough. -- RK
      </p>
      <hr/>
      <p>
        Edit an email message after it's been sent. Like having a <em>private</em> wiki page you share only with whomever you specify. (comment deleted as too stupid to respond to)
      </p>
      <hr/>
      <p>
        <strong>Reversibility</strong>
      </p>
      <p>
        No history. Can't undo commands. Can't undo changes to files. Can't go back to where you were before in the shell / filesystem browser (backspace in windows and cd .. in Unix both take you up, not back). Can't go back to where you were in the <a href="RefactoringBrowser.html">RefactoringBrowser</a>; is it a browser or isn't it? Why all this pain? Because programmers think that an irrelevant abstract concept of "root directory" (which is actually just an <em>implementation detail</em> since object systems are restricted to hierarchies) matters more than the concrete concepts of "past" and "present".
      </p>
      <p>
        <em>What about undo commands, journaling file systems, backups,  or </em><a href="RevisionControlSystem.html">RevisionControlSystem</a>s, cd $<em> Journaling has nothing to do with history and undo only exists in special cases, when an applications programmer bothers to think it might be worth having. As for </em><a href="RevisionControlSystem.html">RevisionControlSystem</a>s and other such "applications", have you ever seen a normal user take advantage of them? Do you think there's a reason why?
      </p>
      <p>
        <em>Maybe you should look at the definition of </em><a href="JournalingFileSystem.html">JournalingFileSystem</a> - The word Journal should be a tipoff that it does have something to do with history. I have seen normal users use CVS for everything from word documents to images to emails. They use it when they want to be able to undo changes to files.<em> I wrote the page on </em><a href="LoggingFileSystem.html">LoggingFileSystem</a> on this wiki and I know exactly what journaling is all about; NOT history. LOGGING is about history, though only GROSS history at that. Journaling is just about reliability, which is irrelevant.
      </p>
      <hr/>
      <p>
        <strong>Deadness, not liveness</strong>
      </p>
      <p>
        See a reference, can't follow it. Dead references instead of live ones. For example, you see a reference to another method in the RB (up arrow indicates the present method overrides a higher one) but the reference is dead and can't be followed to its source.
      </p>
    </div>
  </body>
</html>