<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Programming Is Thinking Too
      </h1>
      <p>
        <em>Of course </em><a href="ProgrammingIsThinkingToo.html">ProgrammingIsThinkingToo</a>.  How can you design unless you think?  <a href="TheSourceCodeIsTheDesign.html">TheSourceCodeIsTheDesign</a>.<em></em>
      </p>
      <p>
        Oh? Then why do so many people ask <a href="ExtremeProgrammer.html">ExtremeProgrammer</a>s 
        "where is the room for thinking in Listen/Code/Refactor".
        Too many people see analysis or design 
        (the noble art of drawing circles and connecting them with lines: <a href="BertrandMeyer.html">BertrandMeyer</a>)
        as thinking and programming as menial labor.
        Therefore, the following rebuttal
      </p>
      <hr/>
      <p>
        Not quite a haiku, but in the same spirit:
      </p>
      <code>
        Think before your program,<br/>
        they say, or troubles will find you.	<br/>
        But programming <br/>
        is thinking too.<br/>
      </code>
      <p>
        Prototypes, for instance, are thought experiments.
        Done well, small prototypes can serve as precise
        analysis models. 
        After all, programming languages are the *most* formal
        construct imaginable; 
        The dumbest things on earth, computers, understand them.
        So your programs must be precise to talk to computers, but
        if the programs also use good abstractions, they will
        talk to people too.
      </p>
      <p>
        You can always prototype, no matter how complex the reality.
        A prototype for an atomic bomb is
      </p>
      <code>
        class AtomicBomb {<br/>
        enum State { Exploded, InItsShinyShell };<br/>
        final State init;<br/>
        Bomb() {<br/>
        init = InItsShinyShell;<br/>
        }<br/>
        State next() { <br/>
        if InItsShinyShell detonate(); return Exploded;<br/>
        if Exploded throw Exception;<br/>
        }<br/>
        }<br/>
      </code>
      <p>
        From this prototype, we know that (1) bombs are initially
        unexploded (2) when detonated they explode (3) there is
        no way to make them unexplode. 
        This is abstract, precise, and nobody gets killed.
      </p>
      <p>
        Write a few classes, if you like, run them.
        Try a few variations, shift responsibilities around.
        You might be suprised how many issues surface when you
        try to do this.
        You don't even always have to type it all out; doodle
        a few interfaces, and the programmer in you will take over.
        One trick that avoids cruft and implementation bias
        is programming with Types, Sets (Collections), 
        Function Objects, Composition, instead of Assignment and Loops.
      </p>
      <p>
        Over time, make this a habit in all your programming; think
        of all programs as specifications, i.e., what they do,
        not necessarily how they do it. It can help isolate you from
        overcommitment to implementation details, and reveal 
        alternative implementations. Sometimes
        the how becomes important. Then think about the what of
        the how, and proceed. 
      </p>
      <p>
        Combine this with refactoring, testing, and occasional
        reflection. This makes for happy programming.
      </p>
      <p>
        -- <a href="AamodSane.html">AamodSane</a>
      </p>
    </div>
  </body>
</html>