<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Continuity Principle
      </h1>
      <p>
        <em>Small changes in requirements should result in correspondingly small changes in application code.</em>
      </p>
      <p>
        <a href="DiscontinuitySpike.html">DiscontinuitySpike</a> describes what happens when <a href="ContinuityPrinciple.html">ContinuityPrinciple</a> is violated.
      </p>
      <p>
        From the <a href="ObjectOrientedSoftwareConstruction.html">ObjectOrientedSoftwareConstruction</a> book by <a href="BertrandMeyer.html">BertrandMeyer</a>.
      </p>
      <p>
        This principle is broken whenever you have limits that cannot be exceeded without excessive work.  For example, you may have a large database-centric application where a particular field is set to be two-bytes wide.  The customer may later decide that four bytes are needed, because values greater than 65,535 are now necessary.  If that change in data type requires massive rework of the application, then the principle is violated.
      </p>
      <p>
        Similarly, if scaling up the application to handle twice as many requests per time period requires that you re-implement the application in another programming language or with a different database back-end, that would be a violation of the principle.
      </p>
      <p>
        In object-oriented programming, following principles such as <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a>, the <a href="DependencyInversionPrinciple.html">DependencyInversionPrinciple</a>, and the <a href="OneResponsibilityRule.html">OneResponsibilityRule</a> can allegedly prevent continuity problems as requirements change.  Ideally, any minor change in a requirement should only affect one class (of course, this ideal is hard to achieve in practice).
      </p>
      <hr/>
      <p>
        This kind of thing is where languages with <a href="StaticTyping.html">StaticTyping</a> often fail IMO. You have to mirror the database field type declaration in the application code, violating <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a>. For example, sometimes you need to change an ID from integer to string when companies merge and the other company has alpha in their keys.
      </p>
      <p>
        See <a href="StaticTypingHindersRefactoring.html">StaticTypingHindersRefactoring</a>.
      </p>
      <hr/>
      <p>
        One factor about calculating the costs of change is the likelihood of such a change. When you "future-proof" something, you should also factor in the chance if it not happening. It is similar to calculating whether or not you want meteor insurance :-)
      </p>
    </div>
  </body>
</html>