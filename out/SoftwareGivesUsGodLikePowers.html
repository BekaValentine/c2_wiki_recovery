<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Software Gives Us God Like Powers
      </h1>
      <ul>
        <li>
           ...inside the software virtual world. As long as it is internally consistent, it can be whatever the hell we want it to be. (copied from <a href="ScienceShouldBeEasy.html">ScienceShouldBeEasy</a>)
        </li>
        <li>
           ...as long as we find the cheat code for <a href="GodMode.html">GodMode</a>
        </li>
        <li>
           ...that explains all the <a href="HolyWar.html">HolyWar</a>s
        </li>
        <li>
           ...and the server owner always getting more frags
        </li>
      </ul>
      <p>
        - summary by an <a href="AnonymousDonor.html">AnonymousDonor</a>
      </p>
      <hr/>
      <p>
        Software design and physical science (Newtonian and quantum physics, chemistry) are two different animals. As described under <a href="LaynesLaw.html">LaynesLaw</a>, software can transcend physical limitations. We now have the ability to make a world in software that has almost any rules we want as long as we solve the problem at hand (right output). <strong>If removing gravity makes the job easier, do it!</strong> We are thus not bound to physics with software (or at least less and less bound over time due to <a href="MooresLaw.html">MooresLaw</a> and related technical improvements). The "science" of software may not have to be hard, unlike physical science. We are stuck with the laws of physics, but we can bend software laws in many ways as needed. It's somewhat similar to using Newtonian physics when modeling quantum physics would be overkill, except that we don't even need to approximate nature if we can find a better model for our goal. <a href="StringTheory.html">StringTheory</a> makes a crappy assembler language for us to work with as humans (except maybe Stephen Hawking). But, we can play God with software and change the rules as long as the output is correct. -- top
      </p>
      <p>
        <em>If software gives us God-like powers, then perhaps I'll go write an application that solves the </em><a href="HaltingProblem.html">HaltingProblem</a>, cures cancer, brings about world peace, deposits (legally) a couple million in my checking account, and causes <insert annoying pop-star here> to develop a permanent case of laryngitis. This is a bunch of pseudo-scientific claptrap, Top. Software is most certainly bound by well-known limitations; which have been demonstrated via axiomatic proof. But once again, when confronted with real evidence that your suggestions are so much crapola, you sing and dance, invoke <a href="LaynesLaw.html">LaynesLaw</a>, and make the asinine suggestion that little in our discipline can be said with any certainty - therefore, anything goes, including any unsubstantiated claim you happen to make.<em></em>
      </p>
      <p>
        <em>Obviously not. The </em>'inside the virtual world<em>' implicates a very finite bound on the rule. You can't simply hack into mankind's mainframe...yet.</em>
      </p>
      <p>
        Just because we can play God does not necessarily mean we are smart Gods with limitless knowledge and wisdom. A chimp given a "launch nuke" button is one extreme example. In other words, power and wisdom are orthogonal. Technology gives us this power, but not necessarily wisdom. Nor did I imply that software's power is open-ended. It is simply transcending the physical world more and more over time. But it has not reached infinite ability by any stretch. Maybe "weak god" is a better description. "Levels" might look something like:
      </p>
      <ul>
        <li>
           Mortal
        </li>
        <li>
           Power to control worlds
        </li>
        <li>
           Power to control worlds and "extra" wisdom (beyond mortals)
        </li>
        <li>
           Power to control worlds and unlimited wisdom 
          <ul>
            <li>
               See "Definition of Omnipotent" below for more.
            </li>
          </ul>
        </li>
      </ul>
      <p>
        Also, the powers only are applicable to the software world, not necessarily outside. "The Sims" (game) anyone? In fact, <strong>software games in general are evidence of this: you can build just about any "world" you want</strong>, as long as you can define it clearly enough to the machine. A game builder is playing god inside their virtual world. This topic is merely an extension of that flexibility applied to domain applications.
      </p>
      <p>
        <em>Oh, wonderful. </em><a href="TopMind.html">TopMind</a> has ventured beyond <a href="PseudoScience.html">PseudoScience</a> into PseudoTheology, inventing hierarchies of deities to try and find a nail to hang his argument on.<em> {continued below}</em>
      </p>
      <p>
        [Not a hierarchy, but a set of deities with relations to various "wisdom" and "power" attributes no doubt. LimitationsOfHierarchies. Nyuk Nyuk, just teasing top :P]
      </p>
      <p>
        Software is moving into the second level. -- top
      </p>
      <p>
        <em>Software, like any other science/art/craft/profession/engineering discipline/whatever, has utterly little to do with religion. This analogy is so laughably bad, that I don't really know where to start. Maybe software is like </em><a href="PhilPrinceOfInsufficientLight.html">PhilPrinceOfInsufficientLight</a>, rather than a full-blown demon.<em></em>
      </p>
      <p>
        I think you are missing my point. I am suggesting that traditional <strong>science is failing to help us with software issues (</strong><a href="DisciplineEnvy.html">DisciplineEnvy</a>) because software is not bound to nearly as many constraints<strong>. I notice that in many debates somebody will say something like, "you can't do it that way because it would run too slow". I then ask if speed was not an issue if it would change their viewpoint. At that point they seem to lose interest in the topic for some reason, perhaps because it is no longer dealing with the here-and-now and into theoretical ether-land. Too many of our definitions and viewpoints are seem based on limits of our physical machines instead of what software could potentially do if cycles were much cheaper. For example, if I suggested an "expanding map" that would allow more than one value per "cell" (essentially a kind of </strong><a href="MinimalTable.html">MinimalTable</a>), the most likely reaction will probably be, "But then traditional maps would run too slow." It is a "dumb idea" because it "runs slow". But that is a machine limit, not a language or software limit. I like to factor out speed to explore the <strong>real limits</strong> of software. -- top
      </p>
      <p>
        <em><RANT long-winded="true" meandering="definitely"></em>
      </p>
      <p>
        <em>Again, </em>BullShit. <a href="ComputerScience.html">ComputerScience</a> - the parts of that which admit axiomatic proof or falsifiable empirical evidence - is alive and well. The <a href="RelationalModel.html">RelationalModel</a>, of course, is founded on it (and you are fond of claiming other paradigms aren't and thus should be given less consideration). The biggest problem I see is that many people - for various reasons - <strong>choose to ignore the science</strong>. I may piss a few folks off here (which is a <a href="GoodThing.html">GoodThing</a>, all considered), but many in certain noisy programming communities like to ignore science and extrapolate their own personal preferences to scientific doctrine, just because they think they're clever. <strong>But that is not science</strong>. The fellows whom we often refer you to - <a href="JohnReynolds.html">JohnReynolds</a>, <a href="BenjaminPierce.html">BenjaminPierce</a>, etc. - <strong>are</strong> engaging in science. If you would read them, you'd find what they say interesting.<em></em>
      </p>
      <p>
        <em>The other problem I see here is that many people - yourself included - confuse science with engineering. The selection of an appropriate data structure or algorithm for an given problem, assuming correctness is satisfied, is an </em>'engineering<strong> problem, not a problem of pure science. No good </strong><a href="ComputerScientist.html">ComputerScientist</a> would utter a claim like "tables are better than all other data structures" - such a claim is inherently unscientific and untestable, especially without qualification. No good <a href="SoftwareEngineer.html">SoftwareEngineer</a> would make that claim either; analyses of what is good and not <strong>always</strong> have to be made in the context of the problem at hand, although some technologies admit themselves to more problems than others. That would be like a civil engineer saying that all bridges should be built out of Georgia pine - many bridges might be better served with concrete and steel.<em></em>
      </p>
      <p>
        <em>Of course, many here on Wiki ought to be offended by that remark - including </em><a href="TopMind.html">TopMind</a> - as pronouncements like "language/technology X is the best language in the world" seem to be popular here. For Top, it's the RDBMS and the underlying <a href="RelationalModel.html">RelationalModel</a>. For others, its <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> or <a href="CommonLisp.html">CommonLisp</a> or Erlang or Haskell - maybe even C++.<em> </em>
      </p>
      <p>
        <em>I started the page </em><a href="ComputerScienceIsaSoftScience.html">ComputerScienceIsaSoftScience</a> (which shares quite a bit with <a href="DisciplineEnvy.html">DisciplineEnvy</a>). I've come to modulate my view on this a bit; the science part of our discipline is in fine shape. It's the engineering part that is for the most part shoddy, and tends to ignore the underlying science. Were a fellow like <a href="TopMind.html">TopMind</a> (or even a brighter light such as a <a href="RichardGabriel.html">RichardGabriel</a>) to burst into a civil engineering convention and make pronouncements about civil engineering topics similar in nature to what Top and RG (and numerous others) make about software, they'd be laughed out of the fucking room.<em></em>
      </p>
      <p>
        <em>-- </em><a href="ScottJohnson.html">ScottJohnson</a><em></em>
      </p>
      <p>
        <em></RANT></em>
      </p>
      <p>
        UnBullShit. For one, I have never claimed that relational is objectively or scientifically better. For all the alleged duplication I am accused of, you should know my position on that by now. I just lobby for my pet paradigms and techniques the way that Lisper's and OO'ers do. 
      </p>
      <p>
        <em>And on that grounds, yer just as obnoxious as the </em><a href="SmugLispWeenie.html">SmugLispWeenie</a>s. Only not as clever.<em></em>
      </p>
      <ul>
        <li>
           I am not promoting tables in this topic, I would note. As far as <a href="SmugLispWeenie.html">SmugLispWeenie</a> being "clever", they sure didn't impress me when they flunked <a href="ChallengeSixVersusFpDiscussion.html">ChallengeSixVersusFpDiscussion</a>. 
        </li>
        <li>
           <em>A point which I strongly suspect the </em><a href="SmugLispWeenie.html">SmugLispWeenie</a>s will dispute.<em></em>
        </li>
        <li>
           Let's leave that decision to that topic.
        </li>
      </ul>
      <p>
        Tablers just happen to be smaller in number. 
      </p>
      <p>
        <em>One wonders why that is.</em>
      </p>
      <ul>
        <li>
           I've met other table fans. There is just no distinct name or club for it. It lacks a unified identity. Besides, <a href="ArgumentFromPopularity.html">ArgumentFromPopularity</a> has limited value.
        </li>
        <li>
           <em>Congratulations! You've finally come to the realization that science is not conducted by opinion polls. That said, there is a reason that we don't see many scientists arguing that the earth is flat, either.</em>
        </li>
        <li>
           I do not understand this insult.
        </li>
        <li>
           {Let me modify the original statement: "Tablers just happen to be smaller in number on this wiki". If you think I am opinionated, wait until you meet a militant DBA. My relativism stance is mild in comparison. Hmmm, is it possible to be a militant relativist?}
        </li>
      </ul>
      <p>
        <em>Certainly, many programmers are familiar with relational, and use it quite happily. Were I in the bespoke software biz rather than the </em><a href="EmbeddedSystems.html">EmbeddedSystems</a> biz, I'd use relational quite happily. However, I certainly don't see it as the cure for all ills. (Nor do I see OO or anything else in this light).<em></em>
      </p>
      <p>
        <em>Keep in mind. Costin and I and a few others here are not </em><a href="ObjectWeenie.html">ObjectWeenie</a>s who want to replace <a href="OracleDatabase.html">OracleDatabase</a> with <a href="GemStone.html">GemStone</a> or PrevaLayer just because OO-whatever gives us a hard-on. We (at least I) object to <strong>all</strong> nitwits who think everything (or most things) should be done in a particular way. Costin, I'd wager, knows far more about relational than either you or I do; he is decidedly not in the pro-OO camp, and yet he thinks your nuts.<em></em>
      </p>
      <p>
        Type theory, <a href="SetTheory.html">SetTheory</a>, and <a href="BooleanAlgebra.html">BooleanAlgebra</a> are also techniques. <a href="BooleanAlgebra.html">BooleanAlgebra</a> is not "science" either. 
      </p>
      <p>
        <em>They are scientific theories; axiomatic systems which have been shown to be consistent; and which have also shown to be useful.</em>
      </p>
      <ul>
        <li>
           That does not make them "science". Religion can also be consistent and useful. Just because a lot can be written about forks and spoons and their use, that does not make them "science". A useful idiom perhaps. Or, a <a href="UsefulLie.html">UsefulLie</a>. <a href="BooleanAlgebra.html">BooleanAlgebra</a> is not a universal truth. It says nothing about the external world (except physical things that we model after it).
        </li>
        <li>
           <em>Religion can be; most religions have numerous contradictions within their doctrine. Either that, or they're tautological in nature. Forks and spoons and the like could be subject to scientific scrutiny (and they are - manufacturers of such articles are always interested in ways to make them better or cheaper, and employ scientists to do the necessary research), though nobody claims them to be a science unto their own right (the making of metal eating utensils falls under metallurgy). If </em><a href="BooleanAlgebra.html">BooleanAlgebra</a> isn't a "science" because it makes no claims about the <a href="RealWorld.html">RealWorld</a>, then call it math. Again, I don't care; you're SplittingHairs on an irrelevant topic.<em></em>
        </li>
        <li>
           Math and science are different things. Math is similar to software (and perhaps the same) in that you can invent your own little worlds as long as the rules are clear and consistent. <strong>Math is not bound to the physical world, but science is.</strong> [<a href="MisuseOfMath.html">MisuseOfMath</a>]
          <ul>
            <li>
               that is why programming is more like math and less like science, since programming is not bound to the physical world, like math. Math also deals with functions, numbers, calculating: just like programming. Math also has something called number types. So pages like <a href="ThereAreNoTypes.html">ThereAreNoTypes</a> are b.s. and is a MisuseOfBrain
            </li>
            <li>
               <em>Note that I did not create the topic </em><a href="ThereAreNoTypes.html">ThereAreNoTypes</a>. I agree "types exist", but disagree with some of the definitions given. And your rude-ness to the topic creator is unnecessary. --top<em></em>
            </li>
          </ul>
        </li>
        <li>
           It seems everyone agrees that "modeling idioms" such as type theory, set theory, Boolean Algrebra, etc. can be useful (<a href="UsefulLie.html">UsefulLie</a>), at least in some circumstances. The disagreement seems to be about which one dominates. If sets and types can both deliver results, then how does one pick and choose? Is it subjective? Software lets us create our own little worlds where we can play the role of a diety with these idioms, and this takes us back to the subject at hand. We can build our little world with sets, types, Boolean algebra, or simulated hamsters running simulated Tinkertoy machines. Other than our little worlds delivering the results agreed upon by the user, the <strong>degree of freedom of design is quite large</strong>. This is the disputed "god range".
        </li>
      </ul>
      <p>
        <em>To me, that makes 'em "science". Or math, if you wish to reserve the word "science" for physics and chemistry and the like - it doesn't matter to me either way.</em>
      </p>
      <p>
        These techniques developed around somewhat simple premises (givens) and conventions and patterns (maths) are built off of them. They are like spoons, forks, and knives. They have proven useful but may not be the only game in town (chopsticks, sporks). Aliens may have eating utensils that we have yet to think of.
      </p>
      <p>
        <em>And such aliens are welcome to publish the details. There is no conspiracy of </em><a href="TypeTheory.html">TypeTheory</a>ists thwarting publication of well-thought-out theories which might compete with <a href="TypeTheory.html">TypeTheory</a> for applicability. Conjecturing about the existence of things, however, doesn't an argument make.<em></em>
      </p>
      <p>
        Plus, one can probably still build software without <a href="BooleanAlgebra.html">BooleanAlgebra</a> etc. It is not a requirement.
      </p>
      <p>
        <em>Well, one could always program in </em><a href="MalbolgeLanguage.html">MalbolgeLanguage</a>, which uses base-3 logic. (I forgot - SQL provides that already - see <a href="NullConsideredHarmful.html">NullConsideredHarmful</a>. :). Coming back to practical <a href="ComputerScience.html">ComputerScience</a>, you pretty much need <a href="BooleanAlgebra.html">BooleanAlgebra</a> 'cause that's how the underlying machine works. But use of base-3 logic, or base-75321 logic, wouldn't give you any advantage in computational power; <a href="AlanTuring.html">AlanTuring</a> himself proved that much many years ago.<em></em>
      </p>
      <ul>
        <li>
           We use boolean algebra because it matches our chips? Please elaborate. It may have originated that way, but I don't think the hardware itself is keeping us there.
        </li>
        <li>
           <em>If you don't understand how the boolean states (true and false) correspond to high/low voltages (or presence/absence of current, etc.) in an electronic circuit, you desperately need to go study CS 101. And the hardware is indeed keeping us there; outside of some specialized applications (such as memory devices, where quaternary logic is occasionally employed), all modern computer systems run off of base 2. They've done so since ENIAC. Much research has been done into higher-radix electronics; and it's consistently been shown to be a bad idea.</em>
        </li>
        <li>
           I am talking software, not hardware. N-way logic is possible and can be used to build CPU's. Binary chips are not a necessity. In fact, some quantum chip plans are exploring N-way logic to get more power per atom. Binary may be the easiest to study and test, but not necessarily the most powerful, or at least not necessarily the way to get the most bank for the buck.
        </li>
      </ul>
      <p>
        Nor do I think "engineering" is a sufficient comparison. We can test different woods on bridges based on models. The software world depends too much on models of human psychology and too little on the physical world, where engineering deals. We have too little outside ourselves to compare software ideas, and that is the very point of this topic. 
      </p>
      <p>
        <em>Then why the diversion into discussing what level of "god" software is at?</em>
      </p>
      <p>
        Bridge building has a lot of potential objective metrics. Software has almost none. Code size (<a href="LinesOfCode.html">LinesOfCode</a>) is probably the most objective (measurable), but even that is subject to subjective counting rules. We have speed (performance), and that is about it. A fallen bridge is a fallen bridge, but we can't rule out that <a href="BrainfuckLanguage.html">BrainfuckLanguage</a> is the most productive language for some people/alien. -- top
      </p>
      <p>
        <em>I think we can safely state that </em><a href="BrainfuckLanguage.html">BrainfuckLanguage</a> is not productive for most programmers. And were someone to do the study, I think that it could be demonstrated scientifically. The problem with this sort of science is not that it isn't possible; but that it's statistical in nature (and statistically valid surveys are often time-consuming and expensive).<em></em>
      </p>
      <ul>
        <li>
           Ah, now we are getting somewhere. 
        </li>
      </ul>
      <p>
        <em>But the other problem is - because some of the science is indeed soft (involving psychology), </em>'people feel free to ignore the results<strong>. It's pretty hard to disclaim scientific observations about gravity, but it's easy to dismiss results involving </strong>HumanFactors as "not applying to me or my particular case". And this is often done not because of any legitimate objection about applicability, but instead because someone doesn't like the results.<em></em>
      </p>
      <p>
        <em>Stepping out of </em><a href="ComputerScience.html">ComputerScience</a> and into the realm of politics, there was an interesting study done recently. Several groups of individuals were presented with a fictional (the participants knew it was fiction) account of a war-crime perpetrated by US troops in Iraq. In one group, the account was backed up with lots of hard "evidence" - photographs, witness testimony, etc. In the other group, there was no evidence; the account was an unsubstantiated rumor. The participants were then asked how they felt about had happened. They were also quizzed about their political leanings, and other socioeconomic data.<em></em>
      </p>
      <p>
        <em>What the researchers found was significant, but not surprising: There was almost no correlation between the subjects' opinion and the amount of evidence presented. There was a high correlation between their opinion on the matter, and their political beliefs. The Republicans thought that the American soldiers in question were being railroaded, no matter how damning the evidence; and the Democrats thought that they were guilty of the deed, no matter how flimsy the evidence.</em>
      </p>
      <p>
        <em>While it may be a stretch to extrapolate this result back from the realm of politics to science, I think the same principle applies. </em>'People believe what they want to believe<em>', and they include or exclude evidence based on their pre-existing beliefs. Some do this more than others, obviously.</em>
      </p>
      <p>
        Well, if the software world is wide open, then you <em>can</em> believe what you want to believe and make a little world however you want it to solve the problem at hand in your way. There is <strong>no objective reality in software</strong> other than the rules you choose to make. Politics deals with the external world, software does not, other than the input and output. What is in between is open-ended. One could do computing by creating a "right wing" world in which computations are done by hunting down and jailing evil liberals. (Ann Coutler OS?) Efficiency aside, such a world could be <a href="TuringComplete.html">TuringComplete</a>, and thus solve any problem any other paradigm or language can. We already use a slightly milder form of such processing-intensive virtual realities to perform work: GUI's. The buttons and pretty icons are not needed to perform the necessary computations, but are instead there to help humans relate to the thing. -- top
      </p>
      <p>
        <em>But you're missing the point. (Not to mention once again hypothesizing rather bizarre worlds in a seeming attempt to prove some point)....</em>
      </p>
      <p>
        My point was that an externally invalid world view may not necessarily be internally invalid. This has big ramifications. People believing what they want to believe in the external world is different than the same thing in an internal world. <strong>One can be "wrong" in the internal world</strong> without the same ramifications, as long as their internal world is consistent (follows its own rules) and as long as the output to the external world is correct. GUI's are inefficient in many ways, but make (most) people comfortable. That is why we use them. Similarly a bad, stupid, naive, etc. external world view can perhaps be turned into a workable internal view (software world) that does real work. How is an Ann Coutler interface conceptually different than a GUI interface?
      </p>
      <p>
        <em>You seem to think that because a discipline isn't subject to axiomatic proof or "hard" scientific claims, that means that </em>'no (authoritative) claims can be made about it at all<strong>. And that therefore, all scientific claims are merely "opinions" and that your opinion - however uninformed or pulled-out-of-your-ass - is as valid as mine or that of </strong><a href="DonKnuth.html">DonKnuth</a>.<em></em>
      </p>
      <p>
        <em>Yeah, it's this kind of crap that makes any user interface designer or even web designer in general's job so miserable. Human behavior is a lot more than opinions and gut-feeling.</em>
      </p>
      <ul>
        <li>
           Perhaps this is wondering off topic, but I don't know of any empirical research that shows how one GUI design is better than another. Most books on the subject seem to be personal opinions and unverified anecdotes from the author. Such books may still be useful because they may point out things that you never noticed or failed to consider, widening your ability to weigh designs, but that still doesn't make them final. And for web-related stuff, a lot of marketing psychology goes into designs, especially when targeting younger buyers who may be more interested in eye-canding or peer opinion than practicals. Such fads change too fast to be subject to double-blind studies and the like. Being analyzable and analyzed are not necessarily the same thing.
        </li>
      </ul>
      <p>
        See below for more on <a href="DonKnuth.html">DonKnuth</a> comparison.
      </p>
      <p>
        <em>Were that to be true, then many fields of study would cease to be effective, including psychology. Yet psychology has seen tremendous progress in the past 100 years since Freud laid down the foundations of the discipline (including the repudiation of most of Freud's work). Likewise with medicine, economics, and numerous other "soft" fields; this despite being "soft" and tainted with political/moral considerations. "Objective reality" is not a prerequisite for scientific inquiry; the suggestion that it is (and that it doesn't exist, so therefore neither does science) is the grand lie of </em><a href="PostModernism.html">PostModernism</a>. The <a href="ScientificMethod.html">ScientificMethod</a> handles soft science just fine.<em></em>
      </p>
      <p>
        Re: <em>"Objective reality" is not a prerequisite for scientific inquiry;</em>
      </p>
      <p>
        <em>Really. To clarify, many in the </em><a href="PoMo.html">PoMo</a> camp claim that because scientific inquiry requires scientists to do the inquiring, that even the hardest science is influenced by human factors - and that therefore, the conclusions of science are always suspect. In other words, they essentially make the claim that a tree falling in the woods with nobody to hear it <strong>doesn't</strong> make a sound. But the <a href="ScientificMethod.html">ScientificMethod</a>, by its use of independently repeatable and falsifiable experiment, provides a filter for all of this. Don't like the results of an experiment; or think the experimenter induced bias or error (intentionally or otherwise)? Run the experiment yourself. Analyze the methodology of the original experiment.<em></em>
      </p>
      <p>
        Psychology and economics are generally based on models. These models sometimes reflect actual reality sometimes don't. They are both immature disciplines. Economists still argue over the primary cause of the Great Depression even though they have had plenty of time to analyze it and the world was simpler back then.
      </p>
      <p>
        <em>Physics and chemistry are also based on models; though the models in the harder science tend to fare better when experimentally compared with reality. Models are necessary in order to make predictions, which is one of the reasons (some say </em>'the<strong> reason) that we do science in the first place. At any rate, all science disciplines adapt their models as new evidence requires. The sure sign of </strong><a href="PseudoScience.html">PseudoScience</a> is a failure or refusal to do so.<em></em>
      </p>
      <ul>
        <li>
           Perhaps some fields are more subject to testing and repeatability than others. Chemists can easily recreate most experiments over and over, changing as many variables they want in the process to see which variables make the most difference. Economics is not like this: we cannot create another depression just to test theories on the Gold Standard. If you tried, you would get flogged by angry mobs. Thus, much of the analyzing is after the fact. In both economics and psychology, there are more variables but less trials than chemistry allows. The "solid" sciences in general have higher trials-to-variables ratios.
        </li>
      </ul>
      <p>
        You are right that science does involve testing models against reality. But the only reality in software is the input and the output. Well, actually it is these:
      </p>
      <ul>
        <li>
           Input
        </li>
        <li>
           Output
        </li>
        <li>
           Programmer productivity (and this is a loaded factor)
        </li>
        <li>
           Performance (speed, RAM)
        </li>
      </ul>
      <p>
        Beyond that, there is not a lot to objectively test. 
      </p>
      <p>
        Psychology often relies on anecdotes because there is nothing better to replace it. 
      </p>
      <p>
        <em>Horseshit. Don't confuse the "psychology" peddled in liberal arts classes (or by armchair politicians) with the scientific discipline; the two have nothing to do with each other. Real psychology is a clinical science much like medicine. Anything else isn't real psychology.</em>
      </p>
      <p>
        But it is mostly just measuring customer satisfaction. IOW, ArgumentByVotes. Psychologists gauge how the patient is doing, or claims to be doing and writes that down. Then statistical sampling is done to see if technique X resulted in better satisfaction grades. But, I don't see much analogy to that in soft eng. other than "what technique do you like the best?" type of questions (<a href="MyFavouriteProgrammingLanguage.html">MyFavouriteProgrammingLanguage</a>).
      </p>
      <p>
        <em>That ain't psychology. Or science.</em>
      </p>
      <p>
        I think the problem with "soft sciences" like psychology and economics is one or more of:
      </p>
      <ul>
        <li>
           The models are hard to test against reality, at least in the shorter run
        </li>
        <li>
           The models are ill-defined (fuzzy)
        </li>
      </ul>
      <p>
        "Computer science" tends to have the opposite problem: there are too many models which can produce the correct answer (right output). In almost none of the top-vs-oop-vs-fp debates did anybody seriously suggest that one of those will produce wrong answers. That was not the issue. -- top
      </p>
      <hr/>
      <p>
        <strong>Examples</strong>
      </p>
      <p>
        One of my favorite examples is library book searching. The physical nature of books and card catalogs limited the searches to mostly hierarchical taxonomies and perhaps author. 
      </p>
      <p>
        <em>Unless you "denormalized the schema", which in the physical world means keeping multiple card catalogs, sorted in a different order.</em>
      </p>
      <ul>
        <li>
           Please clarify
        </li>
      </ul>
      <p>
        Now text search engines allow one to search on many different criteria. The physical location of the books and library cards in 3D space is now irrelevant.
      </p>
      <p>
        <em>But that's not a "god-like power" by any stretch of the imagination.</em>
      </p>
      <p>
        To somebody in the 1800's it might be. Columbus's ability to predict eclipses was "god-like" to the native Americans at that time. But he was just using math that was not known to the native Americans. <strong>Things are often god-like until you know how they work</strong>. A notebook computer might similarly convince Columbus. Perhaps our "God" is really some geek in a torn T-shirt running our universe as a simulation on a trillion-core PC using 4D chips in his 4D realm. He could perform (insert) supernatural acts into our universe like 40-day floods, parting seas, and talking bushes. However, once we get to see that he's just a geek with a big computer, he loses his "God" persona to us (although we may still take care to be nice to him for obvious reasons). --top
      </p>
      <p>
        <em></em><a href="ArthurCeeClarke.html">ArthurCeeClarke</a> had something to say about this.<em></em>
      </p>
      <p>
        <strong>GUIs</strong>
      </p>
      <p>
        Gui's present a fictitious paper desk- and/or control-panel-like visual interface. This is merely a <a href="UsefulLie.html">UsefulLie</a>, and command-line aficionados will claim it is not that useful to them. GUI's are a phony world. Software has no manila folders and buttons and slide knobs. These are purely for human relation. 
      </p>
      <p>
        Programming techniques may be doing the same thing. Does OOP reflect the actual world it is modeling? Probably not. Does relational? Probably not. The real world is not in tables for the most part. No <a href="GoldenHammer.html">GoldenHammer</a> clearly fits the actual world better. 
      </p>
      <hr/>
      <p>
        Re: "<a href="TopMind.html">TopMind</a> has ventured beyond <a href="PseudoScience.html">PseudoScience</a> into pseudo theology..."
      </p>
      <p>
        You know, you may be right. But I am <em>forced to</em> because there is no real science in software so far. See <a href="DisciplineEnvy.html">DisciplineEnvy</a>. However, I would not call it "theology" because it is not meant to suggest human actions (morals, rituals, etc.), but merely as a <a href="UsefulLie.html">UsefulLie</a> to explore, talk about, and hopefully explain software. <strong>What is the alternative?</strong> There is no real science for it yet, so my approach may be the next best thing. Think about it. Stop complaining about having to use leaves for toilet paper when the only alternative at present is your hand. <a href="DontComplainWithoutAlternatives.html">DontComplainWithoutAlternatives</a>.
      </p>
      <p>
        Religion in fact may be a <a href="UsefulLie.html">UsefulLie</a> that allowed humans to encode useful survival tips and social structures. For example, they may not understand microbes, but thinking of flues as "demons that make children demons who can hop on nearby people and possess them also" supplies a mental model that reminds one to stay away from people with flues. The demon is an accidental approximation of germs. It is an abstraction that happens to generally model the real thing (germs). Dogma that increases the survival of a group will spread using a kind of Darwinian selection process. The most useful lies spread because they keep the population holding them alive to bear more children, who in turn learn the dogma. It is a <a href="UsefulLie.html">UsefulLie</a> that works! (Of course sometimes religious doctrine goes awry, but it is the net benefits that count in the end.) It is "natural selection of <a href="UsefulLie.html">UsefulLie</a>s". [I just entered this theory into wikipedia, surprised that it was not already there.]
      </p>
      <p>
        Similarly, software apps may merely be <a href="UsefulLie.html">UsefulLie</a>s that allow us to use the computer to do work. Rarely are our software models "proved correct" in the purest sense. They just run a damned model that produces something we want to use. Having value or utility, and being "correct" or "ideal" may be different things. Theory and logic may improve or speed up achieving the utility or value, but that's not the same as being it.
      </p>
      <p>
        Were <a href="EpiCycles.html">EpiCycles</a> "pseudo-science"? They provided predictive value better than anything else at the time. Science is a journey, and the journey sometimes takes the wrong road. I suppose if someone lied about the effectiveness of the predictive value of epicycles, it would be fair to call that "pseudo-science".
      </p>
      <p>
        Pseudo-science would require science as a reference point, and if there is no "science" in software, then my statements about software cannot be pseudo-science in the general sense. Science is about testing theoretical models against the "real" model: our environment. If we can model environments that have no relation to the "real" environment, then there's nothing to test against, at least nothing "real". Software allows us to make our on realities such that any "falseness" has to be in reference to a stated "reality" (virtual world/universe).
      </p>
      <p>
        -- top
      </p>
      <hr/>
      <p>
        Re: <em>You seem to think that because a discipline isn't subject to axiomatic proof or "hard" scientific claims, that means that no (authoritative) claims can be made about it at all. And that therefore, all scientific claims are merely "opinions" and that your opinion - however uninformed or pulled-out-of-your-ass - is as valid as mine or that of </em><a href="DonKnuth.html">DonKnuth</a>.<em></em>
      </p>
      <p>
        Let's explore some examples of some alleged external proofs provided by <a href="DonKnuth.html">DonKnuth</a>, outside of performance. What absolutes do we have? 
      </p>
      <p>
        In domain-space, yes we do have more rigor. But I'm talking in general here. -- top
      </p>
      <hr/>
      <p>
        Quote from Slashdot poster 585321: <em>The comparison with algorithms/programming is also weak, since it is perfectly possible to have two different algorithms (with different complexity, in all senses of the word) that solve exactly the same problem, but it is arguably not possible that you have two different physical theories explaining the same phenomenon that are both true at the same time (although I guess this is a rather philosophical question).</em>
      </p>
      <p>
        [In science you can have two models that explain the same phenomenon. For example classic atomic theory where atoms were like billiard balls with electrons (dots) spinning around the atom, versus the newer theory which explains electrons more like a cloud (and/or wave) and less like the familiar dot that we knew before. Algorithms are more like math than science. In science we use math, though - so there is some overlapping.]
      </p>
      <hr/>
      <p>
        <strong>Definition of Omnipotent</strong>
      </p>
      <p>
        Suppose as a human you create a software simulation of another universe and sentient beings eventually arise in or are custom-created in this simulated universe (SU). As the "creator", you have full practical control over your SU: you can delete beings, go back in time (restore from backup), mess with their heads by moving their furniture around when their back is turned, give them rewards, etc. 
      </p>
      <p>
        However, this doesn't mean that you have perfect knowledge of your creation. You <strong>cannot possibly grok every</strong> simulated atom of your SU, being a human. Sure, you can stop the simulation and study in detail any particular atom, but you cannot grok every atom and its influence at every time-point. Even if you lived forever you may not want to bother inspecting every atom at every point in time, and it's possible you still may miss something subtle. After all, if you could run the whole thing in your head you wouldn't need a computer.
      </p>
      <p>
        With this perfect potential control but imperfect knowledge of your domain, are you still "omnipotent" from the perspective of the beings in the SU? 
      </p>
      <p>
        As a <strong>working definition</strong>, I'm defining "omnipotent" as having unlimited power (for a given universe/world), not necessarily unlimited knowledge. Note that even a lone chimp in the same lab room as the simulation server has "unlimited power" in that he/she can potentially tinker with it and end it as she/he pleases, stomping on the motherboard, for example. But that doesn't mean the chimp will actually do anything "smart" with the simulation.
      </p>
      <p>
        Another way of saying this is that Omniscience ("all knowing") is not the same as Omnipotent ("all powerful"). Within our software universe, we have omnipotence, but not omniscience (so far) because no human can grok the influence/interaction of every bit.
      </p>
      <p>
        --top
      </p>
      <hr/>
      <p>
        Topics with related issues, and perhaps refactoring material:
      </p>
      <ul>
        <li>
           <a href="EverythingIsRelative.html">EverythingIsRelative</a>
        </li>
        <li>
           <a href="SeparationAndGroupingAreArchaicConcepts.html">SeparationAndGroupingAreArchaicConcepts</a>
        </li>
        <li>
           <a href="PageAnchor.html">PageAnchor</a> "transcend" in <a href="LaynesLaw.html">LaynesLaw</a>
        </li>
        <li>
           <a href="SeparateMeaningFromPresentation.html">SeparateMeaningFromPresentation</a>
        </li>
        <li>
           <a href="ProgrammingIsInTheMind.html">ProgrammingIsInTheMind</a>
        </li>
        <li>
           See <a href="BlackAndWhite.html">BlackAndWhite</a>, and other games where you play "god".
        </li>
        <li>
           <a href="CommonSenseIsAnIllusion.html">CommonSenseIsAnIllusion</a>
        </li>
      </ul>
      <hr/>
      <p>
        <strong>Related Links</strong>
      </p>
      <ul>
        <li>
           <a href="http://www.geocities.com/tablizer/science.htm">http://www.geocities.com/tablizer/science.htm</a>
        </li>
      </ul>
      <ul>
        <li>
           <a href="http://www.newscientist.com/article.ns?id=dn6857">http://www.newscientist.com/article.ns?id=dn6857</a>
        </li>
      </ul>
      <hr/>
      <p>
        <a href="CategoryPhilosophy.html">CategoryPhilosophy</a>, <a href="CategorySubjectivityAndRelativism.html">CategorySubjectivityAndRelativism</a>, <a href="CategoryScience.html">CategoryScience</a>, <a href="CategoryMetaphor.html">CategoryMetaphor</a>
      </p>
    </div>
  </body>
</html>