<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Remote Gui Protocols
      </h1>
      <p>
        This is to document and discuss various <a href="GraphicalUserInterface.html">GraphicalUserInterface</a> protocols that have come into existence or have been proposed to deal with distributed and/or standardized GUIs.
      </p>
      <hr/>
      <p>
        We need an HTTP-friendly GUI protocol in order to satisfy the requests of managers and users who want to make HTML-based Web pages look and act like GUIs found in applications built with VisualC++, GTK, <a href="VisualBasic.html">VisualBasic</a>, <a href="BorlandDelphi.html">BorlandDelphi</a>, <a href="PowerBuilder.html">PowerBuilder</a>, KDE, etc. (<a href="BrowserAbuseSyndrome.html">BrowserAbuseSyndrome</a>) HTML and its extensions (DOM, DHTML, <a href="JavaScript.html">JavaScript</a>, etc.) act like an afterthought add-on rather than a solution.
      </p>
      <hr/>
      <p>
        Factors to compare by:
      </p>
      <ul>
        <li>
           Proprietary versus open standard
        </li>
        <li>
           Bandwidth and response-time requirements
        </li>
        <li>
           HTTP-friendly to avoid fire-wall bureaucracy
        </li>
        <li>
           Execution reliance - reliance on client-side <a href="ScriptingLanguage.html">ScriptingLanguage</a> or <a href="TuringComplete.html">TuringComplete</a> execution language for app-specific functionality
        </li>
        <li>
           Maturity (road-tested)
        </li>
        <li>
           Target domain: business forms, games, CADD, etc.
        </li>
        <li>
           Base language type (XML, etc.)
        </li>
      </ul>
      <hr/>
      <p>
        Protocols that rely on low-level transport (TCP/IP) and low-level client executable/library:
      </p>
      <ul>
        <li>
           <a href="VirtualNetworkComputing.html">VirtualNetworkComputing</a> (VNC) - Can be bandwidth intensive because it is generally an image mirroring technology, in contrast to techniques that treat screen widgets as abstract concepts.
        </li>
      </ul>
      <ul>
        <li>
           <a href="XwindowProtocol.html">XwindowProtocol</a> - heavy bandwidth requirements, does not rely on client-side scripting, not HTTP-friendly
          <ul>
            <li>
               Of course, when dealing with X you have to be careful what you mean by "client" and "server". In X jargon, the "client" is the end-user application, which may run on a central machine; the "server" is the program running on the terminal which provides display and user-input services. In other words, many networks consist of <a href="ThinClient.html">ThinClient</a>s running X-servers providing UI services to X-clients running on large <a href="ComputeServer.html">ComputeServer</a>s. Got that? <em>Keep in mind that the context here is "remote".</em>
            </li>
            <li>
               X protocol is also generally not appropriate for running over the Internet, for many reasons besides bandwidth. [<em>Latency is the only real problem I can think of; even with good bandwidth a GUI is pretty sluggish when it takes 100ms just to send "mouse moved!" to the program. If you're thinking of security, tunneling over SSH is the normal thing to do.</em>]
            </li>
            <li>
               Are you saying that what dogs X will also dog other protocols? X is too low-level from what I know. For example, each character you type has to make a round trip before it appears in a text box. An HTTP-friendly protocol would not need such a round trip (unless explicitly told to wait on or monitor such events).
              <ul>
                <li>
                   Any kind of sophisticated GUI requires at least the possibility of this sort of event model. X is pretty low-bandwidth, a dial-up line is fine. The latency is the issue and that will (and does) dog any streaming protocol. Batch protocols like HTTP have their own (different) problems.
                </li>
                <li>
                   <em>See </em><a href="ItsTheLatencyStupid.html">ItsTheLatencyStupid</a><em></em>
                </li>
                <li>
                   The latency can be avoided if common processing is done on the X server. This is certainly true for text widgets: "each character you type" should not have to make a network roundtrip. Too bad that the BerlinProject went nowhere and its ancestors <a href="InterViews.html">InterViews</a> and <a href="FrescoFramework.html">FrescoFramework</a> are long dead.
                </li>
              </ul>
            </li>
            <li>
               Note that X can be optimized for low bandwidth and/or high latency links quite well. Low bandwidth X (LBX) is quite old and already quite an improvement, NX from nomachine.com is rather recent and achieves miracles by cutting down on roundtrips.
              <ul>
                <li>
                   <em>Remember, low bandwidth and latency are two different kinds of problems, sometimes related and sometimes not.</em>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <p>
        Protocols that rely on high-level transport (e.g. HTTP) and high-level runtime (e.g. scripting inside browser):
      </p>
      <ul>
        <li>
           GTW (<a href="GoogleWebToolkit.html">GoogleWebToolkit</a>)
        </li>
        <li>
           <a href="MozillaXul.html">MozillaXul</a> - XML-based, HTTP-friendly, relies on client-side-scripting
        </li>
        <li>
           XWT - XML-based, HTTP-friendly, relies on client-side-scripting
        </li>
      </ul>
      <p>
        Other protocols:
      </p>
      <p>
        At first glance, none of these are "protocols". For a second glance, defenders should explain otherwise, or split this list into protocol vs nonprotocol, or something:
      </p>
      <ul>
        <li>
           <a href="JavaApplet.html">JavaApplet</a> - heavy reliance on client-side executable. Tends to require entire app be loaded instead of dividing up by as-needed modules or screens. Interface awkward on some OS's.
        </li>
        <li>
           HTML alone - Has to be regenerated per communication
        </li>
        <li>
           HMTL+DOM+JS scripting, now called <a href="AjaxWebApplications.html">AjaxWebApplications</a> -- HTTP-friendly, ...
        </li>
        <li>
           Curl
        </li>
        <li>
           SCGUI - XML-based, HTTP-friendly, does not rely on client-side scripting, immature
        </li>
        <li>
           Droplets
        </li>
        <li>
           Kenamea
        </li>
        <li>
           The Y Window System (<a href="http://www.y-windows.org/)">http://www.y-windows.org/)</a> -- still in its infancy, aspiring to replace X Window.
        </li>
        <li>
           <a href="ScalableVectorGraphics.html">ScalableVectorGraphics</a> + <a href="JavaScript.html">JavaScript</a>
        </li>
        <li>
           WHAT - Web Hypertext Application Technology (<a href="http://www.whatwg.org/)">http://www.whatwg.org/)</a> Still in the works
        </li>
        <li>
           <a href="NetworkAsComputer.html">NetworkAsComputer</a> - Where the DataExchangeProtocol is more like <a href="PeerToPeer.html">PeerToPeer</a> than <a href="ClientServer.html">ClientServer</a> and the application run on the local machine blends local execution, remote execution, and data exchange into a process patterned after HumanConversation, using HumanConversationAlgorithms.
        </li>
      </ul>
      <hr/>
      <p>
        There is a project named Vedga (former Glan, sourceforge.net/projects/glan/) which offers unversal component-drawing client (somewhat like a player or browser) and all GUI is processed at the server (process per client). It is built on the Qt library and protocol thinks in terms of Qt objects, slots and signals -- high-level enough for protocol to be really fast. -- nuclight
      </p>
      <hr/>
      <p>
        What seems hardest to standardize are widgets such as editable grid widgets and tree/outline browser/editor widgets. These are the last that implementers "get right".
      </p>
      <p>
        [There's a difference between a GUI protocol and a widget set. X Windows, for example, provides no widgets at all, only basic GUI services. The rest is handled at a higher level. At the other extreme, HTML/other markups provide ONLY widgets. Editable grids aren't especially difficult, but making a one-size fits all one is, if it's even possible.]
      </p>
      <ul>
        <li>
           And this is exactly what makes X sluggish! The widget kit is run on the client, therefore everything that is more sophisticated than static rectangular windows requires a network roundtrip. Some of that processing could <em>easily</em> be done on the server.
        </li>
      </ul>
      <p>
        When I imagine a remote GUI protocol I image a set of widget primitives, but also the ability to represent more primitives that run locally. Using the browser as an example, the server would define it's custom tree-editor as a combo of html,css,and js that runs locally and quickly, then builds upon that new primitive.
      </p>
      <hr/>
      <p>
        There seems to be some debate about whether you need a <a href="TuringComplete.html">TuringComplete</a> scripting language embedded in the protocol to get decent performance over HTTP. Makes for an interesting debate.
      </p>
      <hr/>
      <p>
        Is being "HTTP friendly" a good thing? I would think that for many GUIs it most certainly is not. I don't want arbitrary applications to be able to make their GUI available through the firewall.
      </p>
      <p>
        <em>How are HTTP GUIs more dangerous than HTML interfaces, </em><a href="JavaScript.html">JavaScript</a>, Java applets, Flash, etc?<em></em>
      </p>
      <p>
        I would think being HTTP friendly is important because of backward compatibility. If everyone is currently using HTML today, it would make sense to design a <a href="ComponentBrowser.html">ComponentBrowser</a> or <a href="RemoteGuiProtocol.html">RemoteGuiProtocol</a> which offered HTML capabilities. My idea with a <a href="ComponentBrowser.html">ComponentBrowser</a> is that you <em>could</em> have one HTML component as just a part of the web browser. But not to base the entire browser on HTML. HTML could still be useful when creating documents. Another component that people might use is an RTF component or a component that used some markup similar to wiki's. No-one wants to create HTML just for simple pages, yet currently we are limited to having to do that.
      </p>
      <p>
        We need to make a distinction between HTTP-based and HTML-based. They are not necessarily one and the same.
      </p>
      <p>
        <em>Judging things by their "HTTP friendlyness" is a stupid misdevelopment of the dotcom era. A simple port filtering firewall or even a http proxy is useless, because these days </em>everything<em> can be tunneled. It's actually worse than useless, because it forces protocols to insane contortions instead of simply opening a tcp connection. If it doesn't work through a firewall (whatever "it" is), it is the fault of the firewall.</em>
      </p>
      <hr/>
      <p>
        <em>Anyone here considered </em><a href="RichInternetApplication.html">RichInternetApplication</a> as a workable option to deliver high bandwidth of communication, without the deployment issues associated with client server apps?<em></em>
      </p>
      <p>
        Most producers and promoters of <a href="RemoteGuiProtocols.html">RemoteGuiProtocols</a> that target HTTP appear to think so. Related: <a href="WebGuiWikiPoll.html">WebGuiWikiPoll</a>.
      </p>
      <hr/>
      <p>
        I think it's not just about the GUI and a protocol for the GUI, though.
        I think it's mainly about the following issues:
      </p>
      <ul>
        <li>
           The software that runs instructions from the server. HTML are the only current instructions from the server that the client reads (and javascript).
        </li>
        <li>
           the software that handles the instructions. Currently software handles HTML and <a href="JavaScript.html">JavaScript</a> instructions. Yet clients like email who connect to the web never rely on HTML in structions.
        </li>
        <li>
           In other words, we don't need just HTML instructions, and the software that connects to the net does not have to display just HTML. It can display other things, and respond to other instructions. We just have to make some standards, so that everyone out there isn't going out and creating their own thin-clients everywhere (<a href="ComponentBrowser.html">ComponentBrowser</a> brings them all together).
        </li>
      </ul>
      <p>
        Since HTML is simply parsed on the user's machine, we could still use HTTP as the protocol for something like a component browser. I think the problem is not mainly the protocol, since HTTP could do the job currently. I think the main problem is that people are too lazy and stubborn to think up and create a browser based on something other than HTML, since people have already done so much work in HTML. They keep extending HTML and extending it more, instead of deciding that the HTML e-brochure can only go so far before it looks ridiculous. The last ridiculous item I saw on an HTML website was a dropdown menu which took a few seconds to load (instead of instantly in a software application).
      </p>
      <hr/>
      <p>
        Moved discussion to <a href="ClientSideAppDataCaching.html">ClientSideAppDataCaching</a>.
      </p>
      <hr/>
      <p>
        I've toyed with the idea of the modification of predefined processes, attributes, using some InventedProcesses and <a href="DataStructures.html">DataStructures</a> in combination with a DesktopApplication and a Desktop controlled <a href="WebSite.html">WebSite</a> to customize a User-Centric-Model of PersonalInformation. There are some ideas here which I think I can use. I have always believed that if one is willing to do the <strong>hard work</strong> required, manageable problems can be solved by clever solutions. Through <a href="PositiveDialogue.html">PositiveDialogue</a> and careful attention to the suggestions and approaches which one will encounter while involved in, or while observing it, there always seem to be possible avenues of solution. While one may not be totally successful, Progress can be made, especially if one does not stop trying regardless of how slowly one might be moving toward that solution.
      </p>
      <p>
        <a href="http://74.125.93.132/search?q=cache:FsmAgLDElaYJ:www.enterpriseinnovation.net/content/through-knowledge-focused-lens+It+does+not+matter+how+slow+you+go+so+long+as+you+do+not+stop.%22+Confucius&cd=5&hl=en&ct=clnk&gl=us">http://74.125.93.132/search?q=cache:FsmAgLDElaYJ:www.enterpriseinnovation.net/content/through-knowledge-focused-lens+It+does+not+matter+how+slow+you+go+so+long+as+you+do+not+stop.%22+Confucius&cd=5&hl=en&ct=clnk&gl=us</a>
      </p>
      <hr/>
      <p>
        See <a href="WebFormMethodologies.html">WebFormMethodologies</a>, <a href="WebsitePatterns.html">WebsitePatterns</a>, <a href="BrowserAbuseSyndrome.html">BrowserAbuseSyndrome</a>, <a href="ProgrammingLanguageNeutralGui.html">ProgrammingLanguageNeutralGui</a>, <a href="GuiMachineLanguage.html">GuiMachineLanguage</a>, <a href="GuiMarkupProposal.html">GuiMarkupProposal</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryUserInterface.html">CategoryUserInterface</a>, <a href="CategoryInternet.html">CategoryInternet</a>, <a href="CategoryWebDesign.html">CategoryWebDesign</a> <a href="CategoryGui.html">CategoryGui</a>
      </p>
    </div>
  </body>
</html>