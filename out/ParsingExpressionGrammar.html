<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Parsing Expression Grammar
      </h1>
      <p>
        Parsing expression grammars (PEGs) are an analytic grammar formalism.
      </p>
      <p>
        They feature the following operators:
      </p>
      <ul>
        <li>
           sequencing (e1 e2)
        </li>
        <li>
           unambiguous choice  (e1/e2)
        </li>
        <li>
           (greedy) repetition (e*)
        </li>
        <li>
           option (e?)
        </li>
        <li>
           one-or-more (e+)
        </li>
        <li>
           positive lookahead (&e)
        </li>
        <li>
           negative lookahead (!e)
        </li>
      </ul>
      <p>
        They are:
      </p>
      <ul>
        <li>
           fast to parse (O(n) in time and space, where n is the size of the input)
        </li>
        <li>
           unambiguous by construction
        </li>
        <li>
           closed under composition, which allows modular grammars
        </li>
        <li>
           more expressive than context-free grammars (they can parse L="a"^n"b"^n"c"^n)
        </li>
      </ul>
      <p>
        However, they come with their share of problems:
      </p>
      <ul>
        <li>
           PEGs can't directly handle left-recursion (not much of a problem in practice)
        </li>
        <li>
           PEGs suffer from so called "prefix capturing": "a*a" will never match any input
          <ul>
            <li>
               (this is what you get for defining away ambiguity)
            </li>
          </ul>
        </li>
        <li>
           PEGs are bad for specifying languages: just guess what language "S <- aSa / aa" parses
          <ul>
            <li>
               for the lazy: A string of "a"s with a length which is a power of two!
            </li>
          </ul>
        </li>
        <li>
           PEGs can't generate strings, only parse them (due to lookahead operators)
          <ul>
            <li>
               <em>it seems to me that one could 'enforce' discovery of whatever one looked ahead to find</em>
            </li>
            <li>
               Generating "(&A)B" would involve finding the intersection of A and B. This is an undecidable problem: If it would be possible to find the intersection of two PEGs we would not have issues detecting prefix capture. Prefix-capture is present in "A/B" iff the language generated by "(&A)B" is not empty. See [1] for more information.
            </li>
          </ul>
        </li>
      </ul>
      <p>
        [1] <a href="http://charybde.homeunix.org/~schmitz/pub/modular.pdf">http://charybde.homeunix.org/~schmitz/pub/modular.pdf</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryCompilers.html">CategoryCompilers</a>
      </p>
    </div>
  </body>
</html>