<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Extreme Programming For Games Discussion
      </h1>
      <p>
        GameDevelopment can, in theory, benefit more than many other classes of application from XP because the flexibility required is very high because the requirements, as well as the code, are subject to change. A monolithic Master Plan (<a href="BigDesignUpFront.html">BigDesignUpFront</a>) approach is quite likely to drown itself. And no, this doesn't mean people in the industry actually use it... -- <a href="CanisLupus.html">CanisLupus</a> 
      </p>
      <p>
        Why can't we extend it simply to the various units? Certainly design can be done collaboratively. Level building can be as well, to some extent. The one that hangs me up is PairArt - two artists staring at one screen while one person moves vertices does not seem like a productivity booster. ;) -- <a href="TomPlunket.html">TomPlunket</a>
      </p>
      <hr/>
      <p>
        <em></em><a href="EditHint.html">EditHint</a>: slowly refactoring this into <a href="DocumentMode.html">DocumentMode</a>, as opposed to RavioliMode<em></em>
      </p>
      <hr/>
      <p>
        <strong>Proposed Adaptations to </strong><a href="ExtremeProgramming.html">ExtremeProgramming</a><strong></strong>
      </p>
      <ul>
        <li>
           A RoleOfToolsmith in the team. [Serving programmers, artists and designers]. The Toolsmith produces unified tools rather than glued together cruft.
        </li>
        <li>
           A RoleOfJournalist (often called a Producer) in the team. [Facilitates communication].
        </li>
        <li>
           Apply XP-like concepts to other areas of development that can benefit from them. Game design and level design may be appropriate, while PairArt is probably not.
        </li>
        <li>
           Model art and design as pseudo customers -- <a href="EddieEdwards.html">EddieEdwards</a>
        </li>
        <li>
           Refinement to formal definition of testing, to include (somehow), non automated testing. <em>New topic </em>UnautomatableUnitTests???<em> -- </em><a href="EddieEdwards.html">EddieEdwards</a> <em>Another cool idea.</em>
        </li>
      </ul>
      <hr/>
      <p>
        <strong>In more detail:</strong>
      </p>
      <p>
        There is a staggering <strong>lack of management skill</strong> within the computer games industry. Almost every company has grown from a small and motley crew of programmers and artists, who manage the organization by default. This is reasonable insofar as it is acknowledged; unfortunately many of these "managers" believe that management skill is inherent not learned, and even evidence (that they do not have the necessary skills and therefore the project is failing) will not convince them. 
      </p>
      <p>
        At the other end of the scale are companies such as ElectronicArts?, which employ a production line metaphor and manage their staff in ways which resemble the bank managers in 60s sitcoms. They get results, but the morale suffers as a result. Many creative people have left such places and formed their own companies, who belong in the above class. 
      </p>
      <p>
        Games coders have an <strong>intricate binding with artists</strong>, so we need a development model that can deal with this massive communications need too.
      </p>
      <p>
        <em>Is there any reason (other than typical fear of change) that programmers and artists could not share the same bullpen, thereby creating an environment where communication is easy and cheap? This seems like a natural extension of the </em><a href="WholeTeam.html">WholeTeam</a> concept to me.<em> -- </em><a href="BrianRobinson.html">BrianRobinson</a>
      </p>
      <p>
        <strong>Reuse is vital</strong>. Software is extremely expensive to develop, and no-one makes a profit from a game that has no sequel. Of course, sequels can be made without naming them after the original game - we reuse the technology, but not the concepts (assuming it was the concepts that failed in the marketplace - if the concepts succeeded in the market place we do a straight sequel). A game cannot usually be adapted to serve a modified purpose - especially not one written as spaghetti code! But modern computer technology is mature enough to allow a modular approach to the design of the important pieces of a game - graphics engine components, overall system architecture, sound library components, etc. And a modular approach asks for - nay, requires - <a href="ObjectOrientation.html">ObjectOrientation</a>, and <a href="MostGamesProgrammersDontGrokObjectOrientation.html">MostGamesProgrammersDontGrokObjectOrientation</a>. 
      </p>
      <p>
        This form of reuse is broad. Lesser forms of reuse should certainly be possible within the industry, but are too microcosmic to be seen by the <a href="ComputerGamesIndustry.html">ComputerGamesIndustry</a> in the large. 
      </p>
      <p>
        Once we have determined that profitability comes from <a href="ObjectOrientation.html">ObjectOrientation</a>, we look to object-oriented design practices. But we must never forget the need to optimize code ... again, an assumed (but highly arguable) prerequisite for success in the marketplace. Perhaps, as well as <a href="DesignPatterns.html">DesignPatterns</a>, we will look to <a href="OptimizationPattern.html">OptimizationPattern</a>s. The NeedForSpeed, and the need for stability and maintainability, are diametrically opposed. 
      </p>
      <p>
        <em>Are they? See </em><a href="RethinkingCompilerDesign.html">RethinkingCompilerDesign</a>.<em></em>
      </p>
      <p>
        Eventually, we must put it all together in a programming team. Such a team may well be run using <a href="ExtremeProgramming.html">ExtremeProgramming</a>, but the question, "<a href="WhoIsTheCustomer.html">WhoIsTheCustomer</a>?" poses a difficulty - programmers answer to not only the publisher (who finances the game) but also the artists and designers. The publisher may or may not provide user stories; the artists and designers most certainly will. 
      </p>
      <p>
        If we can answer this question, and unify the communications across teams by modelling the art and design departments as pseudo-customers, then <a href="ExtremeProgrammingForGames.html">ExtremeProgrammingForGames</a> promises to solve the ultimate problem, that of project management (I assume here that <a href="ExtremeProgramming.html">ExtremeProgramming</a> per se solves the majority of management problems, which is why it is so valuable. It tells us how to manage the project.) 
      </p>
      <p>
        My vision is for a unified approach to the problem, which exploits symmetries in the problem domain. The idea of a RoleOfToolSmith is an important one - programmers, artists and designers all need tools. A well-written tool could serve all these needs in a unified manner, rather than (as is typical) having a bunch of tools all different and all incompatible. I believe we can justify the cost in terms of increased productivity; but if one employs reuse in a broad way, one can spread the cost of tools over several architecturally similar projects. 
      </p>
      <p>
        -- <a href="EddieEdwards.html">EddieEdwards</a> 
      </p>
      <hr/>
      <p>
        Eddie: On toolsmiths - IMO all coders should be involved in enhancing and developing the tools they use. The RoleOfToolsmith is as a coordinator / lead developer of tools. <em>They need strong skills in prioritizing as well as raw coding skill.</em> -- <a href="JamesCrook.html">JamesCrook</a>
      </p>
      <p>
        <em>I would agree; toolsmiths are akin to specialists, and a fair XP dictates that there are no specialists (or at least they're minimized). Having a full-time specialist is bad. :) Tools to solve a problem should be written by the people who need the problem solved. You wouldn't hire someone to just code editor macros all day because different people need different macros, and the end user is the one that knows the requirements so can most easily do the development. On tools - such as plugins to 3dsMAX, get the people who are doing rendering in touch with the people that know the 3ds API and watch the sparks fly. -- </em><a href="TomPlunket.html">TomPlunket</a><em></em>
      </p>
      <hr/>
      <p>
        <strong>Missing in Xp...</strong>
      </p>
      <p>
        We cannot simply bolt XP onto an existing production strategy - well, maybe we could if there was an existing production strategy that manifestly worked, but in my experience (4 games companies) there is NO existing working production strategy. In the case a game gets released, it is released because all the programmers and many of the other staff work 100 hour weeks. XP promises a <a href="FortyHourWeek.html">FortyHourWeek</a>, and I like that (esp. as a soon-to-be-married man). 
      </p>
      <p>
        The problem is 99% communication. XP elegantly solves the communication problem between programmers. What about the communication problem between programmers and artists? Can we extend XP to contain "views", where in one "view" the artist is the customer, and in another, the publisher is the customer? This would allow XP to be applied, using the same principles of "stories", but stories would now come from the other departments which depend upon programming, as well as the customer. 
      </p>
      <p>
        Everyone depends on the programmers, but it's not a simple pipeline. Designers require custom design tools or format convertors from OTS design tools. Artists need much the same, plus a graphics engine which meets their artistic requirements ("we're not doing another DOOM game!") 
      </p>
      <p>
        Programmers form a unit. These guys write code. Artists form a unit. These guys make content (I'll include sound effects here) Level designers form a unit. These guys make levels.
      </p>
      <p>
        <em>Programmers talk to the customers. We're making one end product, but we have a variety of products that we need to build. For some (most) tasks, Design is our customer. For other tasks, Art is the customer. I let Art and Design figure out priorities between them. They can figure out how model exporters and animation playback systems need to be scheduled relative to AIs and design tools between themselves.</em>
      </p>
      <p>
        <em>In some ways, Game Development is really cool because we </em>always<em> have customers on-site. The game changes a bit when you're doing XP though due to Publishing coming up and dictating these and those changes. In this case, however, the Developers' position is strengthened because you're already used to on-the-spot cost analysis. If Publishing wants those changes, you can tell them how much they will cost, and tell them what expense will be thrown away in making the change. -- </em><a href="TomPlunket.html">TomPlunket</a><em>z</em>
      </p>
      <hr/>
      <p>
        <strong>What Games Designers really do</strong>
      </p>
      <p>
        A good designer is a game architect. They maintain the creative vision. They are the main fun engineer and lead creative person. One of the common causes of lame computer games are programmers who think they can design. (See comments about people who think they can manage and do not know they can't.) A lot of communication problems in game teams stem from not having a lead designer. In game people will not only lose track of what they are supposed to be making, they will not even agree on what they should be making. You get things cool in isolation that make no sense as a whole. More often you get things that are not cool alone or combined, except to the author. I could rant at (greater) length about this but won't unless someone wants to hear it. -- <a href="KenMegill.html">KenMegill</a>
      </p>
      <hr/>
      <p>
        <strong>Central Vision Is Important</strong>
      </p>
      <p>
        The problem of a central vision for a game design is related to a problem that <a href="ExtremeProgramming.html">ExtremeProgramming</a> tries to address for programming. A motley rag bag of routines in different styles is quite the opposite of what Xp aims for. In my book Xp allows a small team of programmers to work as if with one mind creating a 'central vision' for the software's implementation. More and cooler programming can be done than one programmer, however brilliant, can do on their own.
      </p>
      <p>
        IMHO the crucial part to Xp is <strong>multiple drafts</strong>. In Xp, Programmers have to be taught how to criticize each other's work <em>productively</em>, as a first step in redrafting. Good programmers, IMHO, naturally do this for their own work, but really have to learn to do this in a team context. The whole business of 'stories' (which I must own up to not having tried yet) is giving a formula which takes some of the emotional investment in being right out of the process. Once redrafting happens as a team effort, a 'central vision' can emerge. At least it can emerge for software implementation.
      </p>
      <p>
        Surely the Xp formula CAN be extended to other realms. And we don't have to be as simplistic as applying it separately in each of the three so-far identified units art, code, gameplay.
      </p>
      <p>
        So, to extend Xp to the other units, do we perhaps need greater clarification of what the various roles <em>really</em> do? Are we not in fact better factoring our definition of what the problem is? If so, what is RoleArtist? Do artists 'merely draw what they are told' just as we programmers 'merely implement the design' and designers 'merely make levels'? Surely <strong>each 'unit' sheds a spotlight on some aspect of the design</strong>, and 'A Central Vision' is important from each of these points of view. I don't expect an artist to fully grok what a coder means in saying their code is in <a href="ExtremeNormalForm.html">ExtremeNormalForm</a>, any more than I expect to fully understand Artistic Integrity, or Design Integrity. Even so, <em>productive</em> criticism across unit boundaries is possible. We all know enough to recognize when the code isn't buggy, the artwork looks great and the game really zings along. -- <a href="JamesCrook.html">JamesCrook</a>
      </p>
      <hr/>
      <p>
        <strong>Cultural issues in adopting </strong><a href="ExtremeProgramming.html">ExtremeProgramming</a> for GameDevelopment<strong></strong>
      </p>
      <ul>
        <li>
           Automated <a href="ProgrammerTest.html">ProgrammerTest</a>ing a game is something which NeverHappens (in practice). It would be difficult to come up with tests for e.g. graphics engines ... a few pixels difference may or may not be important, depending on whether they are noticeable and affect the game experience. However, other areas of the game (infrastructure, game logic, etc.) may be more easily testable, and if nothing else, would reduce the amount of RandomMonkeyTesting needed.
        </li>
        <li>
           Game developers tend to resist <a href="CollectiveCodeOwnership.html">CollectiveCodeOwnership</a>, possibly because of a lack of <a href="PairProgramming.html">PairProgramming</a>. It's common, when finding a bug in "another person's code", to either expect someone else to fix it, or else apply a band-aid to make it work "well enough", without really understanding what is going on. The band-aid fix adds cruft to the system, can give a false sense of resolution, and can prevent the original programmer from seeing that something needs to be fixed. This attitude isn't something that's limited to GameDevelopment, but it's certainly prevalent there.
        </li>
      </ul>
      <hr/>
      <p>
        <strong></strong><a href="ProgrammerTest.html">ProgrammerTest</a>s in GameDevelopment<strong></strong>
      </p>
      <p>
        Why can't you test a graphic engine, and who says they can be sloppy? For given input data you know exactly what you're going to get on the back end, so write the damn tests and don't cry about not really understanding the code you're writing. You can test your code because you know what it's supposed to do. A vertex at this position with this matrix is going to show up here on the screen. Use your calculator and figure it out. I don't see how this is any different from testing whether or not messages sent to an object get there. -- <a href="TomPlunket.html">TomPlunket</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryDiscussion.html">CategoryDiscussion</a>
      </p>
    </div>
  </body>
</html>