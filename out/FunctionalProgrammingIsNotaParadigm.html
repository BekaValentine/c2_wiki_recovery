<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Functional Programming Is Nota Paradigm
      </h1>
      <p>
        There are a lot of pages discussing how <a href="FunctionalProgramming.html">FunctionalProgramming</a> compares
        to different programming paradigms such as OO.  These pages have begun
        to piss me off a little.  Even though I am an advocate of
        <a href="FunctionalProgramming.html">FunctionalProgramming</a> and sympathise with most of the arguments
        presented for functional therein, there is this little problem:
      </p>
      <p>
        <strong>Nobody knows what functional programming is.</strong>
      </p>
      <p>
        This is not like the fuzziness of <a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a>, because
        that boils down to arguing whether inheritance is important or not.  But
        inheritance is a language feature, and only indirectly relates to how
        problems are structured.  Now proponents of <a href="FunctionalProgramming.html">FunctionalProgramming</a>, on
        the other hand, can show without effort how easy it is to program in
        OO, <a href="FlowBasedProgramming.html">FlowBasedProgramming</a>, <a href="LogicProgramming.html">LogicProgramming</a>, etc. ways in functional
        languages.  Thus, functional programming is here understood as a
        <strong>means</strong> of structuring programs in different ways, not a way to
        structure programs, that is, a paradigm.
      </p>
      <p>
        But even when <a href="FunctionalProgramming.html">FunctionalProgramming</a> is seen as a paradigm, there is
        little consensus about how it structures programs.  Some emphasise
        laziness and dataflow-style programming.  Some emphasise recursion and
        program proving.  Some emphasise absence of side-effects (often the same
        ones as the former group), or heavy use of higher order functions, or
        <a href="MonadicProgramming.html">MonadicProgramming</a>.  Some emphasise <a href="DeclarativeProgramming.html">DeclarativeProgramming</a>, whatever
        that means.
      </p>
      <p>
        In effect, I have come to the conclusion that whenever people talk about
        <a href="FunctionalProgramming.html">FunctionalProgramming</a> here, they usually talk about <em>methodology</em>, not
        <em>paradigms</em>.  When they talk about paradigms, they talk about
        different paradigms.
      </p>
      <p>
        -- <a href="PanuKalliokoski.html">PanuKalliokoski</a>
      </p>
      <hr/>
      <p>
        Before we ask whether foo is a paradigm, we should first ask what a "paradigm" is. I smell a long terminology debate ahead....  see <a href="LaynesLaw.html">LaynesLaw</a>.
      </p>
      <hr/>
      <p>
        The history of "functional programming" seems interesting. I believe it started off meaning a style of programming where one can conveniently pass around functions as a useful object. Just as you could say "integer programming" lets you pass around integers. Perhaps you could also inspect a function for its documentation string, or inquire as to what code composes it.
      </p>
      <p>
        In the same way, I'm told that recursion did not initially mean a function calling itself (of course, I also mean fn-a calling fn-b calling fn-a). It simply meant a function calling another function. And I prefer that old definition because when you use the newer definition for the reason of being "less trivial," people have a hard time understanding it. Self-recursion is just one interesting kind of recursion, not something to fetishize (as <a href="SiCp.html">SiCp</a> does with eval/apply).
      </p>
      <p>
        I like these old definitions. I think our desire for specialization makes our scopes narrower. -- <a href="TayssirJohnGabbour.html">TayssirJohnGabbour</a>
      </p>
      <hr/>
      <p>
        The notion of "functional programming" has changed quite a bit over time.  <a href="LispLanguage.html">LispLanguage</a> is oft acknowledged as the first <a href="FunctionalProgrammingLanguage.html">FunctionalProgrammingLanguage</a>, having first class functions and in many ways being little more than syntactic sugar for the <a href="LambdaCalculus.html">LambdaCalculus</a> (I'm speaking of early Lisp dialects, not <a href="CommonLisp.html">CommonLisp</a> or <a href="SchemeLanguage.html">SchemeLanguage</a> or anything else modern).  However, since then the "functional" community has diverged quite a bit from the "Lisp" community in numerous ways:
      </p>
      <ul>
        <li>
           Amount of, and attitude towards, SideEffects.  Early Lisp programs generally discouraged side effects and multiple assignment (though operations to mutate conses and variables have always been part of the language), in modern Lisp programming (<a href="SiCp.html">SiCp</a> nonwithstanding) use of mutable state is quite common.  Indeed, <a href="CommonLispObjectSystem.html">CommonLispObjectSystem</a> embraces a <em>very</em> stateful manner of programming.  The mainstream "functional" languages (Haskell, ML, and dialects thereof) OTOH still actively discourage explicit mutable state in programs (and make it difficult to write stateful programs); other notions such as monads and <a href="LinearTypes.html">LinearTypes</a> are used to emulate state in a "safe" manner.  (Here, safe means "doesn't violate <a href="ReferentialTransparency.html">ReferentialTransparency</a>").
        </li>
      </ul>
      <ul>
        <li>
           <a href="StaticTyping.html">StaticTyping</a> vs <a href="DynamicTyping.html">DynamicTyping</a>.  Lisp is dynamically typed, and <a href="CommonLisp.html">CommonLisp</a> has a very powerful dynamic type system (CLOS).  Haskell and ML are both statically typed languages with extremely powerful static type systems.  This is likely related to the first point--the static functional languages use <a href="ReferentialTransparency.html">ReferentialTransparency</a> to good advantage in being able to perform <a href="TypeInference.html">TypeInference</a>--<a href="TypeInference.html">TypeInference</a> is harder in the presense of mutable state.
        </li>
      </ul>
      <p>
        (Of course, then there are languages like <a href="OzLanguage.html">OzLanguage</a> and <a href="ErlangLanguage.html">ErlangLanguage</a>, which are dynamically typed but are also <a href="SingleAssignmentLanguage.html">SingleAssignmentLanguage</a>s; though Oz lets you use state if you want to).
      </p>
      <p>
        The one key commonality between these different camps within functional programming is--of course--first class functions.  And this remains a key differentiator between any of these, and mainstream OO languages like C#, C++, or Java--though all three are getting more and more "functional" as time progresses.  (See <a href="MainstreamInfluenceOfFunctionalLanguages.html">MainstreamInfluenceOfFunctionalLanguages</a>).
      </p>
      <p>
        <em>Actually, </em>early<em> Lisp programs did not avoid side-effects at all, at all. Go look up the MIT </em>AiMemos for some examples of really early Lisp code. The notion of referential transparency as a virtue came out of the <a href="LambdaTheUltimate.html">LambdaTheUltimate</a> papers, IIRC.<em></em>
      </p>
      <hr/>
      <p>
        I have always understood that the main purpose of FP is to write program functions that behave as functions in the lambda calculus do. That it, FP programs should be written as so that they define a relationship between the function's domain and its range, with the actual desired computation being treated as a secondary concern - hence the term <a href="DeclarativeProgramming.html">DeclarativeProgramming</a>. The remaining 'definitions' are really techniques for accomplishing this goal. Certain, this was the thrust of Backus' Turing Award speech, which is usually seen as the beginning of FP as a formal method (though of course many programmers using Lisp and related languages had been using what today are considered 'functional' techniques for years). Am I mistaken in this? - <a href="JayOsako.html">JayOsako</a>
      </p>
      <p>
        <em>Actually, I would not call them function in lambda calculus. Technically they are lambda expressions, and in principle a lambda expression is technically a distinct (albeit related) mathematical concept then a function.</em>
      </p>
      <p>
        <em>But anyways you are right that computation is a secondary concern and FP programs should be written to describe the relation between input and output. In particular the relation should be described by means of functional composition. Because we also have </em><a href="LogicProgramming.html">LogicProgramming</a> (or <a href="ConstraintProgramming.html">ConstraintProgramming</a> ) that has the almost same definition except that the relation between input and output is described by means of specifying constraints. This is already referenced on wiki, see <a href="NygaardClassification.html">NygaardClassification</a>. <em> --Costin</em>
      </p>
      <hr/>
      <p>
        Isn't the above, so far, merely a classic illustration of <a href="LaynesLaw.html">LaynesLaw</a>?  <em>Definitely!</em>
      </p>
      <p>
        If there is a point to be gleaned from this page, perhaps it is that <a href="ThereAreNoParadigms.html">ThereAreNoParadigms</a>.
      </p>
      <hr/>
      <p>
        <a href="NovemberZeroFive.html">NovemberZeroFive</a> (I knew from the first post, that this would become topical, I just had to wait)
      </p>
      <p>
        <a href="CategoryFunctionalProgramming.html">CategoryFunctionalProgramming</a> <a href="CategoryRant.html">CategoryRant</a>
      </p>
    </div>
  </body>
</html>