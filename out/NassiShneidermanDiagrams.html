<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Nassi Shneiderman Diagrams
      </h1>
      <p>
        <a href="NassiShneidermanDiagrams.html">NassiShneidermanDiagrams</a>
      </p>
      <p>
        <em>(from </em><a href="VisualProgrammingBook.html">VisualProgrammingBook</a>)<em></em>
      </p>
      <p>
        Nassi-Shneiderman (N-S) Diagrams are "structured flow charts" drawn as boxes-within-boxes.
      </p>
      <p>
        N-S diagrams restrict the programmer to using only valid <a href="StructuredProgramming.html">StructuredProgramming</a> constructs by representing the flow of control through procedural code with nested boxes and sequential (top-to-bottom) placement.
      </p>
      <hr/>
      <p>
        <strong>Sequence:</strong>
      </p>
      <code>
        +----------+<br/>
        | First    |<br/>
        +----------+<br/>
        | Second   |<br/>
        +----------+<br/>
        | Third    |<br/>
        +----------+<br/>
      </code>
      <p>
        <strong>Condition:</strong>
      </p>
      <code>
        +-------------------+<br/>
        |\ test condition  /|<br/>
        | \______   ______/ |<br/>
        |  True  \ / False  |<br/>
        +---------+---------+<br/>
        | Code to | Code to |<br/>
        | execute | execute |<br/>
        | when    | when    |<br/>
        | TRUE.   | FALSE.  |<br/>
        +---------+---------+<br/>
      </code>
      <dl>
        <dt> </dt>
        <dd><em>(It's hard to get the diagonal lines right in </em><a href="AsciiArt.html">AsciiArt</a>.  ;-)<em></em></dd>
      </dl>
      <p>
        <strong>Repetition:</strong>
      </p>
      <code>
        +-----------------------+<br/>
        | While loop condition  |<br/>
        |  +--------------------+<br/>
        |  | Body of code to    |<br/>
        |  | execute multiple   |<br/>
        |  | times.             |<br/>
        +--+--------------------+<br/>
      </code>
      <p>
        <strong>Example code snippit:</strong>
      </p>
      <code>
        +--------------------------------------------+<br/>
        | Open input file.                           |<br/>
        +--------------------------------------------+<br/>
        | While there are more lines to read...      |<br/>
        |  +-----------------------------------------+<br/>
        |  | Read next line into buffer.             |<br/>
        |  +-----------------------------------------+<br/>
        |  |\ If record type = 'X'                  /|<br/>
        |  | \_________________   _________________/ |<br/>
        |  |   True            \ /           False   |<br/>
        |  +--------------------+--------------------+<br/>
        |  | Add inventory to   | Flush buffers.     |<br/>
        |  | master record.     +--------------------+<br/>
        |  +--------------------+ Increment count of |<br/>
        |  | Increment count of | 'Y' records.       |<br/>
        |  | 'X' records.       |                    |<br/>
        +--------------------------------------------+<br/>
        | Close input file.                          |<br/>
        +--------------------------------------------+<br/>
      </code>
      <p>
        <em>In block structured code, this would be...</em>
      </p>
      <code>
        Open input file.<br/>
        While there are more lines to read...<br/>
        Read next line into buffer.<br/>
        If record type = 'X' Then<br/>
        Add inventory to master record.<br/>
        Increment count of 'X' records.<br/>
        else<br/>
        Flush buffers.<br/>
        Increment count of 'Y' records.<br/>
        end if<br/>
        Close input file.<br/>
      </code>
      <hr/>
      <p>
        Use of N-S diagrams on large projects is probably infeasible without automated tool support.
      </p>
      <p>
        Tools that can do round-trip "forward and reverse engineering" -- diagrams-to-code and code-to-diagrams -- would be feasible and desirable.
      </p>
      <hr/>
      <hr/>
      <p>
        Opinion:
      </p>
      <p>
        As an experiment, in the late 1980's, I made an N-S diagram of a relatively complex function.
        Placing the code and the diagram side-by-side, I found that I preferred the code, as more expressive and more readable than the N-S diagram.
        Aside from the high cost of creating and maintaining N-S diagrams without special-purpose tools, I found that the horizontal division of the page that occurs with "if" statements leaves an inadequate space to fit very many characters per line.
        This results in excessive line wrapping, or a severe need to abbreviate.
        Also, reasonable indention of source code blocks does a good job of revealing the code's structure anyway.
      </p>
      <p>
        So, I found N-S diagrams to provide practically no additional value, and to have a high cost.
      </p>
      <p>
        I suspect that N-S diagrams would be useful for teaching structured programming concepts to students learning a procedural language, like FORTRAN.
        <em>(...but then you'd have to teach them to </em>'stop<em>' using them, once they understand the concept.  ;-)</em>
        -- <a href="JeffGrigg.html">JeffGrigg</a>
      </p>
      <hr/>
      <p>
        It's been five years since I last used an NS diagram (which means they survived into the 90's, at least), and that was as an n-dimensional truth table to help ferret out problems with a requirements statement. Drawn horizontally, it took up the better part of a large whiteboard. It took no more than 15 minutes, including some redrawing, and the resulting, <em>"oh yeah, we didn't consider that case."</em> saved at least a person-week of development. The same result could have been reached through some other visualization. --<a href="DaveSmith.html">DaveSmith</a>
      </p>
      <p>
        I wrote an editor for these things once. You could fly into or out of the logic with details surfacing much like with modern mapping software. Subroutine calls would be expanded in place so the terrain could be quite rich. It didn't seem to help programming much though. I consider a good <a href="SystemOfNames.html">SystemOfNames</a> far more valuable. -- <a href="WardCunningham.html">WardCunningham</a>
      </p>
      <hr/>
      <p>
        <em>"Aside from the high cost of creating and maintaining N-S diagrams without special-purpose tools, I found that the horizontal division of the page that occurs with "if" statements leaves an inadequate space to fit very many characters per line."</em>
      </p>
      <p>
        This is easily fixed.  Each internal rectangle can be replaced by a reference ("see box 5") which then gets its own page.
      </p>
      <p>
        I once had a rather complex page of output to put together in code.  NS diagrams immediately broke it down into easy pieces.  I wouldn't use them everywhere, of course, but they can be a very useful tool. -- David Wolff
      </p>
      <hr/>
      <p>
        <a href="http://rdrop.com/~cary/html/psd.html">http://rdrop.com/~cary/html/psd.html</a>
        has some links to NassiShneiderman editors.
      </p>
      <hr/>
      <p>
        From a software engineering perspective, NS diagrams are not much helpful to solve real problems. Though these diagrams might be useful to document and maintain systems written in old languages like lisp/fortran where lanuages are not as clean as the newer languages. Now  languages like python may be more useful, since we can write code which nearly looks like a NS diagram and with a little more effort is also executable. ( The view projected here are from a programmers prespective).  -- Suman Karumuri 
      </p>
    </div>
  </body>
</html>