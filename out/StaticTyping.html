<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Static Typing
      </h1>
      <p>
        Static typing is very often misunderstood to mean that values are associated with types at <a href="CompileTime.html">CompileTime</a>, when instead it means that that a <a href="ReferenceValue.html">ReferenceValue</a> is manifestly (which is not the same as at <a href="CompileTime.html">CompileTime</a>) constrained with respect to the type of the value it can denote, and that the language implementation, whether it is a compiler or an interpreter, both enforces and uses these constraints as much as possible.
      </p>
      <p>
        An example of the use of static (manifest) type constraint by the is the ability to allocate exactly the right amount of memory to a variable, and another is the ability to disambiguate overloaded function calls in many cases.
      </p>
      <p>
        Some languages allow associating constraints other than type based ones on the values that may be denoted by a reference, but this is uncommon.
      </p>
      <p>
        <a href="TypeInference.html">TypeInference</a> makes many/most/all type declarations unnecessary if the <a href="TypeSystem.html">TypeSystem</a> of your <a href="ProgrammingLanguage.html">ProgrammingLanguage</a> is strong enough.
      </p>
      <p>
        However even when not necessary, type constraints can be very valuable in documenting assumptions and intentions.
      </p>
      <p>
        Static typing is often confused with <a href="StrongTyping.html">StrongTyping</a>. Also see <a href="DynamicTyping.html">DynamicTyping</a> and <a href="SoftTyping.html">SoftTyping</a>.
      </p>
      <hr/>
      <p>
        It's worth noting that modern hardware is somewhat statically typed. In particular, the set of operations that can be done on a value (defining that variable's type) depends on the variable that refers to it. i.e:
      </p>
      <ul>
        <li>
           I can do fadd $f0, $f1, $f2, which means that $fN is a floating point value.
        </li>
        <li>
           I can do addi $r1, $r2, 3, which means that $rN is an integral value.
        </li>
        <li>
           I can NOT do fadd $r1, $r2, $r3, or addi $f0, $f1, 3...   <em>(you CAN do this on the </em>OpenRISC architecture, however.)<em></em>
        </li>
      </ul>
      <p>
        Now, there are few hardware-defined types on most platforms. Integer and address are often the same hardware type; segments are sometimes their own type, when they exist; floats are usually their own; vectors are their own type (or multiple types on x86). --<a href="AdamBerger.html">AdamBerger</a>
      </p>
      <hr/>
      <p>
        Languages or compilers that use static typing:
      </p>
      <ul>
        <li>
          <a href="JavaLanguage.html">JavaLanguage</a>
        </li>
        <li>
          <a href="CeePlusPlus.html">CeePlusPlus</a>
        </li>
        <li>
          <a href="PascalLanguage.html">PascalLanguage</a>
        </li>
        <li>
          <a href="AdaLanguage.html">AdaLanguage</a>
        </li>
        <li>
          <a href="ObjectiveCaml.html">ObjectiveCaml</a>
        </li>
        <li>
          <a href="SmlLanguage.html">SmlLanguage</a>
        </li>
        <li>
          <a href="HaskellLanguage.html">HaskellLanguage</a>
        </li>
      </ul>
      <hr/>
      <p>
        See <a href="DefinitionsOfTypes.html">DefinitionsOfTypes</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryLanguageTyping.html">CategoryLanguageTyping</a>
      </p>
    </div>
  </body>
</html>