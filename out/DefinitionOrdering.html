<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Definition Ordering
      </h1>
      <p>
        Some programming languages require that types/classes/function/subroutines be defined in bottom-up order: that is, one must fully define element E before one can define any elements that use E. However, many languages allow definitions to occur in a source file in any order, provided that any necessary forward declarations are included.
      </p>
      <p>
        How do people order their definitions in source files, and why?
      </p>
      <p>
        The goals of any deliberate ordering routine would be:
      </p>
      <ul>
        <li>
           <strong>Readability</strong> -- The definitions are ordered in a way intended to ease comprehension by someone unfamiliar with the code.
        </li>
        <li>
           <strong>Scanability</strong> -- The definitions are ordered in a way intended to make it easy for a programmer to quickly find definitions of interest.
        </li>
        <li>
           <strong>Locality</strong> -- Putting related functions close to one another makes it easy for a programmer to navigate between them. Compiler/linker optimizations may be possible when functions are close to one another or ordered in a particular way.
        </li>
        <li>
           <strong>Tool support</strong> -- When using "wizards" or other tools that automatically insert code into editable source files, or that process such code, it may be necessary to conform to conventions dictated by the tool.
        </li>
      </ul>
      <p>
        With use of source code browsers, <a href="LiterateProgramming.html">LiterateProgramming</a>, and other tools, the physical order of definitions is often irrelevant to a reader. However, a logical ordering can help a reader to learn the relationships between definitions.
      </p>
      <p>
        Some organizational techniques are:
      </p>
      <ul>
        <li>
           <strong>Top-down</strong> -- Define highest-level functions at the top of the file, with lower-level functions defined later. This emphasizes an overview of the module's functionality, leaving the details for later.
        </li>
        <li>
           <strong>Bottom-up</strong> -- Define lowest-level functions at the top of the file, with higher-level functions defined later. This emphasizes the low-level details of the module, first showing the pieces and then later showing how they are assembled.
        </li>
        <li>
           <strong>Subsystem</strong> -- The source file is organized into groups of tightly related definitions. Each group often has a big block comment that acts as a visual boundary and describes the group.
        </li>
        <li>
           <strong>One per file</strong> -- Some people adopt a rule of having only one function or subroutine per source file. This practice is becoming less common, but is still used in some structured-programming environments and in library implementations. The benefits are that the name of the file usually matches the name of the defined element, making it easy to find, and it is easier for linkers to exclude unused object code from an executable.
        </li>
        <li>
           <strong>Haphazard</strong> -- Define new items wherever is convenient, usually in the blank space above or below the last element examined. This emphasizes locality.
        </li>
        <li>
           <strong>Alphabetical</strong> -- Not very helpful for learning the relationships between elements, but it does help you find an element when you know its name.
        </li>
        <li>
           <strong>Historical</strong> -- Each new element is added to the end of the file, leaving older elements at the top. Automated source code generation tools usually follow this practice. This gives a reader some idea of the history of the file's development, and tends to put the implementation of the most important functionality at the top of the file and new features and bug fixes at the bottom.
        </li>
        <li>
           <strong>Visibility or Protection Level</strong> -- Public elements first, followed by protected/package elements, then private elements. The reverse order (private-to-public) is also seen.
        </li>
      </ul>
      <hr/>
      <p>
        See also:
      </p>
      <ul>
        <li>
           <a href="CodeOrdering.html">CodeOrdering</a>
        </li>
      </ul>
      <hr/>
      <p>
        <a href="CategorySourceManagement.html">CategorySourceManagement</a> <a href="CategoryDefinition.html">CategoryDefinition</a>
      </p>
    </div>
  </body>
</html>