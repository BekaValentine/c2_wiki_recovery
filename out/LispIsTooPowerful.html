<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Lisp Is Too Powerful
      </h1>
      <p>
        I think one of the problems with Lisp is that it is <em>too</em> powerful. It has so much meta ability that it allows people to invent their own little worlds, and it takes a while to figure out each person's little world (<a href="SoftwareGivesUsGodLikePowers.html">SoftwareGivesUsGodLikePowers</a>).
      </p>
      <p>
        Languages are more than just languages, they are a form of <em>culture</em>, and by being culture they tend to enforce (indirecty or directly) a certain way of doing things, i.e. standards or conventions. This means that if you know the language and its culture, there are less surprises and a longer learning or adaptation curve. Lisp is almost an interpreter <em>builder</em> rather than just an interpreter/compiler. This means that one can make it be just about anything they want. Thus, its culture is almost a lack of culture. 
      </p>
      <p>
        Now if the benefits of this power outweighed the drawbacks, I think it would be worth it in a commercial setting. But I have yet to see a good demonstration that Lisp significantly simplifies things beyond what other languages can do (<a href="ChallengeSixVersusFpDiscussion.html">ChallengeSixVersusFpDiscussion</a>). It only slightly simplifies things. The cost of more surprises due to lack of "culture" is thus greater than the ability to make custom idioms that simplify things to a fairly minor extent over what "regular" languages can.
      </p>
      <p>
        This is why Lisp is a <a href="HackerLanguage.html">HackerLanguage</a> instead of a commercial language: hackers are generally loners who don't care if others can figure out their code (at least while they are in the mode or role of hacking). Thus, they build their own little world in it that fits themselves nicely so that they can hack fast, but the rest of the world be damned. 
      </p>
      <p>
        Further, to acheive and take advantage of this heavy meta-ability, Lisp does not fit the style of other languages. Thus, it takes longer for most to get "fast" in Lisp.
      </p>
      <p>
        Sometimes consistency trumps power.
      </p>
      <p>
        (I may have said this somewhere else already, and I apologize for duplicating if I did. Some of it sounds a bit familiar.)
      </p>
      <p>
        --top
      </p>
      <p>
        Above you talk about lisp interpreters but most of the lisps used in the "real world" are compiled. Also there is a lot of shared lisp culture, especially in macros small examples are naming macros that define "things" defthing, macros that lock and unlock, or open and close a resource all follow a similiar style, and lots of macros that are syntatically and semantically similar to defclass. If there is a lack of standardisation in lisp programs it is because there is lack of standardisation in what the programs do.
      </p>
      <p>
        TomA
      </p>
      <p>
        <em>I adjusted the "compiler" issue. As far as "standardization", it is not so much language conventions as it is the ability of the language to bend to be almost anything you want. Even with conventions it is more bendable than "regular" languages.</em>
      </p>
      <p>
        <em>Suppose I created a very </em><a href="ExBase.html">ExBase</a>-like sub-language using Lisp. It would closely resemble <a href="ExBase.html">ExBase</a>, but with more parenthesis. If other developers were forced to read and modify such, they'd say, "What kind of screwy commands are these? This is a weird language with weird conventions! What are you, some kind of table lover? Dude, the 80's are dead." Sure, one could probably do that in many languages, but in Lisp its easier. <em></em>
      </p>
      <p>
        I think the problem of lisp is less that <a href="LispIsTooPowerful.html">LispIsTooPowerful</a> but rather that the power of simplicity is taken a bit too far (<a href="GoldenHammer.html">GoldenHammer</a>-like). Lisp lacks a clear distinction between its powerful facilities. Maybe the left out syntax facilities could have provided this. ColaLanguage does this better. The way Lisp now is is that it is <a href="TooPowerfulForItsOwnGood.html">TooPowerfulForItsOwnGood</a>. 
      </p>
      <ul>
        <li>
           Are there any real life examples of Lisp developers creating DSL's that can't be deciphered by their colleagues? This argument sounds a lot like speculation to me. -- LarryColeman
        </li>
      </ul>
      <ul>
        <li>
           <em>"Can't" is relative in this biz. Given enough time it usually can; but does one want to take that time? And </em><a href="PaulGraham.html">PaulGraham</a>'s Y-store lisp project was allegedly rewritten into another language by Yahoo because existing programmers had difficulty figuring out the lisp code. -t<em></em>
        </li>
      </ul>
      <ul>
        <li>
           Actually, "can't" is correct in this case.  The way that closures were used in the original Yahoo! Store is just not supported in languages like C++ without essentially implementing a Lisp interpreter.  Here's what Paul Graham said about the rewrite:
        </li>
      </ul>
      <ul>
        <li>
           <em>I was only addressing the "can't decipher" issue, not the closure issue. There indeed may be multiple issues involved, but based on the ordering, human groking of the code was an important stated reason for the language change. I'm not sure if the closure issue had to do with co-integration of Lisp and C++, or was only a statement about emulation, but it probably doesn't matter to the key issue. -t</em>
        </li>
      </ul>
      <dl>
        <dt> </dt>
        <dd>(a) The reason they rewrote it was entirely that the current engineers didn't understand Lisp and were too afraid to learn it. </dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd>(b) The resulting program is a new world's record case of Greenspun's Tenth Rule.  The Yahoo Store Editor called compile at runtime on s-expressions made on the fly.  To translate this into C++ they literally had to write a Lisp interpreter.</dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd>(c) Even then, they had to drop some features (involving advanced uses of closures).</dd>
      </dl>
      <p>
        <em>Who's going to formally admit to being confused by it? They just avoid it the future rather than document headaches. They vote with their feet. You have a right to ask for such evidence, but it probably won't exist.</em>
      </p>
      <ul>
        <li>
           But that assumes there's at least one actual person who is confused. On the other hand, you can find people who formally admit to being confused by Lisp almost daily on comp.lang.lisp.  
        </li>
        <li>
          <em>And, you can find even </em>'more<strong> people who admit to being formally confused on comp.lang.c, by sheer virtue of C having more coders than Lisp.  This doesn't prove anything.</strong>
        </li>
        <li>
           That nothing is being proved is my point. We just have an assertion here of confused colleagues, and I haven't seen a verified example of a Lisp coder confused by code written by a colleague. There was one on comp.lang.lisp who claimed to be confused by inherited code, but that post could have been made up by the resident spammer.  
        </li>
        <li>
           [I developed in Scheme for quite a while, and found myself plenty confused by various macro packages. OTOH, it takes a while to get a feel for any API, be it library, DSL, or framework.]
        </li>
        <li>
           (It may be an issue of weighing <a href="MindOverhaulEconomics.html">MindOverhaulEconomics</a>.)
        </li>
        <li>
           There is now a lot of startups using Lisp to build commercial DSLs. I work at one and we can all figure out each other's code 
        </li>
        <li>
           <em>Being useful for start-ups may not scale to general organizations, remniscent of Paul Grahm's Yahoo Stores project. I do in general find Lisp harder to read than the equivalent in </em><a href="AlgolFamily.html">AlgolFamily</a> languages, and others have made similar observations (see <a href="ChallengeSixLispVersionDiscussion.html">ChallengeSixLispVersionDiscussion</a>). Lisp may limit an organization's hiring base to those who can read Lisp fast. But maybe the pattern will somehow be broken and <a href="IfFooIsSoGreatHowComeYouAreNotRich.html">IfFooIsSoGreatHowComeYouAreNotRich</a> will finally be "solved". The DSL pattern may merely be an industry-specific "habit" of a kind, meaning they each "do it" merely because competitors "do it" and they may want to poach some of their employees or avoid retraining time.<em></em>
        </li>
      </ul>
      <hr/>
      <p>
        <strong>Not a Language</strong>?
      </p>
      <p>
        Perhaps Lisp is not really a language, but a meta-language with libraries and conventions that almost make it look like a language. It's a <strong>nested-list machine language</strong>.
      </p>
      <p>
        [If it's a nested-list machine language, how is it not a language? I feel like I'm reading a direct contradiction...]
      </p>
      <p>
        Perhaps "not an application language" would be more appropriate. CPU machine language and <a href="BackusNaurForm.html">BackusNaurForm</a> are examples of languages that are not application languages. They are generally used as building blocks or assistance tools for application languages.
      </p>
      <p>
        Let me put it another way. In a "normal" language when one encounters a new application to maintain they typically are not starting from scratch, but rather at least know the app language. You were likely hired because of knowledge in a particular language (for good or bad). Thus, you can then focus primarily on specifics of the application at hand and don't have to worry much about learning the new application language it is written in (although different shops and programmers may use a different subset). This cuts down on what you have to learn.
      </p>
      <p>
        However, with a meta-language like Lisp, a language that allows you to "make up" a new language (or semi-language), you then have the possibility of BOTH chores for each new app encountered: learning the app AND the new "language" created via the meta system. 
      </p>
      <p>
        Given enough power, each programmer will eventually shape the language to fit their mind. Unless you think like them, you may have a strange new world to learn. As stated in another topic, the power of standards and conventions is as much in what they don't let you do as they are about what they do let you do. Standards and conventions are about walls and gates. These walls and gates hopefully create consistency in organization and familiarity for faster groking and communication. They are essentially a social tool. Lisp has fewer linguistical walls and gates.
      </p>
      <p>
        For a stretched analogy, if you stick with Legos or Tinkertoys, then anybody who is familiar with Legos or Tinkertoys can quickly dig into contraptions built with them and make necessary changes. They've learned various Lego and Tinkertoy idioms over the years and are quick and handy with them. 
      </p>
      <p>
        (Tinkertoy computer: <a href="http://www.retrothing.com/2006/12/the_tinkertoy_c.html">http://www.retrothing.com/2006/12/the_tinkertoy_c.html</a> )
      </p>
      <p>
        But along comes a new building kit called Lispo's which allows one to build different building atoms (blocks, sticks, connectors, etc.) with all kinds of odd shapes and connections. Every Lispo builder makes very different "atoms". Or at least enough of them go "wayward" to create a fair amount of bottleneck projects.
      </p>
      <p>
        Lispo-built contraptions are often compact and efficient, but they can be very difficult for new maintainers to grok, including other fellow Lispo-ers.  Further, Lispo tends to attract those who like to customize atoms such that the probability of encountering a contraption that is hard to grok is noticeably greater in the Lispo community. It attracts more "lone hackers" because it has this meta ability.
      </p>
      <p>
        In the end, you will <strong>admire</strong> Lispo and Lispo-ers and maybe even build a few of your own as a hobby, but want nothing to do with others' Lispo projects.
      </p>
      <p>
        --top
      </p>
      <p>
        With great power comes great responsiblity. This is why some must avoid it.  --Bottom 
      </p>
      <p>
        <em>I've had to stop coding in Lisp, because I'm not wise, intelligent, or compassionate enough to wield such a potent weapon.  No human could be.  Lisp is reserved for Gods.</em>
      </p>
      <ul>
        <li>
           Gods without team members and turn-over perhaps.
        </li>
      </ul>
      <ul>
        <li>
           <em>You work for places that hire brain-dead code monkeys.  Sad, that.  I always hired good programmers who liked learning new tools, exploring Lisp, and discovering new concepts.</em>
        </li>
      </ul>
      <p>
        <img src="http://imgs.xkcd.com/comics/lisp.jpg" />
      </p>
      <hr/>
      <p>
        The notion that LISP lets you create "semi-languages" that add another layer of unreadability, or that this is frequently done, is rather exaggerated.  Even when it is explicitly done, it raises no more barrier to understanding LISP code than, say, procedures, functions, methods, etc., in any other language.  Or, any more barrier to understanding than any <a href="DomainSpecificLanguage.html">DomainSpecificLanguage</a>, whose clarity (or lack thereof) is a factor of the language rather than LISP.  Arguably, <a href="ForthLanguage.html">ForthLanguage</a> is more inclined to host unreadable "semi-languages" than LISP, especially in the hands of an inexperienced Forther.  For most uses, LISP is employed as a fairly conventional language, with <a href="HigherOrderFunctions.html">HigherOrderFunctions</a> being perhaps the biggest conceptual hurdle for those raised on Algol-derived languages.  You get used to prefix notation extremely quickly, but only if you <em>use</em> the language.  Merely reading it is not enough. 
      </p>
      <p>
        Much of the objection to LISP comes, I suspect, from people who have only (tried to) read it or who have been forced to use it by work or school.  People are rarely positive about things they've been forced to use.
      </p>
      <p>
        <em>HOF are a tool to allow one to build arbitrary loop and conditional statements/operations, for example, creating less standardization and more Picasso-code. Perhaps it encourages Lisp fans to use HOF and other FP constructs just for the hell of it, such as the "cool factor", not because it's an objectively better way to do it. I've asked for some good practical examples of heavy FP helping in my domain, such as </em><a href="ChallengeSixVersusFpDiscussion.html">ChallengeSixVersusFpDiscussion</a>, but have not seen them, only what sound like excuses. FP may be "fun", but is it helpful? Lisp may encourage programmers to focus on gee-whiz instead of maintenance.<em></em>
      </p>
      <p>
        I don't recall seeing HOFs used to build arbitrary loop and conditional statements very often.  They're typically used where the alternative would be considerably more complex code -- like having to create a family of static functions or awkward conditional statements, or expose the internal workings of some existing mechanism -- where a single HOF would do.  
      </p>
      <p>
        Imagine a query language that supports summarisation (i.e., GROUP BY in SQL) with the usual aggregate operators like AVG, SUM, STD, VAR, etc.  Imagine you need a new one-off aggregate operator, such as a special weighted average whose composition varies with each row.  With HOFs (presuming the query language supports passing arbitrary aggregate operators to the summarization operator), it can be trivially added without any other syntax extensions.  
      </p>
      <p>
        HOFs enhance readability by reducing the need for complicated, confusing code.
      </p>
      <p>
        Can you find an example of the practical use of HOFs where the alternative would be simpler and more readable?
      </p>
      <p>
        <em>No. I never claimed so. They are generally both competitive with each other in terms of expressiveness. They each may do certain things a little bit better, and thus I'm not against mixing in some FP as needed. But, the key is "some". Algol-style languages do about 3/4 of everything just fine, and is the standing default. </em>'Sprinkle in<strong> a little FP and OOP where they have a </strong>clear<em>' advantage for that usage spot. (I'll leave TOP out of the discussion for now.) But FP fanboys say going full-bore FP will greatly improve things, which has not been demonstrated with realistic scenarios. I think they use C as a reference point, and C is a poor language from a human usage perspective. It lacks many features that improve imperative programming.</em>
      </p>
      <p>
        <em>Algol-style is the current default "base" for most of the app because 1) it's the easiest to learn for most people, 2) has most of the existing code-base, 3) Has not been proven clearly worse as the base default.</em>
      </p>
      <p>
        <em>I believe LISP's potential power is in it's ability to create </em><a href="DomainSpecificLanguage.html">DomainSpecificLanguage</a>s, not FP and HOF's. I'm skeptical that FP offers offers significant expressive improvement in my domain, custom biz apps, and past scenarios given on this wiki failed to produce significant expressive improvement. -t<em></em>
      </p>
      <p>
        Your belief about LISP's potential power notwithstanding, its actual power does derive from <a href="FunctionalProgramming.html">FunctionalProgramming</a> and HOFs.  Being able to create domain-specific languages is a bonus.  Whether or not LISP offers significant expressive improvement when developing "custom biz apps", whatever those are, is something for you to determine.
      </p>
      <p>
        {It is unclear to which alternative <a href="TopMind.html">TopMind</a> is comparing HOFs. Many other languages support something similar (<a href="FunctorObject.html">FunctorObject</a>s, script + data passing, function pointer + data passing, stack-scoped functions). The main advantages of HOFs above these other mechanisms are anonymity (ability to create a new instance locally without overhead of naming a function) and lexical scoping (reduces need to explicitly gather data), both of which reduce <a href="BoilerPlateCode.html">BoilerPlateCode</a>. Every Algol-style language 'reinvents' HOFs with at least one alternative, but rarely achieves the full convenience of HOFs.}
      </p>
      <hr/>
      <p>
        <strong>Contentious Discussion Below:</strong>
      </p>
      <p>
        <em>I invite somebody who has at least 5 years of custom biz experience, including maintenance, and is also a Lisp fan to provide a clear demonstration of its improvement.</em>
      </p>
      <p>
        I have 25 years "custom biz" experience, including maintenance, assuming "custom biz" means developing a variety of bespoke applications -- including employee scheduling, inventory, bookkeeping, and medical records systems, plus development tools from compilers to GUI toolkits to DBMSes -- for use by businesses.  I am a Lisp fan and a <a href="FunctionalProgramming.html">FunctionalProgramming</a> fan.  Internally, my <a href="RelProject.html">RelProject</a> has a largely functional core.  However, I have no desire to expend the energy required to provide you with a clear demonstration of its improvement.  What purpose would that serve?  I don't need to convince <em>you</em> of anything, and I've little doubt it would turn into a lengthy, pointless, and frustrating debate with you that would end in mutual insults.  I have much, much more productive and worthwhile things to do.
      </p>
      <p>
        Therefore, I invite <em>you</em> to learn Lisp, try it with an open mind, and thereby respond to your own challenge in a far more definitive and convincing manner than anyone could do for you.
      </p>
      <p>
        <em>If you want to evangelize Lisp into the mainstream, then don't just focus on me. Custom biz apps is one of the largest niches to push it into if you want to expand. "Trust me and try it for 5 years" is NOT a good way to convince others. Otherwise, if you don't want to spend the effort to document betterment, just say so and move on. Rel is more about "purity and protection" than expressiveness, so it's likely I wouldn't be very receptive of samples done in your style anyhow. Further, FP may be of more value in </em>SystemsProgramming than biz apps because the engineer has more control over the much of domain, and thus gear it around clean, logical interfaces, idioms, and conventions. In biz apps, one is often modeling politics and manager & marketer personalities, which are usually not very logical. You often must bust encapsulation because everything must be able to spill into everything else. -t<em></em>
      </p>
      <p>
        It doesn't matter to me whether Lisp becomes mainstream or not.  In particular, it doesn't matter to me whether <em>you</em> like Lisp or not.
      </p>
      <p>
        By the way, I didn't say "trust me and try it for five years."  I asked you to try Lisp for yourself, for however long or short a time you like.  Then you don't have to trust anyone except you.
      </p>
      <p>
        <em>My "try" list already has plenty of stuff in it.</em>
      </p>
      <p>
        You'd get through that list faster if you'd spend more time trying things on it and less time complaining here about languages and tools other people are using.
      </p>
      <p>
        <em>Where's the competitive testosterone-driven spirit of Lisp evangelists? If it's more expressive, then show it expressing. "Trust me, use/try it for 5 years" is for pussies.</em>
      </p>
      <p>
        If you're looking for "the competitive testosterone-driven spirit of Lisp evangelists", you'll probably find it on a Lisp advocacy forum.  I like Lisp, but I have no interest in Lisp evangelism or bothering to "show it expressing".  I'd rather use it to accomplish useful things for my own purposes.  By the way, what part of "I <strong>didn't</strong> say 'trust me and try it for five years'" wasn't clear to you?  If you're having comprehension difficulties, I recommend taking a remedial reading course.  Or are you just trolling?
      </p>
      <p>
        <em>When you "invite" somebody to try/use something in order to "get it" like you allegedly do, the </em>implication<em> is a kind of "trust me" in most cases. It's an implied </em><a href="ArgumentFromAuthority.html">ArgumentFromAuthority</a>.<em></em>
      </p>
      <p>
        <strong>'Its not an argument at all. But don't let that stop you. Oh well, actually, yes please let it stop you..</strong>'
      </p>
      <code>
        -- Why am I still here?<br/>
      </code>
      <p>
        That's your grumpy interpretation.  It's certainly not my intent, and it doesn't explain where you got "five years".  One's impression of Lisp, like so many computer things -- plus skiing, skydiving, fast cars, motorcycles, hiking, gourmet food and sex -- gains nothing from explanation and everything from experience.
      </p>
      <p>
        <em>Your examples are for entertainment, not solving external problems. (Some Lisp benefits may be </em><a href="WetWare.html">WetWare</a>-specific, but those are not the ones that are of interest here.)<em></em>
      </p>
      <p>
        You're in the wrong line of work if you don't find programming entertaining.  My examples are for illustration of the subjective nature of appreciation, which applies as much to Lisp (and many other things) as it does to (say) skydiving and sex.
      </p>
      <p>
        <em>If you merely want a mental challenge, then try </em><a href="BrainFsck.html">BrainFsck</a>.<em></em>
      </p>
      <ul>
        <li>
           You're obviously just trolling.
        </li>
        <li>
           {He's been trolling from the marked start of this section. And you totally fell for it...}
        </li>
        <li>
           Well, yeah.  So did you, below. :-)
        </li>
        <li>
           {That's a logical trap, intended to eventually point out <a href="TopMind.html">TopMind</a>'s <a href="DoubleStandards.html">DoubleStandards</a>, should he bother pursuing it.}
        </li>
        <li>
           It seems to have worked well.  I'm increasingly of the opinion that arguing with Top is like mud-wrestling with a pig: Even if you wind up on top (pun intended), you have to get desperately filthy and the pig enjoys it. (<a href="MudWrestlingWithPigs.html">MudWrestlingWithPigs</a>)
        </li>
      </ul>
      <p>
        {Huh? I've seen no objective evidence that <a href="BrainFsck.html">BrainFsck</a> is more challenging for business applications and systems software programming than is Lisp. I invite you to provide clear evidence that it is more challenging.}
      </p>
      <p>
        Sure.  Fine.  One pf.-by-example, coming right up...
      </p>
      <p>
        Lisp example:
      </p>
      <code>
        (def func (lambda (i foo)<br/>
        (* i foo)<br/>
        ))<br/>
        (display (func 12 10))<br/>
        (display (func 13 9 ))<br/>
      </code>
      <p>
        <a href="BrainFsck.html">BrainFsck</a> example:
        ++++++++++>++++++++++++<[>[>>+>+<<<-]>>>[-<<<+>>>]<]>>
        . will that work?  I haven't a clue
        [-]<[-]<[-]
        ++++++++++>++++++++++++<[>[>>+>+<<<-]>>>[-<<<+>>>]<]>>
        .
      </p>
      <p>
        Now, let's make a simple change:
      </p>
      <code>
        (def func (lambda (i foo)<br/>
        (+ i foo) ; the change is right here!<br/>
        ))<br/>
        (display (func 12 10))<br/>
        (display (func 13 9 ))<br/>
      </code>
      <p>
        characters changed (minus the comment): 1.
      </p>
      <p>
        ++++++++++>++++++++++++<[->>+<<]>[->+<]>
        . 
        [-]<[-]<[-]
        ++++++++++>++++++++++++<[->>+<<]>[->+<]>
        .
        Characters changed (minus the comment):  58.
      </p>
      <p>
        Conclusion:  by at least one one anecdote, <a href="BrainFsck.html">BrainFsck</a> is 58 times less maintainable than lisp.
        Secondary conclusion:  This is because <a href="BrainFsck.html">BrainFsck</a> has no modules, and therefore every useful procedure must be coded multiple times.
      </p>
      <p>
        Add more tests, people!
      </p>
      <p>
        <em>It's a start, but most will agree that BF is difficult to use because of more than just lack of functions. </em>'BF with functions<em>' would probably look something like:</em>
      </p>
      <code>
        ++(+<[(->>+)<<](>[->+<]>++(+)++<[->>+<<]>[-(>)+<)]>+<[-(>>+)<]>[-(>)...<br/>
      </code>
      <p>
        <em>Disclaimer: No attempt has been made to have this example make sense. It's only a rough visual illustration. -t</em>
      </p>
      <hr/>
      <p>
        See also: <a href="GreatLispWar.html">GreatLispWar</a>, <a href="TooPowerfulForItsOwnGood.html">TooPowerfulForItsOwnGood</a>, StandardToolDependency/<a href="StandardToolDependancy.html">StandardToolDependancy</a> (title changes due to an <a href="EditWar.html">EditWar</a> with GV)
      </p>
      <hr/>
      <p>
        <a href="CategoryLisp.html">CategoryLisp</a>
      </p>
      <hr/>
      <p>
        <a href="JuneTen.html">JuneTen</a>
      </p>
    </div>
  </body>
</html>