<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Super Commutativity
      </h1>
      <p>
        To make following the discussion of <a href="LiskovWingSubtyping.html">LiskovWingSubtyping</a> easier, <a href="AlistairCockburn.html">AlistairCockburn</a> proposes the following much simpler declaration and research program:
      </p>
      <dl>
        <dt> </dt>
        <dd>"What is wanted here is something like the following arithmetic property: For <strong>all</strong> binary operators '#', the result of applying # is <strong>unchanged</strong> when the order of the arguments is reversed, that is, a#b produces the same result as b#a. This property is called Super Commutativity."</dd>
      </dl>
      <p>
        The research goal is:
      </p>
      <dl>
        <dt> </dt>
        <dd><strong></strong><a href="SuperCommutativity.html">SuperCommutativity</a><strong> "A small number of research groups around the world are working on the concept of </strong><a href="SuperCommutativity.html">SuperCommutativity</a>. The outcome of the research project will be much simplified mathematics, considerably easier for children to learn, and less expensive for the school systems to teach."</dd>
      </dl>
      <hr/>
      <p>
        Unless I'm reading the proposed definition wrongly, this property is not generally compositional. I.e. given the language (*,+,==, if) - for which all the <em>binary</em> operators are commutative (if is ternary) - one can easily construct a binary function that is not commutative, such as
      </p>
      <code>
        pow(x,y)= if(y == 0) then 1 else x * pow(x,y+(-1))<br/>
      </code>
      <p>
        Being non-compositional would severely limit the alleged utility of this feature to nearly trivial. Achieving composable commutativity is feasible only at severe expense to expressiveness.
      </p>
      <hr/>
      <p>
        It may interest others to note that - is a derived property for precisely that reason. Or that it is defined in terms of the additive inverse for precisely that reason. Or that the property is called symmetry.... Or you may consider this despositive evidence that it is never possible to define a symmetric property on an asymmetric operation by reworking the definitions of your operations  in such fashion as to have the same expressive power. Words truly fail me. -- ANON
      </p>
      <hr/>
      <p>
        I think you have a misconception here. The property is useful often enough that we ought to teach it to all math students until the research program has reached its final goal. Already extensions have been found to widen it's applicability. 3^3 = 27; and also 3^3 = 27.
      </p>
      <hr/>
      <p>
        What a great goal. Never mind if the math isn't quite perfect, at least it's a useful heuristic on occasion and a wonderful social program!
      </p>
      <hr/>
      <p>
        <em>Alistair, this is not a "property". This is a definition of the </em><a href="SuperCommutativity.html">SuperCommutativity</a> relation between <em>a</em> and <em>b</em>. I am not very strong in the English terms for the math, but I suspect that the same relation is also called "equality". Are you really going to say that the presence of "equality" makes the math "not quite perfect"? -- <a href="NikitaBelenki.html">NikitaBelenki</a><em></em>
      </p>
      <p>
        You are right in the opening of of your paragraph (it does not define a relation, it is a search for a property that holds across all arithmetic operators). This page is written with more than just a little bit of tongue-in-cheek. There is, of course, no property or principle or whatever-you-might-like-to-call-it that will allow <strong>all</strong> arithmetic operators to be commutative (the relation is not called "equality", because there is no thing as what the opening declaration calls for). Subtraction, division, exponentiation, are not commutative, no matter how pleasant life would be if they were so, or how many examples are nominated. The point of the page is to construct an impossible research program that is syntactically close to that constructed in <a href="LiskovWingSubtyping.html">LiskovWingSubtyping</a>, in order that people can see that claiming to search for an impossible property does not make it meaningful to search for that property. -- <a href="AlistairCockburn.html">AlistairCockburn</a>
      </p>
      <p>
        <em>Well, I don't see quantifiers for </em>a<em> and </em>b<em>, so they must be free variables (remember, this should be an analogy to LSP, which does contain free variables </em>S<em> and </em>T<em>), and this </em>'is<strong> a definition of a predicate on a tuple <em>(a,b)</em>. Why do not call this predicate "the </strong><a href="SuperCommutativity.html">SuperCommutativity</a> relation"?<em></em>
      </p>
      <p>
        <em>But if </em>a<em> is </em>SuperCommutative with [i.e. equal to] <em>b</em>, then <em>a#b</em> will be the same as <em>b#a</em> for any arithmetic operator <em>#</em>, commutative or not. The same is also applicable to LSP, as long as we consider it to be a definition of LWS relation and a property of the objects [i.e. types] that conform to LSP, but not a property of all objects and relations that were called "types" and "subtyping", accordingly, at least once by at least one person.<em></em>
      </p>
      <p>
        <em>Actually, equality [of types] itself is a LWS relation, so there is no question whether the LWS is "true". The question is if there are more meaningful uses to LWS than to be yet another equality relation.</em>
      </p>
      <p>
        Good touch. Probably <a href="SuperCommutativity.html">SuperCommutativity</a> will prove to be an improper analog, since the phrasing would have to be much the way you phrased it. In LWS, a program 'p' operates on types 'S' and 'T', and LWS is a search for a relation < such that ( S<T ) implies p(S)=p(T) for all 'p'. To find a perfect analog, we need some sort of syntactically similar business. I can't think of a really good question that is syntactically similar. I only got as far as binary operations being similar to programs... -- Alistair
      </p>
      <p>
        No it is not. Readers are referred to the published papers to learn what LWS really means.
      </p>
      <code>
        Barbara Liskov and Jeanette Wing, "A Behavioral Notion of Subtyping", ACM Transactions on Programming Languages and Systems, Vol 16, No 6, November, 1994, pages 1811-1841.<br/>
      </code>
      <p>
        link pending ..
        -- ANON
      </p>
    </div>
  </body>
</html>