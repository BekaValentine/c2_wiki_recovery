<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Regular Expression
      </h1>
      <p>
        Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems. --<a href="JamieZawinski.html">JamieZawinski</a> 
      </p>
      <p>
        For a contrary opinion, and a pointer to a book well worth reading, <a href="http://gilesbowkett.blogspot.com/2011/10/i-had-problem-and-i-decided-to-use.html.">http://gilesbowkett.blogspot.com/2011/10/i-had-problem-and-i-decided-to-use.html.</a> -- <a href="RobertField.html">RobertField</a>
      </p>
      <hr/>
      <dl>
        <dt> </dt>
        <dd>Also known as regex or regexp (<a href="RegExp.html">RegExp</a>)</dd>
      </dl>
      <p>
        <a href="RegularExpressions.html">RegularExpressions</a> are a fundamental building block of <a href="ComputerScience.html">ComputerScience</a>. In their basic form, the language of <a href="RegularExpressions.html">RegularExpressions</a> is formally equivalent to <a href="FiniteAutomata.html">FiniteAutomata</a> (<a href="FiniteStateMachine.html">FiniteStateMachine</a>s), both of the deterministic and nondeterministic flavors. Regexes are also extremely commonly used in Unix, and are basically the heart of the Perl programming language. 
      </p>
      <p>
        They are also a wonderful way to write programs that are WrongButGoodEnough?. <a href="RegularExpressions.html">RegularExpressions</a> are most often incorrect - to do a correct search, you usually need to consider the structure of the file. -- <a href="LexSpoon.html">LexSpoon</a> 
      </p>
      <p>
        Note that the <em>programming language feature</em> known as regular expressions, and the thing from computation theory (the set of grammars which can be recognized by a DFA) are two different things.  <a href="RegularExpressionsArent.html">RegularExpressionsArent</a>.
      </p>
      <p>
        I find <a href="RegularExpressions.html">RegularExpressions</a> a wonderful way of coming up with programs that are Right, let alone <a href="GoodEnough.html">GoodEnough</a>. In practice, <a href="RegularExpressions.html">RegularExpressions</a> are usually capable of handling the structure of the file (in other words, for simple enough structures). Granted, there is often the temptation to use overly simplified regex - but this way lies madness. If it is a relatively sane parsing problem, <a href="RegularExpressions.html">RegularExpressions</a> are just the ticket. -- <a href="AnonymousDonor.html">AnonymousDonor</a> 
      </p>
      <p>
        <a href="RegularExpressions.html">RegularExpressions</a> are surprisingly good at analysing imprecise, free-form or natural-language material. They really suck for structured-text analysis, which I think is what <a href="LexSpoon.html">LexSpoon</a> is talking about. 
      </p>
      <p>
        I guess a good exercise is to try and make a <a href="RegularExpression.html">RegularExpression</a> that matches all SGML/XML tags within text. You have to make sure they are not within a quoted environment, and in searching the end of the tag, you have to take into account comments, quotes and quoted quotes. And that doesn't yet even check the tag is correctly written. The complete <a href="RegularExpression.html">RegularExpression</a> might get many lines long. -- <a href="PanuKalliokoski.html">PanuKalliokoski</a> 
      </p>
      <p>
        Actually, I believe complete XML parsing with <a href="RegularExpressions.html">RegularExpressions</a> isn't possible, due to limitations inherent to <a href="RegularExpressions.html">RegularExpressions</a>. It's been a couple of years since I read a book about 'compiler building' (the new DragonBook?, I believe it was), and I'd have to crack it open again to fill in the details. (And I believe there is some information on wiki about the three levels of grammars, but I can't find it. Anyhow, only the most restricted of those levels can be parsed with only regexps. And XML isn't in that level). 
      </p>
      <p>
        <strong><em>Matching all tags</em>' is not the same as </strong>parsing<em>'. XML parsing is indeed impossible with Regular Expressions, as is anything that allows arbitrarily deep nesting (the touchstone of a non-regular language), but that doesn't imply that it is impossible to at least pluck out all tags with a nice, long regular expression. I don't think it's impossible but a standard Finite Automata to do so would be as ugly as sin, because standard Finite Automata do not fare well with rules like "Anything but an A followed by a B"... nest two or three of those within each other and it passes the human ability to read or write with the multiplicity of states, but it is still, technically, an FA. A regular expression can be written because while a correct one must worry about CDATA and commenting, there are still a finite number of permutations of "modes" you can be in, because you can't be in a "CDATA nested in a comment nested in CDATA nested in CDATA".</em>
      </p>
      <hr/>
      <p>
        <strong>A few pages on this wiki:</strong> [<a href="EditHint.html">EditHint</a>, move to bottom?]
      </p>
      <p>
        See <a href="TextFormattingRegularExpressions.html">TextFormattingRegularExpressions</a> for the regular expressions this Wiki uses. 
      </p>
      <p>
        See <a href="RegularExpressionMatchAssertion.html">RegularExpressionMatchAssertion</a>, <a href="AlternativesToRegularExpressions.html">AlternativesToRegularExpressions</a>, <a href="StructuralRegularExpressions.html">StructuralRegularExpressions</a>, <a href="RegularExpressionExamples.html">RegularExpressionExamples</a>.
      </p>
      <hr/>
      <p>
        <strong>Other sources of information on </strong><a href="RegularExpressions.html">RegularExpressions</a>:<strong></strong>
      </p>
      <p>
        Jeffrey E.F. Friedl's book <a href="MasteringRegularExpressions.html">MasteringRegularExpressions</a> has more information than you probably want to know, including specifics of POSIX <a href="RegularExpressions.html">RegularExpressions</a>.
      </p>
      <p>
        For an online tutorial see: <a href="http://www.regular-expressions.info/about.html">http://www.regular-expressions.info/about.html</a>
      </p>
      <hr/>
      <p>
        Regular expressions are a broken form of <a href="PrologLanguage.html">PrologLanguage</a>. Without cuts!
      </p>
      <p>
        You can't write a serious program with regular expressions. Even toy programs end up having to reimplement cuts outside of regexp. That's because each additional subexpression explodes the space which has to be backtracked, and the run time ends up being very polynomial.
      </p>
      <p>
        Concrete example: I have a regular expression made up of 27 distinct subexpressions, and I want to match the whole sucker to a string that contains a <strong>single</strong> matching entry. Matching 17 of those 27 subexpressions takes 0.8 seconds. 19 takes 8 seconds. I ran out of patience so I don't even know how long it takes to match 21 out of 27.
      </p>
      <p>
        Oh, and here's the bad thing. Regular expressions are <em>also</em> polynomial in the <em>number of matching entries</em> they're working over. But if you limit it to 3 subexpressions, it's linear. Go figure.
      </p>
      <p>
        <em> The problem is Perl (or some other PCRE language).  Use awk (lol) and/or see </em><a href="http://swtch.com/~rsc/regexp/regexp1.html''">http://swtch.com/~rsc/regexp/regexp1.html''</a>
      </p>
      <p>
        Restructuring my program so it CAN make use of cuts, which of course I'll have to implement, will be a pain.
      </p>
      <hr/>
      <p>
        <a href="RegularExpression.html">RegularExpression</a>s were introduced by S.C. Kleene to describe the McCulloch and Pitts 1943 finite automata model of neurons. ("Representation of Events in Nerve Nets", p3-40 in <a href="ClaudeShannon.html">ClaudeShannon</a>/<a href="JohnMcCarthy.html">JohnMcCarthy</a> "Automata Studies", 1956)
      </p>
      <p>
        The first application of <a href="RegularExpression.html">RegularExpression</a>s to editor search/replace (in the QED editor) was by <a href="KenThompson.html">KenThompson</a>, who published a <a href="RegularExpression.html">RegularExpression</a>-to-NFA algorithm in 1968, "Regular Expression Search Algorithm", CACM 11:6, 419-422
      </p>
      <p>
        <a href="KenThompson.html">KenThompson</a> went on to reimplement this in the Unix <strong>ed</strong> editor, which <a href="BillJoy.html">BillJoy</a> turned into the <strong>vi</strong> editor. <a href="KenThompson.html">KenThompson</a> adapted the <strong>ed</strong> code for <strong>grep</strong> and <strong>sed</strong>. (Some years after its creation, Emacs eventually borrowed the idea of <a href="RegularExpression.html">RegularExpression</a>s, but not the code, directly from these Unix editors -- RMS, private communication)
      </p>
      <p>
        SteveJohnson (prior to, and building towards, his Unix <strong>yacc</strong> tool) and MikeLesk (in the Unix <strong>lex</strong>) did some of the earliest applications of <a href="RegularExpression.html">RegularExpression</a>s to compiler lexical analyzers via automated DFA-building tools.
      </p>
      <p>
        Awk is a scripting language/command line tool derived directly from this Unix Culture of <a href="RegularExpression.html">RegularExpression</a>s; it is no coincidence that the language most famous for <a href="RegularExpression.html">RegularExpression</a>s today, <strong>perl</strong>, was developed in a Unix environment, inspired by <strong>awk</strong> and other Unix <a href="RegularExpression.html">RegularExpression</a> tools.
      </p>
      <p>
        <a href="RegularExpression.html">RegularExpression</a>s were thus widespread in Unix tools of all sorts from the beginning, years to decades before this technology was widespread elsewhere (although obviously there were exceptions), and <a href="RegularExpression.html">RegularExpression</a>s have always been an extremely important (albeit under-acknowledged) part of <a href="UnixCulture.html">UnixCulture</a>, contributing to the historical attitudes of SmugUnixWeenies that other systems <a href="JustDontGetIt.html">JustDontGetIt</a>.
      </p>
      <p>
        Pipes have historically been considered to have been the <a href="KillerApp.html">KillerApp</a> of Unix, but there's a strong argument that it was actually <a href="RegularExpression.html">RegularExpression</a>s. Never heard that, but if its a "strong" argument, I'm convinced
      </p>
      <hr/>
      <p>
        <strong>Resources</strong>
      </p>
      <p>
        <em>Netscape </em><a href="JavaScript.html">JavaScript</a> <em> </em><a href="http://www.evolt.org/article/Regular_Expressions_in_JavaScript/17/36435/">http://www.evolt.org/article/Regular_Expressions_in_JavaScript/17/36435/</a> and 
        <a href="http://web.archive.org/web/20030810202454/devedge.netscape.com/library/manuals/2000/javascript/1.5/reference/regexp.html">http://web.archive.org/web/20030810202454/devedge.netscape.com/library/manuals/2000/javascript/1.5/reference/regexp.html</a>
      </p>
      <p>
        <em></em><a href="PerlLanguage.html">PerlLanguage</a> usage<em></em>
      </p>
      <p>
        Syntax 
      </p>
      <ul>
        <li>
           <a href="http://search.cpan.org/dist/perl/pod/perlre.pod">http://search.cpan.org/dist/perl/pod/perlre.pod</a>
        </li>
      </ul>
      <p>
        Tutorial
      </p>
      <ul>
        <li>
           <a href="http://search.cpan.org/~dapm/perl-5.10.1/pod/perlretut.pod">http://search.cpan.org/~dapm/perl-5.10.1/pod/perlretut.pod</a>
        </li>
      </ul>
      <p>
        Operators
      </p>
      <ul>
        <li>
           <a href="http://search.cpan.org/~dapm/perl-5.10.1/pod/perlop.pod">http://search.cpan.org/~dapm/perl-5.10.1/pod/perlop.pod</a>
        </li>
      </ul>
      <p>
        Reference
      </p>
      <ul>
        <li>
           <a href="http://search.cpan.org/~dapm/perl-5.10.1/pod/perlreref.pod">http://search.cpan.org/~dapm/perl-5.10.1/pod/perlreref.pod</a>
        </li>
      </ul>
      <p>
        <em></em><a href="VbScript.html">VbScript</a> usage<em></em>
      </p>
      <p>
        <a href="http://msdn.microsoft.com/library/default.asp?URL=/library/en-us/dnclinic/html/scripting051099.asp">http://msdn.microsoft.com/library/default.asp?URL=/library/en-us/dnclinic/html/scripting051099.asp</a>
      </p>
      <p>
        <em>RegExp Coach</em> <a href="http://farm.tucows.com/blog/_archives/2004/10/27/167823.html">http://farm.tucows.com/blog/_archives/2004/10/27/167823.html</a>
      </p>
      <p>
        <em>RegexCoach (same as above?)</em> <a href="http://www.weitz.de/regex-coach/">http://www.weitz.de/regex-coach/</a> - <em>Very good! And in Lisp, for all the </em><a href="SmugLispWeenies.html">SmugLispWeenies</a> out there.<em></em>
      </p>
      <p>
        <em>Steve Ramsay's Guide to Regular Expressions</em> <a href="http://etext.lib.virginia.edu/helpsheets/regex.html">http://etext.lib.virginia.edu/helpsheets/regex.html</a>
      </p>
      <p>
        <em>Redet</em> <a href="http://billposer.org/Software/redet.html">http://billposer.org/Software/redet.html</a> - a regular expression development and execution tool, supporting more than 40 search programs and programming languages.
      </p>
      <p>
        <a href="TclTk.html">TclTk</a> regexp visualizer  - can highlught what each part of the regexp matches - very useful when learning regexps
      </p>
      <ul>
        <li>
           <a href="http://www.doulos.com/knowhow/tcltk/examples/trev/">http://www.doulos.com/knowhow/tcltk/examples/trev/</a>
        </li>
      </ul>
      <hr/>
      <p>
        I've been known to refer to <a href="RegularExpressions.html">RegularExpressions</a> as "<em>a precise notation for fuzzy matches</em>" or "<em>a precise notation for expressing fuzzy search logic</em>" when explaining them to people familiar only with "string matching" as their search method.
      </p>
      <p>
        The concept of inclusion in/exclusion from sets, and a grammar for saying things like "any digit at the beginning of a line, followed by at least 1 but not more than 12 of any non-punctuation character, followed by any combination of alpha-numeric characters joined to a set of non-empty parentheses, said line ending in a semicolon, possibly followed by white space" in a compact and exact notation is not necessarily easily taught, but the look of revelation when one "gets it" is priceless.
      </p>
      <p>
        <em>As a pedagogical tool for helping people to "get it", that's interesting. I suppose it doesn't matter that it's technically inaccurate to call it fuzzy matching, since it depends on the pattern whether or not one specifies a literally fuzzy match in the technical </em><a href="ZadehLotfi.html">ZadehLotfi</a> <a href="FuzzyLogic.html">FuzzyLogic</a> sense, since these people  won't be familiar with <a href="FuzzyLogic.html">FuzzyLogic</a> now nor in the future?<em></em>
      </p>
      <p>
        Just so.  I originally hesitated before using "fuzzy" to describe it, but you're right, <a href="FuzzyLogic.html">FuzzyLogic</a> is well beyond the scope of where they'll go (though I usually throw in a disclaimer that I'm playing fast and loose with the term).  The main hurdle for them is usually the use of "any" and "not" in conjunction with "at least" and so on.  It's getting them to the point where they realize that they're not looking for precise spellings and not confined by having to examine every occurrence of some word just because they can't remember <em>exactly</em> what words are around it.  It's a little liberty I take -- somewhat in the name of <a href="WittgensteinsLadder.html">WittgensteinsLadder</a> -- to get over the concept hump.
      </p>
      <hr/>
      <p>
        I think I just broke a refactoring record. I was rewriting code from a <a href="BadProgrammer.html">BadProgrammer</a> and I chopped 127 lines into 7 using a <a href="RegularExpression.html">RegularExpression</a> in <a href="CsharpLanguage.html">CsharpLanguage</a>  :) The Regex parsed an XML file stream and split out 2 elements by name, with values optionally in quotes. The other programmer manually parsed the file, split it into arrays, split those into key/value pairs, foreach-ed through those till he found the ones he wanted, stored them into separates strings, then later recombined them into the final XML. OMG what a nightmare it was, but I will never go back to a non-<a href="RegularExpression.html">RegularExpression</a> language! (I'm a former VB6 junkie)
      </p>
      <ul>
        <li>
           <a href="RegularExpression.html">RegularExpression</a> was not supported well in MS environments (buggy and slow) before. Why did you not use the Xml parsers to do what you need to do?
        </li>
      </ul>
      <hr/>
      <p>
        MyBrowser, <a href="FireFox.html">FireFox</a> 2.0.0.11 -- allows Find in this page, but without <a href="RegularExpression.html">RegularExpression</a>s -- Maybe the <a href="OpenSource.html">OpenSource</a> contributors can add that.
      </p>
      <hr/>
      <p>
        See also: <a href="AlternativesToRegularExpressions.html">AlternativesToRegularExpressions</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryRegularExpressions.html">CategoryRegularExpressions</a> <a href="CategoryLanguageFeature.html">CategoryLanguageFeature</a>
      </p>
    </div>
  </body>
</html>