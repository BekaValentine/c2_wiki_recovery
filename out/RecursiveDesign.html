<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Recursive Design
      </h1>
      <p>
        Originally coined for the <a href="ShlaerMellorMethod.html">ShlaerMellorMethod</a>, <a href="RecursiveDesign.html">RecursiveDesign</a> is the
        approach to translative software construction where the translator
        is part of the source code of the project, and the translator is
        also developed using this translative approach.
      </p>
      <p>
        This contrasts with the approach of many OOD CASE tools which attempt to
        deliver <a href="OneSizeFitsAll.html">OneSizeFitsAll</a> code generators. This approach gives code generation
        a bad name, because the impression is given that code generation is only suitable for situations where performance is unimportant.
      </p>
      <p>
        The generic approach to code generation works well for translating a low
        level language (such as C) to machine code. It is usable for higher level
        languages, but there is an increasing disconnect between the source code
        and the target machine. The translation of the higher level descriptions
        require tradeoffs to be made in the translation. Once these tradeoffs
        go beyond basic speed/size tradeoffs then project specific translators
        become a sensible approach for optimisation.
      </p>
      <p>
        The <a href="ShlaerMellorMethod.html">ShlaerMellorMethod</a> provides a simple formalism that allows you
        to build models that are easy to write translators for. The simplicity
        of this formalism leaves it open to criticisms (some valid, IMHO) that
        it is too simple. Any comparison of Shlaer Mellor against traditional,
        full-featured, formalisms tend to show SM in an unfavourable light.
      </p>
      <p>
        But the SM approach truely allows you to draw diagrams that are
        the source code. SM originally came with its own notation, but is
        has been shown that you can use a subset of the UML is you prefer.
        As soon as you have a diagram, you can use a generic
        code generator to run simple tests (and to gain insight into the
        behaviour of the code/diagram). SM CASE tools will usually provide
        simulators: these either interpret the models or generate highly
        instrucmented code for the model. An orthogonal activity is to
        construct (and maintain) a code generator that produces code that
        meets the performance/interface requirements of the system.
      </p>
      <p>
        --<a href="DaveWhipp.html">DaveWhipp</a>
      </p>
      <hr/>
      <p>
        See <a href="AspectOrientedProgramming.html">AspectOrientedProgramming</a>, <a href="MetaRefactoring.html">MetaRefactoring</a>.
      </p>
    </div>
  </body>
</html>