<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Nygaard Classification
      </h1>
      <p>
        In the presence of much bickering for what is or is not <a href="ObjectOriented.html">ObjectOriented</a>, some people might use the wisdom of the computing pioneer <a href="KristenNygaard.html">KristenNygaard</a>, father together with <a href="OleJohanDahl.html">OleJohanDahl</a> of object orientation itself.
      </p>
      <p>
        He classifies the major paradigms of programming (in existence at that time) as follows:
      </p>
      <ul>
        <li>
           <strong></strong><a href="ProceduralProgramming.html">ProceduralProgramming</a><strong>. A program execution is regarded as a (partially ordered) sequence of procedure calls manipulating variables.</strong>
        </li>
      </ul>
      <ul>
        <li>
           <strong></strong><a href="FunctionalProgramming.html">FunctionalProgramming</a>.<strong> A program is regarded as a mathematical function, describing a relation between input and output.</strong>
        </li>
      </ul>
      <ul>
        <li>
           <strong></strong><a href="ConstraintProgramming.html">ConstraintProgramming</a>.<strong> A program is regarded as a set of equations describing relations between input and output.</strong>
        </li>
      </ul>
      <ul>
        <li>
           <strong></strong><a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a>.<strong> A program execution is regarded as a physical model, simulating the behavior of either a real or imaginary part of the world.</strong>
        </li>
      </ul>
      <p>
        Interestingly he goes on to say:
      </p>
      <dl>
        <dt> </dt>
        <dd><em>"The notion of a physical model should be taken literally. Most people can imagine the construction of physical models by means of, for example, Lego bricks. In the same way, a program execution may be viewed as a physical model. Other perspectives on programming are made precise by some underlying model defining equations, relations, predicates, etc. For object-oriented programming, however, we have to elaborate on the concept of physical models."</em></dd>
      </dl>
      <p>
        From Object-Oriented Programming in the Beta Programming Language (<a href="ftp://ftp.daimi.au.dk/pub/beta/betabook/betabook.pdf).">ftp://ftp.daimi.au.dk/pub/beta/betabook/betabook.pdf).</a>
      </p>
      <p>
        Some folks disagree that <a href="NygaardClassification.html">NygaardClassification</a> is the right way to define OO. See <a href="NygaardClassificationContested.html">NygaardClassificationContested</a>
      </p>
      <hr/>
      <p>
        <em>Many don't agree with the "physical" definition of OO. See </em><a href="OoBestFeaturePoll.html">OoBestFeaturePoll</a>.<em></em>
      </p>
      <p>
        Well, "many" is nowhere near comparable with <a href="KristenNygaard.html">KristenNygaard</a>, he invented the damn thing, so his definition of what he invented must have some weight. It's not argument by authority, but I guess definition by the authority of the inventor. It's similar to <a href="TopMind.html">TopMind</a> getting to define <a href="TableOrientedProgramming.html">TableOrientedProgramming</a>.
      </p>
      <hr/>
      <p>
        I think <a href="NygaardClassification.html">NygaardClassification</a> gives the proper definition of <a href="ObjectOriented.html">ObjectOriented</a> because it goes to the heart of the matter. Object Orientation is essentially about a how one goes to construct object oriented systems and what one should recognize in an object oriented system. 
      </p>
      <p>
        It also properly distinguishes "object oriented" from other paradigms, otherwise, given the power of many languages it's easy to write procedural code in Smalltalk, functional code in Python, or object oriented code in Scheme.  Some people claimed polymorphism and encapsulation as the distinguishing features of object orientation but that falls on its face since both are supported by all major functional languages. 
      </p>
      <p>
        However given the above definition, it is fairly easy to distinguish object oriented from functional  or logic programming.
      </p>
      <p>
        <em>... if you think that this is a useful thing to do.</em>
      </p>
      <p>
        If the design focuses on describing autonomous entities that react to messages by updating their state and/or sending other messages ( thus simulating a physical model ), then it is object oriented. If the design focuses on describing a system of constraints that will be solved by a inference engine, then it is logic programming. If the design focuses on creating functions through functional means (lambda abstraction, recursion, higher order functions, currying, etc) then it is functional programming. It is thus very hard to confuse one for the other.
      </p>
      <hr/>
      <hr/>
      <p>
        Somebody added <em>arguably</em> to "the father of object orientation itself". Nygaard and and Dahl are widely recognized as "fathers of object oriented programming" because of having invented the core notion of objects and classes in <a href="SimulaLanguage.html">SimulaLanguage</a>, and nobody of any authority in computing contested that.
      </p>
      <p>
        <em>Contested and refuted above.</em>
      </p>
      <hr/>
      <p>
        <em>What happened to the description of "object" as an entity exhibiting state and behavior? Does that figure into the model, the programming language, or somewhere else in the paradigm?</em>
      </p>
      <p>
        It's there in the book, chapter 2.2.2.  Of course physical models are composed of objects that have state and behavior (react to stimuli <=> respond to messages ). The book is definitely worth at least a cursory read.
      </p>
      <hr/>
      <ul>
        <li>
           <strong>Object-oriented programming.</strong> A program execution is regarded as a physical model, simulating the behavior of either a real or imaginary part of the world.
        </li>
      </ul>
      <p>
        Help me understand what this means.  Couldn't I regard the execution of my OO code as a physical model of that imaginary part of the world that is "a  (partially ordered) sequence of procedure calls manipulating variables"?  If we should "elaborate on the concept of physical models", but those physcial models represent imaginary things, can't they be any model we can imagine?  What makes them more "physical" than other models?
      </p>
      <p>
        <em>Intuitively, just think of modern GUIs, which are, with preponderence OO, even if some of them are programmed in C. All the widgets on the screen act like "objects", and the code is organized for them to act like object, the organization of the code mirror the organization of an imaginary physical model. </em>
      </p>
      <p>
        [I can't grasp what's more "physical" about that imaginary model than any other imaginary model.  Perhaps I'm not intuitive enough.]
      </p>
      <p>
        In the ideal case (rarely seen in implementation), objects exist in space and time and obey rules similar to that of physical objects rather than magically appearing/disappearing, whereas values are timeless and locationless (have no unique location, can be copied or destroyed invisibly). <a href="LinearLogic.html">LinearLogic</a> is a pure version of this view of objects.
      </p>
      <p>
        Pure functional programming is a pure version of non-object, value-based programming, and hence is amenable to traditional mathematical treatment.
      </p>
      <p>
        Most math concerns values which are treated as if they always exist in some Platonic realm even without being constructed (constructive mathematics is a rather small subset of all of mathematics), although it is not literally necessary to believe in a dualistic Platonic philosophy, only to use the word "exists" alone as if it referred to such a thing.
      </p>
      <p>
        Most OO language and practice strays from this extreme, and most functional/procedural programming strays from the other extreme.
      </p>
      <p>
        None of this is to say that OO programming <strong>cannot</strong> be analyzed mathematically, it's just that it tends to stray quickly into newer areas of math, such as <a href="TemporalLogic.html">TemporalLogic</a>/SpatioTemporalLogic.
      </p>
      <p>
        -- <a href="DougMerritt.html">DougMerritt</a>
      </p>
      <p>
        [What is ideal about objects obeying rules similar to that of physical objects?  We build imaginary software machines precisely because it's impossible or too expensive to build real machines that have to obey the laws of physics.]
      </p>
      <p>
        Because we have 650 million years of evolution worth of neural power that understands the behavior of physical objects intuitively. The same is not true of mathematical magical values, which is one major reason why only a tiny fraction of the population does well in math. --dm
      </p>
      <p>
        Also, according Abelson and Sussman in their lectures on <a href="StructureAndInterpretationOfComputerPrograms.html">StructureAndInterpretationOfComputerPrograms</a>, the idea behind the organization of code to simulate physical objects, is that objects in the real world have good modularity, so the good effect is to have better modularity in the code. That was the main idea behind Simula and how <a href="ObjectOrientation.html">ObjectOrientation</a> came about, whether you like it or agree with it or not. Other technical details like encapsulation, polymorphism are trivially available in good functional/procedural languages and also in logic programming.  --Costin
      </p>
      <p>
        Yep. Also, if you think about it, this (physical objects having good modularity) ends up being the same thing as my evolutionary point, ultimately: we understand and prize modularity because of the environment we evolved in.
      </p>
      <p>
        Your other point, that encapsulation/polymorphism/etc are available outside of OO languages, is very important and often neglected. The good practices that are valued in OO did not develop in a vacuum. In recent years it seems that, since everyone is talking about OO now, people have stopped talking about good practice in non-OO languages; for instance, discussions here reveal that even old-timers have forgotten some of the definition of structured programming (like single-entry/single-exit), and why that used to be considered very important. Other things that have been partly forgotten include coupling strength and degree of cohesion; I was thinking about putting up a page on the subject. Top might find it of interest. :-) But those issues still apply even in purely OO languages, I just don't hear people talking about them.
        --dm
      </p>
      <p>
        [I agree that we should play to our mental strengths (see <a href="OoFitsOurMentalAbilities.html">OoFitsOurMentalAbilities</a>), but I'm wary of placing too much value on physical reality while coding.  Programs are designs for imaginary machines.  It's beneficial to make those machines modular.  It isn't beneficial to make them heavy, slow, brittle, 2 or 3 dimensional, or many of the other properties we're familiar with from the world of molecules.  I often think of a program as if the methods and fields were connected by n-dimensional springs.  Use increases tension on the springs, pulling the methods and fields that use each other the most closer together, revealing practical component boundaries at different scales of abstraction.  That's all well and good, but I don't have to worry about the springs interfering with each other in 3 dimensional space like I would with a physical machine.  And I don't have to worry if the springs pull my imaginary machine into components that aren't identical to a physical machine or system it may be replacing or interacting with.]
      </p>
      <ul>
        <li>
           For what it is worth a  key point that has always formed the core of my personal operational definition of OO ( for which I make no  grand claim ) is that behavior and state are combined into a single representation. One model that has behavior and state in one abstraction. This does not mean that every object must have state, but if it does that state lives in the same abstraction. 
        </li>
      </ul>
      <p>
        --<a href="MarcGrundfest.html">MarcGrundfest</a>
      </p>
      <hr/>
      <p>
        <strong>Measuring World-ness?</strong>
      </p>
      <p>
        There is no way to measure "fitness to the real world". Thus, even if we did agree on such a definition, there is still a second hurdle. And, what about modeling things that have no real-world counterpart, such as intellectual property and electronic money transfers? 
      </p>
      <p>
        If we think of the real world in terms of "things", then perhaps something that groups code by nouns may be an indicator. (But "things" is mostly a perceptual issue, not something the universe "knows" about outside of an intelligent observer.)  OO tends to group by "nouns" more than procedural, which tends to group by verbs, but RDBMS group by nouns because tables (entities) tend to correspond to domain nouns. Thus, <a href="NygaardClassification.html">NygaardClassification</a> would suggest that RDBMS are "object oriented". But most would reject this. 
      </p>
      <hr/>
      <p>
        Looking at the classification one clearly sees that <a href="ProceduralProgramming.html">ProceduralProgramming</a>, <a href="FunctionalProgramming.html">FunctionalProgramming</a> and <a href="ConstraintProgramming.html">ConstraintProgramming</a> are different paradigms, they are mutually exclusive.  <a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a> however is compatible with each of the three major paradigms, a program can be procedural and object-oriented at the same time, or it can be functional and object-oriented.
      </p>
      <p>
        Obviously OOP is <em>not</em> a new programming paradigm, contrary to common belief.  It's just a set of conventions layer over procedural or functional programming.  One really has to wonder why it is so oversold.
      </p>
      <hr/>
      <p>
        The big problem here is that <a href="NobodyAgreesOnWhatOoIs.html">NobodyAgreesOnWhatOoIs</a>.
      </p>
      <hr/>
      <p>
        <a href="CategoryObjectOrientation.html">CategoryObjectOrientation</a>
      </p>
    </div>
  </body>
</html>