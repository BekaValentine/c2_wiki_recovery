<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Anote On Distributed Computing
      </h1>
      <p>
        <a href="http://www.sun.com/research/techrep/1994/abstract-29.html">http://www.sun.com/research/techrep/1994/abstract-29.html</a>
      </p>
      <p>
        <em>from the abstract ...</em>
      </p>
      <p>
        A Note on Distributed Computing  Jim Waldo, Geoff Wyant, Ann Wollrath, and Sam Kendall  TR-94-29 (November 1994) 
      </p>
      <p>
        We argue that objects that interact in a distributed system need to be dealt with in ways that are intrinsically different  from objects that interact in a single address space. These differences are required because distributed systems  require that the programmer be aware of latency, have a different model of memory access, and take into account  issues of concurrency and partial failure. 
      </p>
      <p>
        We look at a number of distributed systems that have attempted to paper over the distinction between local and  remote objects, and show that such systems fail to support basic requirements of robustness and reliability. These failures have been masked in the past by the small size of the distributed systems that have been built. In the enterprise-wide distributed systems foreseen in the near future, however, such a masking will be impossible. 
      </p>
      <p>
        We conclude by discussing what is required of both systems-level and application-level programmers and designers if one is to take distribution seriously. 
      </p>
      <hr/>
      <p>
        For several years, ever since I have been coding distributed applications, one of the things I have never been able to grasp is why would we try to imitate in process object model for distributed enterprise applications. For as long as I can remember I have modeled distributed applications as queueing systems. This entails use of a one or more queue managers between clients and servers, clients put out COMMANDS on one or more queues and subscribe to ACKNOWLEDGE. Servers have already subscribed to the COMMANDS, they perform their respective tasks and place ACKNOWLEDGE on designated queues. With proper architecture (pub/sub combos) this system cannot go down as long as there is at least one queue manager available to take COMMANDS. Granted if all servers / workers are down, your system won't be functional in real time but at least it won't fail.
      </p>
      <p>
        fbabar@hotmail.com
      </p>
      <hr/>
      <p>
        See also: <a href="UnderstandingDistributedSystems.html">UnderstandingDistributedSystems</a>
      </p>
    </div>
  </body>
</html>