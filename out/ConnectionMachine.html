<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Connection Machine
      </h1>
      <p>
        <img src="http://images.amazon.com/images/P/0262580977.01.MZZZZZZZ.jpg" />
      </p>
      <p>
        [ISBN 0262580977]
      </p>
      <p>
        A <a href="MassivelyParallel.html">MassivelyParallel</a> machine originally designed by <a href="DanielHillis.html">DanielHillis</a> in a Ph.D. thesis, then built by the company he founded, <a href="ThinkingMachinesCorporation.html">ThinkingMachinesCorporation</a>. The CM-1 and CM-2 were SIMD machines, consisting of up to 65536 bit-serial processors each with 1024 bits of memory and an 8 instruction machine language. The memory could be viewed from a host as a linear store and thus accessed, but then it could act as an active memory for <a href="MassivelyParallelProcessing.html">MassivelyParallelProcessing</a>.
      </p>
      <p>
        Messages were sent from processor to processor using wormhole routing with conflicts resolved by using an operator that was associative and commutative.
      </p>
      <p>
        Quoting <a href="RichardFeynmanAndTheConnectionMachine.html">RichardFeynmanAndTheConnectionMachine</a>:
      </p>
      <dl>
        <dt> </dt>
        <dd> <em>The router of the Connection Machine was the part of the hardware that allowed the processors to communicate. It was a complicated device; by comparison, the processors themselves were simple. Connecting a separate communication wire between each pair of processors was impractical since a million processors would require $10^{12]$ wires. Instead, we planned to connect the processors in a 20-dimensional hypercube so that each processor would only need to talk to 20 others directly. Because many processors had to communicate simultaneously, many messages would contend for the same wires. The router's job was to find a free path through this 20-dimensional traffic jam or, if it couldn't, to hold onto the message in a buffer until a path became free.</em></dd>
      </dl>
      <hr/>
      <p>
        The Connection Machine was one of the [most|few] beautiful computers ever made. A giant black-on-black cube, subdivided into 8 smaller cubes, with one side covered in red LEDs for each processor that lit to show processor activity (or just to create moving patterns in demos :).
      </p>
      <p>
        <img src="http://www.paulos.net/images/cm2_small2.jpg" />
        <a href="http://www.paulos.net/other/cm2.html">http://www.paulos.net/other/cm2.html</a>
      </p>
      <p>
        As a system test, Conways <a href="GameOfLife.html">GameOfLife</a> was the first program ever run on it.
      </p>
      <hr/>
      <p>
        May I ask why it is not now our <strong>overlord</strong>?
      </p>
      <p>
        Are humans capable of programming it to capacity? and of comprehending the best algorithms for its architecture? --<a href="PhlIp.html">PhlIp</a>
      </p>
      <p>
        <em>Earliest versions were SIMD computers, which are incredible for doing some kinds of vector operations. But, it slows down when data must be moved from processor to processor, so is less effective on many things. Multi-core and vector processors can do the same things effectively, and many others more effectively, so they have become the mainstay of parallel processing, along with networks. However, SIMD may have a niche.</em>
      </p>
      <hr/>
      <p>
        See also StarLisp.
      </p>
      <hr/>
      <p>
        <a href="CategoryBook.html">CategoryBook</a>, <a href="CategoryMachineOrientation.html">CategoryMachineOrientation</a>
      </p>
    </div>
  </body>
</html>