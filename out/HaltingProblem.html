<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Halting Problem
      </h1>
      <p>
        One of the most interesting theoretical parts of <a href="ComputerScience.html">ComputerScience</a> is the study of what can (and cannot) be computed. For instance, take the question, "does this program complete?" I.e., will it not go into an infinite loop. How would you answer this question, given an arbitrary piece of code? You could try running it. But what if it takes a long time? How long are you willing to wait?
      </p>
      <ul>
        <li>
           <a href="http://www.cprogramming.com/tutorial/computersciencetheory/halting.html">http://www.cprogramming.com/tutorial/computersciencetheory/halting.html</a>
        </li>
      </ul>
      <p>
        The <a href="HaltingProblem.html">HaltingProblem</a> asks the question: "Given a program and its input, determine whether the program will complete or run forever."
      </p>
      <p>
        <a href="AlanTuring.html">AlanTuring</a> proved in 1936 that there cannot exist a general algorithm for answering this question for <em>any</em> arbitrary program and input. Turing introduced the <a href="TuringMachine.html">TuringMachine</a> in this proof. The first link below relates this result to <a href="GoedelsIncompletenessTheorem.html">GoedelsIncompletenessTheorem</a> for mathematical formal systems.
      </p>
      <p>
        Links:
      </p>
      <ul>
        <li>
           <a href="http://en.wikipedia.org/wiki/Halting_problem">http://en.wikipedia.org/wiki/Halting_problem</a>
        </li>
      </ul>
      <p>
        <em>The halting problem is no longer an interesting question. No one actually using computers asks whether a program is going to halt, because nowadays they have the Ctrl-C and other measures to stop the machine if there seems to be a problem. Otherwise, I challenge you to come up with anything other than a </em><a href="ToyProblem.html">ToyProblem</a> where there is a real issue. Please, don't delete my comment again, until you can cite a real issue in the field. See also the <a href="BusyBeaverProgram.html">BusyBeaverProgram</a>.<em></em>
      </p>
      <p>
        The halting problem isn't a question, even though it's phrased that way above. It actually leads to an important proof that certain types of algorithm cannot be implemented. These are not just <a href="ToyProblem.html">ToyProblem</a>s, but real issues. For example, when your boss asks you to write a program to determine if anyone in the development team has written code that will get caught in an endless loop, the proof allows you to provide a reason why it can't be done. As for pressing Ctrl-C, sure, you can do that if you're at a console and have made a decision that a long-running program should be stopped. However, what if it's a background process? How does a monitoring program know whether the process is simply busy and will finish eventually, or actually caught in a loop? Based on the source code and input data, it can't know. In short, the <a href="HaltingProblem.html">HaltingProblem</a> tells us that a certain category of what otherwise might be very useful, pragmatic monitoring programs or compile-time code checkers -- those that look at source code and input and determine whether they'll eventually produce output or not -- can't exist.
      </p>
      <p>
        <em>The proof does not tell you that the existence of an endless loop cannot be determined; rather, it tells you that there is no </em>single<em> Turing machine which can determine the existence of the endless loop </em>for any arbitrary program.<em> In fact, for any arbitrary program, there </em>is<em> a Turing machine which can determine whether it halts; such a machine need only be large enough to contain a directed graph of all possible states (a finite set, assuming your computer is a Turing machine, which I imagine it is, and your input is finite (or at least, it gets its input from one or more Turing machines)) of the system and check that graph for cycles. Granted, such a machine would be impossibly large for all but the simplest of programs, but the point is that for any </em>one<em> program, the halting question is answerable given sufficient resources. At any rate, the semantics of whatever programming language you use typically allow you to take a </em>few<em> shortcuts.</em>
      </p>
      <p>
        [No, its not always possible to construct a specific machine for another specific machine to determine if its halts. If it was possible, your proof program could be constructed automatically just by brute force. Such a brute force prover could verify your program as you write it. What if I write a program to compute pi and search for a certain string of digits somewhere within. Can I write a program to tell me if the first will halt? What if I have a program that accepts a stream of 'a' and halts when it receives a 'b' (failing on any other input). What if my pi search program generates an 'a' every time it computes a new digit and outputs a 'b' when it finds the sub string. It's output is fed into my a-or-b program. Can I write a program that tells me if my a-or-b program halts?]
      </p>
      <ul>
        <li>
           Thank you, and furthermore, to the original commentor, your example is ridiculous, no boss ever asks "write a program to determine if code will get caught in an endless loop", they ask instead "write code without any bugs". See, we programmers, monkeys that we are, actually learned to write code so we can see progress. This is how programming culture <em>evolved</em>: to refine the ability to prevent the need to abort drastically or dump core.
        </li>
      </ul>
      <ul>
        <li>
           <em>It's entirely realistic for a boss to ask for a program that will predict how long another program will take to finish, for example, and it's the same problem. There are undoubtably an infinite number of equivalent, and realistic, problems that are essentially variations on the </em><a href="HaltingProblem.html">HaltingProblem</a>.<em></em>
        </li>
      </ul>
      <hr/>
      <p>
        Many problems can be shown to equivalent to the halting problem
      </p>
      <p>
        <a href="http://www.cs.bris.ac.uk/history/teaching/algorithms/chapter5.html">http://www.cs.bris.ac.uk/history/teaching/algorithms/chapter5.html</a>
      </p>
      <p>
        I like the Security Problem "Given a security scheme for an operating system, test
        whether it can be broken, just by using normal commands"
      </p>
      <p>
        -- <a href="NickKeighley.html">NickKeighley</a>
      </p>
      <hr/>
      <p>
        Sorry your comment was deleted. <a href="GrammarVandal.html">GrammarVandal</a> spoofed your <a href="UserName.html">UserName</a> cookie and thereby merged his edits with yours, so the <a href="SharkBot.html">SharkBot</a> reverted the lot.
      </p>
      <hr/>
      <p>
        Related:
      </p>
      <ul>
        <li>
           <a href="GeneralHaltingProblem.html">GeneralHaltingProblem</a>
        </li>
        <li>
           <a href="GeneralHaltingProblemProblem.html">GeneralHaltingProblemProblem</a>
        </li>
        <li>
           <a href="GeneralHaltingProblemProblemProblem.html">GeneralHaltingProblemProblemProblem</a>
        </li>
        <li>
           <a href="HaltingEquivalent.html">HaltingEquivalent</a>
        </li>
        <li>
           <a href="HaltingTheorem.html">HaltingTheorem</a>
        </li>
        <li>
           <a href="PatternHaltingProblem.html">PatternHaltingProblem</a>
        </li>
        <li>
           <a href="WhatDoesHaltingMean.html">WhatDoesHaltingMean</a>
        </li>
        <li>
           <a href="PatternHaltingProblem.html">PatternHaltingProblem</a>
        </li>
        <li>
           <a href="PenroseCannotConsistentlyAssert.html">PenroseCannotConsistentlyAssert</a>
        </li>
        <li>
           <a href="UnsolvableSoftwareDevelopmentProblems.html">UnsolvableSoftwareDevelopmentProblems</a>
        </li>
      </ul>
      <hr/>
      <p>
        <a href="FixYourWiki.html">FixYourWiki</a>: <a href="HaltingProblemDiscussions.html">HaltingProblemDiscussions</a>
      </p>
    </div>
  </body>
</html>