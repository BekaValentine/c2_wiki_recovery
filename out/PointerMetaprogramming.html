<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Pointer Metaprogramming
      </h1>
      <p>
        OK, I admit it... I'm posting this page mainly to be play the <a href="DevilsAdvocate.html">DevilsAdvocate</a>. (The fact that this disclaimer is necessary just goes to show how well-received this topic is likely to be.) But given that <a href="DevilsAdvocate.html">DevilsAdvocate</a> is a fun and productive game to play (and I firmly believe that the world would be a better place if more people looked at the other side of issues rather than merely basking in their own self-assuredness), here is my (latest) attempt to shove a stick into the pot and stir the proverbial hornet's nest.
      </p>
      <hr/>
      <p>
        <a href="PointerMetaprogramming.html">PointerMetaprogramming</a> is the practice, commonly found in languages such as <a href="CeeLanguage.html">CeeLanguage</a> and <a href="CeePlusPlus.html">CeePlusPlus</a>, of using techniques such as <a href="PointerArithmetic.html">PointerArithmetic</a>, forced typecasts, and other forms of (hopefully) <a href="ImplementationDefined.html">ImplementationDefined</a> behavior in order to engage in <a href="MetaProgramming.html">MetaProgramming</a>. Not all forms of <a href="PointerMetaprogramming.html">PointerMetaprogramming</a> necessarily require use of pointer operations; but most do involve pointers at some level.
      </p>
      <p>
        <a href="PointerMetaprogramming.html">PointerMetaprogramming</a> is a very powerful metaprogramming technique, as it allows the programmer to manipulate program data in unlimited ways; ways typically disallowed by the facilities present in most high-level languages. Many types of systems programs (including the runtime systems for most high-level languages) require use of <a href="PointerMetaprogramming.html">PointerMetaprogramming</a>; which is why one seldom encounters (for example) a <a href="JavaVirtualMachine.html">JavaVirtualMachine</a> which is written in Java.
      </p>
      <p>
        <a href="PointerMetaprogramming.html">PointerMetaprogramming</a> is also a controversial technique (like many other techniques for <a href="MetaProgramming.html">MetaProgramming</a>), it is often alleged that many programmers lack the skill/training to do it correctly. <a href="PointerMetaprogramming.html">PointerMetaprogramming</a> is often subjected to the following criticisms:
      </p>
      <ul>
        <li>
           While a properly-written program using <a href="PointerMetaprogramming.html">PointerMetaprogramming</a> invokes (at worst) <a href="ImplementationDefined.html">ImplementationDefined</a> behavior; many <em>improper</em> programs invoke <a href="UndefinedBehavior.html">UndefinedBehavior</a>; in most such instances, the language and its toolchain cannot determine the difference. (As a concrete example - use of <a href="PointerArithmetic.html">PointerArithmetic</a> to navigate a data structure in C. If you do it wrong, it's undefined - and the implementation cannot determine when it is valid and when it isn't).
        </li>
        <li>
           The reliance on <a href="ImplementationDefined.html">ImplementationDefined</a> behavior makes many such programs unportable.
          <ul>
            <li>
               <strong>However</strong>, this can often be abstracted away. The "vararg" facility in C is a classic example of <a href="PointerMetaprogramming.html">PointerMetaprogramming</a> made accessible to the application programmer. The results of this have been...fascinating.
            </li>
            <li>
               Also, in many cases (such as many systems programming tasks) the application in question is highly tied to a specific machine anyway.
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a> is a good way to partition a program into those parts which need the power of <a href="PointerMetaprogramming.html">PointerMetaprogramming</a>, and those which do not (and can be written in a higher-level language).
      </p>
      <p>
        Key techniques of <a href="PointerMetaprogramming.html">PointerMetaprogramming</a>:
      </p>
      <ul>
        <li>
           <a href="PointerArithmetic.html">PointerArithmetic</a>. The use of arithmetic operations on pointers (above and beyond the practice of traversing an array within it's declared bounds) can be productively used to traverse data structures, examine the <a href="ActivationRecord.html">ActivationRecord</a>s of functions, implement dynamically-sized arrays, and such.
        </li>
        <li>
           PointerSwizzling.
        </li>
        <li>
           PointerBitStuffing. The runtime systems of many high-level-languages use <a href="TagBit.html">TagBit</a>s to efficiently encode and store metadata about objects and object references, such as whether a given word on the stack is a pointer or not. This technique is also useful for coloring the object graph in a tracing <a href="GarbageCollector.html">GarbageCollector</a>.
        </li>
        <li>
           Pointer casts. One hallmark of <a href="PointerMetaprogramming.html">PointerMetaprogramming</a> is the construction of pointer casts which are neither proven typesafe by the compiler, nor verified by a runtime typecheck (yet which are correct). This technique can be productively applied to implement polymorphism, both generic and subtype (see <a href="PointerCastPolymorphism.html">PointerCastPolymorphism</a>).
        </li>
      </ul>
      <p>
        Several languages support <a href="PointerMetaprogramming.html">PointerMetaprogramming</a> "out of the box".
      </p>
      <ul>
        <li>
           <a href="CeeLanguage.html">CeeLanguage</a> and it's OO cousins (<a href="CeePlusPlus.html">CeePlusPlus</a>, <a href="ObjectiveCee.html">ObjectiveCee</a>).
        </li>
        <li>
           Many Lisp dialects.
        </li>
      </ul>
      <p>
        Other languages allow it, but only in distinguished code modules (those marked as "unsafe" or with some other pejorative keyword).
      </p>
      <ul>
        <li>
           <a href="ModulaThree.html">ModulaThree</a>
        </li>
        <li>
           <a href="CsharpLanguage.html">CsharpLanguage</a>
        </li>
      </ul>
      <p>
        Others disallow it completely, like <a href="JavaLanguage.html">JavaLanguage</a>. (However, even languages which disallow <a href="PointerMetaprogramming.html">PointerMetaprogramming</a> do provide a <a href="ForeignFunctionInterface.html">ForeignFunctionInterface</a> which can be used to <a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a>, thus providing an "escape hatch").
      </p>
      <p>
        In some languages (many of them <em>typeless</em>/single-type languages where the only type provided is a machine word), virtually <em>all</em> programming is <a href="PointerMetaprogramming.html">PointerMetaprogramming</a>. One classic example is C's predecessor <a href="BeeLanguage.html">BeeLanguage</a>. Another is <a href="ForthLanguage.html">ForthLanguage</a> (though that comment ought to be taken with a grain of salt, as there really isn't a single language called "Forth", and some Forth dialects do impose types).
      </p>
      <hr/>
      <p>
        See also <a href="PointerCastPolymorphism.html">PointerCastPolymorphism</a> and some related discussion on <a href="FirstClass.html">FirstClass</a>.
      </p>
      <p>
        See also <a href="ThreeStarProgramming.html">ThreeStarProgramming</a>.
      </p>
      <hr/>
      <p>
        <a href="CategoryPolymorphism.html">CategoryPolymorphism</a>
        <a href="CategoryMetaprogramming.html">CategoryMetaprogramming</a>
      </p>
    </div>
  </body>
</html>