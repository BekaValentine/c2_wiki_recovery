<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Strongly Typed
      </h1>
      <p>
        What are the <a href="TypesOfTyping.html">TypesOfTyping</a>?
      </p>
      <p>
        I did just a little research a few months ago, trying to find out just what it meant for a language to be <a href="StronglyTyped.html">StronglyTyped</a>.
      </p>
      <ul>
        <li>
           See <a href="StronglyTypedWithoutLoopholes.html">StronglyTypedWithoutLoopholes</a>.
        </li>
      </ul>
      <p>
        My conclusion: there is no commonly agreed-upon meaning for 'strongly typed language'.
      </p>
      <ul>
        <li>
           <em>An example for a statically, but </em>'weakly<em>' typed language is C.</em> (<a href="http://compilers.iecc.com/comparch/article/95-10-071)">http://compilers.iecc.com/comparch/article/95-10-071)</a>
        </li>
      </ul>
      <ul>
        <li>
           <em>C is </em>'strongly<em>' typed...</em> (<a href="http://www.cs.njit.edu/~elsa/280/280%20Lecture%2013_files/slide0138.htm)">http://www.cs.njit.edu/~elsa/280/280%20Lecture%2013_files/slide0138.htm)</a> ( <a href="BrokenLink.html">BrokenLink</a> )
        </li>
      </ul>
      <ul>
        <li>
           <em>This works fine in </em>'weakly<em>' typed languages such as C.</em> (<a href="http://www.mvps.org/vb/hardcore/html/typelessvariables.htm)">http://www.mvps.org/vb/hardcore/html/typelessvariables.htm)</a>
        </li>
      </ul>
      <ul>
        <li>
           <em>LISP engines ...  are themselves generally written in </em>'strongly<em>' typed languages like C...</em> (<a href="http://tlug.linux.or.jp/ML/0010/msg00352.html)">http://tlug.linux.or.jp/ML/0010/msg00352.html)</a>
        </li>
      </ul>
      <ul>
        <li>
           <em>In a </em>'weakly<em>' typed language such as C, ...</em> (<a href="http://www.cs.colorado.edu/~diwan/5535-99/hw-6-soln.html)">http://www.cs.colorado.edu/~diwan/5535-99/hw-6-soln.html)</a>
        </li>
      </ul>
      <ul>
        <li>
           <em>TYPE: </em>'strongly<em>' typed: (C, Algol, Fortran)</em> (<a href="http://sweat.cs.unm.edu/~bap/teach/S2000/CS257/notes/lecture/2000-01-19.txt)">http://sweat.cs.unm.edu/~bap/teach/S2000/CS257/notes/lecture/2000-01-19.txt)</a>
        </li>
      </ul>
      <p>
        Similarly, Pascal was frequently cited as 'strongly typed' in contrast to C, even though the Pascal and  C type systems are nearly identical and both Pascal and C both provide several mechanisms for evading compile-time type checks.
      </p>
      <p>
        Other articles conflated 'strongly typed' with 'has compile-time type checking' (<a href="http://whatis.techtarget.com/definition/0,289893,sid9_gci213058,00.html">http://whatis.techtarget.com/definition/0,289893,sid9_gci213058,00.html</a> for example.) It appears that 'strongly typed' may have at least the following meanings:
      </p>
      <ol>
        <li>
           A language is strongly typed if type annotations are associated with variable names, rather than with values. If types are attached to values, it is weakly typed.
        </li>
      </ol>
      <ul>
        <li>
           <em>Why this distinction? It seems potentially a matter of syntax and not semantics. See examples in </em><a href="ImplicitTyping.html">ImplicitTyping</a>. -t<em></em>
        </li>
        <li>
           [The point is rather poorly described.  In short, a strongly typed language does not permit the type of a variable (and, hence, the type of values it references) to change within the lifetime of that variable.]
        </li>
      </ul>
      <ol>
        <li>
           A language is strongly typed if it contains compile-time checks for type constraint violations. If checking is deferred to run time, it is weakly typed.
        </li>
      </ol>
      <ul>
        <li>
           <em>This implies that all interpreted languages are "weakly typed". This is odd, since they may require things like explicit (run-time) type declarations of all vars. -t</em>
        </li>
        <li>
           [Again, the point is poorly described.  A language is strongly typed if, in general and wherever possible, it performs checks for type constraint violations before execution rather than during execution.]
        </li>
        <li>
           <em>This implies that no purely-interpreted language can ever be "strongly typed" since by definition there is no "before execution" activity. Is this correct? -t</em>
        </li>
        <li>
           [In <strong>every</strong> language there will be something identifiably "before execution"; what activity happens there depends on language and implementation.]
        </li>
      </ul>
      <ol>
        <li>
           A language is strongly typed if there are compile-time or run-time checks for type constraint violations. If no checking is done, it is weakly typed.
        </li>
      </ol>
      <ul>
        <li>
           <em>This is "static" versus "dynamic" typing, not a strong/weak determinant. -t</em>
        </li>
        <li>
           [The point could have been simplified to "[a] language is strongly typed if there are checks for type constraint violations.  If no checking is done, it is weakly typed."  That is accurate.  The distinction between "static" and "dynamic" typing is essentially defined by whether or not slot types & function return values can change at run-time under program control.  In dynamically typed languages, they can.  In statically typed languages, they cannot.]
        </li>
      </ul>
      <ol>
        <li>
           A language is strongly typed if conversions between different types are forbidden. If such conversions are allowed, it is weakly typed.
        </li>
      </ol>
      <ol>
        <li>
           A language is strongly typed if conversions between different types must be indicated explicitly. If implicit conversions are performed, it is weakly typed.
        </li>
      </ol>
      <ol>
        <li>
           A language is strongly typed if there is no language-level way to disable or evade the type system. If there are casts or other type-evasive mechanisms, it is weakly typed.
        </li>
      </ol>
      <ol>
        <li>
           A language is strongly typed if it has a complex, fine-grained type system with compound types. If it has only a few types, or only scalar types, it is weakly typed.
        </li>
      </ol>
      <ol>
        <li>
           A language is strongly typed if the type of its data objects is fixed and does not vary over the lifetime of the object. If the type of a datum can change, the language is weakly typed.
        </li>
      </ol>
      <p>
        I was repeatedly reminded of articles about the cold-war-era use of words like 'democratic', or recent uses of the word 'biased'. These words have ceased to have any objective meaning, and instead become epithets: our country is democratic, yours is not; your statements are biased, ours are not. These words are used automatically to describe anything at all, and their use by a single person may not be consistent with even that person's stated definition.  For example, the author of #8 above (<a href="http://stofi.host.sk/fc_c.htm)">http://stofi.host.sk/fc_c.htm)</a> contrasts the language 'Force' with C, using C as a 'weakly-typed' language, even though, according to the author's own definition, C is strongly typed.
      </p>
      <p>
        I no longer use the phrases 'strongly typed' or 'strong typing'.
      </p>
      <p>
        -- <a href="MarkJasonDominus.html">MarkJasonDominus</a>
      </p>
      <hr/>
      <p>
        There is undoubly a lot of confusion about this term, however the the second definition given above seems right to me:
      </p>
      <p>
        <a href="StronglyTyped.html">StronglyTyped</a> languages are defined in the way which allows to check typing constraints at compile-time. <em>No, that's </em><a href="StaticallyTyped.html">StaticallyTyped</a>.<em></em>
      </p>
      <p>
        According to this definition C, C++ or Java aren't <a href="StronglyTyped.html">StronglyTyped</a> languages.
        In C and C++ there is <em>pointer to void</em>, Java has typing constrains 'leak' for arrays.
        <a href="ObjectiveCaml.html">ObjectiveCaml</a> can be example of <a href="StronglyTyped.html">StronglyTyped</a> language. In <a href="ObjectiveCaml.html">ObjectiveCaml</a> compiler is able to check any type constraint at compile
        time.
      </p>
      <p>
        -- <a href="PiotrWocal.html">PiotrWocal</a>
      </p>
      <hr/>
      <p>
        No need to be confused- there always will be programmers that use such terms without understanding them, as there will always be people that use words they don't understand.  Please see [[<a href="http://kahakai.sourceforge.net/wiki/index.php/StronglyTyped]]">http://kahakai.sourceforge.net/wiki/index.php/StronglyTyped]]</a>
      </p>
      <p>
        -- imilev
      </p>
      <p>
        <em>The definition given there simply proves </em><a href="MarkJasonDominus.html">MarkJasonDominus</a>' point:<em></em>
      </p>
      <p>
        Does not permit arbitrary, implicit conversion between types. For example adding a string constant to an int constant is usually forbidden. A <a href="StronglyTyped.html">StronglyTyped</a> language checks type integrity of programs statically -- that is, at compile time. A program can never fail at runtime due to a type error. Ada, Haskell, ML and Java are all <a href="StronglyTyped.html">StronglyTyped</a> languages.
      </p>
      <p>
        <em>Forbidding implicit conversion is a different and independent property from checking type integrity of programs at </em><a href="CompileTime.html">CompileTime</a>. The latter is what most people would call <a href="StaticTyping.html">StaticTyping</a>, not strong typing. Java <em>does</em> allow implicit conversions in some cases. Java programs can fail at runtime due to a type error.<em></em>
      </p>
      <hr/>
      <p>
        There's a problem here. It very often doesn't make sense to talk of a language of <a href="StronglyTyped.html">StronglyTyped</a>, or <a href="StaticallyTyped.html">StaticallyTyped</a>, or whatever. One needs to draw a distinction between the <em>language</em> and the <em>style</em> it is being used in. Frequently a program will use both <a href="StaticallyTyped.html">StaticallyTyped</a> and <a href="DynamicallyTyped.html">DynamicallyTyped</a> styles together. There is nothing inherently wrong with this.
      </p>
      <p>
        A <a href="StaticallyTyped.html">StaticallyTyped</a> programming <em>style</em> means that one relies on the compiler to do type checking. A <a href="DynamicallyTyped.html">DynamicallyTyped</a> programming <em>style</em> means that type checking is done at runtime.
      </p>
      <p>
        A <a href="StronglyTyped.html">StronglyTyped</a> programming <em>style</em> means that one works within the type system, that is, you don't arbitrarily convert from one type to another. A <a href="WeaklyTyped.html">WeaklyTyped</a> programming <em>style</em> means that you use something like a C cast or C++ reinterpret_cast<> to do exactly that.
      </p>
      <p>
        Examples:
      </p>
      <ul>
        <li>
           C++ supports <a href="StaticallyTyped.html">StaticallyTyped</a> and <a href="DynamicallyTyped.html">DynamicallyTyped</a> and <a href="StronglyTyped.html">StronglyTyped</a> and <a href="WeaklyTyped.html">WeaklyTyped</a> programming
        </li>
        <li>
           Java supports <a href="StaticallyTyped.html">StaticallyTyped</a> and <a href="DynamicallyTyped.html">DynamicallyTyped</a> and <a href="StronglyTyped.html">StronglyTyped</a> programming
        </li>
        <li>
           Python supports <a href="DynamicallyTyped.html">DynamicallyTyped</a> and <a href="StronglyTyped.html">StronglyTyped</a> programming
        </li>
      </ul>
      <p>
        The freedom to adopt multiple styles has both benefits and drawbacks. For instance, <a href="WeaklyTyped.html">WeaklyTyped</a> programming allows to you go between raw memory and the type system (can be useful), but can make programs unmaintainable. So it's best to stay <a href="StronglyTyped.html">StronglyTyped</a> where you can, but sometimes the freedom to get around the type system might be helpful (personally I don't ever seem to need this, but there you go).
      </p>
      <p>
        <a href="WeaklyTyped.html">WeaklyTyped</a> programming is obviously the least popular of the 4 styles above. C more or less forces <a href="WeaklyTyped.html">WeaklyTyped</a> programming upon people, which is why people seem to think of it as a "<a href="WeaklyTyped.html">WeaklyTyped</a> language". But it makes more sense to say that "writing non-trivial programs in C will often only be possible by using a <a href="WeaklyTyped.html">WeaklyTyped</a> style".
      </p>
      <hr/>
      <p>
        Yeah, people get confused about this a lot. It's a rather fine grain of distinction, and it takes a bit of experience with a diverse group of languages to realize what people are talking about.
      </p>
      <p>
        Firstly, 90% of the time, we don't talk about <a href="StrongTyping.html">StrongTyping</a> or <a href="WeakTyping.html">WeakTyping</a> (even if we say it). We <em>usually</em> mean <a href="StaticTyping.html">StaticTyping</a> and <a href="DynamicTyping.html">DynamicTyping</a>.
      </p>
      <ul>
        <li>
           <a href="StaticTyping.html">StaticTyping</a> : Type checking occurs at compile time, with data available only in the source files and annotations. (This incldues <a href="ManifestTyping.html">ManifestTyping</a> and <a href="TypeInference.html">TypeInference</a>). C++ without the virtual keyword or typecasts would fit this profile. ML derivatives also fit this profile.
        </li>
        <li>
           <a href="DynamicTyping.html">DynamicTyping</a>: Type checking occurs at runtime. A type error generally cannot occur at compile time (although some languages blur these lines). Ruby is a good example of a language that follows this paradigm. 
        </li>
      </ul>
      <p>
        <a href="StrongTyping.html">StrongTyping</a> and <a href="WeakTyping.html">WeakTyping</a> are more obscure and a little bit trickier. They can be tough to recognize within the context of the previous two. 
      </p>
      <ul>
        <li>
           <a href="StrongTyping.html">StrongTyping</a> : Values are strongly associated with a type, and this type cannot be changed. An int is an int, no matter what lexical variable points at it. Conversions from one type to another are accomplished by constructing a new data object out of the old one, not by converting the same data value to a new type. Many lanuages with <a href="DynamicTyping.html">DynamicTyping</a> use this. Scheme is an example of a language with <a href="StrongTyping.html">StrongTyping</a> and <a href="DynamicTyping.html">DynamicTyping</a>.
          <ul>
            <li>
              Delphi/Pascal is an example. An int is an int no matter what time of day. A programmer must use StrToInt and IntToStr functions/procedures and etc. to convert one type to another. 
            </li>
          </ul>
        </li>
        <li>
           <a href="WeakTyping.html">WeakTyping</a> : Vales are <em>not</em> strongly associated with a type. Usually, they are just values that may be interpreted in variety of ways dependon on the lexical variable that references them. This kind of typing is a bit funky when applied with <a href="DynamicTyping.html">DynamicTyping</a>, so a Dynamically and Weakly Typed language is a rare thing. A good example of this is C. To see what we mean by this, consider the following C snippet:
        </li>
      </ul>
      <code>
        int *my_int = malloc( sizeof( int ) ); // Make a memory address on the heap.<br/>
        char *my_char = (char *)(my_int); // Note the typecast, a hallmark of this kind of programming<br/>
        int **my_ptr_int = (int **)(my_int); // Another type.<br/>
      </code>
      <p>
        We associate one heap address with several types of data. There really isn't an "authorative" representation here. The memory is just memory, and the syntax of C defines the type. 
      </p>
      <p>
        I know this repeats a bit of what's said above, but I wanted to consolidate what we had and add an example.
      </p>
      <p>
        -- <a href="DaveFayram.html">DaveFayram</a>
      </p>
      <p>
        Why say "C++ without the virtual keyword"?  "virtual" doesn't get in the way of complete static typing.
      </p>
      <p>
        Another difference between static and dynamic type checking is that static typing assigns types to a program's terms (i.e. the code), while dynamic typing assigns types to a program's runtime values.
      </p>
      <p>
        Your description of "weak typing" seems to mean "a language that performs implicit conversions".  This would imply that strong typing doesn't allow for different behavior in different contexts (such as C++-style method overloading).  Also, I don't see how C is dynamically typed at all.
      </p>
      <p>
        My preferred definition of strong/weak typing is when you make "strongly typed" synonymous with "has a powerful type system".  "Using the programming language's type system, how accurately can you describe your data and algorithms?"  It's a scale, not a yes/no thing.  C++ is more strongly typed than C because it has parametric polymorphism (through templates), letting you create generic data types that are still accurately typed.  Python is not as strongly typed as C++ because it can't accurately represent such types.  C++ may have loopholes, but Python's type system is still weaker.
      </p>
      <p>
        -- KannanGoundan
      </p>
      <hr/>
      <p>
        An even easier example is:
      </p>
      <code>
        union { int i, char c, int *p };<br/>
      </code>
      <p>
        BTW: "Translating" the above to Java would possibly result in a base class with three derived classes and accessing the "wrong" storage layout would be caught at run time. (But to play devils advocate: from the user's viewpoint, does it REALLY matter whether some application fails with a "BadCastException" thrown or for some other reason?)
      </p>
      <hr/>
      <p>
        When I made type errors like the union example in C++ the system crashed 4 releases and 6 months later in production.  When I make type errors like this in Java the system crashes 2 seconds later in a unit test.  <a href="FailFast.html">FailFast</a> is close to what this is about.  Your mileage may vary, I am sure better bounds checkers, and operating systems other than Windows 3.1 would help.
      </p>
      <hr/>
      <p>
        See also <a href="TypingQuadrant.html">TypingQuadrant</a>, <a href="WeakAndStrongTyping.html">WeakAndStrongTyping</a>, <a href="StronglyTypedCollection.html">StronglyTypedCollection</a>, <a href="StronglyTypedWithoutLoopholes.html">StronglyTypedWithoutLoopholes</a>.
      </p>
      <hr/>
      <p>
        <a href="CategoryLanguageTyping.html">CategoryLanguageTyping</a>
      </p>
    </div>
  </body>
</html>