<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Directed Graph
      </h1>
      <p>
        A directed graph is a <a href="DataStructure.html">DataStructure</a> containing a vertex set <em>V</em> and an <em>arc</em> set <em>A</em>, where each arc (or <em>edge</em>, or <em>link</em>) is an ordered pair of vertices (or <em>nodes</em>, or <em>sommets</em>). The arcs may be thought of as arrows, each one starting at one vertex and pointing at precisely one other.
      </p>
      <p>
        There are several variants of this data structure:
      </p>
      <ul>
        <li>
           The arrowheads may be removed, resulting in an <a href="UndirectedGraph.html">UndirectedGraph</a>.
        </li>
        <li>
           Weights may be put on the arcs, resulting in a <a href="WeightedDirectedGraph.html">WeightedDirectedGraph</a>.
        </li>
        <li>
           If it is not possible, starting from any given vertex and following any positive quantity of arcs to successive vertices, to return to the starting point, the graph is said to contain no <em>circuits</em> and is called a <a href="DirectedAcyclicGraph.html">DirectedAcyclicGraph</a>.
        </li>
        <li>
           Of course, there's also <a href="WeightedDirectedAcyclicGraph.html">WeightedDirectedAcyclicGraph</a>s.
        </li>
      </ul>
      <hr/>
      <p>
        A <a href="DirectedGraph.html">DirectedGraph</a> is primarily a <a href="MathematicalNotation.html">MathematicalNotation</a> which can be <em>represented</em> as a <a href="DataStructure.html">DataStructure</a> for programming. You might say <a href="ProgrammingIsMath.html">ProgrammingIsMath</a>, but <a href="IsProgrammingMath.html">IsProgrammingMath</a>?
      </p>
      <hr/>
      <p>
        <a href="StuFeldman.html">StuFeldman</a>'s algorithm (1979) finds a solution to every problem that can be written as a <a href="DirectedAcyclicGraph.html">DirectedAcyclicGraph</a>.  The algorithm finds and traverses a path through the graph.  The graph is called a <strong>makefile</strong>, and his tool is called <strong>make</strong> (see <a href="MakeProgram.html">MakeProgram</a>). -- <a href="ChrisGarrod.html">ChrisGarrod</a>
      </p>
      <p>
        <em>How does </em><a href="StuFeldman.html">StuFeldman</a>'s algorithm answer this?<em></em>
      </p>
      <dl>
        <dt> </dt>
        <dd><em>Given a </em><a href="DirectedAcyclicGraph.html">DirectedAcyclicGraph</a> <strong>G</strong>, consider the set <strong>S</strong> of all possible linear orderings consistent with <strong>G</strong>. For two vertices <strong>A</strong> and <strong>B</strong>, let <strong>P(A,B)</strong> be the probability that <strong>A</strong> comes before <strong>B</strong> in an element of <strong>S</strong> chosen uniformly at random. Prove that if <strong>|S|>1</strong> then there exist <strong>A</strong> and <strong>B</strong> such that <strong>1/3 <= P(A,B) <= 2/3</strong>.<em></em></dd>
      </dl>
      <p>
        That's not a problem writable <strong>as</strong> a <a href="DirectedAcyclicGraph.html">DirectedAcyclicGraph</a>, that's a problem <strong>about</strong> <a href="DirectedAcyclicGraph.html">DirectedAcyclicGraph</a>s. There is a difference. You're going to have to express your problem <strong>as</strong> a graph, at which point the effectiveness of the algorithm should be obvious. either for or against (see parenthetical paragraph below). However, while with sufficient work such proofs can be expressed as graphs, you may not like the running time.
      </p>
      <p>
        A graph of a proof will start with what you gave the system (the Givens in your problem). Each application of an axiom is an arc leading to a new result. It gets real big, real fast. (Colloquialism deliberate.) 
      </p>
      <p>
        (In fact it is infinite, technically, and despite the claim that <a href="StuFeldman.html">StuFeldman</a>'s algorithm finds a solution to all DAG problems, I would expect that only holds for graphs where all nodes have a finite number of exiting arcs. That isn't true in the obvious formulations of the graph I described, because of the presence of numbers, where you can technically try statements about any proportion of the graph.)
      </p>
      <p>
        <em>Well, I guess I'm having trouble finding any examples of difficult and/or interesting problems that can be "written as a DAG". The only examples I've come up with are simple search problems, or have been devised by taking problems and rewriting/encoding them in a non-natural way.</em>
      </p>
      <p>
        <a href="TheReformSociety.html">TheReformSociety</a> probably isn't the kind of example you were looking for, but you may find it interesting nevertheless as it's meant to be a <a href="DirectedAcyclicGraph.html">DirectedAcyclicGraph</a>.
      </p>
      <p>
        <em>As a graph-theorist and compiler writer I have any number of examples of DAGs. I just don't understand what it means to "write a problem as a DAG."</em>
      </p>
      <p>
        "Traditional" artificial intelligence is where you want to look, specifically their "search problems". Massive state spaces with discrete transitions, all represented as DAGs. A lot of problems that don't look like a "search" actually are.
      </p>
      <p>
        <em>OK, I can see you're trying to help, so let me be more specific. It was claimed above that </em><a href="StuFeldman.html">StuFeldman</a>'s algorithm(s) "solved" every problem that can be written as a DAG. I can't see how <a href="StuFeldman.html">StuFeldman</a>'s algorithm(s) do anything particularly special. I had discounted the traditional AI problems because <a href="StuFeldman.html">StuFeldman</a>'s algorithm clearly does nothing there more interesting than the usual, and not very successful, AI searches, so I guess I was hoping for more. I can't find a "problem written as a DAG" in which the "make" algorithms are of any clear benefit over almost any other techniques well-known to almost any graph-theorist.<em></em>
      </p>
      <p>
        Actually, I only wrote the later stuff; I've never heard of <a href="StuFeldman.html">StuFeldman</a>'s algorithm. I was just trying to explain the problem-as-DAG aspect. Sorry.
      </p>
      <p>
        <em>No need to apologise, I'm just trying to understand what the original author was saying.</em>
      </p>
      <hr/>
      <p>
        I have written a directed graph class for Java where the nodes are Enum values and the vertexes are stored in EnumSet objects. Generics makes it a whole lot clearer:
      </p>
      <p>
        class <a href="DirectedGraph.html">DirectedGraph</a><T extends Enum<T>> extends EnumMap<T, EnumSet<T>>
      </p>
      <p>
        <em>Good for you.  Rather than waste the reader's time patting yourself on the back, would you consider either (a) sharing your code with us; or (b) delete the above and stop teasing us?</em>
      </p>
      <hr/>
      <p>
        <a href="CategoryDataStructure.html">CategoryDataStructure</a>
      </p>
    </div>
  </body>
</html>