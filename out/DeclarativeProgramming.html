<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Declarative Programming
      </h1>
      <p>
        Programming where problems are described, or <em>conditions</em> on a solution are described, and the computer finds a solution. Often it involves the separation of "facts" from operations on the facts.
      </p>
      <p>
        "Declarative Programming" has also been described as a model of computation that "generalizes the pure functional model". That is, all pure functional programs are declarative programs, and <a href="DeclarativeProgramming.html">DeclarativeProgramming</a> retains almost all of the advantages of <a href="FunctionalProgramming.html">FunctionalProgramming</a>. This is explained in more detail in the book <a href="ConceptsTechniquesAndModelsOfComputerProgramming.html">ConceptsTechniquesAndModelsOfComputerProgramming</a>.
      </p>
      <p>
        Subcategories of <a href="DeclarativeProgramming.html">DeclarativeProgramming</a> include <a href="LogicProgramming.html">LogicProgramming</a>, <a href="ConstraintProgramming.html">ConstraintProgramming</a>, and <a href="ConstraintLogicProgramming.html">ConstraintLogicProgramming</a> (which, as its name suggests, is a hybrid of the two - see <a href="ConstraintAndLogicProgramming.html">ConstraintAndLogicProgramming</a>).
      </p>
      <hr/>
      <p>
        While the above is nice in a <a href="HandWaving.html">HandWaving</a> way, it is vague and leads to of <a href="HolyWar.html">HolyWar</a>s about whether this or that language is 'declarative' or effectively supports '<a href="DeclarativeProgramming.html">DeclarativeProgramming</a>'. Due to the vagueness of the original definition, <a href="DeclarativeProgramming.html">DeclarativeProgramming</a> is effectively a sliding scale. The following operational characteristics might be used to judge the extent to which a programming model is declarative:
      </p>
      <ul>
        <li>
           In <a href="DeclarativeProgramming.html">DeclarativeProgramming</a>, order of statements and expressions should not affect program semantics. For example, they should not affect the termination characteristics and should not affect the observable IO properties, and ideally shouldn't affect performance.
        </li>
        <li>
           In <a href="DeclarativeProgramming.html">DeclarativeProgramming</a>, replication of a statement should not affect program semantics. What matters is that some fact or constraint exists, not how many times it is declared or computed. This allows refactoring and abstraction of statements, and is also a basis for many optimizations.
        </li>
      </ul>
      <p>
        Or, essentially, <a href="DeclarativeProgramming.html">DeclarativeProgramming</a> should exhibit properties of <strong>commutativity</strong> and <strong>idempotence</strong> across statements. <a href="DeclarativeProgramming.html">DeclarativeProgramming</a> models vary widely in how they support <a href="SideEffect.html">SideEffect</a>s, synchronization and coordination, modularity, composition, security, consistency, and IO. (To name a few approaches: oracles, single-assignment future values, temporal or reactive semantics, constraint maintenance, graph or <a href="TermRewriting.html">TermRewriting</a>, generative grammars.) 
      </p>
      <p>
        Pure <a href="FunctionalProgramming.html">FunctionalProgramming</a> exhibits commutativity and idempotence in-the-small. However, it has traditionally used imperative 'glue' (such as monads) that tend to make composition of statements <em>imperative</em> at higher levels. The ideal of <a href="DeclarativeProgramming.html">DeclarativeProgramming</a> is to keep things 'declarative' even at the top-level (in-the-large, integrating with IO, and across modules). Some disciplined forms of <a href="FunctionalProgramming.html">FunctionalProgramming</a> (such as <a href="FunctionalReactiveProgramming.html">FunctionalReactiveProgramming</a> and FunctionalRelationalProgramming) support far more declarative composition than monads.
      </p>
      <hr/>
      <p>
        There seem to be two distinct types of <a href="DeclarativeProgramming.html">DeclarativeProgramming</a>.
      </p>
      <p>
        In the first, you describe something, and the computer implements it.
      </p>
      <p>
        In the second, you use more commands. "Find me all things which satisfy the following conditions."
      </p>
      <p>
        They appear to be related; The first is passive, lazy. When the information is needed, it is deduced from the description. The second is active, imperative. You tell the computer to get the information <em>now.</em>
      </p>
      <hr/>
      <p>
        I love using a declarative approach to a problem when it fits - and it can fit surprisingly often. Whenever complex algorithms are applied repeatedly to complex and widely varying data, this is an opportunity to simplify using declarative programming.
      </p>
      <p>
        The most obvious common example of declarative programming is writing database queries. In this case, the evaluation engine is usually a black box -- either because it's proprietary, or you prefer not to look inside it. Optimizing and executing queries efficiently is complex, so the ability to declare the desired query results in terms of a simple algebra or query language is a huge savings of effort.
      </p>
      <p>
        In some sense, declarative programming is ubiquitous. Every common high-level programming language lets you express mathematical calculations at a high level, without worrying about the mechanisms of register allocation, table lookups for transcendental functions, etc. So declarative programming "in the small" is a technique that every programmer uses every day, without thinking twice about it.
      </p>
      <p>
        Where declarative programming sometimes becomes a problem is when the evaluation engine isn't expressive enough, or when it exhibits undesirable characteristics - bugs, performance problems. This is an example of a <a href="LeakyAbstraction.html">LeakyAbstraction</a>, since the engine is abstracting algorithmic complexity, and details of the implementation affect program viability. This is particularly frustrating when the engine is a black box. Sometimes you can work around it by tweaking the representation of the problem that is presented to the engine. This problem might explain why many programmers are uncomfortable with this style of programming. Their reaction might be akin to the <a href="NotInventedHere.html">NotInventedHere</a> syndrome that works against the use of third-party libraries in general.
      </p>
      <hr/>
      <p>
        Some code prefers to be declarative rather than imperative. For example, imperative code to create a hierarchy of GUI widgets, associated content models and observers, etc. and link them all together can be quite bulky. E.g. creating a widget and initializing it with a label, observer, and layout information might require 10+ lines of code. The bulk mostly occurs because in imperative code, you have to spell out not only what you want the result to look like, but each step needed to achieve the result. This code is a good candidate for externalizing into some sort of declarative modelling language (e.g. an XML template or something). Now you are still describing what the resulting hierarchy of objects looks like, but you don't have to be explicit about all the creation steps because your runtime (or compiler, or ...) can figure that part out itself. Your 10+ lines of imperative code are reduced to a 1 or 2 line specification.
      </p>
      <p>
        As another example, I've been thinking about scripting languages used for games programming. Games often use home-grown scripting languages in which (for example) a script is run once each frame and must detect events by polling all the conditions it is interested in. Why not design a declarative scripting language that relies on <a href="EventDrivenProgramming.html">EventDrivenProgramming</a> (presumably with a TriggerSystem tightly integrated into the language)? Then the script author only has to declare what event conditions he is interested in, leaving it up to the engine (or compiler, or ...) to figure out exactly what trigger machinery is needed to efficiently detect when the declared conditions have occurred.
      </p>
      <p>
        <em>Something like the event mechanism in the </em><a href="ToolCommandLanguage.html">ToolCommandLanguage</a>?<em></em>
      </p>
      <hr/>
      <p>
        See also: <a href="DataCentricThinking.html">DataCentricThinking</a>, <a href="IsDeclarativeLessExpressive.html">IsDeclarativeLessExpressive</a>
      </p>
      <hr/>
      <p>
        <a href="ProgrammingParadigm.html">ProgrammingParadigm</a>
      </p>
    </div>
  </body>
</html>