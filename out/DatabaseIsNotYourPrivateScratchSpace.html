<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Database Is Not Your Private Scratch Space
      </h1>
      <p>
        If <a href="DatabaseIsNotYourPrivateScratchSpace.html">DatabaseIsNotYourPrivateScratchSpace</a> then.. WhatIsMyPrivateScratchSpace 
      </p>
      <p>
        Why I can not use a database as a private scratch space? I'd like to know if relational theory has anything to say about this... if I am not supossed to use the database as my private scratch space then, what am I supposed to use? isn't it a big omission that we have all this rules about how to deal with complete facts, but no rules on how to incrementally and declaratively build those facts that we are supposed to store in the database? is this a RelationaModelFlaw ?  or SqlDatabaseFlaw? or just an SqlDatabaseOmission ? 
      </p>
      <ul>
        <li>
           [None of the above...  If you must use a database as your private scratch space, install a local DBMS like SQLite.  Or, use other client-side tools appropriate to the problem at hand.  Or use temporary tables, if your DBMS supports them.  Or, use persistent tables specifically intended to represent partial or "scratch" data.  Really, if your client-side data is already in RAM, it would be more effective to sort, group, and search it <em>in situ</em> than waste network bandwidth, DBMS resources, and persistent storage space by using it to handle what should be client-side functionality.] -- <a href="DaveVoorhis.html">DaveVoorhis</a>
        </li>
      </ul>
      <ul>
        <li>
          <em>Or you could embedd the </em><a href="DatabaseType.html">DatabaseType</a> into your application if it was possible.. using the database right within your program as if it was a native type. Or some form of <a href="TableOrientedProgramming.html">TableOrientedProgramming</a> language or <a href="TutorialDee.html">TutorialDee</a> would be useful, with the tables right there and ready for you.. in the language. SQL is too hard and takes too much up front diddling.. it seems. Databases are also too boxy. <a href="MicroSoft.html">MicroSoft</a> Excel is also another scratch space and a fake database of sorts. Marketing companies and real world companies understand that purism and perfect relational models don't suit peoples' every day needs, in many cases. That's why the fellows over at dbdebunk.com use Microsoft Word to manage their website instead of a real database.<em> </em>
        </li>
      </ul>
      <ul>
        <li>
           I'm not sure how embedding a "<a href="DatabaseType.html">DatabaseType</a> into your application" would make any difference.
        </li>
        <li>
           Numerous languages and libraries provide built-in local facilities for searching and sorting.  There's even a whole book about it by some guy (maybe you've heard of him?) named Knuth, should you wish to roll your own.
        </li>
        <li>
           Use of <a href="TutorialDee.html">TutorialDee</a> (for example) as a DBMS would not solve this problem, because you'd still be wasting network and DBMS resources by using the server-side for client-side tasks.  Use of <a href="TutorialDee.html">TutorialDee</a> as an application development language might help, but that's essentially the same point as above.
        </li>
        <li>
           Databases are only "too boxy" for those who use them inappropriately.  The <a href="RelationalModel.html">RelationalModel</a> is not a type definition system; it is an attribute and data management system -- a <a href="DatabaseIsRepresenterOfFacts.html">DatabaseIsRepresenterOfFacts</a>.  The <a href="RelationalModel.html">RelationalModel</a> does not specify how types are constructed, only that values may be of any type.  Complex values (e.g., documents, etc.) are best represented using the type system of a sound <a href="RelationalLanguage.html">RelationalLanguage</a>, then use the <a href="RelationalModel.html">RelationalModel</a> to manipulate collections of values of these types.  Unfortunately, most SQL systems have an abysmally inadequate type system, which creates the misconception that the <a href="RelationalModel.html">RelationalModel</a> is flawed, when in fact the problem is a plethora of <a href="SqlFlaws.html">SqlFlaws</a> and DBMS type-definition limitations.  The <a href="RelationalModel.html">RelationalModel</a> isn't perfect, of course -- by definition, no model is perfect -- but for its intended purpose (data management, which must be considered distinct from programming, application development, etc.) it has so far proven superior to the alternatives.
        </li>
        <li>
           SQL may be inconsistent, but I've never heard it described as "too hard" and what is "up front diddling"?  If you find it "too hard", I recommend practicing it more.
        </li>
        <li>
           <a href="MicroSoft.html">MicroSoft</a> Excel won't help your client-side application with sorting and searching, unless you either re-implement the whole application in Excel, or use various COM or whatever nastiness.
        </li>
        <li>
           The individual who maintains dbdebunk.com is a theoretician; his background is almost entirely non-technical.  To my knowledge, he does not know SQL, HTML, or any other technical aspect of Web site creation.  That is why his site uses Word rather than a DBMS.
          <ul>
            <li>
               Oh, is that because SQL is too hard, contradicting your previous statement?
            </li>
            <li>
               <em>No, it's because he's non-technical.  Many sound academics (whether </em><a href="FabianPascal.html">FabianPascal</a> is one is another subject), theoreticians, pundits, commentators, bloggers etc., couldn't code their way out of a wet paper bag in <em>any</em> language, SQL or otherwise, and this is no reason to deprecate their work.<em></em>
              <ul>
                <li>
                   Someone who does not know SQL, criticises SQL? He studies and knows SQL well. He doesn't use it, because designing his site in a relational way (the proper way) would require too much work up front, even though he is an <em>expert</em> technically in relational design. He is not technical? A scientist, mathematician is not technical? Technical is not separate from science and math.. those two subjects are intertwined very closely. It's called hypocrisy. Take a look at the date format on his website also. This has nothing to do with technical knowledge versus science. If he is such a smart relational pure type driven third manifesto well read up person, he would not be using dates such as 03/05/04 on his site, worse yet 03/05 style dates. He is a hypocrite, with a lot of valid points and he is a very smart man.. as are Date, Codd, etc. But he is also very Pargent.
                  <ul>
                    <li>
                       <em>Let me clarify:  By non-technical, I mean that he is not a programmer, because he isn't.  He doesn't write code.  That doesn't stop him from critiquing it or its theoretical underpinnings, or even teaching it.  I'll bet half your professors in university were of a similar ilk; some probably did significant work in computer science and even in programming without being able to code a simple application or Web site.  As for the date formats, I never noticed and I doubt he did either.</em>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>
               {To my impression, Fabian Pascal (who runs www.dbdebunk.com) is hardly a theoretician.  A proper theoretician would be busy fairly testing ideas other people come up with and coming up with his or her own hypotheses that contradict 'the word of Codd' and testing them with some degree of rigor.  But this man is so faithful to the idea of relational that he laughs at other ideas rather than giving them proper consideration - something I saw repeatedly in his responses to others.  That makes him a religious zealot, or weenie, or... a consultant and teacher, apparently.  Don't they call that sort of teacher a 'proselytizer'?  I think that might work better than 'theoretician' to describe Fabian Pascal.} 
              <ul>
                <li>
                   Exactly. Eat your own dog food... 
                </li>
              </ul>
            </li>
            <li>
               <em>Pascal's irascible approach won him a few fans and no friends.  Even his supporters were regularly subject to abuse, and his cantankerous approach has probably done more harm than good in terms of general acceptance of the </em><a href="RelationalModel.html">RelationalModel</a>.  Some of his attitude may be due to years of battling against people who don't understand the value and appropriate application of the model -- which is surprisingly difficult to articulate (yet alone successfully convey) despite its simplicity -- but some of that is just...  Him.  To my knowledge, he no longer actively contributes to the field, and his best work was his books.  His on-line behavior was consistently deplorable.<em></em>
              <ul>
                <li>
                   He has some active pages that he gives real world examples on how to normalize databases that are very handy.. that I use myself as working cases for how to normalize my tables.. but he also doesn't understand that his solution doesn't always fit every problem.. such as this wiki page which <em>could</em> be organized in a relational way.. but doesn't have to.. since we are human.  If we really wanted to, we could organize this page and all his word.doc files into a relational model.. but the point is that this wiki itself is a scratch space and his word.doc files are a scratch space since SQL is too hard for him and since <a href="TutorialDee.html">TutorialDee</a> doesn't exist yet..  hence we aren't Eating Our Own Dog Food by practicing purism.
                  <ul>
                    <li>
                       <em>Huh?  </em><a href="TutorialDee.html">TutorialDee</a> exists.  See the <a href="RelProject.html">RelProject</a>, MighTyD, Alphora D (though it's more based on <a href="TutorialDee.html">TutorialDee</a> than a strict implementation), Duro, and others.  There are also a number of <a href="RelationalLanguage.html">RelationalLanguage</a> efforts that are not <a href="TutorialDee.html">TutorialDee</a>, but that embrace its principles or related ones.<em></em>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>
               A proper scientist, theotician, and a person <em>worth his salt</em> will test SQL for its real world flaws, and will study it so that he knows what to improve on it. And, dbdebunk is not just one person.. but it contains several articles from several people. Eat your own dog food. He doesn't. He doesn't even use databases,  and therefore has no reason to claim he knows about them (but, I do agree with many of his statements and philosophies, regardless of whether he is an academic who doesn't know his hand from his arse). And by criticizing him and his websites, I am fully willing to lose friendship also. However many people agree with me and I may gain friends by speaking up and gathering other friends who feel the same way. 
              <ul>
                <li>
                   <a href="FabianPascal.html">FabianPascal</a> has obtained contributions from colleagues.  The site is his, however, and maintained entirely by him.
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <em>If you want a private scratch space, consider </em><a href="TiddlyWiki.html">TiddlyWiki</a> and <a href="WikiIde.html">WikiIde</a> (in the future).  If you want one designed for building facts, consider a <a href="SemanticWiki.html">SemanticWiki</a> or <a href="SemanticWeb.html">SemanticWeb</a> technology.<em></em>
      </p>
      <p>
        See <a href="DatabasesPunishYou.html">DatabasesPunishYou</a>
      </p>
    </div>
  </body>
</html>