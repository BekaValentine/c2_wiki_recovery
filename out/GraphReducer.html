<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Graph Reducer
      </h1>
      <p>
        A <a href="GraphReducer.html">GraphReducer</a> is a means for evaluating (executing) expressions coded in a (usually lazy and pure) <a href="FunctionalProgrammingLanguage.html">FunctionalProgrammingLanguage</a>. A <em>lazy</em> FPL uses <a href="NormalOrderEvaluation.html">NormalOrderEvaluation</a> (<a href="CallByName.html">CallByName</a>) or <a href="LazyEvaluation.html">LazyEvaluation</a> (<a href="CallByNeed.html">CallByNeed</a>, an optimization of the former) by default; a <em>pure</em> FPL is free of <a href="SideEffect.html">SideEffect</a>s. (Note that some use pure to mean lazy.) Pure FPL's, whether lazy or eager, have the desirable property of <a href="ReferentialTransparency.html">ReferentialTransparency</a> - any named term (variable) in the language can be substituted with its expression at any time; the two are always equivalent. (If <a href="SideEffect.html">SideEffect</a>s are allowed, this is no longer true.)
      </p>
      <p>
        For FPLs which are <em>eager</em> (use <a href="CallByValue.html">CallByValue</a>), often the most straightforward implementation is an imperative one, similar to how one would implement an imperative language. ML is one such language, Lisp is another (both ML and Lisp allow side effects). For lazy languages, though, a straightforward imperative implementation generally requires lots of extra thunks (to inject laziness) and other inefficient nastiness.
      </p>
      <p>
        A common alternative, then, is the <a href="GraphReducer.html">GraphReducer</a>. The program is essentially converted to a <a href="DirectedAcyclicGraph.html">DirectedAcyclicGraph</a>, with nodes being computations and vertices being dependencies between computations. Evaluation of a program is essentially traversal of this graph. One typically starts at the <em>result</em> node, and for each computation determines which inputs are needed, and recursively computes those. A graph reduction algorithm usually performs memoization, so that if a given node is needed for more than one subsequent computation, it need not be recomputed.
      </p>
      <p>
        Note that <a href="GraphReducer.html">GraphReducer</a>s can be also used for eager FPLs, and even (if one excludes memoization) for imperative languages. However, for these latter cases, use of a <a href="GraphReducer.html">GraphReducer</a> is generally inefficient; translation to some other form (an IntermediateForm, <a href="ByteCode.html">ByteCode</a>, or even translation to <a href="MachineCode.html">MachineCode</a>) is generally a better solution.
      </p>
      <hr/>
      <p>
        See also <a href="AbstractSyntaxTree.html">AbstractSyntaxTree</a>
      </p>
      <p>
        <a href="CategoryProgrammingLanguage.html">CategoryProgrammingLanguage</a>
      </p>
    </div>
  </body>
</html>