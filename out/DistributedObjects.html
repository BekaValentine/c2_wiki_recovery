<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Distributed Objects
      </h1>
      <p>
        From <a href="AnOoMagicBullet.html">AnOoMagicBullet</a>:
      </p>
      <p>
        I have my doubts about the performance of 'distributed objects' in the real world. 
      </p>
      <p>
        <em>What are your doubts? I confess I fail to understand how OO or the lack of it is relevant to the performance of distributed components. When you come down to it OO is simply good factoring - good for maintainability - and that has nothing to do one way or the other with performance. Or is there some kind of inobvious connection?</em>
      </p>
      <p>
        My experience has been that network traffic concerns impact negatively on the design of object collaborations when the objects are distributed. I think that there's a mis-match here like the mis-match between OO and RDBMS technologies. That doesn't mean that the technologies shouldn't be used together, however. What it means is that using the technologies together creates, rather than solves, engineering problems. 
      </p>
      <p>
        So, naively "distributing objects" probably won't ever result in a usable system. But, designing a system that uses both network capabilities and object oriented design techniques to their fullest advantage is still possible and desirable. -- <a href="PhilGoodwin.html">PhilGoodwin</a>
      </p>
      <hr/>
      <p>
        <strong>"There is no such thing as a good distributed object model"</strong>
      </p>
      <p>
        <a href="TedNeward.html">TedNeward</a> commented on <a href="DistributedObjects.html">DistributedObjects</a> in mid05 and viewed that all <a href="DistributedObjects.html">DistributedObjects</a> implementation, irrespective of platform (<a href="EjbObject.html">EjbObject</a>, <a href="ComPlus.html">ComPlus</a>, <a href="CorbaComponentModel.html">CorbaComponentModel</a>, etc) sucks. His blog was on EjbPlatform and located at <a href="http://www.neward.net/ted/weblog/index.jsp?date=20050727#1122529218328">http://www.neward.net/ted/weblog/index.jsp?date=20050727#1122529218328</a>
      </p>
      <ul>
        <li>
           <em>Not every problem we face lends itself to an object-oriented solution</em>
        </li>
      </ul>
      <hr/>
      <p>
        The main thing to realize about any distributed system is that you can't treat it as if it the network doesn't exist.  One of the problems with systems like COM, RMI and CORBA is that they tend to try and hide the fact that you are actually talking across a network.  
      </p>
      <p>
        Anyone tried <a href="JavaSpaces.html">JavaSpaces</a> ?  Seems to me like it's a protocol that doesn't try to pretend that the network doesn't exist.
      </p>
      <p>
        <em>More preciese, it does pretend that network exists. Rather common for everything related to </em><a href="JiniTechnology.html">JiniTechnology</a>.<em></em>
      </p>
      <p>
        -- <a href="GlenStampoultzis.html">GlenStampoultzis</a>
      </p>
      <hr/>
      <p>
        It is one type of factoring, along with templates and good old functions. Most new C++ libs seem to be using templates. Why? Because OO failed? We'll see what Java looks like when it is mature. (See 'Deprecated') OO has its good and bad points, and many of its idioms do not work well over a network. The golden rule 'the implemented system models the real world' for instance. 'Small and lots' of method calls for another instance. I'm not saying OO is no good - but it isn't suitable for everything. 
        (I made the original comment)
      </p>
      <hr/>
      <p>
        Why does the fact that 'most new C++ libs seem to be using templates' imply that 'OO failed'? As I understand it from my limited C++, C++ templates are a mechanism for parameterising types and are a pre-processing add-on to a class definition that aids compile time type checking and reduces the need for downcasts. Templates are surely therefore explicitly bound to classes through the class definition and hence reinforce OO concepts. Or not? --<a href="LanceWalton.html">LanceWalton</a>
      </p>
      <hr/>
      <p>
        I didn't say OO failed - I left a question mark to let the reader make their own mind up.  IMHO it wasn't entirely successful, although some people still treat it as a silver bullet.  To me, the mechanisms OO brought, are just extra tools in the box.  I think that the strength of OO is in analysis, not necessarily implementation.
      </p>
      <p>
        C++ templates are, in the opinion of some, a better mechanism for building class libraries than a typical OO approach (such as Java's class libs).  To me templates are just another tool in the box, but I can see the trade-offs with OO reuse.  Polymorphism is definitely problematic.
      </p>
      <p>
        If you're a Java programmer then you don't get the option, although I do hear that they intend to extend the language further to allow some type of templates.
      </p>
      <hr/>
      <p>
        I saw the question mark and I guess what I was asking was how the conclusion 'because OO failed' could be drawn from 'most new C++ libs use templates' at all (by anybody) <em>i.e.</em> I can't see the connection - I'm absolutely not saying that this conclusion cannot be drawn from the premise but I'd like some help connecting the two (even if I disagree with it once it's been elucidated :-)
      </p>
      <p>
        The <a href="PizzaLanguage.html">PizzaLanguage</a> is Java with parameterized types and whatever else they've added since I last looked. --<a href="LanceWalton.html">LanceWalton</a>
      </p>
      <hr/>
      <p>
        <em>Polymorphism is definitely problematic.</em>
      </p>
      <p>
        What?! Polymorphism is the key. The more dynamic bindings you make versus static bindings, the simpler the program.
      </p>
      <p>
        What's wrong with polymorphism?
      </p>
      <p>
        -- <a href="SunirShah.html">SunirShah</a>
      </p>
      <hr/>
      <p>
        I don't think OO/polymorphism is either evil or a silver bullet.  OO hasn't failed completely - but it hasn't been entirely successful.  I'll state again that I think there are inherently some big problems with the distributed objects idea (the vision of CORBA?) - I don't think it will work (See <a href="PhilGoodwin.html">PhilGoodwin</a>'s comments above).  At the very least there'll be a comprimise situation to get it working.
      </p>
      <p>
        <a href="TimEwald.html">TimEwald</a> has commented elsewhere (where was it?) that transposing analysis to implementation is different on a distributed system than a local system.  Simply put the OO tricks you may use on your local PC for one user, will not perform over the (inter)network, with a large number of users.
      </p>
      <p>
        A number of people have commented on the testing, and maintenance issues with polymorphic interfaces.
      </p>
      <hr/>
      <p>
        To go back to a point raised above about trying to hide the distribution, I fell into a similar hole myself some years ago. In my case I was trying to make objects persistent but hide this detail from the users. Thus when a client asks for a collection of objects, it doesn't know that they are being dragged off a disk somewhere. This worked to a degree but I soon came up with a scenario where performance was terrible because the client wasn't considering the performance aspects with persisting data. In other words you can't expect things like distribution and persistence to be completely transparent to the user. There has to be some consideration from the outset, during design. If this happens then there is no issue with DOs.
      </p>
      <p>
        <a href="RussFreeman.html">RussFreeman</a>
      </p>
      <hr/>
      <p>
        Have you read <a href="AnoteOnDistributedComputing.html">AnoteOnDistributedComputing</a>? This "hole" you mentioned already considered more than decade ago.
      </p>
      <p>
        See also <a href="DistributedComputing.html">DistributedComputing</a>, <a href="HalfObjectPlusProtocol.html">HalfObjectPlusProtocol</a>, <a href="DistObj.html">DistObj</a>.
      </p>
    </div>
  </body>
</html>