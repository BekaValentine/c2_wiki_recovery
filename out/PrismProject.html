<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Prism Project
      </h1>
      <p>
        (Apparently abandoned)
      </p>
      <p>
        <a href="http://www.prism.cx">http://www.prism.cx</a>
      </p>
      <p>
        <em>The following description is from the "Prism Manifesto." [1]</em>
      </p>
      <dl>
        <dt> </dt>
        <dd>Prism's mission is to improve programmer productivity by improving the state-of-the-art in programming tools. At this time, interoperable codes (specifically, interoperable domain-specific languages) seems to be the best way to do so. Prism also has a few other related goals, each of which shall be achieved by a particular "phase" of the project. In brief, those phases are as follows: </dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd>Phase 1: Create a way for metaprograms (compilers, parsers, "lint"ers, etc.) to interoperate. This opens up the compilation pipeline, enabling competition for specific aspects of the compilation process and simplifying the creation of metaprograms, leading to higher-quality metaprograms and a more diverse toolset. It also lays the groundwork for phase two. </dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd>Phase 2: Create a way for codes to interoperate. This eliminates the biggest accidental difficulty remaining in the programming process, as described above.  [See [1] for further discussion.  The premise is that program design is an <a href="AccidentalDifficulty.html">AccidentalDifficulty</a> not an <a href="EssentialDifficulty.html">EssentialDifficulty</a>.]</dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd>Phase 3: Extend the Prism approach to visual and interactive codes. The most popular and useful codes today seems to be spreadsheet codes. I presume their visual, interactive syntax have a lot to do with their success.</dd>
      </dl>
      <hr/>
      <p>
        In <a href="LanguageUsability.html">LanguageUsability</a>, <a href="JeffGrigg.html">JeffGrigg</a> said
      </p>
      <dl>
        <dt> </dt>
        <dd><em>"It's been my experience that the most powerful tools, the ones that give you the greatest leverage -- and hence highest productivity, have a more limited scope.  That is, they're less 'general purpose.'  So, you trade development efficiency/productivity for limited scope of solutions you can deliver."</em></dd>
      </dl>
      <p>
        and <a href="JimLittle.html">JimLittle</a> said
      </p>
      <dl>
        <dt> </dt>
        <dd><em>"This is the premise of the Prism project."</em>  [More specifically, Prism sees domain-specific tools as being the best way to increase programmer productivity.  It addresses the scope issue by enabling domain-specific languages to interoperate.]</dd>
      </dl>
      <hr/>
      <p>
        <a href="JeffGrigg.html">JeffGrigg</a>'s conclusion from reading several of the documents of the Sphere/Prism site...
      </p>
      <ul>
        <li>
           Nice ideas, but he's missed the boat.
        </li>
        <li>
           He's trying to solve a problem that's already been solved a number of times in the industry, by COM, CORBA, and other inter-language interfaces.  (And a number of compiler vendors, like Microsoft, have already standardized their internal code generation interfaces, so that they can share optimizer logic across language compilers.)
        </li>
      </ul>
      <p>
        <em>But COM and CORBA </em>increase<em> the accidental difficulty of programming rather than decreasing it.  They're complex solutions that are hard to get working right.  They're also run-time solutions rather than compile-time solutions.  Prism is purely a compile-time solution whose goal is to </em>reduce<em> programming difficulty as much as possible.  Think of it as a next-generation linker that allows multiple domain-specific languages to be compiled into a single executable.</em>
      </p>
      <ul>
        <li>
           His solution is not adequate to the problem he's trying to address:  To achieve inter-language operability, you need more than a common representation format (like XML or BNF) -- you need to standardize the meaning of the constructs across languages, so that all compilers can produce the same "generated code" representation.
        </li>
      </ul>
      <p>
        <em>Standardized codes are part of the plan, but the project hasn't gotten that far along yet [as of 22 March 2000].  Right now, codes and parsers are being created for existing languages.  If nothing else, these parsers will be useful for other people creating metaprograms, but the plan is to identify common elements and factor them out to generate standardized codes.</em>
      </p>
      <hr/>
      <p>
        See also:  <a href="InterLanguageUnification.html">InterLanguageUnification</a> -- an <a href="OpenSource.html">OpenSource</a> <a href="ObjectRequestBroker.html">ObjectRequestBroker</a> from <a href="XeroxParc.html">XeroxParc</a>.
      </p>
      <hr/>
      <p>
        Also check out Intentional Programming.  This is a project being run by <a href="CharlesSimonyi.html">CharlesSimonyi</a> at Microsoft Research.  "IP" provides a development tool for representing programs as a tree of statements called 'intentions'.  Each intention totally defines its action in a language neutral way.  Intentions
        are like super C++ templates.  
      </p>
      <p>
        The intention tree can be "compiled" to a target programming language and platform.  The idea is increase code reuse by several orders of magnitude.    Once a stack data type has been defined once, for example, it never needs to
        be defined again.  Stacks of any size and contents can be derived from the
        basic Stack.
      </p>
      <p>
        I've heard recently that Intentional Programming has moved out of Microsoft
        Research and is now part of a Products division.  We may see something soon.
      </p>
      <p>
        See <a href="http://www.aisto.com/roeder/ip/.">http://www.aisto.com/roeder/ip/.</a> The original
        site at Microsoft Research is not available anymore.
      </p>
      <hr/>
      <p>
        Also search the web for <a href="GenVoca.html">GenVoca</a>.  It's a tool by Don Batory in Texas.  <a href="GenVoca.html">GenVoca</a>
        is tool for defining code constructs in a higher level than program code.  The
        idea is to compose objects out of a series of 'layers'.  Each layer handles a specific aspect of the object.  Layers can be mixed and matched in a very flexible way.  One example was a tree data type whose memory allocation layer
        could be one of: a fixed array (for speed), a series of large RAM blocks (for large in-memory trees), and a full distributed memory system (for terrabyte sized trees).
      </p>
      <hr/>
      <p>
        Host www.prism.cx is unknown on 22/08/2001.
      </p>
      <hr/>
      <p>
        <a href="CategoryProject.html">CategoryProject</a>
      </p>
    </div>
  </body>
</html>