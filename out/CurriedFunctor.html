<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Curried Functor
      </h1>
      <p>
        <a href="FunctionalProgrammingLanguage.html">FunctionalProgrammingLanguage</a>s support <a href="CurryingSchonfinkelling.html">CurryingSchonfinkelling</a> (aka <a href="CurriedFunction.html">CurriedFunction</a>s). A similar concept can be supported in Object Oriented language environments using <a href="FunctorObject.html">FunctorObject</a>s. 
      </p>
      <p>
        Recall that <a href="HigherOrderFunction.html">HigherOrderFunction</a>s implement general behaviors that can be parameterized with specialized functions. The <a href="HigherOrderFunction.html">HigherOrderFunction</a> implements some high level protocol and delegates the details of the operation to one or more specialized functions. Often there is a specialized function available that can perform a required subtask but that will require more parameters than the <a href="HigherOrderFunction.html">HigherOrderFunction</a> is prepared to supply. In a <a href="FunctionalProgramming.html">FunctionalProgramming</a> language a new function can be created from such a function by calling it with only the missing parameters. The result is a <a href="CurriedFunction.html">CurriedFunction</a> that acts exactly as if it has the missing parameters cached along with a reference to the original function. When the rest of the parameters become available they can be supplied to the <a href="CurriedFunction.html">CurriedFunction</a> and it will act as it were the original function with all of the parameters supplied at once.
      </p>
      <p>
        In an Object Oriented programming enviornment we use <a href="FunctorObject.html">FunctorObject</a>s so that we can emulate the function manipulations that are possible in a <a href="FunctionalProgramming.html">FunctionalProgramming</a> language. Likewise we can use <a href="CurriedFunctor.html">CurriedFunctor</a>s to emulate <a href="CurriedFunction.html">CurriedFunction</a>s. 
      </p>
      <p>
        <strong>Implementation:</strong>
      </p>
      <p>
        Add invocation methods (versions of operator() in C++) that take a subset of the ordinarily required parameters to <a href="FunctorObject.html">FunctorObject</a> definitions. Implement these methods by creating a new <a href="FunctorObject.html">FunctorObject</a> (a <a href="CurriedFunctor.html">CurriedFunctor</a>) that holds the values of the parameters as well as a reference to the original <a href="FunctorObject.html">FunctorObject</a>. Implement the invocation method of the <a href="CurriedFunctor.html">CurriedFunctor</a> by calling the original <a href="FunctorObject.html">FunctorObject</a> with both the stored parameters and the newly supplied parameters.  
        Large gains in efficiency can be made if parts of the function can be pre-calculated especially if the new functor is to be used several times and most especially if certain input values will cause the function to degenerate into (values of zero or one will often cause terms in mathematical functions to simply disappear.) There is a danger to this however: if the intermediate results rely on the state of the system, and the state of the system changes before they are used, then the final result will be incorrect.
      </p>
      <hr/>
      <p>
        <a href="CategoryObjectFunctionalPatterns.html">CategoryObjectFunctionalPatterns</a>
      </p>
    </div>
  </body>
</html>