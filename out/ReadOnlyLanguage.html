<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Read Only Language
      </h1>
      <p>
        The complement to a <a href="WriteOnlyLanguage.html">WriteOnlyLanguage</a>. A language where working programs are obvious in their intent, but unexpectedly difficult to construct.
      </p>
      <hr/>
      <p>
        A term often applied to (for example) <a href="AppleScript.html">AppleScript</a>. When Applescript was originally designed, <a href="MacOs.html">MacOs</a> only used <a href="CooperativeThreading.html">CooperativeThreading</a>, which put a very large latency cost on inter-process communication. To fight this, Applescript was designed to send very high level commands to targeted programs. So, rather than asking for an interface to a collection of objects, then asking for the third element, a single AppleEvent would bundle up both the object and the concept of "third". The <a href="AppleEventObjectModel.html">AppleEventObjectModel</a> went as far as supporting a kind of <a href="ListComprehension.html">ListComprehension</a>, which was exposed in Applescript syntax as expressions involving "every/each", "where/whose", and associated relational tests. When it worked well, it leads to compact yet readable code like this:
      </p>
      <code>
        tell application "Finder"<br/>
        set f to folder "Documents" of home<br/>
        set my_list to every item of f whose name starts with "A"<br/>
        end tell<br/>
      </code>
      <p>
        The downside of this approach was that implementing the high level semantics of the AppleEvent model was left up to the recipient of the event. For example, the Finder must be able to get a collection of "items" from a folder reference, implement the "whose" message on a collection of "items", and the implementation must support the "starts with" clause -- all from unpacking one AppleEvent.  Most target applications fall short of a complete implementation, and no two fell short in the same way.
      </p>
      <p>
        The experience of writing <a href="AppleScript.html">AppleScript</a> was one of writing the program you want to write, discovering that some message is not supported by the object you're targeting, then rewriting to avoid using that type of event -- for example, if you discover you cannot access an object by name, you fall back on retrieving the list of object references and then write a loop querying each one's name in turn.
      </p>
      <p>
        Now that <a href="MacOsx.html">MacOsx</a> programs are largely written in <a href="ObjectiveCee.html">ObjectiveCee</a>, it is reportedly much easier to wire up a standard AppleEvent interpreter to an application's object model.
      </p>
    </div>
  </body>
</html>