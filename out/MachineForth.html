<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Machine Forth
      </h1>
      <p>
        A significantly reduced set of and in some cases redefined semantics for Forth primitives.  The intention is to take advantage of the existing microprocessor as much as possible as a stack CPU.  Many CPUs are amazingly adept at doing this, with only relatively minor amounts of compiler intelligence.  Resulting binaries offer adequate (but certainly not stellar) performance, and is often possible with a compiler measuring only a few hundreds of bytes.
      </p>
      <p>
        Typical characteristics of a <a href="MachineForth.html">MachineForth</a> include:
      </p>
      <ul>
        <li>
           Tail recursion elimination
        </li>
        <li>
           Non-destructive IF (in ANSI Forth, IF pops the value it tests off the stack; in <a href="MachineForth.html">MachineForth</a>, IF actually tests the CPU's <em>zero flag</em> directly).
        </li>
        <li>
           A new core word, -IF, is used to quickly check for less-than-zero conditions.
        </li>
        <li>
           <strong>?</strong>, <strong>0=</strong>, or some other primitive to set the CPU's zero-flag correctly for the benefit of IF.
        </li>
        <li>
           <strong>0<</strong> or similar primitive to set the CPU's negative-flag correctly for the benefit of -IF.
        </li>
        <li>
           Compiled words have no headers in the output image; the output of a <a href="MachineForth.html">MachineForth</a> compiler is very often a static binary image, as you'd get from, say, a C compiler.
        </li>
      </ul>
      <p>
        Despite the fact that <a href="MachineForth.html">MachineForth</a> actually is at a lower-level than ANSI Forth when starting out, it still is a meta-language, and hence, can evolve towards higher levels of abstraction very quickly.  Due to the reduction in control flow and tail recursion elimination, it can often do so more compactly as well.
      </p>
      <hr/>
      <p>
        See <a href="http://www.colorforth.com/forth.html">http://www.colorforth.com/forth.html</a> for a sample mapping of <a href="ColorForth.html">ColorForth</a> primitives, derived from an earlier set of <a href="MachineForth.html">MachineForth</a> primitives, and how they map to Intel Pentium machine language instructions.  The chart isn't as clear as I'd like, but it saves me from having to cut-n-paste-n-clean-up here.
      </p>
      <hr/>
      <p>
        Contrast with <a href="AnsForth.html">AnsForth</a>.
      </p>
      <p>
        See also <a href="SeaForthArchitecture.html">SeaForthArchitecture</a>
      </p>
    </div>
  </body>
</html>