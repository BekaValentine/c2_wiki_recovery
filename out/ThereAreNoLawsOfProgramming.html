<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        There Are No Laws Of Programming
      </h1>
      <p>
        In Webster's New World Dictionary (2nd ed. 1978), there are 13 definitions of the word <strong>law</strong>.
        Excluding all the definitions related to legal/judicial, religious, and sports, we have these: "8. a) a sequence of events in nature or in human activities that has been observed to occur with unvarying uniformity under the same conditions: often <em>law of nature</em>; b) the formulation in words of such a sequence [the law of gravitation, the law of diminishing returns]; 9) any rule or principle expected to be observed [the laws of health, the law of grammar]; 10) inherent tendency; instinct [the law of self-preservation]; 12) <em>Math., Logic, etc.</em> a general principle to which all applicable cases must conform [the laws of exponents]."
      </p>
      <p>
        The software industry is too young to <em>know</em> any particular principles solidly enough to declare any "laws."  We are still exploring and learning, trying different paradigms, methodologies, languages, and other tools.
      </p>
      <p>
        We have grown and developed some reasonably good skills and knowledge, and some of us are pretty pleased with ourselves for this.  Some of us are starting to try to make bold statements about what we think we understand about building software, and a few of us are naive enough to think these might be "laws."
      </p>
      <p>
        But they aren't; they are merely theorems, observations, tendencies, heuristics, and so on at this point.  Maybe in another fifty or a hundred years, we'll be a better position to start discussing "Laws Of Software Engineering."
      </p>
      <p>
        Consider "9) any rule or principle expected to be observed".  I think we do have rules or principles that are expected to be observed in software development.  This is, by far, the most common use of the term law, and would seem to contradict the title of this page.
      </p>
      <hr/>
      <p>
        I see three broad categories to which the word <strong>Law</strong> is applied
      </p>
      <ol>
        <li>
          ) Laws of Nature - these are models which tell us what the effects of a given cause will be, <em>if</em> certain assumptions hold true. They are usually formulated based on observation. If an observation does not conform to one of these Laws then it is probably because the assumptions were not true
        </li>
      </ol>
      <ol>
        <li>
          ) Civil and Criminal Law - these represent what the Legislature of a particular  state hold to be acceptable behavior for subjects of that state. Failure to comply will attract sanction by the Executive of that state, usually after interpretation by a Judiciary.
        </li>
      </ol>
      <ol>
        <li>
          ) Natural and Moral Law - Natural Law is believed by it's proponents to be innate to all Humans - the internal guidelines which cause us to view certain behavior as good. Moral Law expands on this, usually based on Divine Revelation. It's proponent's would contend that failure to adhere to Moral Law will cause the subject not to attain it's full potential.
        </li>
      </ol>
      <p>
        It seems to me that the Laws of Programming fall somewhere between these three definitions! <a href="AonghusOhAlmhain.html">AonghusOhAlmhain</a>
      </p>
      <p>
        <em>In other words, they aren't laws at all.</em>
        Actually, what I meant is that they have elements of each of the above 
      </p>
      <hr/>
      <p>
        I don't believe this maturity business. We programmers have forgotten more in fifty years than "software engineers" ever knew. My first law of software engineering is <em>follow the money</em>: 1. state cuts back on funding for university, 2. university administration demands computer science department serve the business community (so as to get local money), 3. business executives ask for engineering discipline where programmer's work is as predictable as assembly line, 4. faculty creates terminal masters in software engineering and staffs it with adjunct professors from local industry, 5. these guys rummage around for some curriculum and find something made up by someone who misunderstood what civil engineers do, 6. industry finds productivity drops precipitously and confuses the poison for the cure, 7. everyone involved finds that if they just sing this party line that the money keeps circulating. The software engineering crowd would have done better teaching anything by, say, <a href="ChrisArgyris.html">ChrisArgyris</a>, or anyone else who understands knowledge based activity. -- <a href="WardCunningham.html">WardCunningham</a>
      </p>
      <p>
        <em>Ward, don't get hung up on the term "software engineering."  It sounds like you've seen some shabby academic programs; I haven't seen them directly, but I've definitely run into the results as coworkers who can't program their way out of a paper bag.  I tend to use it because it sounds better than "programming"; because I feel that what I do involves more than slinging code.  My degree was in "Computer Science."  But I feel that I learned most of what I use on a day to day basis myself, more in the spirit of hacking and pragmatism.  After 25 years, I know what works, and I don't let myself get tangled up by any particular methodology, language, diagram, or whatever.</em>
      </p>
      <p>
        I wouldn't call the programs either shabby or academic, though I would say misguided and uninformed. An experienced developer was telling me just last week that his new boss, a young woman, had asked for a day by day list of tasks and had protested when he added two weeks for unspecified clean-up. He argued that his 25 years of experience had shown that such was always required. She said no way and offered as her credential a newly minted Masters in Software Engineering Management.
      </p>
      <p>
        <em>So, to get to the point of this page, do you feel that people building software (whatever term you want to use to refer to them) have gained enough fundamental understanding of what works and what doesn't to start declaring absolute "laws"?</em>
      </p>
      <p>
        I wouldn't use the term "law" either, but I find RodneyRyan's observations pretty close to the mark and worthy of more than superficial ridicule.
      </p>
      <p>
        <em>I'm sorry you perceive my comments about "laws" as "superficial ridicule" -- I certainly didn't intend it that way.  I feel it is important that a good concept be phrased as carefully as possible.  It is human nature that many words come with lots of baggage, so an unfortunate choice of words can end up limiting the understanding of a very good concept.  Personally, if I put something up here that is poorly conceived or written or doesn't make sense, or could be improved by rephrasing </em>(yes, including this page!)<em>, I would hope people would say so.  (In fact, this has already happened... I consider it a strength of </em><a href="WikiWiki.html">WikiWiki</a>.)<em></em>
      </p>
      <hr/>
      <p>
        Suppose there were laws of programming and I broke one.  Who would stop me?  The programming police?  -- <a href="NickBensema.html">NickBensema</a>
      </p>
      <p>
        I guess <em>law</em> in this sense is a broad generalization of reality. No one will get into trouble for breaking <a href="MooresLaw.html">MooresLaw</a>, or the LawOfGravity, though I have heard arguments for repeal of the latter. -- <a href="DavidBrantley.html">DavidBrantley</a>
      </p>
      <p>
        To break Ryan's laws you would have to code carelessly and find that this made your work go faster or you would have to find a mature design in your documents while monkeys typed the code. If either were to happen I'd check the radar gun. -- <a href="WardCunningham.html">WardCunningham</a>
      </p>
      <p>
        I don't mind if you go faster than the speed of light.  Who's going to stop you?--<a href="ApoorvaMuralidhara.html">ApoorvaMuralidhara</a>
      </p>
      <hr/>
      <p>
        Much of what <a href="JerryWeinberg.html">JerryWeinberg</a> has written, including <em>Secrets of Consulting</em> and the <em>Quality Software Management</em> set uses Laws as organizing principles around which to better understand the complex systems we're dealing with.  Jerry uses somewhat comical and unusual names for some of these Laws (cf. <em></em><a href="LawOfRaspberryJam.html">LawOfRaspberryJam</a><em>), in order to help himself (and us too) remember them better.  As a trained physicist, this seemed the natural thing for him to do.  The </em>Square Law of Computation<em>, is a natural law which helps explain much of the difficulty of large software systems development.</em>
      </p>
      <hr/>
      <p>
        <em>A programmer's experience is inverse to their fundamentalism. They know their only limits are computer science and karma</em>
      </p>
      <hr/>
      <p>
        <em>8. a) a sequence of events in nature or in human activities that has been observed to occur with unvarying uniformity under the same conditions</em>
      </p>
      <p>
        If you don't make a special effort to keep the structure of a body of code clean as things are added to it, it doesn't stay clean.  That is, structure degrades unless effort is made to preserve it.
      </p>
      <p>
        If that phenomenon is not a law of programming (in sense 8a), I don't know what is.
      </p>
      <p>
        If you're developing code and value it being clean, that leads to a law of programming (sense 9): make an effort to keep your code clean.  (The reasons you value clean code may be laws (8a) of their own: e.g. cleaner code requires less effort to modify; cleaner code requires less effort to test; etc.)
      </p>
      <hr/>
      <p>
        See <a href="FirstLawOfProgramming.html">FirstLawOfProgramming</a>, <a href="SecondLawOfProgramming.html">SecondLawOfProgramming</a>, <a href="TheyreJustRules.html">TheyreJustRules</a>, <a href="ShuHaRi.html">ShuHaRi</a>
      </p>
    </div>
  </body>
</html>