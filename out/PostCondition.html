<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Post Condition
      </h1>
      <p>
        Pre-conditions and post-conditions are used in formal specification to specify an operation, which is essentially a state change.  Typically, any conditions not specifically stated as post-conditions are not constrained.  For example, a deletion operation in which element <em>n</em> is deleted from set <em>S</em> has a post-condition that <em>n</em> is not in <em>S</em>.  To work properly, it also needs a post-condition that says that all other elements of <em>S</em> before the deletion, except for <em>n</em> are still in <em>S</em> afterward.  When describing operations in terms of pre-conditions and post-conditions, you are stating only the essential <em>what</em>, carefully avoiding the <em>how</em>.  Note the close relationship between specifications and tests.
      </p>
      <hr/>
      <p>
        Here is a testing strategy: use post conditions like <a href="UnitTest.html">UnitTest</a>s. Inside the
        method when it is done with the work it has to do it tests its result to
        see if it is as expected. This checking can be much more specific than
        an Assertion. As a simple example if the method computes sqrt(x), the 
        post condition can test if result*result==x.
      </p>
      <p>
        <em>assert(result * result == x);</em>
      </p>
      <p>
        <strong>Good idea, bad example. Think </strong>RoundingError.<strong></strong>
      </p>
      <p>
        The main advantage here is that the state information is fresh and easily
        accessible inside the method. Some of this will be lost when the <a href="UnitTest.html">UnitTest</a> gets
        around to examining the outcome.
      </p>
      <p>
        There is a cost in execution speed. If this is significant then use macros 
        to conditionally compile these post conditions. Or leave them in (<a href="ShipWithAssertionsOn.html">ShipWithAssertionsOn</a>)
        and have a  live monitoring system constantly test your code as it runs. The 
        post conditions could log errors and be otherwise non-obtrusive (<a href="ReportBugsSilently.html">ReportBugsSilently</a>).
      </p>
      <p>
        Here is an example: a database is updated and then tested to see if the 
        updated record has the correct values. It is easier to describe a thing
        than it is to construct it. And so this testing of correctness is easier 
        than the computation. -- <a href="AsimJalis.html">AsimJalis</a>.
      </p>
      <p>
        The downside is that all of the post conditions can greatly inflate the code, making it harder to read. <em>which is why it is best to associate the contracts with interfaces, not the implementation.</em>
      </p>
    </div>
  </body>
</html>