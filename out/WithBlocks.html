<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        With Blocks
      </h1>
      <p>
        A "with block" is a form of <a href="SyntacticSugar.html">SyntacticSugar</a> -- a way of saying "I'm going to do a couple (or a bunch) of things with this one instance of this structure/record/class, so please assume that the following method/property/field accesses are relative to this object."
      </p>
      <p>
        See also <a href="WithBlockCodeSmell.html">WithBlockCodeSmell</a> -- largely an argument that you shouldn't use WITH blocks.
      </p>
      <hr/>
      <p>
        <strong>[</strong><a href="VisualBasic.html">VisualBasic</a>]<strong></strong>
      </p>
      <p>
        In <a href="VisualBasic.html">VisualBasic</a> and most variations, one can simplify the syntax of multiple method/property calls to the same object, like this:
      </p>
      <code>
        With ActiveDocument:<br/>
        .SaveAs "backup.doc"<br/>
        Set HeaderTable = .Tables(1)<br/>
        Set AddressTable = .Tables(2)<br/>
        Set InvoiceTable = .Tables(3)<br/>
        End With<br/>
        HeaderTable.Select   ' selects ActiveDocument.Tables(1)<br/>
      </code>
      <p>
        Unfortunately, <a href="VbScript.html">VbScript</a> doesn't have With blocks, making this kind of code much uglier, and perhaps even slower (see the bit on dereferencing in Pascal below).
      </p>
      <hr/>
      <p>
        <strong>[</strong><a href="PascalLanguage.html">PascalLanguage</a>]<strong></strong>
      </p>
      <p>
        <a href="PascalLanguage.html">PascalLanguage</a> has had "with" statements since the very beginning, and they're still present in current implementations, such as Borland's <a href="DelphiLanguage.html">DelphiLanguage</a>. On the plus side, they can make the code much more readable. On the minus side, they can lead to bugs that cause you to tear your hair out, because you can't see what's right in front of you, namely that the variable named Foo is actually SomeObject.Foo and not the outer-level Foo that you think it is. I've pretty much given up on using "with" in my own code, although there are times when I look wistfully at a tedious-looking block of code and consider relenting.
      </p>
      <p>
        <em>(aside: Visual Basic gets around this problem by assuming that all variables are specified as usual, only assuming an object member if the name is preceded by a dot.)</em>
      </p>
      <p>
        There used to be another advantage for using "with":  If you had some (Delphi) code that looked like this...
      </p>
      <code>
        MyObject.Foo := 42;<br/>
        MyObject.Bar := 'forty-two';<br/>
        MyObject.Baz := MyOtherObject.Baz;<br/>
      </code>
      <p>
        then the compiler would have to dereference the MyObject pointer for each and every statement. Using "with" meant doing the dereferencing only once:
      </p>
      <code>
        with MyObject do begin<br/>
        Foo := 42;<br/>
        Bar := 'forty-two';<br/>
        Baz := MyOtherObject.Baz end;<br/>
      </code>
      <p>
        But nowadays, the Delphi optimizer is smart enough to factor out the pointer dereferencing, even if you write code that looks like the first example. -<a href="SteveSchafer.html">SteveSchafer</a>
      </p>
      <p>
        Err... how can a "with" block remove the dereference of the MyObject pointer?  I can see how the code below could reduce pointer dereferences by caching the value of O1.O2.O3 and avoiding multiple dereferences through O1 and O2, but in the code above I cannot imagine how use of the MyObject pointer could be avoided.
      </p>
      <code>
        with O1.O2.O3 do <br/>
        begin<br/>
        Foo := 42;<br/>
        Var := 'forty-two'<br/>
        end<br/>
      </code>
      <p>
        The "with" block doesn't eliminate <em>all</em> dereferencing of the MyObject pointer, only the <em>redundant</em> dereferencing. Let's look at what goes on when accessing MyObject.Foo (we'll assume that Foo is a simple field of the object). MyObject is a variable that holds a pointer to the actual object instance, allocated on the heap. Given
      </p>
      <code>
        MyObject.Foo := 42;<br/>
      </code>
      <p>
        this is the code generated by the Delphi 5.0 compiler:
      </p>
      <code>
        mov eax,[MyObject]  // get the value of the pointer to <br/>
        // MyObject into the EAX register<br/>
        mov [eax+32],42     // offset that value by 32 to get to the Foo field,<br/>
        // then store the value 42 into that location<br/>
      </code>
      <p>
        Now, in the naive (Delphi 1.0) implementation, repeated references to MyObject.<whatever> would cause the EAX register to be reloaded from the MyObject variable each time, whereas a "with" block would cause it to be loaded only once. Since Delphi 2.0, the compiler's optimizer has been able to figure out that it doesn't need to do the repeated register reloads, even without the "with" block. -ss
      </p>
      <hr/>
      <p>
        <strong>[</strong><a href="CobolLanguage.html">CobolLanguage</a>]<strong></strong>
      </p>
      <p>
        COBOL has "MOVE CORRESPONDING source-structure TO destination-structure" which copies the values of all fields with the same names, recursively.
        This is not the same as a <a href="PascalLanguage.html">PascalLanguage</a>/<a href="VisualBasic.html">VisualBasic</a> "with" statement, but in some ways it's a related concept.
      </p>
      <hr/>
      <p>
        <strong>[</strong><a href="SmalltalkLanguage.html">SmalltalkLanguage</a>]<strong></strong>
      </p>
      <p>
        <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> has semicolons for this purpose:
      </p>
      <code>
        Transcript show: 'a'; show: 'b'.<br/>
      </code>
      <hr/>
      <p>
        <strong>[</strong><a href="CeeLanguage.html">CeeLanguage</a>, <a href="CeePlusPlus.html">CeePlusPlus</a> and other block structured (<a href="AlgolFamily.html">AlgolFamily</a>) languages]<strong></strong>
      </p>
      <p>
        In C++, and most other languages, you can create an extra locally-scoped variable to hold the common subexpression:
      </p>
      <code>
        {<br/>
        Document *d = activeDocument;<br/>
        d->SaveAs( "backup.doc" );<br/>
        d->SetHeaderTable( tables[1] );<br/>
        d->SetAddressTable( tables[2] );<br/>
        d->SetInvoiceTable( tables[3] );<br/>
        } // d goes out of scope here.<br/>
      </code>
      <p>
        It just comes out with the wash if you write short functions. This would become a function with a signature like:
      </p>
      <code>
        void SetTables( Document *d, const Table tables[3] );<br/>
      </code>
      <p>
        and called with activeDocument as argument.
      </p>
      <p>
        or 
      </p>
      <code>
        activeDocument->SetTables(tables);  //at which point you should see why with smells.<br/>
      </code>
      <p>
        <em>[see </em><a href="WithBlockCodeSmell.html">WithBlockCodeSmell</a>]<em></em>
      </p>
      <hr/>
      <p>
        [<a href="PythonLanguage.html">PythonLanguage</a>]
      </p>
      <p>
        As in C++, you can create an extra variable to hold the common subexpression. Yet, unlike C++, there are no curly braces in Python to limit its scope and name visibility.
      </p>
      <code>
        # reference to object<br/>
        annoyinglyLongNameForActiveDocument = Document()<br/>
      </code>
      <code>
        # new reference to existing object<br/>
        d = annoyinglyLongNameForActiveDocument<br/>
        d.saveAs('backup.doc')<br/>
        d.setHeaderTable(table[1])<br/>
        d.setAddressTable(table[2])<br/>
        d.setInvoiceTable(table[3])<br/>
        # delete d from namespace now (<a href="GarbageCollection.html">GarbageCollection</a> happens later)<br/>
        del d<br/>
      </code>
      <code>
        # object and long reference still exist<br/>
        annoyinglyLongNameForActiveDocument.saveAs('backup.doc')<br/>
      </code>
      <p>
        Although it's perfectly doable, using this construct could indicate poor design in your program (<a href="WithBlockCodeSmell.html">WithBlockCodeSmell</a>).
      </p>
      <hr/>
      <p>
        <strong>[</strong><a href="RubyLanguage.html">RubyLanguage</a>]<strong></strong>
      </p>
      <p>
        I know of instance_eval in <a href="RubyLanguage.html">RubyLanguage</a>, but I suspect it's not a true analogue of the above.
      </p>
      <p>
        <em>True, but you can easily write this</em>:
      </p>
      <code>
        def with(obj,&block)<br/>
        obj.instance_eval &block<br/>
        end<br/>
        with 'foo' do<br/>
        puts size #=> 3<br/>
        puts self #=> foo<br/>
        end<br/>
      </code>
      <p>
        <em>Nice showing of blocks' power, ain't it?</em>
      </p>
      <hr/>
      <p>
        <strong>[</strong><a href="JavaScript.html">JavaScript</a>]<strong></strong>
      </p>
      <p>
        In <a href="JavaScript.html">JavaScript</a> you can use "with". The runtime will search the provided object for fields and methods before searching the normal search path:
      </p>
      <code>
        with ( activeDocument ) {<br/>
        saveAs("document.doc");<br/>
        setHeaderTable( tables[0] );<br/>
        setAddressTable( tables[1] );<br/>
        }<br/>
      </code>
      <hr/>
      <p>
        <strong>[</strong><a href="CommonLisp.html">CommonLisp</a>]<strong></strong>
      </p>
      <code>
        (with-slots (a b)<br/>
        obj<br/>
        (setf a 1<br/>
        b 2))<br/>
      </code>
      <p>
        You can avoid any aliasing problems by renaming the slots. eg.
      </p>
      <code>
        (let ((a 42))<br/>
        (with-slots ((aa a) b)<br/>
        obj<br/>
        (setf aa 99<br/>
        b 2))<br/>
        (values a (slot-value obj 'a))) => 42, 99<br/>
      </code>
      <p>
        with-accessors is also available.  with-accessors works the same way but deals with the object's accessors (generic functions) rather than directly with the instance variables.
      </p>
      <hr/>
      <p>
        <strong>[</strong><a href="IoLanguage.html">IoLanguage</a>]<strong></strong>
      </p>
      <p>
        Object (the top-level prototype) provides the do message, which evaluates all its contents in that object's scope. Often used to produce the analogue of a class definition:
      </p>
      <code>
        NewObj := Object clone do (<br/>
        method_one := method(do_stuff)<br/>
        method_two := method(do_other_stuff)<br/>
        )<br/>
      </code>
      <hr/>
      <p>
        Is there anything similar in other languages? <em></em><a href="PerlLanguage.html">PerlLanguage</a>'s <a href="DollarUnderscore.html">DollarUnderscore</a> construct? or is that another can of worms?<em></em>
        <em>Yes, Perl is a can of worms.</em>
      </p>
      <p>
        Perl is a <em>cannery</em> of worms.
      </p>
      <p>
        <em>Perl can worm its way out of anything.</em>
      </p>
    </div>
  </body>
</html>