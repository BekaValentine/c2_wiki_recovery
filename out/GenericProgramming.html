<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Generic Programming
      </h1>
      <p>
        To quote <a href="AlexanderStepanov.html">AlexanderStepanov</a>:
      </p>
      <dl>
        <dt> </dt>
        <dd>Generic programming is a programming method that is based in finding the most abstract representations of efficient algorithms. That is, you start with an algorithm and find the most general set of requirements that allows it to perform and to perform efficiently. The amazing thing is that many different algorithms need the same set of requirements and there are multiple implementations of these requirements.</dd>
      </dl>
      <p>
        Generic programming arose out of Stepanov's work with <a href="AdaLanguage.html">AdaLanguage</a>, and was then moved over to <a href="CeePlusPlus.html">CeePlusPlus</a> to form the <a href="StandardTemplateLibrary.html">StandardTemplateLibrary</a>.  It's also been argued that Lisp supported generic programming well before Stepanov's work, in the form of macros.  <a href="LispMacro.html">LispMacro</a>s (combined with <a href="DynamicTyping.html">DynamicTyping</a>) allow one to express any code fragment in terms of its barest parameters, allowing a level of abstraction that <a href="TemplateMetaprogramming.html">TemplateMetaprogramming</a> is only beginning to match.
      </p>
      <p>
        In some ways, generic programming is simply <a href="WellFactoredCode.html">WellFactoredCode</a>.  The process of breaking a system into reusable chunks will naturally lead to more abstract and generalized routines.  One possible difference is that generic programming seeks to determine the most general representation in isolation, while <a href="ReFactoring.html">ReFactoring</a> only generalizes code as the client system requires.
      </p>
      <p>
        There is some confusion in C++ circles over the definition of <a href="GenericProgramming.html">GenericProgramming</a>, as the most common use for the STL is to provide parameterized container types.  This is an instance of generic programming (it seeks to make code more general), but is more properly termed <a href="ParametricPolymorphism.html">ParametricPolymorphism</a>.  Generic programming also covers parameterization over behavior (<a href="HigherOrderFunction.html">HigherOrderFunction</a>s) and the use of interfaces or <a href="TypeClasses.html">TypeClasses</a> to specify algorithm requirements.
      </p>
      <p>
        <a href="ConceptCpp.html">ConceptCpp</a> introduces <a href="GenericProgramming.html">GenericProgramming</a> into <a href="CeePlusPlus.html">CeePlusPlus</a> in a more rigorous way and can be used, for example, to enforce requirements when using the STL.
      </p>
      <hr/>
      <p>
        <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a> <em>requires</em> generalizing code via <a href="ReFactoring.html">ReFactoring</a> in order to simplify the implementation. By this method, many abstractions precipitate out of the code, abstractions that we wouldn't even see otherwise. There's the rub. How do you know what abstractions are useful? And how do you know your abstractions are usefully implemented? Yes, there are standard data structures and algorithms. But anything from a specific problem domain we probably won't understand enough to abstract until we write a few systems, as per the <a href="RuleOfThree.html">RuleOfThree</a>. (See also <a href="ThreeStrikesAndYouRefactor.html">ThreeStrikesAndYouRefactor</a>, <a href="ThreeStrikesAndYouAutomate.html">ThreeStrikesAndYouAutomate</a>, <a href="UseBeforeReuse.html">UseBeforeReuse</a>.) Usually, writing the abstraction up-front is <a href="PrematureAbstraction.html">PrematureAbstraction</a>.
      </p>
      <p>
        At the very least, you need to leave the abstraction in flux, even if you know up-front that you'll need an abstraction <em>and</em> know the problem domain. When I write a reusable class-library for a domain in which I am expert, I find I need to tweak the library's <a href="ApplicationProgrammingInterface.html">ApplicationProgrammingInterface</a> for the first few applications that use it, no matter how thorough my planning was. This is true even if that planning involved analyzing other implementations. Most of the tweaked library code ends up being refactored from the applications themselves.
      </p>
      <p>
        --<a href="TimKing.html">TimKing</a>
      </p>
      <hr/>
      <p>
        <a href="GenericProgramming.html">GenericProgramming</a> was pioneered in other languages prior to STL/templates in C++, but did the name "generic programming" itself come from Stepanov? I can't clearly recall.
      </p>
      <p>
        Thanks for creating this page; I've been referencing it for a long time. :-) -- <a href="DougMerritt.html">DougMerritt</a>
      </p>
      <ul>
        <li>
           I think I made this comment back in Jan 2004 or so...how time flies...
        </li>
      </ul>
      <hr/>
      <p>
        In this day and age, comments about <a href="GenericProgramming.html">GenericProgramming</a> in Java and C# would doubtless be of interest.
      </p>
      <hr/>
      <p>
        <a href="CategoryNotOo.html">CategoryNotOo</a>
      </p>
    </div>
  </body>
</html>