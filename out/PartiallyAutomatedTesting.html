<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Partially Automated Testing
      </h1>
      <p>
        Some types of software are not amenable to <a href="AutomatedTesting.html">AutomatedTesting</a>:
      </p>
      <ul>
        <li>
           <a href="GuiTesting.html">GuiTesting</a> -- Automated tests for GUI components are usually difficult to write and are very brittle (they need to be rewritten whenever any change is made to the window being tested)
        </li>
      </ul>
      <ul>
        <li>
           <a href="WebTesting.html">WebTesting</a> -- You can automatically test whether the expected HTML is generated, but you need human eyes to determine whether various web browsers render the display as expected.
        </li>
      </ul>
      <ul>
        <li>
           Monitoring and control of external devices -- You may need a person to turn devices on and off or manipulate them in some fashion to get them into the states needed for tests. The only way to totally automate this would be to buy some robots.
        </li>
      </ul>
      <p>
        For such software, some resort to manual testing where a person follows a written test script and records the results.
      </p>
      <p>
        A middle ground is a testing regime that is moderated by the machine. It displays test steps and waits for a human tester to perform the step and then indicate whether the test passed or failed. For example, it might display a dialog box like the following:
      </p>
      <code>
        Tests.testModemOffline<br/>
        ======================<br/>
      </code>
      <code>
        Turn off the modem.<br/>
        Click the "Send Message" button in the application window.<br/>
      </code>
      <code>
        Did the application display a message box indicating that the modem is offline?<br/>
      </code>
      <code>
        [Yes] [No] [Skip] [End Tests]<br/>
      </code>
      <p>
        Such tests can be specified using the same <a href="TestingFrameworks.html">TestingFrameworks</a> used for fully automated tests. Each test can be as simple as displaying a message box and then asserting that the answer is Yes or No. You can take advantage of those frameworks' test runners and reporting features.
      </p>
      <p>
        A partially automated test suite ensures that all steps are followed in a repeatable fashion although it cannot ensure 
        that the human tester is doing the job properly. The obvious downside to such tests is that they are time-consuming 
        and labor-intensive. It is not cost-effective to run all the partially automated tests after every refactoring. They 
        should be kept separate from the fully automated tests that you do run after every minor change.
      </p>
      <p>
        Besides <a href="RegressionTests.html">RegressionTests</a>, another use of partially automated tests is as <a href="AcceptanceTest.html">AcceptanceTest</a>s. Rather than trying to convince witnesses that a <a href="GreenBar.html">GreenBar</a> proves that everything worked, you can demonstrate test steps that are obviously doing something.
      </p>
      <p>
        Having external device tests with your regular test suite can really slow down progress. You can use <a href="MockObject.html">MockObject</a>s to <a href="UnitTest.html">UnitTest</a> your code and have a separate test suite to test your actual external interfaces which will be much slower.
      </p>
    </div>
  </body>
</html>