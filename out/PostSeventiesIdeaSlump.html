<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Post Seventies Idea Slump
      </h1>
      <p>
        Have ideas stagnated since the 70's? By the 70's we had:
      </p>
      <ul>
        <li>
          [Original heading which caused the paragraph "ideas have not ceased" to be created] This page contains ideas which were generated as a result, whether they be Software, Hardware, Software Schemas, and any ideas affecting the field of computing. It you wish to confine your contribution exclusively to <a href="SoftwareEngineering.html">SoftwareEngineering</a> ideas, please use <a href="PostSeventiesSoftwareEngineeringIdeaSlump.html">PostSeventiesSoftwareEngineeringIdeaSlump</a>.
        </li>
      </ul>
      <ul>
        <li>
           Lisp and <a href="FunctionalProgramming.html">FunctionalProgramming</a>
        </li>
        <li>
           OOP (via Simula and <a href="SmallTalk.html">SmallTalk</a>)
        </li>
        <li>
           <a href="RelationalModel.html">RelationalModel</a>
        </li>
        <li>
           <a href="StructuredProgramming.html">StructuredProgramming</a> (reduced use of Goto's)
        </li>
        <li>
           GUI's (Sutherland, PaloAlto)
        </li>
        <li>
           Intranet (known as "Arpanet" I think) - Or more generally, reduntant-path package routing. 
        </li>
        <li>
           Collaboration - <a href="XanaduProject.html">XanaduProject</a>
        </li>
        <li>
           Multitasking pre-emptive OS's (in mainframes back then)
        </li>
        <li>
           Open-source software model
        </li>
        <li>
           Bad Pants
        </li>
      </ul>
      <p>
        <img src="http://www.geocities.com/tablizer/70s_style.jpg" />
      </p>
      <p>
        Most new ideas are just rehashes or refinements of these. Nothing really new has come since. So get out your plaid pants and afro wigs and shake your booty.
      </p>
      <p>
        ''Methinks you're going to play the game called '<a href="NoTrueScotsman.html">NoTrueScotsman</a>' regarding what means a 'NewIdea'.  There is no idea that is not built upon or derived from other ideas, and it is impossible to express a new idea except in terms of old and better understood ideas.  I see, below, that many of your <strong>bold counters</strong> rely upon the notion that the idea has antecedents.  To be frank, so does everything on your list.  Put away your afro wig and plaid pants... put on a toga.<em> -- </em>'Any true Scotsman knows that it's not an afro, it's a SeeYouJimmyHat. :) By the way, I'm not in bold to SHOUT, just to distinguish myself from the person who was posting in<strong> <em>italic</em> </strong>. (More shortly, including hopefully some <a href="ViolentAgreement.html">ViolentAgreement</a>, the other WikiCliche we can't go without.)<strong></strong>
      </p>
      <hr/>
      <p>
        No, ideas have not ceased:
      </p>
      <ul>
        <li>
           Laptop and Palmtop computers operable from anywhere a wireless phone works (PointOfAccess)
        </li>
        <li>
           News, Weather, and millions of tunes available worldwide
        </li>
        <li>
           <a href="SoftwareDevelopment.html">SoftwareDevelopment</a> tools available to anyone who owns a computer, programmer or not.
        </li>
        <li>
           Data processing capability exceeding that of Corporations in the 50's, 60's and early 70's on the desktop of a computer setting on top of a small desk in the corner of a room.
        </li>
        <li>
           FlashDrives the size of your little finger holding (circa mid 2007) 8 Gigabytes of data plug compatabile to any computer with a USB Connection
        </li>
        <li>
           DigitalCameras approaching resolutions of (and perhaps soon exceeding) that of film in cameras the size of a deck of cards with the number of pictures which can be taken exceeding hundreds and thousands (and even 10 thousands - at lower resolutions) Some even doubling as CamCorders.
        </li>
        <li>
           <a href="SearchEngine.html">SearchEngine</a>s - allowing the discovery of billions of facts and items of information, images and sound, at PointOfAccess.
        </li>
        <li>
           VirtualComputation and <a href="VirtualReality.html">VirtualReality</a>. <strong></strong>BattleZone (1980), earlier FlightSimulators<strong></strong>
        </li>
        <li>
           High-Resolution, High-Speed Multi-User-Gaming (Way beyond Wumpus) 
        </li>
        <li>
           Social Communities and ChatNetworks
        </li>
        <li>
           PersonalInformationManagers
        </li>
        <li>
           <a href="WikiWiki.html">WikiWiki</a> -- <strong>See </strong><a href="OnLineSystem.html">OnLineSystem</a> (1968)<strong></strong>
        </li>
        <li>
           Input Devices which detect hand or other types of motion, speech, eye-movement, key-clicks as events processable by software
        </li>
        <li>
           Output Devices which print or display on a LcdScreen letters, images, colors, vectors, graphs and which play multichannel sounds. -- <strong>LCD display was anticipated as part of </strong><a href="DynaBook.html">DynaBook</a>; the <a href="SmallTalk.html">SmallTalk</a> systems (among others) were already doing graphics, animation and sound. SuperPaint (see <a href="DealersOfLightning.html">DealersOfLightning</a>) manipulated colour video.<strong></strong>
        </li>
        <li>
           Input/Output devices with feedback sensation. -- <strong>Haptic systems have been researched and used for decades.</strong>
        </li>
        <li>
           LocationDetection and LocationDisplay and <a href="MetaData.html">MetaData</a> about the location, available worldwide at PointOfAccess
        </li>
        <li>
           <a href="ActorsModel.html">ActorsModel</a>, <a href="CommunicatingSequentialProcesses.html">CommunicatingSequentialProcesses</a>, <a href="PiCalculus.html">PiCalculus</a>, <strong>All of these are either actually from the '70s, or have strong '70s backgrounds and antecedents.</strong> <em>CSP is 85, and </em><a href="PiCalculus.html">PiCalculus</a> is 1992.  Typing for the <a href="ActorsModel.html">ActorsModel</a> is definitely post-70s.  In any case, your statement involving <strong>strong '70s backgrounds and antecedents</strong> is misleading; I could say that almost all formal languages we use have <strong>strong 350BC background</strong>, but it doesn't mean they don't contain new ideas.<em> </em>'The CSP book is 1985; the first CSP paper is 1978. (The first CCP paper is 1980.) Typing and formalising Actors and similar models is surely an important achievement (I didn't write the text at the top) but it doesn't seem to outshine the importance of developing such models in the first place. The influence from CSP to the <a href="PiCalculus.html">PiCalculus</a> is appreciably more direct than that from Euclidean geometry.<strong> <em>Euclid wasn't born until 323 BC.  I was actually alluding to Aristotle, who used a formal notation for logic.  The influence from logic notation to lambda-calculus, and from lambda-calculus to pi-calculus is quite direct... and the idea of using a formal notation to describe and discuss difficult concepts is certainly antecedent to all programming languages and models.</em></strong>
        </li>
        <li>
           considerable advances in <a href="TypeTheory.html">TypeTheory</a>  -- <strong>True, but again </strong><a href="MlLanguage.html">MlLanguage</a> had been implemented by 1974.<em>' </em>... which is entirely irrelevant.  <a href="TypeTheory.html">TypeTheory</a> has advanced a great deal even after <a href="MlLanguage.html">MlLanguage</a> was implemented in 1974.<em> </em>'Again, yes, it has. But it's hardly<strong> <em>irrelevant</em> </strong>that ML dates from 1973, since it not only set the paradigm for languages like <a href="HaskellLanguage.html">HaskellLanguage</a> and <a href="ObjectiveCaml.html">ObjectiveCaml</a> but is a fairly direct ancestor to them.<em>'  </em>You seem to be under the mistaken impression that ML and its descendents (Haskell, OCaml) embody the only significant advances in <a href="TypeTheory.html">TypeTheory</a>.  I recall sub-structural and protocol typing, dependent typing, types as service contracts, process typing, object-typing based on views rather than heirarchy, and various other advanced type systems.  I'll also point out that ML's type-inferencing is nice, but it isn't actually significant to type <strong>theory</strong>; you can at most infer those types that your type theory supports.  If I were to point to a language that better embodies type theory advances of the 70s, it'd be OBJ.<em></em>
        </li>
        <li>
           <a href="CascadingStyleSheets.html">CascadingStyleSheets</a>, HTML, XML (admittedly based in SGML which is based in IBM's GML - 1960).  
        </li>
        <li>
           Modelling languages - VRML, <a href="PovRay.html">PovRay</a>, etc. -- <strong>Things like </strong><a href="OpenGl.html">OpenGl</a> and current RayTracing systems are descended from work which was underway at EvansAndSutherland and the <a href="UniversityOfUtah.html">UniversityOfUtah</a>, among other places, since the late '60s.<strong></strong>
        </li>
        <li>
           TeX, LaTeX (dunno the <a href="WikiWord.html">WikiWord</a>) -- <strong>Work on </strong>TeX had begun by 1977/8. And without understating the importance of TeX, it wasn't the first computerised typesetting system.<strong></strong>
        </li>
        <li>
           RSS (<a href="ReallySimpleSyndication.html">ReallySimpleSyndication</a>)
        </li>
        <li>
           <a href="RemoteProcedureCall.html">RemoteProcedureCall</a> (1976), <a href="WebServices.html">WebServices</a> (IBM SNA and TN3270, 1974), <a href="ServiceOrientedArchitecture.html">ServiceOrientedArchitecture</a> (esp. with real ServiceContracts; possibly found in CICS (1974 also)?).
        </li>
        <li>
           PublicKeyCryptography (DiffieHellman, RSA both ~1977) - many ideas for applications thereof are post 70s.
        </li>
        <li>
           <a href="PeerToPeer.html">PeerToPeer</a> filesharing; <a href="BitTorrent.html">BitTorrent</a>
        </li>
        <li>
           <a href="ExtremeProgramming.html">ExtremeProgramming</a>, <a href="PairProgramming.html">PairProgramming</a>, Blogs, <a href="SocialComputing.html">SocialComputing</a>
        </li>
        <li>
           Interconnected, Interactive Computing machines with installed working software made available at low cost to the masses (at WalMart or KMart or Sears) and not just the reserve of research labs, large corporations, government and academic institutions
        </li>
        <li>
           USB, HomeNetworks, <a href="WiFi.html">WiFi</a>, Computing while travelling (air, rail, bus, car passenger, etc), GPS and the associated revolution made possible by it
        </li>
        <li>
           WebCams, ChatRooms, WebCasting of audio and videos, PersonalWebServers
        </li>
        <li>
           Spreadsheets, WordProcessors, PresentationEnvironments, TouchScreens, VoiceAndVisualRecognition, WorldwideReservationSystems
        </li>
        <li>
           Scanners and All-in-One IO devices, Digitizers
        </li>
        <li>
           BBSs, ElectronicPublishing, Shareware, Freeware. <a href="OpenSource.html">OpenSource</a>, WorldwideCollaboration, SoftwareDevelopmentRepositories, AutomaticUpdates, Viruses, Worms, Anti-Virus Software
        </li>
        <li>
           ComputerizedAnimation
        </li>
      </ul>
      <p>
        <em>Most of the above are about hardware advances. The topic was meant to be about software engineering. I reworked the intro to make this more clear. Althought it is true there've been new programming languages, none of them have any significant new ideas in them. At best, they are a good packaging of pre-known ideas.</em>
      </p>
      <p>
        The advances above are advances in "ideas", hardware does not operate in a vacuum, it requires software to function. Software exists to make hardware "work". The advances made to make the items in the above are primarily advances in Human/Machine Interfacing. Software not only operates using algorithms and processes, it also operates by responding to "events". What makes most of the above ideas work is software handling events through interfaces to move data as directed by the user while the user's computer is running the software. <em>If this is defined as merely good packaging of pre-known ideas, and not the implementation of new ideas, then what old, pre-known activity can be defined as doing the "packaging"?</em> -- <a href="DonaldNoyes.html">DonaldNoyes</a>
      </p>
      <ul>
        <li>
           What specific software ideas in them are revolutionary? Event-driven programming is not new. PIM's are just miniaturized mini- or microcomputers.(microcomputers did not exist such that the average person could use them in the 1970's) (Hmmm. Maybe wavelet-based media compression qualifies as a post-70's revolutionary idea. But, it tends to be a specific-use idea.)
        </li>
      </ul>
      <ul>
        <li>
           <em>The idea that millions of users can control and change what their personal computer does while it is running based on user input devices is revolutionary and post-1970. The management and organization of information and the availabilty of billions of bytes of information via software-driven search engines which learn, adapt and accumulate based on user's queries, is revolutionary and post 1970. The existance of extensible programming environments and data-driven, user-centric environments is revolutionary and post 1970. -- </em><a href="DonaldNoyes.html">DonaldNoyes</a><em></em>
        </li>
      </ul>
      <ul>
        <li>
           "The idea that millions of users can control and change what their personal computer does while it is running based on user input devices  is revolutionary and post-1970." -- <strong>In fact it's 1963 (</strong><a href="SketchPad.html">SketchPad</a>) or earlier (<a href="MemexVision.html">MemexVision</a>).<strong></strong>
        </li>
      </ul>
      <ul>
        <li>
           "The existance of extensible programming environments and data-driven, user-centric environments is revolutionary and post 1970." -- <strong>Possibly (but again, see </strong><a href="SketchPad.html">SketchPad</a>), but it's certainly not post sevent<strong> <em>ies</em> </strong>(ie. post-1979). The end of the "golden age" is usually put to something like 1974 or even 1979-ish.<strong></strong>
        </li>
      </ul>
      <ul>
        <li>
           Search engines have incrementally improved over the years. There is no one revolutionary idea. Mostly it is the hardware that got faster. Even Google's famous reference-based linking rank is similar to research article citation tracking, which is an old idea. Plus, text search is a specific niche, not a wide-spread software-engineering technique. It still is not clicking.
        </li>
      </ul>
      <p>
        <em></em><a href="InformalHistoryOfProgrammingIdeas.html">InformalHistoryOfProgrammingIdeas</a> suggests "patterns" and UML are revolutionary. Patterns are merely an attempt to classify certain coding idioms. Giving names to something does not by itself make it new. (Plus, some people, such as <a href="PaulGraham.html">PaulGraham</a>, feel that patterns are signs of a lacking language or paradigm.) And UML diagrams have similarities to ideas that existed for decades. It is merely an attempt at standardization.<em></em>
      </p>
      <p>
        I think that social processes as well as meta-topics around software-engineering might be new ideas. 
      </p>
      <ul>
        <li>
           Example of processes: <a href="ExtremeProgramming.html">ExtremeProgramming</a> of course (1999)
        </li>
        <li>
           Example of meta: <a href="http://en.wikipedia.org/wiki/Software_Engineering_Body_of_Knowledge">http://en.wikipedia.org/wiki/Software_Engineering_Body_of_Knowledge</a> (1998)
        </li>
      </ul>
      <p>
        Some might disqualify these as they are deemed not formal and fundamental enough, but then one could easily go the opposite way and exclude most on of the list at the top and say that only electricity and math are formal enough.
      </p>
      <hr/>
      <p>
        Perhaps the post-70s period seems to suffer an "idea slump" because we're still too close to it to identify the ideas that are becoming, or will become, influential.
      </p>
      <p>
        And also because contemplated ideas may take years to centuries to become implemented ideas, and because the implementation of the idea may take on facets and twists not contemplated fully by the many original ideas which become part of its realization. A perfect illustration of this can be seen in the ideas and sketches of <a href="LeonardoDaVinci.html">LeonardoDaVinci</a> regarding manned flight and submersible ships. An IdeaImplemented is most often conglomerations of more than one IdeaConceived. --<a href="DonaldNoyes.html">DonaldNoyes</a>
      </p>
      <p>
        <em>But I have not seen any decent candidates even.</em> 
      </p>
      <p>
        <strong>Only because you reject candidates that build upon, derive from, or advance ideas from pre-70s.  You could do the same for pre-1870s.  Every idea has antecedents.</strong>
      </p>
      <p>
        Perhaps it could be said that 40's-to-70's is when the key software engineering ideas we use today were identified, described, and recognized as fairly distinct and powerful ideas. Darwinian evolution was indeed hinted at many times before Darwin, but he "opened the book" on it. Same with Dr. Codd (relational). 
      </p>
      <p>
        [Very true.  The <a href="ElderDays.html">ElderDays</a> established the essential foundations of computing.  The "no, ideas have not ceased" list is one of relatively narrow iterative refinement and commercial application of <a href="ElderDays.html">ElderDays</a> foundations -- or outright obviousness.  There is not an item in that list that does not rely on <a href="ElderDays.html">ElderDays</a> foundations, and there are few (if any) ideas in the list that are equal in generality or significance to any <a href="ElderDays.html">ElderDays</a> foundations.]
      </p>
      <p>
        [Every industry goes through a "Golden Age" of significant research, invention, and innovation, where genuinely new territory is explored.  In the automotive industry, for example, its <a href="ElderDays.html">ElderDays</a> were roughly from the late 1800s to the late 1930s.  Virtually everything currently found in a modern car was either theoretically or practically explored at that time.  Apparently modern innovations like airbags, anti-lock braking, emissions controls, electronic fuel injection, lightweight materials, hybrid power, etc., are all iterative refinements to pre-existing foundational work, and only appear to be significant to those unfamiliar with the history of the foundations that made them possible.  Current automotive "innovation" is little more than applications of basic ideas, the majority of which are nearly a century old.  Similarly, modern computing is little more than application of the basic ideas established in the <a href="ElderDays.html">ElderDays</a>.] 
      </p>
      <p>
        By this reasoning there have been no significant ideas in math and physics since hundresth of years. I think you have to refine your condition for 'significance' somewhat and will realize, that it's not as easy as you think. -- .gz
      </p>
      <p>
        [There is a clear and obvious distinction between fundamental theoretical research and trivial technological development.  In physics, for example, no one would confuse the development of (say) string theories with the invention of a better mouse trap.  Yet, above, we have clear "mouse trap" entries like <a href="CascadingStyleSheets.html">CascadingStyleSheets</a>, <a href="RemoteProcedureCall.html">RemoteProcedureCall</a>, and <a href="ReallySimpleSyndication.html">ReallySimpleSyndication</a>.  None of these required extensive research or any significant intellectual effort.  They might be somewhat clever applications of existing technology, but that does <strong>not</strong> make them important in any foundational sense.  In scientific terms, they are trivial.  This is not meant to diminish their industrial significance, but to regard <a href="CascadingStyleSheets.html">CascadingStyleSheets</a> as on par with (say) the <a href="RelationalModel.html">RelationalModel</a> is as ludicrous as treating the discovery of general & special relativity as on par with developing a slightly smaller portable MP3 player, or treating the invention of the internal combustion engine as equivalent to making a better windshield wiper.  In terms of its pervasive foundational significance, there is an order of magnitude difference between the work done in the <a href="ElderDays.html">ElderDays</a> and the bag of gadgets listed above.  Admittedly, there are some fuzzy areas -- like the "advances in <a href="TypeTheory.html">TypeTheory</a>" -- but let's not insult the true innovators and researchers in computing by making the ludicrous claim that (say) <a href="ReallySimpleSyndication.html">ReallySimpleSyndication</a> is somehow a significant idea, by <strong>any</strong> meaning of the term "significant".] 
      </p>
      <p>
        <em>Only if you disregard the millions of computer users who daily employ the implementation of this idea (RSS). You might consider usage of idea implementations as one measure of </em>'significance<strong>. Success of an idea demonstrated by its widespread use is in my view </strong>significant<strong>.  It is obvious to me that significance of ideas is based on </strong><a href="ItDepends.html">ItDepends</a> on who you are, and the value system you wish to use in determining what is <strong>significant</strong>, and what is "trivial".  -- <a href="DonaldNoyes.html">DonaldNoyes</a> 20070712<em></em>
      </p>
      <p>
        I imagine that many of what you consider 'weak' ideas like <a href="CascadingStyleSheets.html">CascadingStyleSheets</a> will be derived from and built upon to far greater extent.  After all, <a href="CascadingStyleSheets.html">CascadingStyleSheets</a> is simply an implementation of an even greater idea: separation of content and presentation.  If it can be done for 2D text, it can be done for 3D Virtual Reality objects and by Display Agents -- <a href="CascadingStyleSheets.html">CascadingStyleSheets</a>, or some derivative thereof, will become pervasive to the point of being part of every HumanComputerInterface you care to name.  Many ideas of the 70s have borne fruit that is visible today, and a great many more have fallen to the wayside and been forgotten except in computer lore (<a href="UseNet.html">UseNet</a>, anyone?).  You can expect the same of many ideas of the 80s, 90s, and today -- some will advance beyond what you currently imagine, and others will fade away.  Heck, it isn't too late for old 70s ideas to fade away.  I expect that the <a href="RelationalModel.html">RelationalModel</a> will be surpassed by ideas already present, including RDF and much of what is listed in <a href="WhatIsData.html">WhatIsData</a> and <a href="KnowLedge.html">KnowLedge</a>... if only because computer agents (future of 'Web3.0') must know what a 'tuple' means by context if it is to perform any sort of learning or <a href="DataMining.html">DataMining</a> across vast stores of information.
      </p>
      <p>
        The author of the bracketed argument above is also grossly underestimating the relative 'intellectual effort' and 'ideas' that went into practical implementations of such things as RemoteProcedureCalls, <a href="CascadingStyleSheets.html">CascadingStyleSheets</a>, and <a href="ReallySimpleSyndication.html">ReallySimpleSyndication</a>.  Fact is, a ballpark notion of where you want to be is just one idea... it takes finding and implementing of detailed ideas to get there... ideas on how to combine one idea with another.  
      </p>
      <p>
        Modern <a href="TypeTheory.html">TypeTheory</a> will probably gain real use no earlier than twenty years down the line.  Users of languages evolve far slower than the languages and language theory currently does, and code-base inertia prevents any rapid change.  However, I expect that the <a href="LanguageOfTheFuture.html">LanguageOfTheFuture</a> will let you use any damn syntax you please (from Befunge to Occam, and even graphical programming like <a href="SmallTalk.html">SmallTalk</a>) and will be tightly integrated with the OS of the future.  Look at <a href="LanguageOfTheFuture.html">LanguageOfTheFuture</a> and <a href="NewOsFeatures.html">NewOsFeatures</a> if you want a list of 'ideas' a long, long way from implementation.  Just glancing at one -- the <a href="ExoKernel.html">ExoKernel</a> -- shows an idea that's been around since circa 1994 but not yet in common use that very well might be the future design-path of all <a href="OperatingSystem.html">OperatingSystem</a>s.  And there are wild ideas, too, like <a href="KillMutableState.html">KillMutableState</a>.  We don't know where all of them are going, and which will turn out to be duds... and which will disappear for fifty years only to appear again when another, newer, idea makes it practical.
      </p>
      <p>
        [<a href="KillMutableState.html">KillMutableState</a> was well implied at least as far back as 1967, by D. L. Childs in "Description of a Set-Theoretic Data Structure".  I don't deprecate the notion of CSS or the broader principle it represents.  I simply reject the notion that it is anything new or innovative, or that it represents the starting point of separating data and presentation.   Such notions have been implicit best practice for decades, with early browsers and HTML actually being a step backward in terms of separating data and presentation.]
      </p>
      <p>
        [You young'ns who genuinely believe the above list represents worthwhile, significant, theoretical innovations would be wise to review some history, starting with reading some of the classic papers in computer science.  You'll be surprised to see how little is new, and how much is simply old wine in new bottles.] <strong>A new bottle IS a new idea.  An idea is just a way of looking at, packaging, or combining other ideas, after all.</strong>
      </p>
      <p>
        [As for RDF, or the content of <a href="WhatIsData.html">WhatIsData</a> or <a href="KnowLedge.html">KnowLedge</a> having any significance at all, let alone surpassing the <a href="RelationalModel.html">RelationalModel</a>... I'll believe it when any of said content becomes the basis of a working multi-terabyte OLTP database or it's echoed in a Knuth volume.  Until then, I'm not holding my breath.]
      </p>
      <p>
        [Imagine that RSS magically disappeared tomorrow morning.  Would the computing world grind to a halt?  No.  A few million users would be slightly inconvenienced by not receiving their daily force-feed of <a href="SlashDot.html">SlashDot</a> posts or whatever, but computing as a whole would be unaffected and Something Else would be easily devised to replace RSS.  The same goes for every item on the list above: take it away and there might be <em>inconvenience</em>, but that's it.  Now imagine that the B-Tree algorithm -- an <a href="ElderDays.html">ElderDays</a> invention from 1971 -- magically disappeared tomorrow morning.  Furthermore, imagine that the B-Tree algorithm is magically replaced with something <em>similar</em>, but slightly poorer performance on any criteria you like.  Though this is obviously wild hypothesising, it is quite likely that the computing world <em>would</em> grind to a halt.  Magically replace RSS with something similar but poorer performance?  I doubt anyone would even <em>notice.</em>  That's why the B-Tree is a foundational <a href="ElderDays.html">ElderDays</a> product, while RSS is a trivial and uninteresting grain of sand on the vast computing landscape.  In ten years, I bet no one will even remember it.]
      </p>
      <p>
        <em>Imagine if the very idea of communicating just disa-</em>
      </p>
      <p>
        [Tee hee... :) ]
      </p>
      <p>
        {RSS, XML, and CSS are commonly used because they are an <strong>industry standard</strong>, not because they are revolutionary. There are plenty of things I would change about CSS if given a choice. It is almost like listing the QWERTY keyboard as revolutionary because it is common. Being a standard does not count for much by itself in the context of this topic. By the way, some argue that Lisp <a href="EssExpressions.html">EssExpressions</a> would be better or equal to XML. Much of the popularity and utility of the web is driven by standardization. But none of those standards are fresh ideas.}
      </p>
      <p>
        <em>I, too, would change many things about CSS... but how, exactly, would I change them?  I've put perhaps fifty hours of study into how one might go about using a variation on the idea behind CSS to automatically transform the artistic styles of virtual worlds (e.g. between cartoony, gritty-realistics, surrealistic like Salvador Dali, etc.).  In particular, my goal was to allow user-constructed characters to traverse one user-constructed 'world' to another and automatically adapt to that world's art style, along with all the items the user carries, and also reduce rework wrgt. models for constructing the worlds (e.g. so a chapel-model would also transform between worlds).  This was 'inspired' by seeing the use fo CSS.  However, while I have an idea what I want and several ideas for approaches, I've not yet been able to find what I'd consider a satisfactory approach to get what I want; at best, I've proven that it will require attaching a great deal of semantic information as hooks into model data, and that model-data must be expressed as constraints on the output (and animation) rather than exacting point data.  i.e. so the model can be recognized as the same (or at least as a unique model in entirely surrealistic settings) from one world to another despite otherwise significant changes.  Using those constraints intelligently, however? that's where the semantic information comes in (I want a </em>'object/man-made/furniture/table<strong> with a </strong>object/natural/plant/vine<em>' 'growing around (or 'engraved upon' or 'engraved into') the table's base' and various other features and constraints...), but making use of that semantic information, expressing constraints, and performing transformations on the constraints/features is difficult, and I still lack ideas for it.</em>  
      </p>
      <p>
        <em>How, exactly, would YOU change CSS? and to what effect?  Or are you out of ideas the moment that question is asked?  Ideas ideas ideas... it takes a lot of ideas to get from an idea of what you want to an idea of how to get there.  As far as XML, I'd rather just skip it entirely and use a typed language for data expression that handles both macro and functional expansion... and possibly syntax extension.  You always need to have an understood language to initiate communication, but the language can self-extend during communication.  Just recycle a language for macro expansion that handles the whole of </em><a href="KolmogorovComplexity.html">KolmogorovComplexity</a> and be done with it!<em></em>
      </p>
      <ul>
        <li>
           Perhaps a discussion on the merits and alternatives to CSS should be put into a different topic.
        </li>
      </ul>
      <p>
        I didn't refer to the gadget list. My list would look more like this (from my not so small references repository):
      </p>
      <ul>
        <li>
           <a href="HigherOrderLoopOptimization.html">HigherOrderLoopOptimization</a>s
        </li>
        <li>
           <a href="ParallelControlAbstraction.html">ParallelControlAbstraction</a>s 
        </li>
        <li>
           FormalModularExceptionHandling
        </li>
        <li>
           IntegrationOfTheoremProvingAndProgrammingLanguages
        </li>
        <li>
           <a href="RemoteEvaluationAlgorithm.html">RemoteEvaluationAlgorithm</a>s (like future pipelining)
        </li>
      </ul>
      <ul>
        <li>
           type theory (cited above)
          <ul>
            <li>
               type types, 
            </li>
            <li>
               type displays 
            </li>
            <li>
               type encodings
            </li>
            <li>
               algebraic types
            </li>
            <li>
               type inference
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           parser theory
          <ul>
            <li>
               incremental scanner generation
            </li>
            <li>
               grammar compaction
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           lots of <a href="IncrementalAlgorithms.html">IncrementalAlgorithms</a>
        </li>
      </ul>
      <p>
        ...
        just ask for more -- .gz
      </p>
      <p>
        I'll add wait-free atomic containers (heaps, lists, sets, maps, etc.).  Those will be damn important when data is distributed widely on nodes across a network... since waiting on a lock held by a node that stops talking is ridiculous and insane.  Oh, and I'll add all the newer theories regarding Network Survivability (which constitutes far more than failure tolerance... it constitutes resistance to -attack- and -natural disaster-) and Disruption Tolerant Networks.  Many of those ideas will be necessary even in software engineering and protocols of the future, since overlay networks will become more and more common.
      </p>
      <p>
        [My complaint was with the "ideas have not ceased" list.  Your list is far more worthy than any that considers WebCams and Blogs to be examples of fertile idea-smithing and productive intellectual toil.  Some day, portions of your list might become as influential and foundational as the work done in the <a href="ElderDays.html">ElderDays</a>.] 
      </p>
      <p>
        <strong>Time as Judge</strong>
      </p>
      <p>
        <em>I reject your position.  This page isn't: </em>PostSeventiesWorthyIdeaSlump.  And you are not the correct judge as to whether a particular idea is worthy... only society and time will determine whether an idea sees use or becomes influential.  And the vast majority of ideas cannot be foundational.  WebCams and Blogs could just as easily influence future ideas (<strong>including</strong> the manner in which (associated or similar) software is engineered) as those from <a href="TypeTheory.html">TypeTheory</a> or any given model or approach to computation or information storage or processing.<em></em>
      </p>
      <p>
        It took about 15 or 20 years before most of the listed ones were clear shiners. Thus if this pattern continues, 80's ideas should start being revered by now. But they are not. Was 80's just a coincidental gap?  (I know I try to forget that decade :-)
      </p>
      <p>
        <em>Maybe not coincidental.  I imagine that the 80s was a period of idea assimilation (that, and the microcomputer was a new hit wonder), and the 90s were loaded with ideas regarding how to use the tool new to the majority of humanity: </em>TheInternet.  Both times were loaded with ideas and derivative ideas, making practical some of the concepts merely fancied in the seventies and earlier.  Your dismissal of the intellectual effort that went into such products and their influence today is in error, but such ideas are harder to point at or put in a list.  The devil is in the details when you're the one implementing them.<em></em>
      </p>
      <p>
        [My "dismissal", as you call, it is not one of error vs. non-error, but simply a reiteration of an observation of evolution in an enduring industry.  See, for example, <a href="http://lambda-the-ultimate.org/node/2059">http://lambda-the-ultimate.org/node/2059</a>  
      </p>
      <p>
        The term "Elder Days" or "Golden Age" or whatever exists because it is commonly recognised that the computer industry, like many other industries, goes through distinct phases:
      </p>
      <ul>
        <li>
           "Elder Days" -- a phase of numerous pervasive innovations and breakthroughs, academic fertility, research, and theoretical development, but limited access (or interest) except to an intellectual elite.  Such a period is rich in novel ideas, where "novel" is unambiguously recognised as such.  This is clearly an "idea" phase, characterised by academic growth.
        </li>
        <li>
           post-"Elder Days" -- a period of persistent technical implementation and wide-scale accessibility, but relatively little theoretical research, innovation or novel ideas.  However, the definition of "novel" (or "ideas"!) may be subject to debates like this one.  This is clearly a "building" phase, characterised by commercial growth.
        </li>
        <li>
           Stasis -- a period of stability, entrenchment and iterative refinement, with relatively little technical or theoretical development.  This is a "maintenance" phase, characterised by commercial consolidation and academic stagnation.  
        </li>
      </ul>
      <p>
        If computing follows the pattern of the automotive industry -- which has arguably reached statis -- it will reach a point of negligible new development, where minor tweaks are heralded as breakthroughs by marketing departments, but no one (outside of Marketing or naive observers) would claim the ideas are, well, <em>ideas</em>.  Of course, some theoretical innovation or discovery (to a limited degree, work on these always continues) may be sufficiently revolutionary to spark a new "Elder Days", and thus renew the cycle.
      </p>
      <p>
        It must be emphasised that I do not deprecate any of these phases, nor do I attempt to put one above another in some fashion; I merely wish to highlight the fact that there <em>is</em> a <a href="PostSeventiesIdeaSlump.html">PostSeventiesIdeaSlump</a> (end of "Elder Days"), but it has been balanced by a PostSeventiesImplementationBoom (post-"Elder Days").  That boom is what the "ideas have not ceased" list is about, and there is clearly a qualitative difference between the nature of the ideas spawned in the <a href="ElderDays.html">ElderDays</a> vs. most of the "ideas" since.  While it's difficult to articulate precisely <em>what</em> makes the development of (say) the B-Tree or Prolog different from developing a Web camera or CSS in terms of "idea-ness", that difference is unquestionably there.]
      </p>
      <p>
        "but no one (outside of Marketing or naive observers) would claim the ideas are, well, ideas." -- <em>So you're saying that those who argue with you are either in Marketing or are naive observers?  How very kind of you.</em>
      </p>
      <p>
        <em>There are, of course, qualitative differences in how the ideas are applied and among those who recognize the ideas.  However, I'm not all that convinced there is a qualitative difference in the development of the ideas, or their </em>'idea-ness<em>'.  Nor am I convinced that the world of computation science has entered a stasis, at least among fields involving automated theorem proving and type-theory, network survivability & disruption tolerance.  It seems to have entered a new phase of pre-implementation work on OS design, compiler optimizations, and HCI as people try to get past what is currently a rather stagnant forms of the same (i.e. there's a lot of talk in these fields about what ought to be done, but little actual change).</em>
      </p>
      <ul>
        <li>
           Note that the original issue was software engineering (organizing software and information for easier maintenence and quality control), and not "computer science". Issues of domain-specific breakthroughs, such as theorem proving or automated burger cooking, are thus not considered.
          <ul>
            <li>
               Theorem Proving applies very directly to a great many aspects of Software Engineering and Computer Science: (1) type checking (for all computer languages), (2) service-contract proofs (for <a href="ServiceOrientedArchitecture.html">ServiceOrientedArchitecture</a> of the future), (3) constraints-based programming (which, while an old idea, is still emerging very slowly... can't really say we 'have it' yet), (4) code safety analysis (very useful in software engineering for organizing and qualifying code), etc.  Don't diss it.  'Domain Specific' it is not.
            </li>
            <li>
               <em></em><a href="ServiceOrientedArchitecture.html">ServiceOrientedArchitecture</a> has hardly taken the industry by storm, and still faces a lot of skepticism.<em></em>
              <ul>
                <li>
                   The current approaches to <a href="ServiceOrientedArchitecture.html">ServiceOrientedArchitecture</a> are not convenient or easy to work with.  Service oriented languages will need to replace what is currently a cobbled-together collection of communications and implementations components that lacks much by way of unity or verification.  However, SOA is very much superior to most other models wrgt. gluing together communicating systems.  One  need only communicate, after all, for one of exactly two reasons: (a) to request a service of the recipient of the communication (including actuation or the negotiation of further service), (b) as part of fulfilling a service, possibly by calling on other services.  As such, SOA matches programmer intention exactly.   Skepticism towards extant approaches to SOA is well deserved, but SOA is still the approach of the future for networked operation across domains... and probably even within the local OS (since the most natural way to describe an OS is as a collection of interdependent services).  Theorem provers will be valuable when developing means to prove that a particular service implementation will fulfill some description of a service contract (including requirements and constraints and communications protocols).  
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <em>As far as phases go... development of new ideas slows down when building atop older ideas only because it takes people a long time to master the old ideas.  There's a lot of educational territory to cover before you reach the frontier.  What you seem to be looking for aren't new ideas, but new 'revolutionary breakthroughs' -- ideas (e.g. models and theories) that, by themselves, open entirely new fields (new frontiers) of study, even if they aren't at all practical until someone starts advancing them through the more normal evolutionary development.</em>
      </p>
      <hr/>
      <p>
        Ancient Quotes (perhaps 600 BC): 
      </p>
      <ul>
        <li>
            "The thing that hath been, it is that which shall be; and that which is done is that which shall be done: and there is no new thing under the sun."
        </li>
        <li>
           "Is there any thing whereof it may be said, See, this is new? it hath been already of old time, which was before us."
        </li>
        <li>
           "There is no remembrance of former things; neither shall there be any remembrance of things that are to come with those that shall come after." 
          <ul>
            <li>
               <a href="http://www.bartleby.com/108/21/1.html">http://www.bartleby.com/108/21/1.html</a>
            </li>
          </ul>
        </li>
      </ul>
      <p>
        Not so ancient quote (perhaps 2004):
      </p>
      <ul>
        <li>
           " To describe is perhaps to value" 
          <ul>
            <li>
               <a href="DonaldNoyes.html">DonaldNoyes</a>
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <p>
        Related:
      </p>
      <ul>
        <li>
           <a href="ElderDays.html">ElderDays</a>
        </li>
        <li>
           <a href="NextBigThing.html">NextBigThing</a>
        </li>
        <li>
           <a href="InformalHistoryOfProgrammingIdeas.html">InformalHistoryOfProgrammingIdeas</a>
        </li>
        <li>
           <a href="EarlyHistoryOfSmalltalk.html">EarlyHistoryOfSmalltalk</a>
          <ul>
            <li>
               <a href="http://gagne.homedns.org/~tgagne/contrib/EarlyHistoryST.html">http://gagne.homedns.org/~tgagne/contrib/EarlyHistoryST.html</a>
            </li>
          </ul>
        </li>
        <li>
           Ideas to implement
          <ul>
            <li>
               <a href="WithinTwentyYears.html">WithinTwentyYears</a>
            </li>
            <li>
               <a href="WithinFiftyYears.html">WithinFiftyYears</a>
            </li>
          </ul>
        </li>
        <li>
           <a href="DontLoseGoodIdeas.html">DontLoseGoodIdeas</a>
        </li>
      </ul>
      <hr/>
      <p>
        <a href="JulyZeroSeven.html">JulyZeroSeven</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryHistory.html">CategoryHistory</a>
      </p>
    </div>
  </body>
</html>