<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Digital Logic
      </h1>
      <p>
        Digital logic is logic with discrete <em>states</em>. These states are represented in computers by electrical potentials. These potentials (in the dominate <em>binary</em> logic) get represented as the binary numbers 0 and 1, forming an <em>abstract </em>'software domain<em></em>' independent of the underlying physics.
      </p>
      <p>
        This is in stark contrast to other <a href="ModelsOfComputation.html">ModelsOfComputation</a>, like <a href="LambdaCalculus.html">LambdaCalculus</a> which are generally continuous (analog) states, not discrete. Further they don't use binary numbers or <a href="BinaryArithmetic.html">BinaryArithmetic</a>, but sentential (or "<a href="PredicateLogic.html">PredicateLogic</a>") with True and False.
      </p>
      <p>
        [What's the difference between true/false, 1/0, on/off, black/white, or any other duality? Computers don't really use ones and zeros, you know. They use +3.5V and neutral (or some such system). Why can 3.5V represent one but not true?]
      </p>
      <p>
        One major difference is that numbers (1 and 0) can do arithmetic. Show me some <a href="BinaryArithmetic.html">BinaryArithmetic</a> using black and white states, please. 
      </p>
      <p>
        [A computer doesn't have ones and zeros in it. It uses voltages to represent 1 and 0. A computer could be built that works on colours, using white to represent 0 and black to represent 1. Then black + white = black; white + white = white; black + black = black white; black white + black = black black.]
      </p>
      <p>
        Okay, I suggest you study <a href="ComputerEngineering.html">ComputerEngineering</a>. Your argument shows that you do not know how computers actually work.
      </p>
      <p>
        [Actually, I do. I am a <a href="ComputerScientist.html">ComputerScientist</a> and have worked in <a href="ComputerEngineering.html">ComputerEngineering</a>. Whilst impractical, I could -- in principle, as it would be infeasibly physically large and totally pointless -- build an electro-optical computer that uses colours to represent 1 and 0, using solenoids, coloured cards, coloured acetates, and photocells (plus some simple circuitry to sense the photocells and drive the solenoids). It would only work when well-lit, though. In fact, you can -- in principle, again -- build a computer with no more than switches and mechanisms that flip switches based on other switches state. It could be electrical, or even purely mechanical and powered by a crank. Switch closed = 1; switch open = 0. Of course, you don't need to stick to <a href="BinaryArithmetic.html">BinaryArithmetic</a> -- at least one digital computer was built that used ternary logic. See <a href="http://en.wikipedia.org/wiki/Ternary_computer]">http://en.wikipedia.org/wiki/Ternary_computer]</a>
      </p>
      <p>
        Okay, I will retract my prior statement. I was reading your terms ("black" and "white") as pigments on paper, not light-emitting devices (which, because of physics and the additive properties of light, could be used theoretically to calculate).
      </p>
      <p>
        [A computer could be made that works from pigments on paper, assuming there is some mechanism for writing on the paper -- perhaps a pencil attached to a solenoid -- and a mechanism for sensing pigment or not, such as a photocell.  However, neither this nor the previous example are relying on the additive properties of light to perform computation.  Both examples are simply using light and colour to (somewhat awkwardly) implement switches.  A computer is nothing more than an arrangement of switches and mechanisms that flip switches based on other switches' state.]
      </p>
      <p>
        Many decades of argument in both the <a href="ComputerScience.html">ComputerScience</a> field and the programming community have resulted from this <a href="ConfusedComputerScience.html">ConfusedComputerScience</a>.
      </p>
      <p>
        <em>Oh really?</em>
      </p>
      <p>
        Have you ever composed from one domain to another? Try it, it takes extreme levels of (mis)direction and acts of magic. Have I? No, but I know anyway. It is bizarre and we've just been riding on the "good vibes" of "just believing" that we aren't been tricked, when in fact there has been something very strange going on. But that's all NovusOrdoSeclorum.
      </p>
      <p>
        <em>I don't know what that means.  Your claim is that "[d]igital logic is logic with discrete </em>states<em>" and "</em><a href="LambdaCalculus.html">LambdaCalculus</a> [is] generally continuous (analog) states" and this has caused "[m]any decades of argument in both the <a href="ComputerScience.html">ComputerScience</a> field and the programming community". Can you provide evidence to support either of the latter two quotes? And what does your answer above have to do with it?<em></em>
      </p>
      <p>
        To the former, you might see Babbage's <a href="DifferenceEngine.html">DifferenceEngine</a>. For the latter, I'm referring to discussion among the TYPES mailing list, available in the archives.
      </p>
      <p>
        <em>You're basing your belief in some grand obstructionist debate on a mailing list? A mailing list that, I assume, like all such mailing lists (and this Wiki), is a form of voluntary entertainment where people go </em>'specifically and deliberately<em>' to engage in debate? I'm still baffled. Little help?</em>
      </p>
    </div>
  </body>
</html>