<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Dont Refactor Published Interfaces Mercilessly
      </h1>
      <p>
        From <a href="RefactorMercilessly.html">RefactorMercilessly</a>
      </p>
      <p>
        Unfortunately, <a href="RefactorMercilessly.html">RefactorMercilessly</a> (and some of the other <a href="ExtremeProgramming.html">ExtremeProgramming</a> methods) does not seem like a good match when you're an <a href="OperatingSystem.html">OperatingSystem</a> or ToolsAndLibraries vendor. Once you have a shipping library that third parties depend on, <a href="BinaryCompatibility.html">BinaryCompatibility</a> becomes an essential goal, and the <a href="FragileBinaryInterfaceProblem.html">FragileBinaryInterfaceProblem</a> becomes your enemy. Note that all languages that let a derived class expose anything from a base interface/class suffer from some form of <a href="ModuleDependencyProblem.html">ModuleDependencyProblem</a>, although some (C++) more than others (<a href="SmallTalk.html">SmallTalk</a>).
      </p>
      <p>
        <em>See </em><a href="PublishedInterface.html">PublishedInterface</a><em></em>
      </p>
      <p>
        Also, trying to write complete <a href="UnitTest.html">UnitTest</a>s for an OS or library would mean that you actually implement all the applications that third parties would implement, and verify that it is possible and runs with good performance.
      </p>
      <p>
        Thus, I can see how this all would work for something like an end-of-the-line application on which nothing else has binary dependencies, but it seems less well adapted to other kinds of development. Unfortunately, when you are earlier in the food chain, an error affects so many more people (ALL the users of ALL the applications using your library).
      </p>
      <hr/>
      <p>
        <em>Also, trying to write complete </em><a href="UnitTest.html">UnitTest</a>s for an OS or library would mean that you actually implement all the applications that third parties would implement, and verify that it is possible and runs with good performance.<em></em>
      </p>
      <p>
        I don't see this at all. <a href="UnitTest.html">UnitTest</a>s are discrete tests of interface members. How does this require you to figure out every possible use of your framework or library? Without <a href="UnitTest.html">UnitTest</a>s, you have to wait for the 3rd party to tell you about bugs in your interfaces. Very bad. -- <a href="RobertDiFalco.html">RobertDiFalco</a>
      </p>
      <p>
        I think you are confusing <a href="UnitTest.html">UnitTest</a>s with user tests. A <a href="UnitTest.html">UnitTest</a> doesn't know it's testing an OS. They are much lower level and fine grained. It tests that given certain inputs (valid or not), you get an expected output. Also I don't think units test have anything to do with performance.
      </p>
      <hr/>
      <p>
        Under <a href="ExtremeProgramming.html">ExtremeProgramming</a>, if your end-users are programmers who buy a library, then your <a href="OnsiteCustomer.html">OnsiteCustomer</a> is a programmer responsible for declaring an interface. Your <a href="CustomerTest.html">CustomerTest</a>s will be specifications for an API and its features. Any "refactoring" which breaks these tests should not be <a href="ContinuousIntegration.html">ContinuousIntegration</a>-ed. Hence the entire idea that "<a href="RefactorMercilessly.html">RefactorMercilessly</a>" is somehow not compatible with this or that field is an idea that neglects XP's checks and balances. --<a href="PhlIp.html">PhlIp</a>
      </p>
      <hr/>
      <p>
        <strong>This is a strawman argument.</strong>  One does not refactor interfaces, one refactors code while maintaining the interfaces.  This is part of the basic definition of refactoring.  "Refactoring is the process of changing a software system in such a way that it does not alter the external behavior of the code yet improves the internal structure."  [Martin Fowler, <em>Refactoring Improving the Design of Existing Code</em> p. xvi.]  Refactoring is a disciplined way to clean up code without breaking things, anyone who is blindly changing interfaces is not refactoring, just playing.  Refactoring mercilessly does not endanger interfaces, it protects them.
      </p>
    </div>
  </body>
</html>