<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Is Programming Math
      </h1>
      <p>
        Some people think programming should be viewed as fundamentally based on math. Others think that programmers simply use math in their work, like physicists, mechanical engineers, and ecologists, but that it doesn't follow that programming is math.
      </p>
      <hr/>
      <p>
        Programming was historically built on a mathematical foundation, but is that the case anymore?
      </p>
      <p>
        <em>What mathematical foundation? Some early use of computers may have been in relation to mathematical problems, but that's not at all the same thing as programming having a mathematical foundation.</em>
      </p>
      <p>
        Turing dreamed up his self modifying typewriter to solve a math problem, Hilbert's <a href="EntscheidungsProblem.html">EntscheidungsProblem</a>. All logical computation is math. Programming may not look like it anymore, but everything we do eventually tells a machine to perform mathematical functions in a specific order. 
      </p>
      <p>
        <em>They are not all mathematical functions. Printing "hello" on a screen or drawing GUI buttons isn't all mathematical. It's like claiming that when you paint a house you are just telling the paint can and brush mathematical equations. Some of it is artistic, some of it is engineering.  Some things may be calculated like how much paint to use, or how many buttons or Hello greetings to use, but it certainly is not all math.</em>
      </p>
      <hr/>
      <p>
        No. Programming is logic, and logic isn't math. (Rather, math is the language of science that is expressed using logic.) :) -- <a href="IvanTkatchev.html">IvanTkatchev</a>
      </p>
      <p>
        Logic isn't maths? Since when? <a href="NickKeighley.html">NickKeighley</a>
      </p>
      <hr/>
      <p>
        But since programs are somewhat ethereal in nature, a capacity for understanding symbolic systems and abstractions tends to be useful, even if the techniques, concepts and values of Mathematics are hardly ever used.
      </p>
      <hr/>
      <p>
        <em>There is an obvious difference between programming and math. In math, you cannot say </em><a href="BugFreeDoesntSell.html">BugFreeDoesntSell</a> about proofs.<em></em>
      </p>
      <p>
        I wish that programming was taught like math. In my math courses, you showed all of your work and you were graded primarily on the logic and clarity of your logic in solving the problem. Coming up with the correct result was secondary. In my programming courses, the professors never cared to look at your source code and anything that produced the correct result was acceptable. I think it is time to put this black box hokum behind us and start to teach clarity in code from the start.
      </p>
      <ul>
        <li>
           I agree with the sentiment that code quality needs to improve. However, I'd be mightily pissed if Microsoft responded to a bug report by saying, "Oh sure, Word italicizes when you tell it to make the font bold, but the code that does it is clean and well laid out."
        </li>
      </ul>
      <p>
        Yes, but, if Microsoft were using <a href="DesignByContract.html">DesignByContract</a> we could agree (or not) if the contract were reasonable. (<a href="PreCondition.html">PreCondition</a> font.state=FS) (<a href="PostCondition.html">PostCondition</a>: font.state'=FS+bold) <a href="NickKeighley.html">NickKeighley</a>
      </p>
      <hr/>
      <p>
        Programming most certainly isn't math, but you can make an argument about <strong>computer science</strong> being a (small) corner of discrete math. There are two camps about this. Still, computer science is not programming. CS may be attempting to form a (yet unrealized) solid foundation for the practice of programming, but that certainly doesn't make them equivalent, any more that physics is mechanical engineering.
      </p>
      <p>
        Many programmers would benefit from a little more knowledge of elementary mathematics, but that is not the same thing at all. Almost no programmers are mathematicians, but that is hardly surprising, since mathematicians by and large do mathematics. (Various Wikizens are qualified as both mathematicians and programmers. Perhaps commercial programmers and systems programmers are less likely to be mathematicians, while other categories are more likely to be.)
      </p>
      <p>
        Many programmers have a fairly weak grasp of CS, let alone mathematics. Furthermore, while mathematical techniques exist for many areas in programming, they are often not used. (When was the last time you asked a manager for a confidence interval on a number they come up with, and got one?) This is probably quite variable across the industry.
      </p>
      <hr/>
      <p>
        A huge number of the things that human beings do can be usefully studied mathematically. That does not make them mathematics. Furthermore, the act of using mathematics in what you do does not make you a mathematician. As for programming specifically, there are vast parts of the practice of programming that have little or nothing to do with mathematics, and can't be solved by its application.
      </p>
      <p>
        <em>Devising a program for a complex task often starts with breaking the task into simpler ones which, when taken together, are equivalent to the first task. That's an exercise in applied logic, which is a branch of mathematics.</em>
      </p>
      <p>
        <em>Some programmers do heavy math thinking every day, and I have nothing but the utmost respect for them. I don't think I'm mathematically sharp enough to do anything near that sort of work. But many programmers don't do much math at all. I know how all the different sorting algorithms work, but in the last five years of my professional life I have never had to implement such an algorithm, much less try to come up with one that bests qsort. (Thank Goodness.)</em>
      </p>
      <p>
        [Hmm. I'll believe that. But long ago, I came across a very small sorting program (written in assembler) which quite a few people (paying customers) were using. It took little trouble to speed it up a bit by reducing indirect addressing. Naturally, the new routine was given a different name, and wasn't given special publicity, but it was freely available and did get used, as far as I know.]
      </p>
      <p>
        <em>Much of my work these days feels kind of like I'm playing with Tinkertoys: Take this piece and connect it to that piece using that slot. If they can't join up with a third piece without breaking, reconfigure them until everything fits. Continue until you've built your spaceship. That sounds like a facetious way of describing the work, but I know that when things work all this slot-matching results in code that makes my clients' lives easier. I don't need a theorem to prove that. -- francis</em>
      </p>
      <p>
        [Sometimes, mathematical proofs are put together like that.]
      </p>
      <hr/>
      <p>
        You need to be logical and rigorous, but programming has much more to do with communication than mathematics: not only communicating your ideas to the computer, but to the other programmers who need to read or use your code. In my experience, mathematicians are not always the greatest communicators.
        -- <a href="DavidPeterson.html">DavidPeterson</a>
      </p>
      <p>
        [<em>Communication helps in all subjects, doesn't it?</em>]
      </p>
      <p>
        <em>You think mathematicians never complete timesheets or never document what they do?</em>
      </p>
      <p>
        This is quite true. My father is a mathematician (topology) and he would not dream of just diving in and start solving a proof. He would first determine the number of lines of text needed to solve the proof. He would then prepare a list of requirements for the proof, using the proper document template, and get the document signed off by all of the department heads. Next, he would prepare a detailed design for the proof as well as a risk assessment with contingency plans. What to do if the chalk breaks? Only now would he begin to actually write the proof. A disciplined approach is needed, as we are all aware the cost of making a mistake grows exponentially. During this time, he reports weekly to the department head on his proof. Strangely, he is 90% done most of the time. I am so happy that mathematics and computer programming are so much alike.
      </p>
      <hr/>
      <p>
        Ultimately, truth has to come from empirical observation, not a top-down theoretical framework. When you evaluate the usefulness of <a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a>, we shouldn't ask whether or not OO has a sound mathematical foundation. We should ask whether it works. The two aren't always the same. Programmers aren't all mathematicians, and perhaps they shouldn't have to be.
      </p>
      <p>
        The reason I asked the question in the first place is this: There are times when people say things like "<a href="ObjectOrientation.html">ObjectOrientation</a> is a mistake because OO programming doesn't have a sound mathematical base." And basically I want to say this: I don't care. I mean, there are plenty of useful things in this world that don't have a sound mathematical base.
      </p>
      <p>
        I feel like programming as a craft is far too young for us to say "Programming is math", or even "Programming is architecture", or "Programming is writing". Programming is programming. And before we put some big over-arching principle over everything we see, maybe we should be skeptical, open-minded, and above all, empirical. We should take a lot more time to gather information - both in terms of statistics and in terms of personal testimonial - to see what works. Maybe when we understand better what works in programming, we'll have a better sense of what programming is.
      </p>
      <p>
        -- francis
      </p>
      <p>
        Empirical, skeptical, open-minded, and all that is good and beautiful. But above all, let us not be forgetful and let us not be ignorant. 
      </p>
      <p>
        A lot of self-appointed (or appointed by the large masses) "gurus", who contributed nothing to the science of programming, recently and not so recently made all kinds of unsupported (and bery often self-interested ) claims along the lines "math does not scale", etc, etc, etc. They don't have even 10% of the understanding of <a href="EwDijkstra.html">EwDijkstra</a>, nor did they bother to actually read what the man had to say, otherwise they'd have known the old man responded to them in advance. That is not skepticism, empiricism, open-mindedness and all that jazz, it is more like ignorant retrograde attitude.
      </p>
      <p>
        So here are some facts: 
      </p>
      <ul>
        <li>
           <a href="ProgrammingIsMath.html">ProgrammingIsMath</a> approach brought all the essential advances in the programming science and technology without which programming wouldn't exist today.
        </li>
        <li>
           there are areas of programming where <a href="ProgrammingIsMath.html">ProgrammingIsMath</a> is not only a good approach, it is the *only* approach.
        </li>
        <li>
           We have yet to see essential positive results being brought by other approaches. People who never read <a href="EwDijkstra.html">EwDijkstra</a> seriously , might prosternate [?] to <a href="ChristopherAlexander.html">ChristopherAlexander</a> and take mystical attitude in search of QWAN and the likes. Still they have yet to make any significant breakthrough other than lots of hype.
        </li>
        <li>
           the fact that we have an undereducated work-force who is opaque and often fights against <a href="ProgrammingIsMath.html">ProgrammingIsMath</a> proves nothing. There were times when workers in auto industry were against robots in the assembly lines. 
        </li>
      </ul>
      <p>
        So if the giants on whose toes we step, showed us the way that <a href="ProgrammingIsMath.html">ProgrammingIsMath</a>, and made it all possible for us to have good jobs and huge salaries, it should take a little bit more than generalities or hand waving or fuzzy warm feelings for us to take the <strong>step back</strong> and say: "wait a second, doc, maybe it is not math after all". Ok, <strong>what is the problem</strong>, is it a problem with their work, or is it a problem with our understanding or our intellectual laziness that prevents us from following their lead? Aren't we the likes of the workers in the auto industry that opposed the introduction of robots in the assembly line (and similar examples are countless)? 
      </p>
      <p>
        Ok, let's grant ourselves a break here, we don't have efficient mathematical tools, and we have to build upon and integrate a lot of "legacy" that is anything but mathematical and most often a clumsy mess, we have a job to do. But a skeptical attitude works also the other way around: we shouldn't bow down to the medicore substitutes and patchwork that proved nothing so far. What do we *really know* that allows us to say: <em>you know the </em><a href="ProgrammingIsMath.html">ProgrammingIsMath</a> approach is not likely to work and not likely to scale and will never catch on and <a href="BlahBlahBlah.html">BlahBlahBlah</a>?<em> Or even worse, go one step further and actively denigrate, oppose, detract, and all that jazz. Because if we do that, great chances are (history goes in only one direction) that we might be proven wrong, and that will mean a lot of bad things (TM). </em>
      </p>
      <hr/>
      <p>
        Let's begin with OO and see whether we agree on some facts. Various OO languages, databases, systems have generally sound "mathematical foundations". Let's take Java for example: the Java Language Specification is a mathematical system defining precisely what happens both at compile time and at runtime. Agreed up to here?
      </p>
      <p>
        <em>I hate to sound contrary, but not quite. I have a problem with this line: "Java Language Specification is a mathematical system defining precisely what happens both at compile time and at runtime." Why is it a mathematical system? Why not simply a rational system?</em>
      </p>
      <p>
        The mathematics is the essence of it; you can represent it in a mechanical machine, an optical circuit an electronic circuit and so on so forth. Or you can represent it over another mathematical layer - the machine code, which would be a smarter thing to do.
      </p>
      <p>
        <em>I don't see anything in the JLS that makes it an inherently mathematical system. Yes, lots of the system deal explicitly with math. And yes, all the implementations of the JLS that we know of are done using mathematical machines. But you can also do lots of non-mathematical things with a JLS implementation.</em>
      </p>
      <p>
        I briefly reviewed JLS, and I have a problem seeing anything at all that's not mathematical: programming language, expressions,types, variables, values, instruction set, virtual machine, etc ... Nor anywhere does it seem that the author is only using mathematical constructs to represent something else, nor it alludes to, either explicitly or implicitly. 
      </p>
      <p>
        To quote: "The book provides complete, accurate, and detailed coverage of the syntax and semantics of the Java programming language. It describes all aspects of the language, including the semantics of all types, statements, and expressions, as well as threads and binary compatibility." What is a programming language, a type, an expression, a thread, and all the others that is not mathematical?
      </p>
      <p>
        <em>I mean, you can represent the English alphabet using math too - that's what ASCII's for. That doesn't make the alphabet mathematical. (Unless you're asking a Kabbalist, of course. Me, I'm not a Kabbalist.)</em>
      </p>
      <p>
        Well, some might argue with you that an alphabet is precisely a mathematical construct. But we're not talking semiotics here, we're talking about programs and mathematics.
      </p>
      <p>
        I really cannot see how anyone can *not* see something like the JLS as a mathematical construct! Doesn't even BNF look vaguely mathy to you? Communication Protocols? FSMs? Is topology maths? <a href="NickKeighley.html">NickKeighley</a>
      </p>
      <hr/>
      <p>
        Programming is not math. Programming is to math what building anything is to math. A house is not a mathematical problem. You could use math, along with some empirically derived formulae or tables, to select a beam girth. That does not make building a house math, because even an illiterate craftsman with no knowledge of mere arithmetic can build a fine house using direct measurement and intuition.
      </p>
      <p>
        Caveat: The declarative and functional programming camps probably have other opinions about this. I roast my marshmallows over the fires of the imperative camp.
      </p>
      <p>
        <em>If programming is not mathematics, give a list of programming activities that mathematicians do not do when developing mathematical algorithms; also explain how programming is accomplished without mathematics in the form of applied logic.</em>
      </p>
      <p>
        The person taking your groceries is using arithmetic: are they mathematicians as well? What about a carpenter, applying logical rules of thumb to do his work? Mathematicians do not work anything like programmers, which is immediately evident to anyone in close contact with both groups. In your daily work as a programmer you apply trivial mathematics and logic. So? Hundreds of other professions and trades do as well. This is not in any meaningful way related to what mathematicians do in *their* day to day work.
      </p>
      <hr/>
      <p>
        All programs require at least an intuitive understanding by the programmer that the code will actually do what it is supposed to do. The programmer may not realize this, but the chain of reasoning contained in this intuitive understanding contains the elements of mathematical proofs regarding properties of the program. Even if the programmer does not know how to express this information in mathematical symbols, he/she is still constructing some equivalent internal representation of it.
      </p>
      <p>
        <em>But if the `intuitive' understanding led to a proof of correctness, the program would work a) without flaws and b) across a definable class of inputs. The reality is that this is almost never the case. What programmers usually create is something more like experimental proof of a special case.</em>
      </p>
      <p>
        Yet programmers are able to write code that works, right? There must be some logical chain of reasoning the programmer follows where creating the algorithm or fixing a bug.
      </p>
      <p>
        <em>This reasoning is very different from a mathematical proof. Almost nobody is writing something as small, clean, and well-defined as, say, quicksort. The practice of programming doesn't have enough of these solid building blocks, so programmers do other things.</em>
      </p>
      <p>
        I submit that it is impossible for anyone to understand Quicksort without reasoning about properties and transformations of sequences. How is this reasoning not a mathematical activity?
      </p>
      <hr/>
      <p>
        In addition, almost all programs require classification of types of objects, reasoning about types and functions/transformations involving types. First, the act of classification (understanding and defining the relevant types/classes) is quite sophisticated in most modern software. This kind of classification activity forms a major part of the work of a modern mathematician.
      </p>
      <p>
        <em>Programmers do a lot of classification, but not in the same way as mathematicians.</em>
      </p>
      <p>
        Furthermore, to do anything useful, the programmer must have some representation of the properties of each type present in his mind (loosely equivalent to a set of axioms) and he or she must construct fairly sophisticated chains of reasoning to obtain derived properties of types and transformations pretty much all the time.
      </p>
      <p>
        <em>The set of representations that a programmer uses are not even loosely equivalent to a set of axioms (with some exceptions for people and languages that are a tiny percentage of the world's programmers).</em>
      </p>
      <p>
        Okay, take a List data structure (which most programmers have used). A list is no less a mathematical object than a natural number, a real number, or a group. The properties of lists, i.e., that there are functions to obtain the head and the tail if not empty, that the tail is a list, and that a list can be empty, are certainly no less axioms than are the axioms of natural numbers, real numbers, or groups. The programmer has to keep these properties (axioms) in his head when working with lists. Understanding how to write a simple recursive function to reverse a list <em>requires</em> the programmer to engage in some sort of inductive reasoning based on the properties of lists. I don't think it is possible to arrive at the solution purely empirically. This reasoning involves playing in your mind with the properties of a mathematical object. This is what mathematicians do. This is Mathematics. 
      </p>
      <p>
        Firstly most programming isn't done with things as well defined as lists. Secondly most programmers wouldn't recognise your definition of a list. EveryOneKnows a list is a line of boxes joined with arrows. And a Line of boxes joined with arrows is <a href="GoodEnough.html">GoodEnough</a> to write linked list software. I know because I've debugged their software.  <a href="NickKeighley.html">NickKeighley</a>
      </p>
      <hr/>
      <p>
        "[A]lmost all programs require classification of types of objects, reasoning about types and functions/transformations involving types" - isn't there an element of linguistics to this, as well?
      </p>
      <p>
        {Q: If you analyse the same problem with several teams, with different native languages, do you get analyses which have a linguistic bias? Do some teams pick out more nouny-based stuff or more-verby stuff depending on their language?}
      </p>
      <hr/>
      <p>
        Or possibly it's more that this technique is at the same sort of stage in development as maths once was? (The Greeks used to write the problems in words, and now we've developed more formal notation system.)
      </p>
      <hr/>
      <p>
        And just to be controversial, should programming be mathematical? It integrates with business systems and people who aren't clean and precise and logical. At some level, non-mathematicalness is going to show up, surely?
      </p>
      <p>
        -- <a href="KatieLucas.html">KatieLucas</a>
      </p>
      <p>
        Integrating with business systems and people is the job of eliciting requirements. For example, programming is constructing the programs that conform to whatever requirements (logical or illogical from the external point of view). No matter how the external domain behaves (logically or illogically), the behavior of your programs has to be logical.
      </p>
      <hr/>
      <p>
        When will we get to the point that it doesn't matter <strong>how<em> it is done but </em>'what</strong> is done? Arguing how programmers are doing their job each day is totally irrelevant. You might look at an optimization problem and use voodoo to come up with a decent result or even with the global optimum. You might feel encouraged to repeat the voodoo next time. However, this doesn't prevent me from saying that you're essentially solving a math problem. 
      </p>
      <p>
        So, if you're writing a program you're <strong>essentially</strong> solving a functional equation, in the sense of coming up (hopefully) with one of possibly many solutions. You might want to use voodoo to do it but the essence of what you are doing is solving the damn equation. If we don't accept that the problem (creating the program) is essentially a math problem, we'll then find it more than acceptable to use voodoo - it apparently gives some results, and then come up with arguments that we don't need the stinking mathematics after all. 
      </p>
      <p>
        We can come up with the conclusion that given the current state of knowledge, we can't do better than voodoo for the problem at hand (and this kind of statement is potentially provable), but that's not to blind us that the problem is a voodoo problem and not a mathematical problem.
      </p>
      <hr/>
      <p>
        You could turn this question around and ask <strong>Is math programming?</strong> There's no algorithm for mathematical discovery and mathematicians use intuition or voodoo or whatever you want to call it every single day. If you think of programming as the *process* of coming up with a program which performs a given task and mathematics as the *process* of coming up with a proof for a given theorem, then the cycles of development are very simmilar. You hack at the problem for a bit, then step back and have a look at what you've accomplished. You re-arrange the various pieces, simplify, refactor, realize you've just reinvented somebody else's wheel badly etc... After the first attack on the problem you might observe a previously unnoticed simmilarity between the current problem and some other problem and find yourself able to reuse some well-established techniques, or you might come to the conclusion that the way you have decomposed the problem into its sub-problems is not working out, and throw everthing away to start again with a new approach. Mathematics is not a collection of theorems and programming is not a collection of programs. Obviously programs are not theorems (unless, perhaps, you are a haskell programmer) but the mysterious process by which programs are written and theorems are proved have some striking simmilarities.
      </p>
      <hr/>
      <p>
        <strong>Is Computer Science Math?</strong>
      </p>
      <p>
        First, let me define "Computer Science" as the study of programming not programming.
      </p>
      <p>
        To take this analogy further, I would say that Object Oriented Programming theory is Set theory. Yon can take any class hierarchy and redraw it as a Venn diagram (the one with the overlapping circles) with no loss of information. Base classes are merely overlapping subsets of derived classes.
      </p>
      <p>
        I will also predict that before they are useful, concepts such as "cohesion" and "coupling" will have to undergo a mathematics-like investigation to become useful to programmers.
      </p>
      <hr/>
      <p>
        Programming seems more like Physics than Maths. In theoretical physics, the intended results (cf. user requirements) are usually known, you then make up a theory (cf. your program), and then do the calculation (cf. run tests) to see if the theory gives the intended results.
      </p>
      <hr/>
      <p>
        <a href="EwDijkstra.html">EwDijkstra</a> was convinced that programming was math. More specifically, he asserted that writing a program was essentially the same as creating a proof. His view was shared by <a href="CarHoare.html">CarHoare</a>, and also by <a href="NiklausWirth.html">NiklausWirth</a> I think. 
      </p>
      <p>
        You could say that a program is a proof that some set of requirements can be completed (though some of the code I've seen is more like a counter-example). <a href="LambdaCalculus.html">LambdaCalculus</a>, the theory that underpins <a href="FunctionalProgramming.html">FunctionalProgramming</a>, shows that programming is something that can be modeled mathematically, and so the theory that <a href="ProgrammingIsMath.html">ProgrammingIsMath</a> is not something that can be dismissed outright.
      </p>
      <hr/>
      <p>
        Although programmers don't "create mathematics" in the sense of discovering new theorems, when we program we are doing math in a certain way. We're essentially solving a special kind of equation: what program fulfills the specification? A computer program is essentially a mathematical object - it's not physical, philosophical, or literary. It's mathematical.
      </p>
      <p>
        <em>Saying that 'a program is a mathematical object' and saying that 'programming is math' are two logically different statements. The first statement does not imply the second. One characteristic of a program is that it can be represented as a mathematical object. This is trivially true. However, this does not in any way make the practice of programming the performance of mathematics. Nor does it even imply that mathematics is a central part of what programmers do; this is a separate, albeit related, issue from what characterizes programs.</em>
      </p>
      <p>
        But other people who use mathematics don't have as their primary task the creation of mathematical objects (programs). Even if programmers aren't applying mathematics, they're still solving a mathematical problem. Sometimes they use non-mathematical tools, like intuition and heuristics, and this is possible to a great extent because much of the mathematical complexity has already been solved by the tools that they're using.
      </p>
      <p>
        Programs are essentially mathematical objects. Concepts such as program, programming language, machine, function, class, object, file, compiler, interpreter, and all the basic ingredients of programming - all of these are mathematical.
      </p>
      <p>
        If programs can be represented as mathematical objects, and they're not a reflection of some concrete reality (we're not saying that an electromagnetic field is mathematical even if we "represent" it mathematically), we might have a reasonable suspicion that they <strong>are</strong> mathematical objects, after all. Especially when we consider that that's how they evolved historically. So the challenge, if you want to infirm this, is for you to find another essence of a program. If the mathematics is only a representation, what else is in a program?
      </p>
      <hr/>
      <p>
        <em>Or what else has come up in the meantime? Because historically programs have been mathematical objects, and I hope you agree that if you write a new version of the "sort" program, it's all about mathematics and nothing else. Pick your favorite programming problem, and try to exemplify, because some of us honestly don't see these other essences of programming.</em>
      </p>
      <p>
        Writing a new sort program has very little to do with what *most* programmers do *most* of the time these days. Which I believe was Francis's original point, and I believe you completely missed it. In fact, one could argue that in coming up with a new sorting routine you are doing computer science, not programming at all. Can you not see the difference?
      </p>
      <p>
        <em>No, I sincerely can't. Maybe you can try to define it, or come up with the slightest example. The burden of proof should not be on me for the reasons I already pointed out, and you haven't addressed. A sort program was just an example. I might have missed your points altogether, but you don't do a lot to help me :) Other than negating my points for no apparently and objectively good reason. I cannot guess or have an intuition of what you and Francis are alluding to, nor do I think that such an exercise would be helpful.</em>
      </p>
      <p>
        Sorry, but I have addressed them. Firstly, programming is not C.S. Secondly, you seem to have difficulty differentiating the use of mathematics from the practice of mathematics. The fact that I am typing this message does not make me a linguist. Thirdly, you seem to have some strange ideas about what mathematics actually is, from the point of view of a mathematician (unless I am mixing up contributers). Fourthly, the absolute *vast* majority of professional programmers I have met, and I believe this generalizes well, have weak mathematical skills and do not tend to apply what little they do have to their daily work. This includes many people with undergraduate training in C.S. or S.Eng. (though there are exceptions, and exceptional schools). And this leads to the crux of the matter. People who program often do not do this in a mathematical way. The practice of programming has diverged from its early tight coupling to C.S. Whether or not this is a good thing is a completely different subject from that of the original page. On that page, as I understand it, Francis was asking "Well, if we aren't doing math, what are we doing?". And it is *immediately* clear to anyone who takes the time to look that what the average programmer is doing today *is not math*. This is why it *is* your burden of proof, because your assertions about the practice of programming today simply do not hold water. Francis is asking what framework you use to measure efficacy if mathematical (or C.S.) formalisms cannot help you. A valid question, I think. Finally, there are large numbers of professions that use mathematical frameworks as much as programming does, and nobody calls them mathematics. You seem to want to dilute the terminology until it is of little value. I have never heard someone say EE is math, it would be absurd. The only reason this becomes an issue is that programming is so ill-defined.
      </p>
      <p>
        <em>The responses to the question: "Well, if we aren't doing math, what are we doing?" is extremely simple: we are all (to a greater or lesser degree varying with individuals, and with very few people being exceptions to this rule) doing </em>'bad mathematics<em>'.</em>
      </p>
      <p>
        Does everyone become a mathematician at tax time? Do you consider arithmetic to be different than mathematics? Similarly, is a physicist "doing mathematics" when modelling a physical process? Mathematics can be a tool as well as a process. Much programming uses mathematics as a tool, just as a carpenter uses the metallurgy in a hammer as a tool. Using a hammer in a new way and applying new, untested stresses doesn't necessarily advance the state of metallurgy, just as a programming cobbling up a different <em>algorithm</em> for a specific problem doesn't necessarily advance mathematics.
      </p>
      <p>
        <em>This looks like a dead end of the discussion. One thing is mathematical research, another is applied mathematics. In Europe, we even have a job title Mathematical Engineer (typically a math graduate who applies advanced mathematics to solve difficult problems in other domains). Nobody on the pro-math side claimed that programmers should advance the state of mathematics (though some computer scientist did that as well).</em>
      </p>
      <p>
        <em> Mathematics is not just a tool in programming, it is the essence of it - even if it is denied. A program is a mathematical object. Denying that is like a musician playing music and denying he's playing music, he might claim that he's philosophizing and notes are just a "tool". Well, nice claim but it's just not good enough. When you write a program, even if you claim you don't do mathematics, you are in fact constructing a mathematical object.</em>
      </p>
      <p>
        <em>That it can be used as a tool to solve, let's say, accounting problems, is another thing altogether. But programming means just the activity of constructing a program. Requirements, validation, investment, management, negotiations and other activities in software engineering are a separate discussion.</em>
      </p>
      <hr/>
      <p>
        From <a href="http://www.cs.utexas.edu/users/misra/Speeches.dir/Schlumberger.Jan02.pdf">http://www.cs.utexas.edu/users/misra/Speeches.dir/Schlumberger.Jan02.pdf</a> (Jayadev Misra):
      </p>
      <dl>
        <dt> </dt>
        <dd>"...And, I contend that lack of useful theorems about a typical C++ program is what makes it so difficult to make claims about it: its intent, whether a particular change will have a disastrous effect on its execution and whether it can be integrated with other programs. In other words, we typically build mathematical systems whose properties we cannot discern."</dd>
      </dl>
      <hr/>
      <p>
        See: <a href="ProgrammingIsMath.html">ProgrammingIsMath</a>, <a href="MathematicianDefinition.html">MathematicianDefinition</a>, <a href="OoIsPragmatic.html">OoIsPragmatic</a>, CurryHowardCorrespondence
      </p>
      <hr/>
      <p>
        I am missing something here? Programming is not Maths at all. ProgrammingIsLanguage. Syntax. Like learning about ablative absolute and gerunds. It requires vocab and logic like maths but so does learning Latin or Greek. The fact that the two have something in common fails completely IMHO to make them the same thing --<a href="AndrewCates.html">AndrewCates</a>
      </p>
      <p>
        <em>You are missing a lot.  First of all mathematics is a lot about language. Anmd is about the same kind of languages that programming is about: </em>'formal<strong>. And is about making languages that are </strong>useful<strong> and </strong>convenient to the human mind<strong> (see </strong><a href="BeautyIsOurBusiness.html">BeautyIsOurBusiness</a>), for the purpose of <strong>deriving logical properties</strong>. The claim was made that programming is essentially a sub-domain of applied mathematics.<em>--</em><a href="CostinCozianu.html">CostinCozianu</a>
      </p>
      <p>
        [How about it's all a matter of perspective, and what programming is... is in the eye of the beholder.  To some, programming is math, to others, it's engineering, to others, it's art, and it's entirely possible that they are all correct.]
      </p>
      <p>
        Dammit, Costin, I hate it when you take a stance with which I disagree.  It wouldn't be so bad if you were ignorant or inarticulate but, that not being the case, I have to think harder to compete.  So this time I'll just wing it.
      </p>
      <p>
        Architecture, music, photography, poetry, and farming (and, yes, programming) are certainly subject to mathematical treatments, and rigorous logical and formulaic models can be applied to [programming], but programming is about directed sequences and decisions.  It can be done with digital devices (computers, et al) and analog devices (e.g. valve systems), including physical switched systems that resemble <a href="RubeGoldberg.html">RubeGoldberg</a> constructs.
      </p>
      <p>
        I've actually done programming on purely mechanical systems driven by punched tape sequences and physical switches.  All you had to know was "when this happens, if switch 'A' is up the light goes on and tape 'T' plays, otherwise a buzzer sounds and tape 'R' plays."  Each tape was punched with codes that turned on motors, actuated relays, and blinked lights.  The holes were read with mechanical fingers run by cams.  The tasks were all simple, but each one was a distinct <em>program</em>.
      </p>
      <p>
        The gadget was designed and built by mechanics and engineers.  No one modeled it mathematically.  I will concede that it <em>could have been</em> so modeled, but the point is that there was no formalism involved.
      </p>
      <p>
        While it may be comfortable to assign math as an invariant attribute of programming, I submit that this is a little like asserting that musicians do math because of the clear formulaic relationships in music.
      </p>
      <p>
        I have to disagree with "<a href="ProgrammingIsMath.html">ProgrammingIsMath</a>" although I can agree that the separation is not entirely clean. -- <a href="GarryHamilton.html">GarryHamilton</a>
      </p>
      <p>
        <em>Now, Garry, I'm honored by your worrying about being in disgareement with me, but I'd like to remind you that I am an extremely unimportant wiki contributor, and in this particular discussion I am trying to defend/reinterpret a point of view belonging to much more notable persons. Speaking of which, I wouldn't bother to recycle these things because others provided those arguments much better than me, unless I thought it useful for these arguments to be made in a language and style appropriate for the wiki audience. So given this </em><a href="MeaCulpa.html">MeaCulpa</a> in advance, I would note that your argument and counterexamples suffer serious flaws, not the least of which is that your counterexample is not.<em></em>
      </p>
      <p>
        <em>Although I said it before, it doesn't take mathematicians to perform math just like it doesn't take a conservatory formal study to play music. So you think you build some software that nobody modeled mathematically. Still that software was a useful mathematical object. Just like a gypsy player can play a music that nobody wrote the notes for. It doesn't make that less than music (even beautiful music at times). There's this implied or derived message that people affirming the "mathematicality" of programming either want or may inadvertently cause taking away something from people coming to programming from other backgrounds. Well, there's something to this point, but not quite. I may come back to further elaborate, but the point was that your counterexample doesn't counter the argument. Plus programming on mechanical systems, well, that was exactly the point of </em><a href="EwDijkstra.html">EwDijkstra</a> and the introduction to <a href="DisciplineOfProgramming.html">DisciplineOfProgramming</a>. Mechanics, electronics, quantum physics, chemistry, the physical computational device just does not really count, as long as it implements an abstract model that is well understood.<em></em>
      </p>
      <p>
        <em>Now going back to Music. Describing music is apparently not formalizable, or at least not yet. That's the reason why we have famous conductors and less than famous conductors and the same partiture interpreted by two different orchestras can sound very different. Plus there's music that cannot be transcribed: for example, although </em>KeithJarrett published the partiture for his famous Koln concert he refers to the audio recording as the definitive description of the music: <a href="http://www.eecs.umich.edu/~lnewton/music/KolnConcert.html.">http://www.eecs.umich.edu/~lnewton/music/KolnConcert.html.</a> Well, audio-tapes are not application of formal languages, programming source code is. So here it goes your music analogy. What else ? --Costin<em></em>
      </p>
      <p>
        Hmmm.  I see.  Since the <em>programming language</em> itself is formally described, then the application of such a language imparts this "math nature" to the activity itself.  I'm still not on board with this, although I can see why the assertion is attractive.
      </p>
      <p>
        I came to programming through a completely different discipline, telex communications.  I found that, to the degree that I could describe the problem domain, I could code representations of the "machinery and materials" of that domain.  I had coded a program to read and write messages through a serial port and a companion full-screen text editor before I encountered the words "parameter" or "function."
      </p>
      <p>
        I borrowed heavily from the paper systems in use to model the message handling stuff, just modeling in "electronic clay" (<a href="AssemblyLanguage.html">AssemblyLanguage</a>, as that was all I knew) what I was seeing around me.  I would have been flattered to know that what I was doing was any kind of math.
      </p>
      <p>
        I have found that, regardless of the language, what I do is describe the domain and then render that description in code, without recourse to anything like a formula.  Yes, occasionally there is math, but it's almost always incidental.
      </p>
      <ul>
        <li>
           Well, ahem, you say that you describe your domain in code but without recourse to any formula. What do you think your code is ? It <strong>is</strong> a mathematical formula, denoting a mathematical object. People have this prejudice that Math is only some spectacular theorem with a itzy-glitzy formula at the end, but even the most mundane programming code is still mathematical in essence.
        </li>
      </ul>
      <p>
        Perhaps I am one of programming's "IdiotSavant" practitioners, doing math without realizing it, but my better sense tells me this is not so.  I'm modeling domains, using the TinkerToys and LegoBlocks of the LanguageDuJour.  If that's math, then somebody mail me my degree so I can stick it on my cube wall.
      </p>
      <ul>
        <li>
           Now that's where the breakdown occurs. Do you think Mick Jagger played music? I guess he did, because a lot of people thought so and paid him for his music. Would somebody mail him a conservatory diploma for that? Highly unlikely, but he's happy with his millions of dollars regardless. 
        </li>
      </ul>
      <ul>
        <li>
           Let me conjecture something else: this sub-domain of applied mathematics is so new and so different than what mathematicians used before that the case can hardly be made that graduates in math (or computing science for that matter) have a substantial advantage over other practitioners. These things happened before when Mathematics was pushed forward by physicists, economists and many people from other domains. That said, there are practical benefits to be had from studying the math area related to programming (logic, programming languages, database theory , etc). And no, I do not believe that mathematical knowledge on esoteric domains like category theory, domain theory, type systems has any practical  benefit to the software engineer out there in the industry. I just came from the ICFP conference where at least 50% (I'm trying to be generous) of the papers were useless math (math that will eventually be abandoned, never materialize in a useful programming language feature or library, etc) that is nevertheless inaccessible to >95% of software engineers out there. Math itself, and discrete math in particular is such a fascinating subject, that I think it takes great people with enormous humility to focus on essential simplicity and stuff that really can make a difference, versus math like you can see in <a href="TheEvolutionOfaHaskellProgrammer.html">TheEvolutionOfaHaskellProgrammer</a>.
        </li>
      </ul>
      <hr/>
      <p>
        My 2c: No. When I program, I am building useful <em>artifacts</em>.
      </p>
      <hr/>
      <p>
        After reading <a href="IsProgrammingMath.html">IsProgrammingMath</a> and <a href="ProgrammingIsMath.html">ProgrammingIsMath</a>, what I'd have to add is the best programmers I've worked with have had backgrounds in Applied Mathematics. CS programmes that are weak in maths seem to produce poor programmers. Here's to higher order, functional, and appreciating programming as applied or computational mathematics, and that maths is the best modelling language produced by mankind. 
      </p>
      <hr/>
      <p>
        See also <a href="DoesMathHaveStrings.html">DoesMathHaveStrings</a>
      </p>
    </div>
  </body>
</html>