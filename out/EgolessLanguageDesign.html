<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Egoless Language Design
      </h1>
      <p>
        <a href="EgolessProgramming.html">EgolessProgramming</a> is one thing, but what do you suppose happens when one applies that approach to library & language design?
      </p>
      <p>
        Something novel, that's what.
      </p>
      <p>
        One would start with TakeOverTheWorld mentality. This sounds counterproductive. It turns out that a language not designed to do everything other than kernel programming cannot be a good enough general purpose language to be generally useful. We know C++/CLR generally failed to find wide usage; however its TakeOverTheWorldMentality was the only thing that in the end gave enough power to be the interop glue language it is now. Corollary: the language must be cross platform. Further Corollary: the language must be able to fix endian problems in input.
      </p>
      <p>
        But one must then remember that this language is not going to actually TakeOverTheWorld. This means the interop gateway must be sufficiently well featured and easy to use so that it can interop with thousands of existing languages. This also means able to start your runtime from any thread, and possibly the ability to host several copies of the runtime in the same memory space.
      </p>
      <p>
        One would have to design the language to be multi-paradigm, with at least <a href="FunctionalProgramming.html">FunctionalProgramming</a>, <a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a>, and <a href="ProceduralProgramming.html">ProceduralProgramming</a>.
      </p>
      <p>
        The language's standard library would have to be written mostly in the language. As a modern language needs a large runtime library, it is not reasonable to assume the library will be bug free. This means, and this is the horrifying part, the application programmer must have the means of fixing library bugs w/o modifying the library as installed on the system.
      </p>
      <p>
        The modern world has imposed another requirement: the language must be able to provide a sandboxed execution environment for untrusted code. You may think this conflicts with the above; however I have in hand a proof it does not.
      </p>
      <p>
        Let us see how this fits for C++:
      </p>
      <ul>
        <li>
           Language designed to be able to do everything: Yes.
        </li>
        <li>
           Cross-platform: Yes, source.
        </li>
        <li>
           Endian aware coding possible: Mostly. Library function.
        </li>
        <li>
           Interop. Yes. C++ and predecessor C could interop to Fortran & system libraries. At the time of writing there were no other suitable candidates to interop to.
        </li>
        <li>
           Start runtime from any thread: Yes.
        </li>
        <li>
           Multi-paradigm: No. <a href="FunctionalProgramming.html">FunctionalProgramming</a> in C++ is a nightmare.
        </li>
        <li>
           Application programmer able to modify runtime libraries: Sometimes. Depends on linker behavior as to whether or not it works.
        </li>
        <li>
           Sanboxed environment available: No.
        </li>
      </ul>
      <p>
        And for Java:
      </p>
      <ul>
        <li>
           Language designed to be able to do everything: Yes.
        </li>
        <li>
           Cross-platform: Yes.
        </li>
        <li>
           Endian aware coding possible: Yes.
        </li>
        <li>
           Interop. No. All interop had to be done in nasty C modules.
        </li>
        <li>
           Start runtime from any thread: No. Java must have main().
        </li>
        <li>
           Multi-paradigm: No.
        </li>
        <li>
           Application programmer able to modify runtime libraries: No.
        </li>
        <li>
           Sanboxed environment available: Yes.
        </li>
      </ul>
      <p>
        And for C#:
      </p>
      <ul>
        <li>
           Language designed to be able to do everything: Yes.
        </li>
        <li>
           Cross-platform: Yes.
        </li>
        <li>
           Endian aware coding possible: Painful.
        </li>
        <li>
           Interop. Yes.
        </li>
        <li>
           Start runtime from any thread: Yes.
        </li>
        <li>
           Multi-paradigm: Yes.
        </li>
        <li>
           Application programmer able to modify runtime libraries: No. Not even by linking to private versions.
        </li>
        <li>
           Sanboxed environment available: Yes.
        </li>
      </ul>
      <p>
        How about <a href="SmallTalk.html">SmallTalk</a>. Somoebody please correct this if wrong:
      </p>
      <ul>
        <li>
           Language designed to be able to do everything: Almost. It didn't quite like unattended services.
        </li>
        <li>
           Cross-platform: Yes.
        </li>
        <li>
           Endian aware coding possible: Difficult.
        </li>
        <li>
           Interop. ?
        </li>
        <li>
           Start runtime from any thread: No.
        </li>
        <li>
           Multi-paradigm: Yes.
        </li>
        <li>
           Application programmer able to modify runtime libraries: Yes. Image based deployment.
        </li>
        <li>
           Sanboxed environment available: No.
        </li>
      </ul>
      <p>
        Please somebody do a chart for <a href="CommonLisp.html">CommonLisp</a>.
      </p>
      <p>
        Unless one of the many LispVariants qualifies than it is likely no language in existence qualifies under these constraints.
      </p>
      <hr/>
      <p>
        <em>Oh, come on: One needs to have a pretty big ego to go off and design your own language. ;-></em>
      </p>
      <p>
        Quite. Making an egoless one must require disciplined effort to do so.
      </p>
      <hr/>
      <p>
        <em>Oh, come on: One needs to have a pretty big ego to go off and design your own language. ;-></em>
      </p>
      <p>
        The low-ego variation is to create a language that makes very few permanent design decisions (i.e. keep everything - including semantics, support for GC, etc. - mutable by the application architect). I can think of several such projects. But I have a bad feeling about interop and reuse, even of regular libraries, in these languages.
      </p>
      <p>
        <em>Funny, I don't.</em>
      </p>
      <hr/>
      <p>
        <strong>Examples? Could we see some examples?</strong>
      </p>
      <p>
        With a mere search query in Google, one can discover far more examples than can be expressed here:
      </p>
      <ul>
        <li>
           <a href="http://www.google.com/search?q=ten+commandments+of+egoless+programming&rlz=1I7RNTN_en&ie=UTF-8&oe=UTF-8&sourceid=ie7">http://www.google.com/search?q=ten+commandments+of+egoless+programming&rlz=1I7RNTN_en&ie=UTF-8&oe=UTF-8&sourceid=ie7</a>
        </li>
      </ul>
      <p>
        Exercising <a href="EgolessLanguageDesign.html">EgolessLanguageDesign</a> is not about having a big ego. Confidence, ego and ambition are driving personality forces existing in people who accomplish things. It is about designing languages that are <a href="UsefulUsableUsed.html">UsefulUsableUsed</a>. If one were not egoless in their approach, they would design a <a href="PrivateLanguage.html">PrivateLanguage</a>, useful for their own personal requirements. 
      </p>
      <ul>
        <li>
           <em>The term 'egoless programming' was coined more than 30 years ago to describe a philosophy that advocates putting developer egos on hold in the interest of producing higher-quality, lower-defect software. Since then, the concept has found its way into various methodologies that involve formal peer code reviews, such as </em><a href="ExtremeProgramming.html">ExtremeProgramming</a>.<em></em>
          <ul>
            <li>
               from: <a href="http://www.techrepublic.com/downloads/ten-commandments-of-egoless-programming/173234">http://www.techrepublic.com/downloads/ten-commandments-of-egoless-programming/173234</a>
            </li>
          </ul>
        </li>
      </ul>
      <hr/>
      <p>
        <a href="JanuaryEleven.html">JanuaryEleven</a> 
        <a href="CategoryLanguageImplementation.html">CategoryLanguageImplementation</a>
      </p>
    </div>
  </body>
</html>