<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Why We Love Lisp
      </h1>
      <p>
        For opposing viewpoints, see: <a href="WhyWeHateLisp.html">WhyWeHateLisp</a>
      </p>
      <hr/>
      <p>
        In what follows, "Lisp" refers to <a href="CommonLisp.html">CommonLisp</a>, as defined by the ANSI X3J13 standard, unless stated otherwise.
      </p>
      <hr/>
      <p>
        <strong>Nihilism</strong>
      </p>
      <p>
        Lisp is nihilist so you don't have to be. In contrast, some languages have certain ideologies: in <a href="SchemeLanguage.html">SchemeLanguage</a>, functional programming is a priority; <a href="PythonLanguage.html">PythonLanguage</a> has the goal of ideally providing the one right way to do anything. Of course, if you prefer a language to be ideological, Lisp may not be for you. Which is fine.
      </p>
      <p>
        What Lisp provides is a substrate. You do have what's needed for functional programming, or <a href="ObjectOrientedProgramming.html">ObjectOrientedProgramming</a>... unbounded size numbers, and so forth. Which you can use directly, or build more on top of.
      </p>
      <p>
        While Lisp may itself be nihilistic, you don't have to be. You are free to be a religious nut.
      </p>
      <p>
        <em>[Caveat: Lisp has been expected to run on a number of devices, including megaliths with 65536 processors. So you won't find things like standard network and GUI APIs in the standard; it wouldn't make sense. But there is a use for limited substandards, which apply to already-standardized homogeneous platforms like Unix/Windows.]</em>
      </p>
      <p>
        <strong>Dangerous</strong>
      </p>
      <p>
        David Noble's book Forces of Production argues that technology encountered one fork in the road - a decision between removing management in favor of skilled workers, or deskilling workers to empower management. It turned out in favor of management, though the other path could also have been taken.
        <a href="http://www.amazon.com/exec/obidos/tg/detail/-/0195040465/002-3851349-3240830?v=glance">http://www.amazon.com/exec/obidos/tg/detail/-/0195040465/002-3851349-3240830?v=glance</a>
      </p>
      <p>
        Lisp doesn't have many "sharp edges" in the normal sense, like requiring use of pointer arithmetic. However, people have correctly pointed out Lisp offers enough power to both require and reward good judgment. Whether or not this is useful depends on what you mean by "technology," at least if you believe David Noble's claim.
      </p>
      <p>
        <strong>Useful macros</strong>
      </p>
      <p>
        In Lisp, the program you are working on is represented using data structures. (The fancy technical term is "symbolic expressions" or sexps, but it's just data like numbers, symbols, strings, lists of data, etc.) This means that, for example at compile time, simple code can be converted to less human-readable code:
      </p>
      <code>
        (loop for i from 0 below 10)<br/>
      </code>
      <p>
        is just the same as the for(i=0;i<10;i++) loop in other languages. If you "macroexpand" it, you see it probably turns into a messy bunch of gotos and who knows what else.
      </p>
      <p>
        So, Lisp users view code as something you can operate on with muscles well trained for data manipulation. It is the main basis for supporting new paradigms which languages aimed at "mainstream programmers" can't easily do, since they are not easily customizable for special requirements. 
      </p>
      <p>
        Macros imply a transfer of power from programming language implementors to users. From a social perspective, the arguments start appearing like those used in grassroots democracy vs. totalitarianism debates, concerning things like mob rule and expertise. At very best, other languages might achieve some sort of top-down democracy, which Java seems to be attempting with BugParade voting on new features. Or a "Love it or fork it" attitude.
      </p>
      <p>
        Some might argue that this level of customization allows one to speak more fluently in terms of the program's domain. After all, domains have their own paradigms. For example, business programmers might want a closer trust relationship with clients by thinking and speaking in terms of the client's domain.
      </p>
      <p>
        <strong>Proper numbers</strong>
      </p>
      <p>
        In Lisp, 3/5 doesn't mean 0 (as in <a href="CeeLanguage.html">CeeLanguage</a> and <a href="PythonLanguage.html">PythonLanguage</a>*) or the inexact floating-point number 0.6 (as in <a href="FortranLanguage.html">FortranLanguage</a> and <a href="PerlLanguage.html">PerlLanguage</a>**). It means the rational number 3/5, which gives the exact integer 3 (not 2.99999999) when you multiply it by 5.
      </p>
      <p>
        In Lisp, 100000000*100000000 doesn't silently overflow and give the wrong answer (as it is liable to do in C), nor does it fall over with an exception (as it is liable to do in Python*), nor does it produce a floating-point number of doubtful exactitude (as it does in Perl). It's just the number 10000000000000000.
      </p>
      <p>
        All this has drawbacks too, of course. If you need efficiency then you need to be careful that your program doesn't start working with 100-digit bignums when floating-point is enough. That's not difficult to do. But when you forget, the only result is inefficiency, not nonsense.
      </p>
      <p>
        <em>(* both points have been addressed in newer versions of Python, AFAIK)</em>
      </p>
      <p>
        <em>Not really, the decimal.Decimal type tries to do better (provides support for "true" decimal floating-point arithmetics) but the regular int type still evaluates 3/5 to 0. Decimal(3)/Decimal(5) evaluates to Decimal("0.6").</em>
      </p>
      <p>
        [Python 3 evaluates 3/5 to float 0.6, and 3//5 to int 0]
      </p>
      <p>
        <em>About the overflow/exception, on the other hand, overflowing integers get silently promoted to Longs (which are arbitrary length integers in python). Yields a noticeable drop in performances though.</em>
      </p>
      <p>
        <em>**</em><a href="PerlSix.html">PerlSix</a> has/will have 3/5 as the literal for a Rational object, which is stored as a 64-bit signed numerator and a 64-bit unsigned denominator.<em></em>
      </p>
      <p>
        <strong></strong><a href="MultipleDispatch.html">MultipleDispatch</a><strong></strong>
      </p>
      <p>
        Ever been puzzled by the <a href="VisitorPattern.html">VisitorPattern</a>? Bid a glad farewell to it with the <a href="CommonLispObjectSystem.html">CommonLispObjectSystem</a>, in which methods can dispatch dynamically on the types of all their arguments.
      </p>
      <p>
        The <a href="CommonLispObjectSystem.html">CommonLispObjectSystem</a> has many other wonders, too. :-)
      </p>
      <p>
        <em>I agree that Visitor stinks, but there are many approaches to a replacement outside of Lisp, I would note.</em>
      </p>
      <p>
        <strong>Interactivity and introspection</strong>
      </p>
      <p>
        If your Lisp program isn't working right, you can play with its bits on the fly. If it isn't working <em>yet</em>, you can develop it in fragments and experiment with them as you go. Things like class names persist at run time. You can interrogate and manipulate your program while it's running Safely.
      </p>
      <p>
        <strong>Good built in types</strong>
      </p>
      <p>
        <em>Container types</em>: Vectors, arrays, linked lists, hash tables. (As well as structures and classes, of course.)
      </p>
      <p>
        <em>Numeric types</em>: Integers (unbounded in length), rationals (unbounded in size), floating-point numbers (of up to 4 different sizes according to need), complex numbers.
      </p>
      <p>
        <em>Stringy things</em>: Characters, strings (which are, by the way, just a kind of vector). Strings (as well as vectors of other types) with "fill pointers" and grow-on-demand, which are SemanticSugar to make it simple to append to a string without scanning through it.
      </p>
      <p>
        <em>Symbols</em>: A specialized type, not normally found in any other language (because they lack the concept of <em>READ time</em>, used to
        hold variable bindings, functions, properties, or for their identities. Symbols are largely what makes the lisp macro system so effective. Symbols are segregated into their own namespaces using the <em>Package</em> system.
      </p>
      <p>
        <em>Functions</em>: In lisp, <em>functions</em> are a first class type, i.e. they can be created at runtime and passed as arguments. This makes
        lisp suitable as a <em>functional</em> programming language (although it is by no means restricted to that style, having operators for side
        effects, such as SETQ).
      </p>
      <ul>
        <li>
           <em>Too many built-in types takes away from the simplicity of a language. If you want to strive for simplicity, then find a more morphable/adaptable single data structure.</em>
          <ul>
            <li>
               That's a very amusing comment, considering the traditional complaint (usually heard from people who know very little about contemporary Lisp) that Lisp deals with lists and only lists. Too few built-in types just causes them to be recreated in terms of the ones that are built-in.
            </li>
            <li>
               I'm guessing that the author of the "too many types" comment above is probably <a href="TopMind.html">TopMind</a>, who thinks that everything should be a relational table, and that anyone who uses any other data structure is guilty of the mortal sin of <a href="ReinventingTheDatabaseInApplication.html">ReinventingTheDatabaseInApplication</a>. If I ever met someone who claimed, for example, that there were too many types in the Java Collections Framework, and that all higher-order data structures should be reimplemented in terms of arrays, I would laugh that person out of the room.
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <strong>Dynamic typing</strong>
      </p>
      <p>
        Of course, the jury is still out (and likely will be for a long time) about whether this is a good thing or a bad thing. See the pages called <a href="DynamicTyping.html">DynamicTyping</a> and <a href="StaticTyping.html">StaticTyping</a>, and their myriad progeny. However, Lisp users are generally strongly in favour, so this counts as a reason <a href="WhyWeLoveLisp.html">WhyWeLoveLisp</a> even if it shouldn't. :-)
      </p>
      <p>
        Lisp has <em>optional static typing</em>, in the sense that you can tell the compiler "this thing is always supposed to be of that type". The compiler can use this to provide helpful compile-time complaints, or better speed, or both.
      </p>
      <p>
        <em></em><a href="AnswerMe.html">AnswerMe</a>: Do any implementations of <a href="CommonLisp.html">CommonLisp</a> actually <em>do</em> either of the above? Or are type annotations treated as comments by most Lisp implementations; and the typechecking and performance improvements implied are only found on the ever-mythical <a href="SufficientlySmartCompiler.html">SufficientlySmartCompiler</a>?<em></em>
      </p>
      <p>
        Yes, Lisp implementations actually do this. All commercial implementations do this. CMUCL and SBCL both do extensive type-inference even without declarations.
      </p>
      <p>
        Some lisps do things better than others. CMUCL and SBCL use a type inferencing engine that makes numerical computation phenomenally fast. We're talking <a href="AsFastAsCee.html">AsFastAsCee</a> here. On the order of OCaml results if set up properly. However, that setting -up-properly process isn't always intuitive.
      </p>
      <p>
        Commercial Lisps tend to focus less on generating tight ASM for computations and more on handling memory very intelligently, since this is a major slow point for most modern computers. Don't underestimate Allegro or <a href="LispWorks.html">LispWorks</a> because it doesn't bench well in, say, Fibonacci or Factorial benchmarks. That's not the way they're tuned. Watch though as they run webapps like nobody's business.
      </p>
      <p>
        <strong>Decent performance</strong>
      </p>
      <p>
        There are other languages with a rather Lispy feel to them (good range of built in data types, interactive, highly dynamic, and so on); the most popular at the moment seems to be Python. However, these languages tend to have only interpreted implementations (sometimes via a byte-compiler) and be awfully slow. Lisp is designed to be compilable to code that runs pretty fast. (Say, within a factor of 2 of
        optimized C.)
      </p>
      <p>
        [There's no reason it can't run as fast or faster than optimized C.] <em>[Is there some reason C can't run as fast or faster than optimized Lisp? It's simply that I think that there's a limit to how fast compiled code can be, and I would expect well-optimized C (and well-optimized Lisp) to be fairly close to this limit. -- </em><a href="AlistairBayley.html">AlistairBayley</a>]<em> Of course not. The point is, very few languages with anything near the power of lisp generate native code with anything near the speed of C. The amazing thing is that while lisp is arguably the most powerful programming language existent, with a good compiler all this extra power doesn't slow you down much at all.</em>
      </p>
      <p>
        <em>Aside: See </em><a href="SufficientlySmartCompiler.html">SufficientlySmartCompiler</a>.<em></em>
      </p>
      <p>
        <strong>Powerful Error Handling</strong>
      </p>
      <p>
        <a href="CommonLisp.html">CommonLisp</a> has one of the most complete and flexible environments for error handling, including the ability to establish <em>restarts</em>,
        search up the stack for handlers, possibly invoking more than one of them, and having code inspect which restarts are currently available to decide which to call. Overall, this makes it possible to write extremely robust programs.
      </p>
      <p>
        You can also have <em>warnings</em>, which are vaguely like optional exceptions, which can be handled or "caught" if desired.
      </p>
      <p>
        See <a href="CommonLispConditionSystem.html">CommonLispConditionSystem</a>
      </p>
      <p>
        <strong>Clear and precise standard</strong>
      </p>
      <p>
        <a href="CommonLisp.html">CommonLisp</a> is blessed with an extremely precisely written standard, which leaves zero margin for error when determining if an implementation is conformant. This helps when complaining to your vendor... :-)
      </p>
      <p>
        <em>Alas, if only the standard really did leave zero margin for error. Some sections (such as section 19) are notoriously vague. --</em><a href="PaulDietz.html">PaulDietz</a><em></em>
      </p>
      <ul>
        <li>
           Which section is section 19?
          <ul>
            <li>
               Path names (<a href="http://www.lisp.org/HyperSpec/Body/chap-19.html),">http://www.lisp.org/HyperSpec/Body/chap-19.html),</a> according to the <a href="CommonLispHyperSpec.html">CommonLispHyperSpec</a>. I don't actually see the ambiguity; I thought the main complaint about CL pathnames is that they're incredibly Byzantine in a world where UnixWon. They were designed to provide CrossPlatform standardization in the era where every minicomputer had a different file system.
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <strong>Fast and productive development environment</strong>
      </p>
      <p>
        While not unique to lisp, having a top-level <a href="ReadEvalPrintLoop.html">ReadEvalPrintLoop</a> where one may ask questions of a running program, and modify it as it runs, is certainly one of the reasons <a href="WhyWeLoveLisp.html">WhyWeLoveLisp</a>. Farewell to the EditCompileDebugCycle!
      </p>
      <p>
        <strong>Beauty</strong>
      </p>
      <p>
        Build layer on layer of abstraction like a drawing.
      </p>
      <p>
        <em>Not very specific. Everyone thinks their pet language has the best abstraction abilities.</em>
      </p>
      <p>
        <strong>Wealth of outstanding literature</strong>
      </p>
      <p>
        By learning some Lisp, you gain access to a lifetime supply of enlightening literature and breathtaking programs. Lisps have been used for incredible research and exposition over decades, and the fruits are readily available to anyone inclined to dig in. For example, <a href="ParadigmsOfArtificialIntelligenceProgramming.html">ParadigmsOfArtificialIntelligenceProgramming</a>, <a href="StructureAndInterpretationOfComputerPrograms.html">StructureAndInterpretationOfComputerPrograms</a>, <a href="EssentialsOfProgrammingLanguages.html">EssentialsOfProgrammingLanguages</a>, <a href="GuySteele.html">GuySteele</a>'s <em>Rabbit</em> compiler and <em>Programming Language Based on Constraints</em>, ConnectionMachineLisp, MIT's AI Lab publications like <a href="GuySteele.html">GuySteele</a> and <a href="GeraldSussman.html">GeraldSussman</a>'s <em></em><a href="LambdaTheUltimate.html">LambdaTheUltimate</a><em> series, </em><a href="HenryBaker.html">HenryBaker</a>'s research archive (garbage collection, parsing, linearity), and oh-so-much more. The Lisp literature records the achievements of some of the world's best programmers.
      </p>
      <hr/>
      <p>
        <strong>Discussion</strong>
      </p>
      <p>
        <strong>Re Scheme:</strong> Scheme not only doesn't make FP a priority, it was developed as an <a href="ActorsModel.html">ActorsModel</a> language, which is essentially OO. The usual complaint about Scheme is that <em>all</em> it provides is a substrate, which must then be built up with libraries. SLIB appears to have emerged as a sort of de facto standard for scheme, so much as you wouldn't make comparisons of C++ to anything else without its standard library, any "fair" comparisons to CL really should be with Scheme+SLIB. 
      </p>
      <p>
        <em>The reason I wrote that is because through looking at all the standard textbooks which teach Scheme, it is clear that they teach a style of programming which is "functional." I take this from </em><a href="SiCp.html">SiCp</a>, Little/Seasoned Schemer books, and HTDP. In fact, when people complain that their experience of Lisp is it's too "functional," further questions almost inevitably show it was Scheme, not Common Lisp, which they experienced. I do not recall seeing one obviously iterative construct in those books. [Caveats: I haven't read HTDP through, I remember <a href="SiCp.html">SiCp</a>'s discussion of tail recursion being iterative in some sense, and I don't mean functional in the sense of "purity".]<em> </em>
      </p>
      <p>
        <em>How might I go about reconciling your explanation with this? Or could you help me pinpoint the flaw in my observations?</em> 
      </p>
      <ul>
        <li>
           [If I might interject: Lisp proponents often complain that most Lisp texts (and college courses) teach the language as if lists were the only data type, leaving an impression of inefficiency, and as if iterative constructs didn't exist. I imagine that Scheme suffers similar problems. Basing an understanding of a language on tutorial textbooks seems likely to be a bad idea. -- <a href="AnonymousDonor.html">AnonymousDonor</a>]
        </li>
      </ul>
      <p>
        <a href="SiCp.html">SiCp</a> is a highly academic book that doesn't really even teach scheme, but a bit of functional programming. <a href="SiCp.html">SiCp</a> is about FP, not scheme. The Schemer books are written by FP advocates, and again there's nothing in scheme that requires you to use an FP style. If you want to see a language that locks you into FP, try Haskell. HTDP is also fairly FP-oriented - anything out of MIT is going to be - and TeachYourselfSchemeInFixnumDays lingers on lots of academic subjects (like amb). Perhaps "Scheme for Perl/Python/Ruby/Vb/Tcl hackers" might be in order. It'd have to be heavy on libraries for sure.
      </p>
      <p>
        <em>IIRC, HTDP and </em><a href="SiCp.html">SiCp</a> where written for the same course, and Little/Seasoned Schemer is a FP-book that seems to be usable as a companion piece to <a href="SiCp.html">SiCp</a>. TYSifd isn't very FP.<em></em>
      </p>
      <p>
        Perhaps what we also need is a Scheme book that covers the <a href="SchemeRequestsForImplementation.html">SchemeRequestsForImplementation</a> libraries, as well. <a href="HowToDesignPrograms.html">HowToDesignPrograms</a> uses some SRFI tools, but only certain ones, and it also leans heavily on the PLT implementation. -- <a href="JayOsako.html">JayOsako</a>
      </p>
      <p>
        The complaint about FP comes from beginners struggling to solve all their problems using a handful of basic functional building blocks such as lists, map, and foldl.  Textbooks intentionally force students to solve programming exercises under this constraint to help them learn functional ways of thinking, but an unfortunate side effect is that students begin to think that simple tasks are impractical or disproportionately intellectually taxing in Scheme.  Beginners who want to do practical programming should be guided to essential practical tools such as vectors, hash tables, sets, and iterations and comprehensions (<a href="http://docs.racket-lang.org/guide/for.html)">http://docs.racket-lang.org/guide/for.html)</a> instead of being left to discover them on their own.  Beginners who are not experienced programmers may even have a hard time finding the docs for (e.g.) file I/O without help; introductory books should keep that in mind. -- DavidHuebel
      </p>
      <hr/>
      <p>
        When comparing the size of <a href="WhyWeHateLisp.html">WhyWeHateLisp</a> to the size of <a href="WhyWeLoveLisp.html">WhyWeLoveLisp</a>, it becomes clear that the number of people angry because of losing their job to a lisp guy is far bigger than the number of people angry because of losing their job to a non-lisp guy.
      </p>
      <p>
        <em>It's interesting what sort of conclusions people come to based on a non scientific wiki with about 5-15 people participating at a time. One could call a sample of 10 people from a phone book (yes 10 people out of a few billion) and come to strong rigorous scientific conclusions also!</em>
      </p>
      <p>
        <strong>Hmm.</strong> That is rather odd. In <a href="EmbeddedSystem.html">EmbeddedSystem</a>s I've never seen Lisp used for anything at all in 35 years of experience. Perhaps the dozens of firms I've been exposed to are simply not representative of the industry?
      </p>
      <p>
        So it's not often used in <a href="EmbeddedSystem.html">EmbeddedSystem</a>s.  That doesn't mean it's not usable for those purposes - I would point at, for example, ecl.  "Nobody uses it" is not ever a valid reason to criticise a tool, though the reasons that they don't might be.  Consider suggesting why you've never seen it used, rather than saying you haven't as if that demonstrates that it shouldn't be.
      </p>
      <hr/>
      <p>
        See: <a href="WhyWeHateLisp.html">WhyWeHateLisp</a>, <a href="HowToSellGoldenHammers.html">HowToSellGoldenHammers</a>
      </p>
      <p>
        <a href="CategoryRant.html">CategoryRant</a>, <a href="CategoryLisp.html">CategoryLisp</a>
      </p>
    </div>
  </body>
</html>