<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Escape Hatch
      </h1>
      <p>
        <em>Perhaps a </em><a href="ProtoPattern.html">ProtoPattern</a>?  There are many uses, some of which would be enumerated in <a href="EscapeMechanisms.html">EscapeMechanisms</a>, but <em>this</em> page is not yet in the <a href="PatternPattern.html">PatternPattern</a>. -- <a href="MatthewAstley.html">MatthewAstley</a><em></em>
      </p>
      <p>
        <strong>Pattern Name:</strong> <a href="EscapeHatch.html">EscapeHatch</a>
      </p>
      <p>
        <strong>Aliases:</strong> <a href="EscapeMechanisms.html">EscapeMechanisms</a>, <a href="EscapeHatchMechanism.html">EscapeHatchMechanism</a>
      </p>
      <p>
        <strong>Context:</strong>
        You are in a paradigm (<em>e.g.</em> language, runtime environment, scribble on back of envelope) and you need to express or do some thing which does not fit.
      </p>
      <p>
        <strong>Problem:</strong>
        You are being restricted by your current tool set.
      </p>
      <p>
        <strong>Forces:</strong>
      </p>
      <ul>
        <li>
           You may not be able to ditch your current tool for various reasons: technical, legal, political or legacy code.
        </li>
        <li>
           There may not be a tool which does everything you need, or it may be too complex.
        </li>
        <li>
           It may be wise to keep some things separate, <em>e.g.</em> the financial accounts and the Internet. (Here, a KVM switch plus spare computer would do the trick .. but only the <a href="ThreeLetterAgencies.html">ThreeLetterAgencies</a> are that paranoid.) Maybe this is a digression or unnecessary generalization?
        </li>
      </ul>
      <p>
        <strong>Solution:</strong>
        Pop the <a href="EscapeHatch.html">EscapeHatch</a> and go somewhere else.  You can generally return from wherever it is you go.
      </p>
      <p>
        <strong>Resulting Context:</strong>
        You now have two tools stuck together, with a route between.
      </p>
      <p>
        <strong>Design Rationale:</strong> 
      </p>
      <p>
        <strong>Examples:</strong>
      </p>
      <ul>
        <li>
           <a href="KawaScheme.html">KawaScheme</a>
        </li>
        <li>
           <a href="HookOperations.html">HookOperations</a>
        </li>
        <li>
           Inline assembler in C source, or linking against an object file generated from another language
        </li>
        <li>
           Java JNI, Perl XS ...
        </li>
        <li>
           Inline <a href="PerlLanguage.html">PerlLanguage</a> in an Exim (mail transport) configuration file
        </li>
        <li>
           Using PuTty (<a href="SecureShell.html">SecureShell</a>) or VNC to escape to your UnixBox, when you are trapped in <a href="MicrosoftWindows.html">MicrosoftWindows</a>
          <ul>
            <li>
               Much less handy the other way around since you can't <a href="CutAndPaste.html">CutAndPaste</a> across TerminalServer with rdesktop (but you can with windows and VNC).
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <strong>Related Patterns:</strong> 
      </p>
      <hr/>
      <p>
        Contributors: <a href="RaySchneider.html">RaySchneider</a>, <a href="StevenBlack.html">StevenBlack</a>, <a href="MichaelFeathers.html">MichaelFeathers</a> [I haven't rolled the other people's comments in yet]
      </p>
      <hr/>
      <p>
        <strong>Original</strong>
      </p>
      <p>
        In general <em>escape hatches</em>
        are ways to get out of the rigid structure of the <em>paradigm</em>
        and add extenders.  UML has a feature that allows that which makes it already a lot better than anything that doesn't.
      </p>
      <p>
        More generally, escape hatches are any structure in a program that provides for extending the program in unanticipated ways later in the development cycle.  It is often necessary to have an <a href="EscapeHatchMechanism.html">EscapeHatchMechanism</a> to make this possible.  Afterall, on most software projects 60% of the requirements are discovered after the requirements documents have been approved.  Argh! (strangling sound) --<a href="RaySchneider.html">RaySchneider</a>
      </p>
      <hr/>
      <p>
        EscapeHatches can be rigged (or are, by definition rigged?) with <a href="HookOperations.html">HookOperations</a>.
        -- <a href="StevenBlack.html">StevenBlack</a>
      </p>
      <hr/>
      <p>
        EscapeHatches are wonderful, in some instances they are really a rudimentary form of a <a href="FrameWork.html">FrameWork</a>.  "Don't call us, we'll call you."  You call the escape hatch and wait for it to return.  The downside of EscapeHatches is that anything can happen.  In the case of UML, stereotypes are an escape hatch.  We'll have to see if they are abused.  
      </p>
      <p>
        I once designed a programming language and wrote a compiler for it.  The compiler produced C++.  We made an escape hatch to allow C++ statements directly in the language.  Saved our lives a couple of times.
      </p>
      <p>
        Java the language/platform can be seen as something without EscapeHatches for security reasons.  It'll be interesting to see if this is wise.
      </p>
      <p>
        -- <a href="MichaelFeathers.html">MichaelFeathers</a>
      </p>
      <p>
        The Java Native Interface API is an escape hatch. -- <a href="DaveHarris.html">DaveHarris</a>
      </p>
      <p>
        Does the concept of "reflection" (as in <a href="FallBackOnReflection.html">FallBackOnReflection</a>) constitute an
        "escape hatch"? (For example, you can use reflection to invoke methods in Java.)
      </p>
      <hr/>
      <p>
        I don't think so.  You cannot do anything with reflection that you can't do with compiled method calls.  On the other hand, the JNI allows you to get beneath the virtual machine and make direct calls operating system or execute real machine code.
        --<a href="NatPryce.html">NatPryce</a>
      </p>
      <p>
        With reflection, you can load a class, check to see what methods it
        implements, and call a method that was not in the interface at the
        time your program was written.  This is something you can't do with
        compiled method calls.
      </p>
      <p>
        Inheritance is a kind of escape hatch.  You don't like the way a class
        works?  Subclass it and override the method you don't like.  It isn't
        as powerful as other escape hatches, but it is safer and easier to use.
      </p>
      <p>
        <em>Do I get slapped if I add "compare: kludge" to this page? 8-)</em>
      </p>
      <p>
        Tut, tut. The modern approach is to call it TheKludgePattern, you barbaric heathen. As long as you call it a pattern, you can do no wrong.
      </p>
      <p>
        Although others may call it an <a href="AntiPattern.html">AntiPattern</a>, of course; aye, there's the rub.
      </p>
    </div>
  </body>
</html>