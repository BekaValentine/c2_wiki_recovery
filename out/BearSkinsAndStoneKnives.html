<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Bear Skins And Stone Knives
      </h1>
      <dl>
        <dt> </dt>
        <dd>"I'm endeavouring, Ma'am, to construct a mnemonic memory circuit using stone-knives and bear-skins."</dd>
      </dl>
      <p>
        Spock to Edith Keeler, "The City On the Edge of Forever". 
      </p>
      <hr/>
      <p>
        Some of us prefer the simplest possible tools - it's amazing what you can do with them, and besides, it seems to us that much (if not all) of the productivity of the fancier tools gets eaten up in installing them, configuring them, learning them, maintaining them, and working around their bugs. -- <a href="WayneConrad.html">WayneConrad</a>
      </p>
      <p>
        <em>Amen to that. I keep saying to to the </em><a href="IdeOlogues.html">IdeOlogues</a>: there are no bugs in the <a href="MakeTool.html">MakeTool</a>.<em></em>
      </p>
      <p>
        Complex tools exist to solve someone's vision of a problem using a particular method. Besides all the defects listed by <a href="WayneConrad.html">WayneConrad</a>, complex tools "make things easier" by removing freedom. I find myself always in a struggle with any complex tool. My vision of a simple solution is always at odds with the solution the guiding hand of the tool's creator wants to force me to accept.
        -- <a href="LeoScott.html">LeoScott</a>
      </p>
      <hr/>
      <p>
        My co-workers have been trying to get me to install <a href="VisualAge.html">VisualAge</a> for months. They will eventually force me. In the mean time, I've got at least a 2:1 productivity edge over them. There are things they can do much quicker than I, but they eat away that advantage by installing new versions, working around  bugs, and going to training sessions. I'm using the time I save to refactor my code so that any fool can understand and modify it. They're rushing through their code because the tool isn't leaving them enough time to make it right.
      </p>
      <p>
        I use compilers, assemblers, editors, shells, and a host of other tools which I have to learn, maintain, etc.  The difference between my co-workers and I is that I adopt a tool only when I'm convinced it's mature enough to be transparent to me - that I won't have to spend much time thinking about the tool or mucking with it. It helps if the tool has a gentle, linear learning curve, so that I can be productive immediately and slowly add to my knowledge of it. My experience is that big-bang tools don't lend themselves to an incremental build-up of knowledge. That is, you don't seem to get a lot of productivity out of the tool until you "get it"; the process of "getting it" taking quite a bit of practice and training.
      </p>
      <p>
        With web development especially, development times are so short that it's difficult to bury that learning curve in the schedule.  If I make this project take longer to learn the tool, will I gain it back on the next project?  Only if the next project uses that tool, or if the tool teaches me a concept or skill that is applicable to a similar tool or situation.
      </p>
      <p>
        I like tools very much. I just prefer those which I can hold in my hand and understand over those with a label saying "no user serviceable parts inside." -- <a href="WayneConrad.html">WayneConrad</a>
      </p>
      <p>
        <em>It's a question of </em>The best tool or the tool I know best<em>.  Being very productive with simple tools (meaning the tools I know best - the </em><a href="MakeTool.html">MakeTool</a> is hardly simple) is fine. Being sure to learn a new tool every year is another good thing too!<em></em>
      </p>
      <p>
        Last year I learned Emacs, Bash, Linux, XML, SQL, and Wiki. I played with enough XP, MySQL, Python, JSP, Apache, Xitami and Tomcat to feel familiar with them (although not learned). We troglodytes aren't sitting still, and we aren't ignoring technology and tools. We're just focusing our effort where it will do us the most good. <a href="DoTheSimplestThingThatCouldPossiblyWork.html">DoTheSimplestThingThatCouldPossiblyWork</a>. -- <a href="WayneConrad.html">WayneConrad</a>
      </p>
      <p>
        I wonder how people in general feel about Wiki itself. There are discussion systems with more bells and whistles than Wiki. To me as an occasional visitor, it's not clear that Wiki is further up the power tool scale than "make". (Actually, it's also like "make" in another, related way. If you don't have an implementation, only the idea, then reimplementing the basics gets you to the point of usefulness pretty fast.) Is Wiki a stone knife? Does anyone worry about not leveraging his communication time/skills/resources/etc. effectively when he uses Wiki instead of some wonderwhiz integrated tool? -- Bill Newman
      </p>
      <hr/>
      <p>
        Stone knives are initially sharper than steel, but they dull quickly. Hence they require frequent retouching (but perhaps have a future in surgeries). Leather is superior to cloth and nylon for many uses - but it does have a "break in" period, and should be maintained (cleaned and oiled). If <a href="VisualAge.html">VisualAge</a> is a more powerful tool, but requires more futzing with installations and workarounds, perhaps you all have the analogy backwards.
      </p>
      <hr/>
      <p>
        The thing about most of these "complex" tools is that they make some things much easier and other things much harder or impossible. If you only need to work within the boundries that the tool provides to you then more power to you. I've often found however that these tools never quite do exactly what I want them to.
      </p>
      <p>
        Long live ASCII & scripting. The great tool integrators.
      </p>
      <p>
        -- <a href="GlenStampoultzis.html">GlenStampoultzis</a>
      </p>
      <p>
        But <a href="GnuMake.html">GnuMake</a>+Vim+Bash+(all the other *nix tools) <em>are</em> an Integrated Development Environment. It's just that they usually don't display as much pretty pictures (usually, I say: the newest Vim can actually display such a row of nice, useless pictures.) -- <a href="StephanHouben.html">StephanHouben</a>
      </p>
      <hr/>
      <p>
        I hadn't thought about it this way before, but I guess I gravitate toward <a href="BearSkinsAndStoneKnives.html">BearSkinsAndStoneKnives</a>: my Java development environment is the free JDK compiler, emacs, JUnit, and (for some projects) <a href="ClearCase.html">ClearCase</a> (which I can mostly ignore).
      </p>
      <p>
        I don't even use Make: I have a file that lists the javac compiler options and all my source files; I put a # before any line I want to suppress (most, usually: java lets you incrementally compile most of the time). When I compile, I use a tcsh alias that does
      </p>
      <code>
        grep -v "^#" ~/sourcefiles<br/>
      </code>
      <p>
        in backquotes as the command-line arguments for javac, then runs the unit tests.
      </p>
      <p>
        Now, emacs has a Java mode (which I mostly use for indentation and brace-matching), and I have a macro that lets me jump to compiler errors, and another that jumps to runtime exceptions (finally figured it would pay off).  But that's bascially it: if I don't need it, I don't have it.
      </p>
      <p>
        I don't think this makes me like those Civil War re-enactors who won't even use nylon thread; I think it just reflects that nobody cares what tools I use, so I use tools that work, and automate the simple things that become repetitive.  From a cost perspective:
      </p>
      <code>
        Emacs:  $0<br/>
        JDK:    $0<br/>
        tcsh:   $0<br/>
        Time spent creating new software instead of wrestling with someone else's: priceless.<br/>
      </code>
      <p>
        This works well for me, it's cross-platform (works on Solaris and on NT after grabbing <a href="CygWin.html">CygWin</a>) and I intend to keep doing it until (a) someone gives me a <a href="RefactoringBrowserForJava.html">RefactoringBrowserForJava</a> or (b) I write one or (c) emacs swallows up that particular bit of functionality as well (kind of like the homeward-bound V*Ger in <a href="StarTrek.html">StarTrek</a> I).
      </p>
      <p>
        Of course, to use the caveman analogy, emacs isn't a bear skin or a stone knife: it's the cave. -- <a href="GeorgePaci.html">GeorgePaci</a>
      </p>
      <hr/>
      <p>
        Try editing XML with VI instead of XmlSpy or other tools. -- <a href="VhIndukumar.html">VhIndukumar</a>
      </p>
      <p>
        <em>Of course, XML is far from being a bear skin or a stone knife when </em><a href="EssExpressions.html">EssExpressions</a> can express the same information without the excess bandwidth usage and effort spent closing tags.<em></em>
      </p>
    </div>
  </body>
</html>