<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Heap Sort
      </h1>
      <p>
        Algorithm using for sorting arrays. It *CAN* be done in-place.
      </p>
      <p>
        <a href="HeapSort.html">HeapSort</a> Algorithm: (assumes you know what a <a href="HeapDataStructure.html">HeapDataStructure</a> is)
      </p>
      <ol>
        <li>
           Divide array into: put in the heap and not put in the heap. Initially all elements are not put in the heap.
        </li>
      </ol>
      <ol>
        <li>
           Grab first element that is not put in the heap. If there are not elements in this area GOTO 5.
        </li>
      </ol>
      <ol>
        <li>
           Put it in the heap, so that the array has one more element in the "heap area" and one less element in the "nonheap area".
        </li>
      </ol>
      <ol>
        <li>
           GOTO 2
        </li>
      </ol>
      <ol>
        <li>
           Extract all elements from the heap, they are retrieved in order, because heaps work just like that. Elements overwrite whatever was previously in the array.
        </li>
      </ol>
      <p>
        If not done in place: The array is sorted and it took at most O(n * log n). This is because putting the array in the heap are n operations (assuming n is the length of the array) and grabbing the heap and putting it back into the array are n operations. How expensive are the operations? Each "put" in the heap is O(log n) at most. Each get is O(1) at most. <em>Accessing the top is O(1), but removing the top is also O(log n). This still doesn't change it from O(n log n), however.</em> O(n) * O(log n) + O(n) * O(1) = O(n * log n) + O(n) = O(n * log n)
      </p>
      <hr/>
      <p>
        <em>Please describe how it could be done in place</em>
      </p>
      <p>
        It is implied by <em>divide array into</em>. During the heap building process, your original array looks like:
      </p>
      <code>
        T -- heap -- B -- unsorted -- |<br/>
      </code>
      <p>
        where T marks the Top of the heap and the divider B marks the bottom of the heap. The divider moves to the right as you percolate item B into the heap.
      </p>
      <p>
        Then during the sorting step, you loop retrieving the Top item, percolating the heap, and swapping the retrieved item to the bottom:
      </p>
      <code>
        T -- heap -- B -- sorted ---- |<br/>
      </code>
      <p>
        where now the divider is moving to the left as the heap shrinks. The end result is an array sorted where T is the smallest element.
      </p>
      <p>
        -- <a href="IanOsgood.html">IanOsgood</a>
      </p>
      <p>
        There is an example heapsort at <a href="http://www-ihm.lri.fr/~thomas/VisuTri/heapsort.html.">http://www-ihm.lri.fr/~thomas/VisuTri/heapsort.html.</a>
      </p>
      <hr/>
      <p>
        Moved here from <a href="SortingAlgorithms.html">SortingAlgorithms</a> (<a href="RefactorMe.html">RefactorMe</a>):
      </p>
      <p>
        <strong></strong><a href="HeapSort.html">HeapSort</a><strong>: A "Heap" is a binary tree with each child smaller (or larger) than the parent. The usual implementation uses an implicit mapping from the linear array to the binary tree where a parent <em>x</em> has children at 2<em>x</em>+1 and 2<em>x</em>+2. We define a process of <em>percolation</em> where an element repeatedly swaps itself with its larger child until it's bigger than both children or at a leaf. The heap sort starts by assuming the first element in the array is a one-element heap. It then grows the heap by repeatedly percolating elements from the top. It then repeatedly swaps the root (which is the largest element) with the element at the end of the array (which gets shorter and shorter) and percolates the former leaf down the heap. <em>Note: I know this explanation probably only makes sense if you already know the heap sort, but it's an outline.)</em> Time-complexity is O(<em>n</em> log <em>n</em>). Not stable. What's really going on here is that a heap is a neat implementation of a </strong><a href="PriorityQueue.html">PriorityQueue</a>; you're adding elements one by one and then removing them one by one in order of "priority". The "adding" phase can be done in time O(<em>n</em>), which means you can find the biggest or smallest k elements in time O(<em>n</em> + <em>k</em> log <em>n</em>).
      </p>
      <p>
        <strong></strong><a href="SmoothSort.html">SmoothSort</a><strong>: By </strong><a href="EwDijkstra.html">EwDijkstra</a>, a sophisticated variant of <a href="HeapSort.html">HeapSort</a>. (Anyone care to do a brief write-up of this one?)
      </p>
      <hr/>
      <p>
        See also:
      </p>
      <ul>
        <li>
           <a href="SortingAlgorithms.html">SortingAlgorithms</a>
        </li>
        <li>
           <a href="AlgorithmsRoadMap.html">AlgorithmsRoadMap</a>
        </li>
      </ul>
    </div>
  </body>
</html>