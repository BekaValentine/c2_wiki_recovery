<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Constraint Imperative Programming
      </h1>
      <p>
        Constraint Imperative Programming (CIP) is what you get when you combine an algol-like language with <a href="ConstraintLogicProgramming.html">ConstraintLogicProgramming</a>.
      </p>
      <p>
        CIP is still in its alpha stage: working implementations, yet to be strongly developed even by academia.
      </p>
      <p>
        Kaleidoscope is a little-known CIP language.
      </p>
      <p>
        [<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.463]">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.463]</a> - a paper describing Kaleidoscope.
      </p>
      <p>
        Turtle is another little-known CIP language.
      </p>
      <p>
        [<a href="http://uebb.cs.tu-berlin.de/~magr/talks/GI2003-pres.pdf]">http://uebb.cs.tu-berlin.de/~magr/talks/GI2003-pres.pdf]</a> - a slideshow that showcases Turtle.
      </p>
      <p>
        As one can see, CIP provides some very desirable ways of expressing certain kinds of programs.
      </p>
      <p>
        CIP is very related to <a href="GoalBasedProgramming.html">GoalBasedProgramming</a> in that it fits into the execute/consequent quadrant mentioned there.
      </p>
      <hr/>
      <p>
        Based on my (admittedly cursory) study of the examples for <a href="ConstraintImperativeProgramming.html">ConstraintImperativeProgramming</a> (in AlmaLanguage) it seems the focus is the automated construction of values that meet imperatively-described goals rather than the automated construction of procedures that meet declarative goals.  If this holds in broader examination, it seems that <a href="ConstraintImperativeProgramming.html">ConstraintImperativeProgramming</a> is far more closely related to <a href="ConstraintProgramming.html">ConstraintProgramming</a> (which obtains values that meet declaratively described goals) than <a href="GoalBasedProgramming.html">GoalBasedProgramming</a> (which constructs procedures to meet declaratively described goals).  I'll be reading the above documents over the next few days and relaying impressions here.  Addendum1: Document on Turtle does nothing to change impression.  
      </p>
      <p>
        <em>One executes actions to meet goals.  The other creates actions to execute to meet the same goals.  The former is, in-effect, doing what the latter does, but at runtime instead of compiletime.  Basically, GBP and CIP seem to be the same paradigm, but utilizing different implementation methods. Of course, I'd rather have both methods at my disposal. :)</em>
      </p>
      <p>
        Both CIP and GBP are both potentially runtime.  I'd say the bigger distinction is that GBP would typically be aimed at a runtime environment that receives continuous feedback while attempting to achieve its goals.  An example might be programming an unmanned vehicle to accomplish certain routine actions while remaining fueled and avoiding driving over any mines.  Manipulating the current 'goal set' in response to sensory and command inputs would be a big part of programming, and actions aimed at achieving these goals and verifying progress towards them would be continuous efforts.  CIP constraints are solved in a more spatially and temporally limited fashion.  <a href="PartialEvaluation.html">PartialEvaluation</a> and other optimizations would allow either to be used for <a href="DeclarativeMetaprogramming.html">DeclarativeMetaprogramming</a> at <a href="CompileTime.html">CompileTime</a>, but isn't required for either.  I do agree that having at least one <a href="ConstraintProgramming.html">ConstraintProgramming</a> language in the toolkit would be useful.  
      </p>
      <p>
        Admittedly, if procedures themselves are first-class and the procedure-processor is available to the constraint-solver (along with such conditions as reentrance, multi-threading, comprehension of shared state, etc.), any <a href="ConstraintProgramming.html">ConstraintProgramming</a> language is automatically capable of a form of <a href="GoalBasedProgramming.html">GoalBasedProgramming</a> by means of constructing procedures that meet a known set of goals.  However, being capable of something and being optimized and designed for it are entirely different beasts (pay attention to <a href="ExpressivePower.html">ExpressivePower</a> and beware the <a href="TuringTarpit.html">TuringTarpit</a>).
      </p>
    </div>
  </body>
</html>