<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Data And Information
      </h1>
      <p>
        The art of information:
        In the olden days, programmers mixed information and data orientation.
        Knowing when to use one or the other was an art form.
      </p>
      <p>
        More recently, most information orientation has been thrown out and
        the industry has moved solidly toward data orientation.
        This is good in that mixing the two approaches causes problems.
        There is really code that should be data oriented only.
        This is bad in that information orientation is useful
        and valuable and makes some goals/problems much easier to achieve/solve.
      </p>
      <p>
        Data orientation has become strong enough by itself to support
        an information oriented software development layer on top of it.
      </p>
      <hr/>
      <p>
        Lexicon of roughly equivalent Data and information oriented concepts
      </p>
      <code>
        Data Oriented jargon			Information Oriented jargon<br/>
        --------------------			---------------------------<br/>
        problem				goal<br/>
        solve					achieve<br/>
        solution				program<br/>
        server					computer<br/>
        differentiate				distinguish<br/>
        differentiation			distinction<br/>
        ordered bitwise enumeration		endeme<br/>
        column, member				field, value<br/>
        table schema				<a href="EndemeSet.html">EndemeSet</a><br/>
      </code>
      <code>
        Data Oriented approaches		Information Oriented Approaches<br/>
        ------------------------		-------------------------------<br/>
        identity PK				GUID PK<br/>
        exception handling			latent error detection<br/>
        default to null			specified default value<br/>
        strong typing				value interpretation<br/>
        objects, classes, members		loosely coupled fields<br/>
        UI code generators			table, class, and field metadata<br/>
        ORM code generators			generic classes<br/>
        information hiding			information drill-down<br/>
        parameterized SQL			dynamic SQL<br/>
        tables and objects			tables and metadata enhanced lists<br/>
        single categories per item		multiple categories per item<br/>
        conceptual decorators			data driven-combinations of concepts<br/>
        category membership			category ordering<br/>
      </code>
      <ol>
        <li>
          's and 0's				relative weightings
        </li>
      </ol>
      <code>
        One dimensional code format		Two dimensional code format<br/>
        text files				Spreadsheets<br/>
        aspect oriented programming		code that knows about itself<br/>
        self-documenting code			self-referential code<br/>
        large complex objects			toolbox of simple objects<br/>
        hierarchical paths			non-hierarchical paths<br/>
        many relational tables			few generic tables<br/>
      </code>
      <code>
        Data Oriented UI			Information Oriented UI<br/>
        ----------------			-----------------------<br/>
        single-select				multi-select<br/>
        errors cause exceptions		errors are ignored<br/>
        precise data formats			situational data interpreters<br/>
        UI displaying data elements		UI representing information structures<br/>
        Application defined search		User defined search<br/>
        Category based search			keyword based search<br/>
        one standardized UI			user specific/adjustable UI's<br/>
      </code>
      <code>
        Higher level Data Orientation		Higher Level Information Orientation<br/>
        -----------------------------		------------------------------------<br/>
        structured data			semantic relationships<br/>
        horizontal layered architecture	vertical metadata controlled architecture<br/>
        integrated silos			universal information metadata<br/>
        hierarchy				network<br/>
        object oriented patterns		OWL<br/>
        information proxies			data proxies<br/>
        project stage specialization		project domain synergy/specialization<br/>
        Users specify UI precisely		Users specify middle tier precisely<br/>
        networking objects			imported data interpretations<br/>
        CSV, XML, JSON				Lists of values with universal field descriptors<br/>
        relational database			endematic infobase<br/>
        XML with schemas			XML without schemas<br/>
        UI converts data to information	middle tier works with information directly<br/>
      </code>
      <code>
        front and back end driven		middle tier driven<br/>
        -------------------------		------------------<br/>
        UI and DB based specifications		middle tier based specifications<br/>
      </code>
      <code>
        the middle tier is glue		the front and back ends <br/>
        between the front		are outgrowths <br/>
        and the back ends		of the middle tier<br/>
      </code>
      <code>
        Data Oriented Goals			Information Oriented Goals<br/>
        -------------------			--------------------------<br/>
        Never imprecise			Graceful degradation<br/>
        Highly tested system			Highly flexible system<br/>
        High performance			High usefulness<br/>
        Standardized				Ad Hoc<br/>
      </code>
      <p>
        There is nothing that says that data and information oriented
        approaches can not be mixed. Many projects can benefit from the concepts
        in both columns.
      </p>
      <code>
        -- <a href="JonGrover.html">JonGrover</a><br/>
      </code>
      <p>
        'Should this page be called DataAndInformationOrientation instead?'
      </p>
      <p>
        It occurs to me that <a href="DataOriented.html">DataOriented</a> techniques in an <a href="InformationOriented.html">InformationOriented</a> system often look like an <a href="AntiPattern.html">AntiPattern</a>,
        and <a href="InformationOriented.html">InformationOriented</a> techniques in a <a href="DataOriented.html">DataOriented</a> system also often look like an <a href="AntiPattern.html">AntiPattern</a>.
      </p>
      <p>
        <em>How do you define "data"? How do you define "information"?</em>
      </p>
      <p>
        <a href="RealInformation.html">RealInformation</a> and <a href="RealData.html">RealData</a> are hard to define as the discussions on those pages indicate. For me it is sort of a sense that this kind of programming is <a href="InformationOriented.html">InformationOriented</a>, and that kind of programming is <a href="DataOriented.html">DataOriented</a>. I don't have a good definition because it is sort of an intuitive sense I have. <a href="RealInformation.html">RealInformation</a> tends to make more sense to users and <a href="RealData.html">RealData</a> tends to make more sense to programmers. The basis of my intuitive sense is that I have been working with <a href="EndemeSet.html">EndemeSet</a> s for a couple of decades now, and I sort of get an Information or a Data <a href="CodeSmell.html">CodeSmell</a> when I am working in one or the other realm. Information smells different than data. Wikipedia <a href="http://en.wikipedia.org/wiki/Information">http://en.wikipedia.org/wiki/Information</a> has a good article on information which goes what information is better than I can. Other sites that try to get at the difference are <a href="http://www.diffen.com/difference/Data_vs_Information">http://www.diffen.com/difference/Data_vs_Information</a> and <a href="http://www.differencebetween.info/difference-between-data-and-information.">http://www.differencebetween.info/difference-between-data-and-information.</a>
        This page attempts to get at the difference by showing differences in implementation and thinking between the two realms.
      </p>
      <p>
        <em>It sounds like your distinctions -- like all I've seen that try to distinguish "data" from "information" -- are personal and artistic rather than objective and scientific.  What is the theoretical basis for your </em><a href="EndemeSet.html">EndemeSet</a>?<em></em>
      </p>
      <p>
        I have just added this to the <a href="EndemeSet.html">EndemeSet</a> page:
        An endeme set is a list of concepts that can be combined in any order. The order is important. Order indicates priority, priority indicates importance, importance implies meaningfulness. When meaning is applied to something that is a form of information. Therefore an endeme set is a schema for an endeme, and an endeme is an atomic unit of information. This is as close as I have been able to get to a theoretical underpinning for an endeme set.
      </p>
      <p>
        <em>That's not a theoretical underpinning, that's a description with some rationale. A theoretical underpinning is a logical and mathematical basis that imparts rigour. For example, the theoretical basis for the </em><a href="RelationalModel.html">RelationalModel</a> is <a href="SetTheory.html">SetTheory</a> and <a href="FirstOrderLogic.html">FirstOrderLogic</a>.<em></em>
      </p>
      <p>
        Information is not rigourous, nor is it a branch of mathematics. It is a branch of business or philosophy. My thesis is that an <a href="EndemeSet.html">EndemeSet</a> implements an atomic unit of information. The Informatics world is a practical application of technology to people's needs for information. My practical work has identified areas where an information oriented mindset can save money, and provide better value to companies, users, and customers. Projects that were once too expensive for a small company can now be achieved using endeme sets. As a result there is significant low hanging fruit for a business to profit from once we start using endemes. You can take endemes to your employer and if you see a good use for them you can provide valuable software functionality to them and their customers that you could not before. You can benefit by using this new primitive type and so can your customers.
      </p>
      <p>
        This page is one part of teaching people how to learn the <a href="InformationOriented.html">InformationOriented</a> mindset by showing a list of things that tend more toward one or the other mindset. You can benefit if you want to learn this.
      </p>
      <p>
        <em>How does your approach compare to or relate to the </em><a href="RelationalModel.html">RelationalModel</a>, <a href="SqlLanguage.html">SqlLanguage</a>, <a href="ObjectOriented.html">ObjectOriented</a> modelling, and semantic modelling in general?<em></em>
      </p>
      <p>
        Relational modeling, SQL language and <a href="ObjectOriented.html">ObjectOriented</a> modeling are <a href="DataOriented.html">DataOriented</a>, whereas SemanticModelling is <a href="InformationOriented.html">InformationOriented</a>. This has to do with differences in the implementation of the 'contexts' inherent in the models. Relational and object oriented models provide context for each data element however the context is implemented in a way that is very hard to change - columns of tables, and members of classes. Whereas semantic models are more often soft-coded. Relationships among nodes in a semantic web are considered data and artifacts are not produced in code that define these relationships. Instead, programs are written to used the relationships that reside in data somewhere rather than to implement those relationships themselves.
      </p>
      <hr/>
      <p>
        <a href="CategoryInformationOrientation.html">CategoryInformationOrientation</a>
      </p>
    </div>
  </body>
</html>