<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Test Collector
      </h1>
      <p>
        When using a unit testing framework like <a href="JavaUnit.html">JavaUnit</a>, forget adding each <a href="TestCase.html">TestCase</a> to the <a href="TestSuite.html">TestSuite</a>. It's tedious and error-prone.
      </p>
      <p>
        Just have some code loop over the directory with your <a href="TestCase.html">TestCase</a>s, and pattern match for your tests (i.e, if your convention is to have "Foo.java" and "FooTest.java", match everything named "*Test.java").
      </p>
      <p>
        Bonus points go to implementations that put the <a href="TestCase.html">TestCase</a>s with the most recent modification times at the top of the list (that way, your most likely failing tests come faster, it's more feedbacky that way).
      </p>
      <p>
        Implementations:
      </p>
      <ul>
        <li>
           <strong>Java</strong>
          <ul>
            <li>
               <a href="http://www.panoptic.com/rking/TestCollector/javaTestCollector.zip">http://www.panoptic.com/rking/TestCollector/javaTestCollector.zip</a> <em><-- This is back - sorry about the downtime!</em>
            </li>
            <li>
               Thanks to <a href="AdamWilliams.html">AdamWilliams</a> and the folks at <a href="RoleModelSoftware.html">RoleModelSoftware</a>
            </li>
            <li>
               Needs timestamp sorting
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           <strong>Ruby</strong>
          <ul>
            <li>
               <a href="http://www.panoptic.com/rking/TestCollector/ruby-directory-test-suite.tar.gz">http://www.panoptic.com/rking/TestCollector/ruby-directory-test-suite.tar.gz</a>
            </li>
            <li>
               This even has a README, a "make install" target, and a handy run_ruby_tests script
            </li>
            <li>
               Needs timestamp sorting
            </li>
            <li>
               Thanks to <a href="RyanKing.html">RyanKing</a>, <a href="DuffOmelia.html">DuffOmelia</a>, <a href="RoyMiller.html">RoyMiller</a>, and the rest at <a href="RoleModelSoftware.html">RoleModelSoftware</a>
            </li>
          </ul>
        </li>
        <li>
           <strong>Php</strong>
          <ul>
            <li>
               <a href="http://www.panoptic.com/rking/TestCollector/php.txt">http://www.panoptic.com/rking/TestCollector/php.txt</a>
            </li>
            <li>
               Sorts by timestamp
            </li>
            <li>
               Courtesy Panoptic.com
            </li>
          </ul>
        </li>
        <li>
           <strong>Python</strong>: <a href="PythonTestCollector.html">PythonTestCollector</a>. No time stamping; instead I run the pieces manually as needed.
        </li>
      </ul>
      <p>
        Implementations built-in to the *Unit:
      </p>
      <ul>
        <li>
           <strong></strong><a href="NunitFramework.html">NunitFramework</a><strong> -- deprecates manual </strong><a href="TestSuite.html">TestSuite</a> creation in favour of an automatic collection mechanism. Each assembly is scanned for tests, and suites are built according to namespace hierarchy.
        </li>
        <li>
           <strong></strong><a href="CsUnit.html">CsUnit</a><strong> -- another unit testing tool for the .NET framework. Also replaces the need of manually maintaining a </strong><a href="TestSuite.html">TestSuite</a> by automatically scanning assemblies, and also by allowing to combine multiple assemblies into a recipe (see <a href="http://www.csunit.org).">http://www.csunit.org).</a>
        </li>
        <li>
           <strong></strong><a href="CppUnit.html">CppUnit</a><strong> -- The more recent versions automatically register all tests (</strong><a href="http://cppunit.sourceforge.net/doc/lastest/cppunit_cookbook.html">http://cppunit.sourceforge.net/doc/lastest/cppunit_cookbook.html</a> - TestFactoryRegistry) is something like a <a href="TestCollector.html">TestCollector</a> built purely within C++ without any external scripts. However, something is still necessary to get an object file linked in, so the static objects can register themselves.  An external script <a href="TestCollector.html">TestCollector</a> is still necessary to do this. Plus, external scripts can provide the "most recent tests first" property.
        </li>
        <li>
           <a href="VisualCeePlusPlus.html">VisualCeePlusPlus</a> - this uses the TEST_(suite, case) macro to collect test cases, without sweeping your hard drive for them...
          <ul>
            <li>
               I presume this is referring to <a href="NanoCppUnit.html">NanoCppUnit</a>, which is for VC++ only.
            </li>
          </ul>
        </li>
        <li>
           <strong>OCUnit</strong> -- Automatically adds subclasses of SenTestCase to the list of test case objects, and instance methods of these objects returning void and with no arguments whose names start with 'test' are added to the suite.  Phew!  MyTestCase:SenTestCase>>- (void)testSomething, for instance, will be automatically run.
        </li>
        <li>
           <strong>SUnit Browser</strong> -- When run from the class browser, collects the tests in the selected TestCase subclass. If the selected class is abstract, collects the concrete subclasses of the selected class. When run standalone, collects all the TestCase subclasses in the image.
        </li>
        <li>
           <strong>Eclipse + JUnit</strong> -- Allows you to run all tests in a Project, Source Folder, Package, File or Class.  Unfortunately, it doesn't seem to give a pleasant way to run tests from a project that the current project depends on, and it doesn't allow you to specify a specific order (i.e., newest first).
        </li>
        <li>
           <strong>Cutter</strong> [<a href="CutterTestingFramework.html">CutterTestingFramework</a>] -- Collects symbols from dynamic loaded shared libraries and selects test function from them. So you don't need to write any registering codes or macros in spite of using <a href="CeeLanguage.html">CeeLanguage</a>.
        </li>
      </ul>
      <hr/>
      <p>
        If you collect tests automatically using a <a href="TestCollector.html">TestCollector</a> (and even if you don't), it's also a good idea to use a <a href="TestInventory.html">TestInventory</a> to detect if tests have silently disappeared.
      </p>
      <hr/>
      <p>
        Is a <a href="TestCollector.html">TestCollector</a> necessary if you <a href="NeverWriteaLineOfCodeWithoutaFailingTest.html">NeverWriteaLineOfCodeWithoutaFailingTest</a>? You should be expecting a <a href="RedBar.html">RedBar</a> when you run your test for the first time, and if it's not, you'll realise you forgot to register the new suite.
      </p>
      <p>
        <em>See </em><a href="ThreeStrikesAndYouAutomate.html">ThreeStrikesAndYouAutomate</a>.  Why should I keep adding test suites when the computer is perfectly capable of doing it for me?<em></em>
      </p>
      <hr/>
      <p>
        I've been thinking about writing a Java test suite collector for a while. I recently put my first attempt at a build collector on <a href="SourceForge.html">SourceForge</a>. It builds three different test suites- AllCollectedFunctionalTests, AllCollectedAcceptanceTests, and AllCollectedUnitTests. 
      </p>
      <p>
        Test collectors will work because your codebase doesn't include tests that depend on the order that they're run. Only a complete tool would commit something like that into a repository.
      </p>
      <p>
        --
      </p>
      <hr/>
      <p>
        In ruby, I just require all the *.rb files under a tree, and then I go through all of the objects looking for ones marked appropriately. (In my case, the convention is to test Foo with a TestCase named TC_Foo.) I used actually just to run everything that inherited from TestCase, until I started creating abstract TestCases descending from TestCase (DBTestCase, WebTestCase, etc.).
      </p>
      <code>
        suite = Test::Unit::TestSuite.new("ruby unit tests")<br/>
        test_regex = Regexp.compile('^(.*::)?TC_[^:]+$', Regexp::EXTENDED)<br/>
        ObjectSpace.each_object(Class) { | klass |<br/>
        suite << klass.suite if test_regex.match(klass.to_s)<br/>
        }<br/>
      </code>
      <hr/>
      <p>
        Requiring all the *.rb files (or some other) is a test pattern that seems quite prevalent. Maybe I should call it something like
        TestAllClassesTogether.  <a href="CppUnit.html">CppUnit</a> and <a href="CppUnitLite.html">CppUnitLite</a> do something like this, by automatically registering all tests with the testrunner.
      </p>
      <p>
        However, in languages like C++ this does not test that the classes (and their associated files) can be used in isolation.
      </p>
      <p>
        Conjecture: <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> and its friends have no concept of file structure.
        All is workspace. 
        Now, I know that I personally have had trouble moving stuff from one workspace to another
        - making sure I have all the dependencies. 
      </p>
      <hr/>
      <p>
        <a href="CategoryTesting.html">CategoryTesting</a>
      </p>
    </div>
  </body>
</html>