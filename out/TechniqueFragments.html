<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Technique Fragments
      </h1>
      <p>
        I'm thinking these days that we really only ever use techniques in fragments, that we don't use a technique fully in normal situations.  That is, in a real situation, we paste together fragments of different techniques, some invented, some known, with glue consisting of actions that are just that - glue.  
      </p>
      <p>
        This may have implications for teaching people techniques - CRC cards, semantic modeling, use cases, etc. Instead of asking them to master a full technique and then being disappointed that they don't use it that way, only ask them to master technique fragments, and know when to apply those.  It may help me get past the <a href="ShuHaRi.html">ShuHaRi</a> bottleneck. --<a href="AlistairCockburn.html">AlistairCockburn</a>
      </p>
      <p>
        I think the misunderstanding was on your part in thinking that "to master a full technique" and to strictly adhere to a full technique was the right thing to do. It is not and there is no such technique able to address all the situations in its domain (not XP, not agile, not RUP, not use cases, not CRC, not anything else ). Authors, methodologists and zealots should have a better understanding of the limits of their greatest and dearest, and they should actively seek to establish such limits (very rarely it so happens in practice).
      </p>
      <p>
        So you have to trust your students that they will know better what's best in each situation they face. To help them more, you should come with examples and try to define where a particular technique is not likely to work, or is simply not the most adequate/efficient solution. 
      </p>
      <p>
        This is the way it works in performance chess training. The master adapts to the style of the student and not the other way around (the students that just copy the style of the master are not likely to make performance). Then a student needs to understand and be able to apply all the different techniques and styles, and he needs to be able to combine them at will, and come up with the best way to address each particular position. Programming has a lot of characteristics in common with the games of chess: it is a matter of science, art and craft, it is very complex and diverse, requires substantial individual creativity, and the list could go on. So a good programmer should have a lot in common with a good chess player, he has to have an extensive cultural background and to know lots of different things and perspectives, and he should first adapt to each concrete situation and be able to choose the best way to deal with it. Therefore it is likely he/she will not fully apply technuiques but combine different <a href="TechniqueFragments.html">TechniqueFragments</a>, and this is the right thing to do.--<a href="CostinCozianu.html">CostinCozianu</a> 
      </p>
      <p>
        <em>Thanks for the comparison --</em><a href="AlistairCockburn.html">AlistairCockburn</a><em></em>
      </p>
      <p>
        That metaphor is consistent with the way I find myself practicing (for instance) refactoring - rarely doing things <a href="ByTheBook.html">ByTheBook</a> (Martin's book in that case) but more often using the book as a source of good moves and combining them with other good moves learned independently. (I'm also reminded of <a href="GoProverb.html">GoProverb</a>s.) On the other hand, don't chess masters (or chess students) <em>also</em> get good at chess by doing what we now call "etudes", where doing things <a href="ByTheBook.html">ByTheBook</a> is crucial ? (<a href="XpXtude.html">XpXtude</a>s to use the official terminology.) On the gripping hand, they also get good by doing other things for which I'm not sure we have equivalents in software design - like studying great games of past masters, or solving chess puzzles, or creating chess puzzles... -- <a href="LaurentBossavit.html">LaurentBossavit</a>
      </p>
      <p>
        <em>But what about </em><a href="ReadingCode.html">ReadingCode</a>? I'm always amazed at how little code programmers actually read (other than code they're modifying and even then it seems to be the minimum amount they could get away with).  Studying great code, or great designs, is surely a way to improve and reading bad code or poor designs is a way to see and learn what doesn't work. -- <a href="TedYoung.html">TedYoung</a>
      </p>
      <ul>
        <li>
           This is one of the great advantages of the <a href="OpenSource.html">OpenSource</a> movement, lots of <a href="GreatProgramsToRead.html">GreatProgramsToRead</a>. And if you choose to work on <a href="OpenSource.html">OpenSource</a> projects, you even get code review and mentoring. (There is no need to go out of one's way to read bad code. <a href="BadCode.html">BadCode</a> will be thrust upon you in your career.)
        </li>
      </ul>
      <p>
        I practiced fencing briefly when I was 18.  One day, I complained to the instructor about doing all of the drills with such precision in the precise way he wanted them done.  He said, "You do the drills my way and you will learn exactly what thing means, and how to do things.  When you go out and compete, forget the drills, just try to win."
        It sounds very <a href="ShuHaRi.html">ShuHaRi</a> to me.  Follow the rules unbendingly until you can follow them perfectly.  Then ignore them.  -- <a href="NickArgall.html">NickArgall</a>
      </p>
      <hr/>
      <p>
        See <a href="NoProcess.html">NoProcess</a> <a href="ArtifactFragments.html">ArtifactFragments</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryLearningMethods.html">CategoryLearningMethods</a>
      </p>
    </div>
  </body>
</html>