<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        General Api
      </h1>
      <p>
        Reading <a href="RestIsJustSqlReinvented.html">RestIsJustSqlReinvented</a> I see here a pattern I have observed often: A few basic operations suffice to do (almost?) everything.
      </p>
      <p>
        What are these operations?
      </p>
      <p>
        SQL says CREATE UPDATE DELETE SELECT.
      </p>
      <p>
        Rest says GET PUT POST.
      </p>
      <p>
        Lisp says defun cons car cdr () <em>with () I mean function application.</em> 
      </p>
      <p>
        From Lisp we can go down to Lambda calculus and S&K combinators etc.
      </p>
      <p>
        One could add
      </p>
      <p>
        <a href="FileSystem.html">FileSystem</a> says: cd, cat, rm, mkdir, ls 
      </p>
      <p>
        What is a <a href="GeneralApi.html">GeneralApi</a> that is
      </p>
      <ul>
        <li>
           efficient (has enough structure to allow optimizations of common patterns)
        </li>
        <li>
           general enough to support tasks involving meta and reflection tasks. This is the reason Lisp has eval().
        </li>
        <li>
           minimal in the sense of <a href="KissPrinciple.html">KissPrinciple</a> 
        </li>
      </ul>
      <p>
        I have kind of an answer to this question but would like to hear your opinion first.
      </p>
      <p>
        -- <a href="GunnarZarncke.html">GunnarZarncke</a> <a href="ThinkingOutLoud.html">ThinkingOutLoud</a>
      </p>
      <p>
        A limited set of operations can be sufficient for operation, but that same logic can be used to defend any <a href="TuringTarpit.html">TuringTarpit</a>. We have indicators for when new features are needed, such as <a href="MissingFeatureSmell.html">MissingFeatureSmell</a>, <a href="SymmetryOfLanguage.html">SymmetryOfLanguage</a>, and <a href="EconomyOfExpression.html">EconomyOfExpression</a>. As a note: I consider <a href="KissPrinciple.html">KissPrinciple</a> as most often used to justify the <a href="SimplySimplistic.html">SimplySimplistic</a>; <a href="MinimalDesign.html">MinimalDesign</a> is another option for minimality. Anyhow, my '<a href="GeneralApi.html">GeneralApi</a>' would be found in '<a href="IdealProgrammingLanguage.html">IdealProgrammingLanguage</a>'; after all, <a href="ApiIsLanguage.html">ApiIsLanguage</a> - doubly or triply so when dealing with protocols like REST or SQL where it isn't a mere 'inconvenience' to add new primitives.
      </p>
      <p>
        <em>Minor quibble:  REST isn't a protocol, it's an architectural style.  An example of a RESTful protocol would be HTTP.</em>
      </p>
      <p>
        Granted. Of course, any RESTful architecture will embody a protocol, and it seems a contradiction to even attempt a RESTful protocol suitable for multi-user <a href="InteractiveSceneGraph.html">InteractiveSceneGraph</a>s and <a href="DeltaIsolation.html">DeltaIsolation</a>, so any such protocol will always be <a href="SimplySimplistic.html">SimplySimplistic</a> for some purposes. The best you could hope for is freedom to readily enhance the 'architectural style' with other protocols to the same resources.
      </p>
      <hr/>
      <p>
        Only two fundamental operations are required:
      </p>
      <ul>
        <li>
           Read
        </li>
        <li>
           Write
        </li>
      </ul>
      <p>
        (Tongue mostly in cheek...)
      </p>
      <p>
        <em>Ah, but you need to specify what to read/write. That is the point of "cd", "cdr"/"car" and "select" above (and implicity present in the URLs used to GET/PUT).</em> 
        <em>The richness of this structure is what differs between the approaches. SQL has the richest (in the sense of providing most structure) - but at the same time the most limiting.</em>
        <em>Lisps cond/car/cdr is minimal but complete for DAGs (and with the addition of setf allows cycles) but it couples representation  too strongly with structure (in my opinion and its simplicity is maybe </em><a href="TooPowerfulForItsOwnGood.html">TooPowerfulForItsOwnGood</a>.<em></em>
        <em>The path notation in URLs and file paths amounts to tree structures - with arbitrary graphs possible with sym-links (files) and 302ers (HTTP).</em>
      </p>
      <p>
        <em>-- Gunnar Zarncke</em>
      </p>
      <p>
        Ah, indeed.  Hang on:
      </p>
      <code>
        void *Read(void *where);<br/>
        int Write(void *where, void *stuff);<br/>
      </code>
      <p>
        That should do it.
      </p>
      <p>
        (Tongue now firmly in cheek.)
      </p>
      <p>
        <em>Yes. That does it. :-) Consequently we know can now go to </em><a href="AssemblyLanguage.html">AssemblyLanguage</a> and provide the <a href="GeneralApi.html">GeneralApi</a> equivalent there: move <src> <dst> <em></em>
      </p>
      <hr/>
      <p>
        See also <a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a>, <a href="ApiIsLanguage.html">ApiIsLanguage</a>, <a href="DomainSpecificLanguage.html">DomainSpecificLanguage</a>, 
      </p>
      <hr/>
      <p>
        <a href="MarchZeroNine.html">MarchZeroNine</a>
      </p>
    </div>
  </body>
</html>