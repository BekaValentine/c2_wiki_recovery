<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Life Critical Systems
      </h1>
      <p>
        For example, see <a href="TheChemicalEngineeringCulture.html">TheChemicalEngineeringCulture</a>.
      </p>
      <hr/>
      <p>
        I've often seen it said that <a href="ExtremeProgramming.html">ExtremeProgramming</a> is not suitable for <a href="LifeCriticalSystems.html">LifeCriticalSystems</a>, mostly because testing need to be more rigorous. In my experience, non-<a href="ExtremeProgramming.html">ExtremeProgramming</a> project do far less testing than <a href="ExtremeProgramming.html">ExtremeProgramming</a> projects. So what's the deal?
      </p>
      <p>
        <em>How do you know via testing that your interrupt will always be served in X period of time? How do you know via testing that in bizarre confluences of events not covered by your testing that you won't kill anyone? It's a different standard of proof.</em>
      </p>
      <hr/>
      <p>
        Testing, of course, proves nothing. If something passes the <a href="UnitTest.html">UnitTest</a>s, then that proves that it passes the <a href="UnitTest.html">UnitTest</a>s. Nothing more.
      </p>
      <p>
        In many applications this may be <a href="GoodEnough.html">GoodEnough</a>, if a comprehensive <a href="UnitTest.html">UnitTest</a> suite is available. Testing gives a large amount of evidence (and a high degree of confidence; though never absolute certainty) that a system, once deployed, won't fail (or fails in an expected way).
      </p>
      <p>
        For some applications, that isn't good enough. Which is why an entirely different set of design methodologies are brought to bear. In many such applications, <a href="TuringComplete.html">TuringComplete</a>ness is abandoned altogether (no dynamic allocation, except for maybe a bounded amount on startup; no recursive functions; etc.) in order to gain provability. (You can't prove that an arbitrary Turing machine will or won't halt; that's the <a href="HaltingProblem.html">HaltingProblem</a>. You can prove, however, that a <a href="FiniteStateMachine.html">FiniteStateMachine</a> will/won't halt; which is why many <a href="LifeCriticalSystems.html">LifeCriticalSystems</a> are implemented using FSMs.)
      </p>
      <p>
        [Note: The FDA has many, many requirements for hardware and software of Class IIB and Class III medical devices. It's just too easy to kill somebody if they are hooked up to a machine that simply passes <a href="UnitTest.html">UnitTest</a>s. 
      </p>
      <p>
        To see about 510(k) submissions, Go to 
      </p>
      <ul>
        <li>
           <a href="http://www.fda.gov/medicaldevices/productsandmedicalprocedures/deviceapprovalsandclearances/510kclearances/ucm089428.htm">http://www.fda.gov/medicaldevices/productsandmedicalprocedures/deviceapprovalsandclearances/510kclearances/ucm089428.htm</a> and/or
        </li>
        <li>
           <a href="http://www.fda.gov/medicaldevices/productsandmedicalprocedures/deviceapprovalsandclearances/510kclearances/ucm089319.htm">http://www.fda.gov/medicaldevices/productsandmedicalprocedures/deviceapprovalsandclearances/510kclearances/ucm089319.htm</a>
        </li>
      </ul>
      <p>
        This is just one aspect of FDA approval for medical devices in the US. Peruse the FDA site to get a glimpse of the nature of FDA testing requirements.]
      </p>
      <p>
        FDA General Principles of Software Validation - go to
      </p>
      <ul>
        <li>
           <a href="http://www.fda.gov/regulatoryinformation/guidances/ucm126954.htm">http://www.fda.gov/regulatoryinformation/guidances/ucm126954.htm</a>
        </li>
        <li>
           <a href="http://www.fda.gov/medicaldevices/deviceregulationandguidance/guidancedocuments/ucm085281.htm">http://www.fda.gov/medicaldevices/deviceregulationandguidance/guidancedocuments/ucm085281.htm</a>
        </li>
      </ul>
      <hr/>
      <p>
        Avionics software
        <a href="http://en.wikipedia.org/wiki/Avionics_software">http://en.wikipedia.org/wiki/Avionics_software</a>
      </p>
      <hr/>
      <p>
        It would be nice if my LifeCriticalSystem had <a href="BugFreeSoftware.html">BugFreeSoftware</a>.
      </p>
      <p>
        <em>Bug free isn't nearly as important as predictive; thusly the above comment about finite state machines in medical applications.</em>
      </p>
      <p>
        If <a href="ProofOfCorrectness.html">ProofOfCorrectness</a> can be more complex than the code it's trying to verify, and subject to errors themselves, surely you don't rely on proofs and no testing for <a href="LifeCriticalSystems.html">LifeCriticalSystems</a>?
      </p>
      <p>
        <em>Actually, there are other mechanisms (besides testing) to insure correctness. I related a couple of stories about the </em><a href="FaganDefectFreeProcess.html">FaganDefectFreeProcess</a> on that page; we proved by inspection that code which had been tested <em>still</em> contained bugs, and code which passed inspection absolutely did not. That's what you need for Class IIb and above medical systems, commercial aircraft avionics, mass transportation controls, etc. -- <a href="MartySchrader.html">MartySchrader</a><em></em>
      </p>
    </div>
  </body>
</html>