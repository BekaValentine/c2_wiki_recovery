<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Python And Ruby Are Converging
      </h1>
      <p>
        <a href="RubyLanguage.html">RubyLanguage</a> and <a href="PythonLanguage.html">PythonLanguage</a> often take ideas from each other.
      </p>
      <ul>
        <li>
           <a href="RubyLanguage.html">RubyLanguage</a>'s *rest argument syntax came from <a href="PythonLanguage.html">PythonLanguage</a>. Python has had <a href="KeywordParameterPassing.html">KeywordParameterPassing</a> since the beginning; Ruby will it them in 2.0.
        </li>
      </ul>
      <p>
        Ruby:
      </p>
      <code>
        def foo(a, b=default, *rest)<br/>
        ...<br/>
        end<br/>
      </code>
      <p>
        Python:
      </p>
      <code>
        def foo(a, *rest, b=default):<br/>
        ...<br/>
      </code>
      <ul>
        <li>
           Python unified long integers and small integers in version 2.4. Ruby already had Fixnum/<a href="BigNum.html">BigNum</a> integration.
        </li>
      </ul>
      <ul>
        <li>
           Python 2.4 adds a Decimal library which allows arbitrary precision decimal math. Ruby had a <a href="BigDecimal.html">BigDecimal</a> one for a while.
        </li>
      </ul>
      <ul>
        <li>
           <a href="RubyLanguage.html">RubyLanguage</a> had iterators and <em>yield</em> since the beginning; <a href="PythonLanguage.html">PythonLanguage</a> added them later. But Python's <a href="CoRoutine.html">CoRoutine</a>-ish generators have some advantages over <a href="InternalIterator.html">InternalIterator</a>s, so now Ruby has the Generator class (built with <a href="CallWithCurrentContinuation.html">CallWithCurrentContinuation</a> in 1.8 or Threads in 1.9 and <a href="InternalIterator.html">InternalIterator</a>s). [Compare <a href="GeneratorsAreNotCoroutines.html">GeneratorsAreNotCoroutines</a>.]
        </li>
      </ul>
      <p>
        Python's generators allow you to mix calls to more than one generator at a time and in Python 2.5 more coroutine features have been added to allow the caller to send values to a generator, raise an exception in the generator, or terminate it.
      </p>
      <p>
        Ruby's internal iterators may be chained through several calls: array.find { |x| x.even? }.map { |x| x + 2 }.sort_by { |x| x % 5 }
      </p>
      <p>
        Python uses "generator expressions" to perform iterative inline operations: sorted((x+2 for x in array if x%2 == 0), key=lambda x: x%5)
      </p>
      <ul>
        <li>
           Class variables in <a href="RubyLanguage.html">RubyLanguage</a> were shared in a class hierarchy, while in <a href="PythonLanguage.html">PythonLanguage</a> they were class-specific; now Ruby follows this rule too. 
        </li>
      </ul>
      <ul>
        <li>
           Ruby 1.8 introduced the colon as possible syntax in the for statement
        </li>
      </ul>
      <code>
        for <vars> in <object> [: | then]<br/>
      </code>
      <dl>
        <dt> </dt>
        <dd>which is identical to the pythonic</dd>
      </dl>
      <code>
        for <vars> in <object>: <br/>
      </code>
      <ul>
        <li>
           Even if <a href="PythonPhilosophy.html">PythonPhilosophy</a> says, "Sparse is better then dense" <a href="PythonLanguage.html">PythonLanguage</a> is approaching density. For example, some methods like sort() used to return None and you could not write stuff like the Rubyish
        </li>
      </ul>
      <code>
        open('sorted.txt','w').puts open('in.txt').sort<br/>
      </code>
      <dl>
        <dt> </dt>
        <dd>But now classes like sorted allow you to write in <a href="PythonLanguage.html">PythonLanguage</a>:</dd>
      </dl>
      <code>
        PrivoxyWindowOpen('sorted.txt','w').writelines(sorted(PrivoxyWindowOpen('in.txt')))<br/>
      </code>
      <ul>
        <li>
           When <a href="PythonLanguage.html">PythonLanguage</a> introduced the __iter__ protocol, it gained 
        </li>
      </ul>
      <code>
        for line in open('foo.txt'): do_stuff(line)<br/>
      </code>
      <p>
        which <a href="RubyLanguage.html">RubyLanguage</a> supported since the beginning.
      </p>
      <p>
        This could also be written in Ruby as:
      </p>
      <code>
        File.open('foo.txt').each do | line | do_stuff(line) end<br/>
      </code>
      <p>
        Or:
      </p>
      <code>
        File.foreach("foo.txt") { |f| do_stuff(f) }<br/>
      </code>
      <ul>
        <li>
           The <a href="PythonLanguage.html">PythonLanguage</a> interpreter in 2.4 got a '-m' option to load modules from the cli, useful for one-liners and such. <a href="RubyLanguage.html">RubyLanguage</a> had this ('-r') since the beginning (part of its <a href="PerlLanguage.html">PerlLanguage</a> inheritance).
        </li>
      </ul>
      <ul>
        <li>
           Python's context managers (syntax: "with" clause) enable error handing patterns similar to how blocks are sometimes used in Ruby (<a href="http://www.python.org/dev/peps/pep-0343/)">http://www.python.org/dev/peps/pep-0343/)</a>
        </li>
      </ul>
      <hr/>
      <p>
        While they may be converging superficially, Ruby and Python's library and user community are moving in very different directions. 
      </p>
      <p>
        Rails is a great example of the <a href="RubyWay.html">RubyWay</a>, which is utterly dynamic in both typing and behavior. Python and Ruby are languages competing for a similar bracket, so they will always appear to be "converging," because smart people are finding the key features. But the philosophy of each language, and the way the community uses them, are utterly different. 
      </p>
      <p>
        Python is moving in a direction where the "ideals" are captured by the decisions made in by GVR. The <a href="PythonLanguage.html">PythonLanguage</a> additions and modifications are often taken from other languages but are carefully rethought and reworked through discusion and research to represent the concensus of "The best/clearest way to solve this problem". This allows many programmers to share code that "feels" similar, despite having different authors. 
      </p>
      <p>
        [[ Substitute Python -> Ruby and GVR -> Matz in the above, and the statement would still hold, IMHO ]]
      </p>
      <hr/>
      <p>
        A lot of the features have really converged in the new <a href="BooLanguage.html">BooLanguage</a>. Boo has a Python syntax but supports <a href="LexicalClosure.html">LexicalClosure</a>s/<a href="AnonymousMethod.html">AnonymousMethod</a>s and optional explicit <a href="StaticTyping.html">StaticTyping</a> declarations.
      </p>
      <hr/>
      <p>
        This is a bunch of hooey.
      </p>
      <p>
        The unification of int and long started with 2.0.
      </p>
      <p>
        Java has <a href="BigDecimal.html">BigDecimal</a>; is it also converging? All languages support strings - they must be the same language!
      </p>
      <p>
        Python's __iter__ protocol is not the same as Ruby's code block approach. For example, in Ruby I can make new control flow through code blocks, while in Python I cannot make new syntax.
      </p>
      <p>
        The "with" statement in PEP 343 has *nothing* to do with code blocks. It's new syntax for a very limited scenerio (resource management) where code blocks easily provide a more general implementation space.
      </p>
      <p>
        Well before the __iter__ protocol you could do
      </p>
      <code>
        for line in open('foo.txt'): do_stuff(line)<br/>
      </code>
      <p>
        with a wrapper which implemented __getitem__ correctly, as 
      </p>
      <code>
        class Iter:<br/>
        def __init__(self, callable, sentinel=None):<br/>
        self.callable = callable<br/>
        self.sentinel = sentinel<br/>
        self.at_end = 0<br/>
        self.counter = 0<br/>
        def __getitem__(self, i):<br/>
        if self.at_end: raise IndexError<br/>
        if i != self.counter:<br/>
        raise AssertionError("forward iteration only")<br/>
        x = self.callable()<br/>
        if x == self.sentinel:<br/>
        self.at_end = 1<br/>
        raise IndexError<br/>
        self.counter = self.counter + 1<br/>
        return x<br/>
      </code>
      <code>
        for line in Iter(open('foo.txt').readline, ""): do_stuff(line)<br/>
      </code>
      <p>
        I think this works even back to Python 1.0.  The advantage is the iter protocol doesn't overload __getitem__, which has the expectation of being random access.  That is, open("foo.txt")[5] shouldn't look like it would work and return the 6th line of the file.
        !
      </p>
      <hr/>
      <p>
        <a href="CategoryPython.html">CategoryPython</a> <a href="CategoryRuby.html">CategoryRuby</a> <a href="CategoryComparisons.html">CategoryComparisons</a>
      </p>
    </div>
  </body>
</html>