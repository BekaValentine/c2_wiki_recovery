<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Inherit Stl Containers Publicly
      </h1>
      <p>
        Part of the <a href="CppHeresy.html">CppHeresy</a>.
      </p>
      <p>
        <em>Let's see, what else is a mess. Oh yes, there's all that drivel where we compose a container and have a method that just calls its methods. Screw that - </em><a href="InheritStlContainersPublicly.html">InheritStlContainersPublicly</a>. Oh, you think that will break encapsulation? <a href="BloodyOath.html">BloodyOath</a> it would, except that python is doing your encapsulation for you. Well then, what about when you have a class with two containers? <a href="ReFactor.html">ReFactor</a> it. But wouldn't that result in MI? Maybe not with <a href="StlStyle.html">StlStyle</a>, but even if it does, <a href="MultipleInheritanceIsNotEvil.html">MultipleInheritanceIsNotEvil</a>.<em></em>
      </p>
      <hr/>
      <p>
        In orthodox (non-Python) <a href="CeePlusPlus.html">CeePlusPlus</a>, an alternative is to inherit privately and add using declarations as needed. It is less typing than composition and it avoids problems like the lack of virtual destructor.
      </p>
      <p>
        <em>This is a </em>much<em> better alternative. It's not so much that it is heresy to publicly inherit from STL containers. Who cares about heresy? It's that </em>it just isn't a good idea<em> and can lead to subtle bugs, especially if you use any polymorphism. You are much better off using simple private inheritance (i.e. </em><a href="ImplementationInheritance.html">ImplementationInheritance</a>) and explicitly publishing the members you want with <em>using</em> declarations. -- <a href="RobertDiFalco.html">RobertDiFalco</a><em></em>
      </p>
      <hr/>
      <p>
        It is usually advised <em>not</em> to derive a class from STL (<a href="StandardTemplateLibrary.html">StandardTemplateLibrary</a>).  This is because STL does not provide virtual destructors and so can cause a problem if you destroy it from the base class.  You can embed the STL class and inline all of the calls you want to use from it.  This will only cost you programming time now and will leave you with a more robust class for future modifications.  -- <a href="WayneMack.html">WayneMack</a>
      </p>
      <p>
        <em>True with public inheritance. However ill advised, you can avoid the problem with private inheritance.</em>
      </p>
      <hr/>
      <p>
        Ah, I wasn't familiar with <em>using</em> plus private inheritance. Yes, this improves the <a href="CppHeresy.html">CppHeresy</a> - thanks! --<a href="PeterMerel.html">PeterMerel</a>
      </p>
      <hr/>
      <p>
        <em>Explanation please?</em>
      </p>
      <hr/>
      <p>
        Attention all alleged C++ heretics. The bonding layer between C++ and the scripting layer is a "<a href="PublishedInterface.html">PublishedInterface</a>" - that's one step above a "<a href="PublicInterface.html">PublicInterface</a>". So, per <a href="EncapsulationIsHierarchical.html">EncapsulationIsHierarchical</a>, wide and reckless interfaces within one capsule are okay so long as you don't >publish< them.
      </p>
      <p>
        If you published them, you'd be responsible for maintaining them, going forward. That would inhibit refactoring.
      </p>
      <p>
        So if we see that the commandment "make <a href="PublishedInterface.html">PublishedInterface</a>s as narrow as possible" is being followed to the letter, then this is <a href="CppOrthodoxy.html">CppOrthodoxy</a>, not <a href="CppHeresy.html">CppHeresy</a>, and our sophomoric attempts to disconcert the gurus must lead elsewhere. 
      </p>
      <p>
        Sorry. --<a href="PhlIp.html">PhlIp</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryCpp.html">CategoryCpp</a> <a href="CategoryContainer.html">CategoryContainer</a>
      </p>
    </div>
  </body>
</html>