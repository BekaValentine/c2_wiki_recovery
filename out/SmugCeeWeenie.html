<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Smug Cee Weenie
      </h1>
      <p>
        This page doesn't refer to progammers who like C (or C++), or who write code in it for a living.  Rather, this page refers to that subset who think that C is the greatest programming language ever created; and that higher-level languages (even C++ sometimes) are crutches intended for weaklings; unsuitable for true programmers.  
      </p>
      <p>
        In particular, the <a href="SmugCeeWeenie.html">SmugCeeWeenie</a> is one who:
      </p>
      <ul>
        <li>
           Views performance as the only requirement that matters; often to the point of sacrificing correctness.  (Other issues like schedule and budget are dismissed as pedestrian concerns of the <a href="PointyHairedBoss.html">PointyHairedBoss</a>, and irrelevant to the programmer).  Views feature requests (from customers) which are difficult for his way of doing things to be irrelevant; after all <a href="TheCustomersAreIdiots.html">TheCustomersAreIdiots</a>.
        </li>
        <li>
           Thinks anyone who cannot do things his way (in C) has no business being in the profession.  Views high-level languages solely as a means to make gurus like him expendable.
        </li>
        <li>
           In general, views abractions with disdain.  Believes it is the programmers' responsibility to have a detailed understanding of all aspects of their code at the lowest level of abstraction (and the performance implications of each).
          <ul>
            <li>
               Abstraction is OK when done for portability--this is why the <a href="SmugCeeWeenie.html">SmugCeeWeenie</a> doesn't abandon C altogether and program in <a href="AssemblyLanguage.html">AssemblyLanguage</a>.  Considers C to be a highly portable language.  Considers any abstractions implemented on top of C superfluous (by implemeting <em>in</em> C, you've met the portability requirement; hence the other abstractions are just overhead).
            </li>
            <li>
               Abstraction is also OK if done to save typing.  Thinks C's terseness is a benefit.  Has a collection of favorite macros which don't permit higher-level reasoning about the code, but require fewer keystrokes to use.
            </li>
          </ul>
        </li>
        <li>
           Often, dislikes C++ immensely.  Not for being too low-level (no automatic memory management; etc) but for being too high-level.  Whines about the immense and burdensome cost of things like constructors and virtual function calls.  Makes silly claims about C++ being bloated, because he compiled a "Hello World" program on Visual C++ ten years ago and it pulled in 400k worth of libraries.
          <ul>
            <li>
               Views the overhead of function calls as undesirable; prefers macros instead.  (Doesn't trust the compiler to respect "inline" declarations, so he resorts to macros to make sure the code is expanded inline).
            </li>
          </ul>
        </li>
        <li>
           Views <a href="PointerArithmetic.html">PointerArithmetic</a>, unchecked typecasts, and such as treasured features that make C indispensable (and high-level languages lacking such features worthless).  Considers use of <a href="UndefinedBehavior.html">UndefinedBehavior</a> within a program to be the badge of a true wizard.
        </li>
        <li>
           Has grudgingly accepted <a href="AnsiCee.html">AnsiCee</a> features like function prototypes; though he still prefers the old K&R way because writing the function declaration twice (once in the header, once in the body) is a waste of his time.
        </li>
        <li>
           Likes to optimize code by hand; doesn't trust the compiler to do a thorough job.
          <ul>
            <li>
               Still uses "register" declarations everywhere througout his code; often claiming that he doesn't trust the optimizer to efficiently assign variables to registers -- and then declares 30 register variables, on a CPU that's lucky if it manages to support just 8.
            </li>
            <li>
               Unrolls loops manually (or uses <a href="DuffsDevice.html">DuffsDevice</a> prolificly throughout his code, and replaces memcpy in other people's code with <a href="DuffsDevice.html">DuffsDevice</a>).  
            </li>
            <li>
               Writes loops that are incomprehensible because he manually hoists loop invariants, or manually inserts additional induction variables to avoid multiplications.
            </li>
            <li>
               Bonus points if he writes different versions of the same function/algorithm, hand-optimized for different platforms, selected via #ifdef.  (The application is intended only for one of the platforms, naturally, but he produces versions for other platforms "just in case".)  Even more bonus points if the function so "optimized" is main().
            </li>
          </ul>
        </li>
        <li>
           Maintains a set of macros for inspecting/modifying activation records on his favorite compiler/platform.  Believes that the compiler/platform vendor has an affirmative duty not to make any ABI changes that would break his macros.
        </li>
        <li>
           Maintains his one library for managing the freestore because "malloc is slow".
        </li>
      </ul>
      <hr/>
      <p>
        <a href="CategoryWeenie.html">CategoryWeenie</a>
      </p>
    </div>
  </body>
</html>