<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Object Oriented Database
      </h1>
      <p>
        Object-Oriented Database Management Systems (OODBMS's) are databases that store their contents as objects.  They map very well to the object models of the programs that use them.  
      </p>
      <p>
        Drawbacks include indexing (sometimes you have to write your own indexing code; often retrieval performance is bad) and interworking with non-OO company-wide systems.  On the upside, the object persistence is easy to program, and complex data objects are surprisingly natural.
      </p>
      <p>
        Price is also high at the time of this writing (<a href="ObjectStore.html">ObjectStore</a>(?) costs around three times what the already-exorbitantly-priced Oracle 8i does). Alternatively, see <a href="OpenSourceObjectOrientedDatabase.html">OpenSourceObjectOrientedDatabase</a>.
      </p>
      <p>
        In the general sense, an OODB is a <a href="NavigationalDatabase.html">NavigationalDatabase</a>... with methods.
      </p>
      <ul>
        <li>
           <em>Many of them called OODBMS don't support methods.</em>
        </li>
      </ul>
      <p>
        Alternatives to an <a href="ObjectOrientedDatabase.html">ObjectOrientedDatabase</a> include a <a href="PrevalenceLayer.html">PrevalenceLayer</a>, a <a href="RelationalDatabase.html">RelationalDatabase</a> (by using <a href="ObjectRelationalMapping.html">ObjectRelationalMapping</a>), or a <a href="HierarchicalDatabase.html">HierarchicalDatabase</a> (e.g. a filesystem).
      </p>
      <hr/>
      <p>
        <em>Why haven't </em><a href="ObjectOrientedDatabase.html">ObjectOrientedDatabase</a> 's become popular?<em></em>
      </p>
      <p>
        I think the reason is that <a href="ObjectOrientedDatabase.html">ObjectOrientedDatabase</a> is an oxymoron.  A database, by definition, is a base of <strong>data</strong> - it allows you to query it, index it, and revert it (transactions).  All of these properties depend on dead, static data (try indexing a true method) - data that is the same no matter how many times you look at it.  Objects, on the other hand, do the exact opposite - they hide the data under behaviors, which can vary depending on hidden things (information hiding), hence precluding queries, indexes, and transactions.  In order to hook up your objects to a database, you need to do 80% of the work of an <a href="ObjectRelationalMapper.html">ObjectRelationalMapper</a> , anyway.
      </p>
      <p>
        The remaining 20% benefit of an <a href="ObjectOrientedDatabase.html">ObjectOrientedDatabase</a> (as well as the syntactical improvements over SQL) isn't worth deviating from the relational/SQL standard.
      </p>
      <p>
        <a href="ObjectOrientedDatabase.html">ObjectOrientedDatabase</a> is not an oxymoron, and what database actually is is defined by what it can do and what it contains, not by some arbitrary definition that focuses on popular aspects only. If database contains "dead static data" only, what about the stored procedures? Triggers? Database contains data, but it does not have to contain only data. A simple, common sense to think what <a href="ObjectOrientedDatabase.html">ObjectOrientedDatabase</a> is would be e.g. take Versant's approach: db stores objects and indexes them according by their public attributes. And you do not have to violate information hiding at all to get them: you could index on public attributes only, or on values returned by getters (like typical java getters). I don't see how finding accessing a public "x" attribute of live in-memory "new Foo()" object is not violation of information hiding, while searching for the Foo class objects in database and bringing them into memory from "hibernation" in <a href="ObjectOrientedDatabase.html">ObjectOrientedDatabase</a> and then accessing their public "x" attributes would supposedly be the case of violating information hiding. Whether you hold objects in memory or on disk seems orthogonal to me to the issue of information hiding in objects. That's "just" a performance consideration, not enscapsulation or representation issue.
      </p>
      <p>
        On popularity issue: there's a number of concerns here. 1. there is no object query language that would be both *standardized* and reasonably small to be *implementable* (practical, in short). 2. reason 1 results in lack of people with <a href="ObjectOrientedDatabase.html">ObjectOrientedDatabase</a> querying skills => companies are unable to find people that would realize the benefits of <a href="ObjectOrientedDatabase.html">ObjectOrientedDatabase</a> and so they don't use OODBs. 3. premises 1 and 2 result in lack of good open source <a href="ObjectOrientedDatabase.html">ObjectOrientedDatabase</a> => there is no place to learn <a href="ObjectOrientedDatabase.html">ObjectOrientedDatabase</a> query language that would be widely applicable (that is, beyond one's personal interest) => premise 2 is reinforced.
      </p>
      <hr/>
      <p>
        It's also worth noting that OO DBAs are a lot harder to find than relational DBAs.
      </p>
      <p>
        And <a href="RubyLanguage.html">RubyLanguage</a> programmers are a lot harder to find than <a href="CobolLanguage.html">CobolLanguage</a> programmers.  It's a <a href="SelfFulfillingProphecy.html">SelfFulfillingProphecy</a> - a function of market penetration, viz. <a href="CrossingTheChasm.html">CrossingTheChasm</a>. (See also <a href="CrossingChasms.html">CrossingChasms</a>, a large pattern language that describes how to connect an object system to a <a href="RelationalDatabase.html">RelationalDatabase</a>. )
      </p>
      <p>
        Ruby is open source, it is widely available and it has <a href="KillerApp.html">KillerApp</a> (<a href="RubyOnRails.html">RubyOnRails</a>). Therefore, soon <a href="RubyLanguage.html">RubyLanguage</a> programmers will soon be more abundant than <a href="CobolLanguage.html">CobolLanguage</a> programmers. OODBs suffer for lack of equivalents of MySQL and PostgreSQL: it's chicken and egg dilemma, you don't use <a href="ObjectOrientedDatabase.html">ObjectOrientedDatabase</a> bc you haven't learned it and risk a lot if you learn vendor-specific OODB (skills unportable between employers), and since few people learn OODBs, they don't get used.
      </p>
      <hr/>
      <p>
        Is there an up to date list of <a href="ObjectOrientedDatabase.html">ObjectOrientedDatabase</a> vendors somewhere? (yes February 2014 <a href="http://www.service-architecture.com/products/object-oriented_databases.html">http://www.service-architecture.com/products/object-oriented_databases.html</a> )  Maybe on <a href="WikiWikiWeb.html">WikiWikiWeb</a>?  A <a href="GoogleSearch.html">GoogleSearch</a> came up with the following (alphabetically):
      </p>
      <ul>
        <li>
           AllegroStore
        </li>
        <li>
           Cache (<a href="http://www.intersystems.com)">http://www.intersystems.com)</a>
        </li>
        <li>
           CommonSQL / UncommonSQL
        </li>
        <li>
           db4o (<a href="DeeBeeFourOh.html">DeeBeeFourOh</a>) <a href="http://www.db4o.com">http://www.db4o.com</a> (open source)
        </li>
        <li>
           <a href="GemStone.html">GemStone</a>
        </li>
        <li>
           GOODS (<a href="http://www.garret.ru/~knizhnik/goods.html)">http://www.garret.ru/~knizhnik/goods.html)</a>
        </li>
        <li>
           Objectivity/DB (<a href="http://www.objectivity.com/object-database.shtml)">http://www.objectivity.com/object-database.shtml)</a>
        </li>
        <li>
           <a href="ObjectDesignInc.html">ObjectDesignInc</a>
        </li>
        <li>
           <a href="OzoneDb.html">OzoneDb</a> (<a href="http://ozone-db.org)">http://ozone-db.org)</a>
        </li>
        <li>
           PLOB! (acronym for Persistent Lisp OBjects; see <a href="http://plob.sourceforge.net/">http://plob.sourceforge.net/</a> )
        </li>
        <li>
           POET
        </li>
        <li>
           Versant
        </li>
        <li>
           Xanalys's CLOS SQL binding
        </li>
        <li>
           XL2 (<a href="http://www.xl2.net)">http://www.xl2.net)</a>
        </li>
      </ul>
      <p>
        (feel free to properly wikify these names if pages already exist for them, remove ones that are not relevant, and add ones that are missing).
      </p>
      <p>
        Q. What are the differentiators for each of the vendors and their products?
      </p>
      <p>
        A. The differentiators are probably the targeted use cases, scalability, product maturity, architectural philosophy, API, and of course, cost.
      </p>
      <hr/>
      <p>
        Is there a clear definition of what an OODBMS is? Or at least a list of guiding principles? <a href="BertrandMeyer.html">BertrandMeyer</a> seems to suggest that OO is against the concept of DBMS's to begin with. There is talk that the concept of a database violates encapsulation. In this view OO is about behavior, not data, and you access data through behavior wrappers(methods). "Naked attributes" violates some definitions of encapsulation.
      </p>
      <p>
        <em>See </em><a href="http://www.odmg.org''">http://www.odmg.org''</a>
      </p>
      <p>
        It seems one has to buy a book in order to make a bulleted list of requirements. That smells.
      </p>
      <ul>
        <li>
           What's smellier is that each book would probably result in a different list.
        </li>
      </ul>
      <p>
        <em>See also "The Object-Oriented Database System Manifesto" (at </em><a href="http://www-2.cs.cmu.edu/People/clamen/OODBMS/Manifesto/htManifesto/Manifesto.html).''">http://www-2.cs.cmu.edu/People/clamen/OODBMS/Manifesto/htManifesto/Manifesto.html).''</a>
      </p>
      <hr/>
      <p>
        There is still no agreed-upon definition or clear characterization of an OODBMS. It's difficult to judge the merits of one without a stable definition or feature set.
      </p>
      <hr/>
      <p>
        <strong>Verb Divas</strong>
      </p>
      <p>
        One of the problems with the idea of OODBMS is that the activities on objects and collections of objects is not standardized. In RDBMS and most prior databases you generally have a standard set of <a href="DatabaseVerbs.html">DatabaseVerbs</a> that all records and all tables respond to in the same fashion. It's a form of <a href="InterfaceFactoring.html">InterfaceFactoring</a>. In OOP philosophy, each and every object is generally considered its own <em>independent</em> state machine with its own behavior. Any sharing of interface or behavior commonality is purely voluntary and thus inconsistent. This is against the idea that <a href="InterfaceFactoring.html">InterfaceFactoring</a> is important and useful; it's essentially anti-database. Having a standard set of collection-oriented operations does not preclude additional custom behavior, I would note. Custom behavior is fine, but one should be discouraged from reinventing the wheel if there already is a "close enough" standard operation. -t
      </p>
      <p>
        <em>Wow.  It's rare I agree with Top, but I agree with Top.  Quick, somebody photograph this moment.</em>
      </p>
      <p>
        For court evidence :-)
      </p>
      <hr/>
      <p>
        See also <a href="PersistenceEngine.html">PersistenceEngine</a>, <a href="PrevalenceLayer.html">PrevalenceLayer</a>, <a href="ModernDinosaur.html">ModernDinosaur</a>, <a href="ObjectRelationalPsychologicalMismatch.html">ObjectRelationalPsychologicalMismatch</a>.
      </p>
      <hr/>
      <p>
        [<a href="CategoryDatabase.html">CategoryDatabase</a>]
      </p>
    </div>
  </body>
</html>