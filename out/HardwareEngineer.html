<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Hardware Engineer
      </h1>
      <p>
        A <a href="HardwareEngineer.html">HardwareEngineer</a> designs electronics. These days that means a lot of PLD, FPGA, and other kinds of ASIC and semi-custom stuff as well as the usual out-of-the-box devices.
      </p>
      <p>
        Question: What distinguishes Hardware from Software Engineers as programmable chips come online?
      </p>
      <p>
        <em>A couple of possibilities... none of these criteria is firmly written in stone:</em>
      </p>
      <ul>
        <li>
           <em>The computational model employed; all general purpose programming languages are based on </em><a href="TuringMachine.html">TuringMachine</a>s (or on other mathematical formulations which have equivalent computational power, such as the <a href="LambdaCalculus.html">LambdaCalculus</a>). (Some special-purpose languages may use less powerful models, such as <a href="FiniteStateMachine.html">FiniteStateMachine</a> or PushdownAutomata). Hardware engineers generally deal with state machines and combinatorial logic, with occasional use of stacks and the like.<em></em>
        </li>
      </ul>
      <ul>
        <li>
           <em>Software engineers are generally freed from having to worry about such things as signal timing, clock skew, bus capacitance and loading (fan-out), analog signal processing (and analog signal characteristics), temperature, power consumption, electromagnetic interference, and a whole host of other nasties which plague hardware engineers.</em>
        </li>
      </ul>
      <dl>
        <dt>	 </dt>
        <dd>Software engineers, however, do have to worry about similar constraints such as response times, memory utilization, code re-entry and other threading issues, and external data sources with various data characteristics. The specifics differ but the concept remains. As a former hardware engineer, though, I find that hardware engineers usually have far better tools available for addressing their issues.</dd>
      </dl>
      <ul>
        <li>
           <em>Hardware engineers can employ high degrees of parallelism when performing computations; software engineers are limited by the </em><a href="VonNeumannBottleneck.html">VonNeumannBottleneck</a>.<em></em>
        </li>
      </ul>
      <ul>
        <li>
           <em>Software engineers are generally not capable of </em>SmokingTheBoard - destroying via software the hardware that the software is running on.<em></em>
        </li>
      </ul>
      <ul>
        <li>
           <em>Software engineers can produce designs that are malleable in ways that hardware engineers cannot approach. This has many functional advantages, but many feel it leads to much greater sloppiness in our craft.</em>
        </li>
      </ul>
      <ul>
        <li>
           <em>Software engineers, in many cases, are wholly unfamiliar with sound engineering practice.</em>
        </li>
      </ul>
      <ul>
        <li>
           <em>Tools for software engineers are (in many ways) much simpler, faster, (and cheaper!) than CAD tools for hardware engineers. While generating optimal code in a compiler and routing an FPGA are both </em><a href="NpHard.html">NpHard</a> problems, quick-and-dirty heuristics will generally suffice for software engineers; you will rarely, if ever, see a C compiler spending hours trying to squeeze every last cycle or instruction out of a function. CAD tools for FPGA or ASIC design, on the other hand, must engage in rather expensive global optimizations to be worthwhile. Consequently, such tools may take hours to run, even on ultra-fast workstations.<em></em>
        </li>
      </ul>
      <ul>
        <li>
           <em>Only one thing more dangerous than a hardware engineer with a compiler: a software engineer with a soldering iron. </em><a href="HaHaOnlySerious.html">HaHaOnlySerious</a><em></em>
        </li>
      </ul>
      <dl>
        <dt>	 </dt>
        <dd>You are presuming he knows which end gets hot, of course. Oh, is it the one without the cord sticking out?</dd>
      </dl>
      <dl>
        <dt>	 </dt>
        <dd>I just hope he never tries to Pair Solder!</dd>
      </dl>
      <ul>
        <li>
           <em>A distinguishing thing between these is that the former has to deal with </em>'physics<em>' -- that's a major constraint.  The latter only has to deal with logic.</em>
        </li>
      </ul>
      <hr/>
      <p>
        See:
        <a href="SoftwareEngineer.html">SoftwareEngineer</a>, <a href="FirmwareEngineer.html">FirmwareEngineer</a>, <a href="EmbeddedSystemsEngineer.html">EmbeddedSystemsEngineer</a>, <a href="JustAnEngineer.html">JustAnEngineer</a>, <a href="ComputerEngineering.html">ComputerEngineering</a>
      </p>
      <p>
        <a href="CategoryHardware.html">CategoryHardware</a>
      </p>
    </div>
  </body>
</html>