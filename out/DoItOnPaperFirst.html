<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Do It On Paper First
      </h1>
      <p>
        See also <a href="PersonalAnalogDevice.html">PersonalAnalogDevice</a>
      </p>
      <p>
        I think the gist of this page is valid. It can be summerised as per Eric Steven Raymond's book The Art of Unix Programming (ISBN:0131429019):
      </p>
      <p>
        One subtle but powerful way to promote compactness in a design is to organize it around a strong core algorithm addressing a clear formal definition of the problem, avoiding heuristics and fudging. Many of its most effective tools are thin wrappers around a direct translation of some single powerful algorithm.
      </p>
      <hr/>
      <p>
        <strong>The key: simulate the execution of a program on paper as an insighful wikizen writes below</strong>
      </p>
      <p>
        This is certainly a principle that has never existed or if it did it was long forgotten: [<em>only</em>] if you can do it on paper you can do it on the computer. 
      </p>
      <ul>
        <li>
           The "only" part is false. Most people who use computers to do things have no idea how to do them on paper. Almost all programmers who implement software <strong>also</strong> could not do the same thing on paper, because they are computer specialists, not generalists; large parts of the process they would not know how to do on paper.
        </li>
        <li>
           Furthermore, the extremely wide use of machine learning and search space algorithms means that computers these days quite frequently do things that no human knows how to do.
        </li>
        <li>
           As I previously said below, "real time" software inherently cannot be done on paper.
        </li>
        <li>
           So although you have a small point (most accurately phrased "if some human can consistently perform an activity on paper, then most of the time <strong>some</strong> programmer, but not all programmers, will be able to figure out how to do the same thing in software"), there is no further generalization of that point that is generally true. -- <a href="DougMerritt.html">DougMerritt</a>
        </li>
      </ul>
      <p>
        A lot of people think a computer is a miracle tool and computers can perform miracles. Untrue! Computers can only do what the human mind can do (usually mechanical tasks) but it does it a lot <strong>faster</strong>. 
      </p>
      <p>
        Most of the software is simply an adaptation on the computer of an existing mechanical or paper system:
      </p>
      <ul>
        <li>
           Software accounting programs are emulations of double accounting entries, Accounts Receivable, Accounts payable, Inventory lists lists. 
        </li>
      </ul>
      <ul>
        <li>
           Spreadsheets are emulations of ... the original paper spreadsheets, which were computed by hand.
        </li>
      </ul>
      <ul>
        <li>
           Word processors are emulations of work produced by a typewriter (to witness the language used: font, margins, tabs, etc.)
        </li>
      </ul>
      <ul>
        <li>
           PIMs are emulations of appointment books and to do lists
        </li>
      </ul>
      <ul>
        <li>
           Wikis are basically emulations of index cards. They are electronic index cards. Albeit index cards that can be viewed and edited by anyone in the world. This is what makes Internet collective tools so revolutionary!  
        </li>
      </ul>
      <ul>
        <li>
           Databases are emulations of paper tables. You remember those tables we'd make with columns...
        </li>
      </ul>
      <ul>
        <li>
           Your turn...
        </li>
      </ul>
      <p>
        <em>one must realize the computer does not create new work.  Computers and software programs are there to improve existing work and work processes.  It should not be a surprise that everything currently done by computer was previously done manually.</em>
      </p>
      <p>
        I think there may be a slight disconnect here.  Is this page discussing whether computers automate tasks that were once done on paper, or is it discussing whether one should create a design on paper prior to writing the code?  The discussion presented seems to differ from what I would expect from the title.
      </p>
      <hr/>
      <p>
        Are <a href="NeuralNetworks.html">NeuralNetworks</a> a counter example?
      </p>
      <p>
        In this case you don't know the algorithm needed for a computer to perform a specific task. (All you know is the algorithm that will enable a computer to learn how to do the task.)
      </p>
      <p>
        <em>How does one tell whether the task is done correctly?  Just because one does not know how to write an algorithm to describe something does not mean it is a brand new operation that has never been done.</em>
      </p>
      <p>
        It's an example of a computer doing a task that we need not know the algorithm for. The computer is performing the task in a manner that has no paper equivalence. 
      </p>
      <hr/>
      <p>
        <strong>The closest thing to this principle is:</strong>
      </p>
      <p>
        <a href="GarbageInGarbageOut.html">GarbageInGarbageOut</a>. If your entries are not well done chances are your program will work poorly. <strong>No kidding!</strong>
      </p>
      <hr/>
      <p>
        <strong>The principle applied to compulinguistics</strong>
      </p>
      <p>
        Perhaps the biggest reproach we can make to all the private investors, companies and governments who have invested millions of dollars in translation by computer since 1946 is the fact that they forgot this very simple principle: if it can be done on paper it can be done on the computer. 
      </p>
      <p>
        Does a system on paper exist? No. OK simple. Can't be done. 
      </p>
      <p>
        Or no wait. It can be done <strong>if you find a paper system</strong>.
      </p>
      <p>
        <em>But is it also true that it can be done </em>'iff<em>' you find a paper system?</em>
      </p>
      <ul>
        <li>
           Note that "iff" means "if and only if"
        </li>
      </ul>
      <ul>
        <li>
           Definitely not; many things are done on computers that cannot be done on paper. The easy examples are things that require real time control; paper is too slow. Non-real-time applications would be solvable in principle on paper, but these days, typically not in a useful way. -- <a href="DougMerritt.html">DougMerritt</a>
        </li>
      </ul>
      <ul>
        <li>
           It's important to realize that real time software is unlike every other kind of computer application, because by definition, if real time software gets an otherwise-correct answer too slowly, then it is <strong>incorrect</strong>. Since that is part of the definition, it follows that real time software cannot be done on paper. With other kinds of things, it's merely that no one in their right mind would try it, but it wouldn't be impossible by definition.
        </li>
      </ul>
      <p>
        <em>Of course, if you can do it on the computer, you can do it on paper as well, because you can always </em>'simulate the execution of a program on paper.<em>' But that would be pointless, this insight doesn't help to write the program in the first place.</em>
      </p>
      <p>
        Instructions are commands you give the Martian. Instead of giving them live, you use some code so that the Martian can execute these instructions. The code is called a programming language. 
      </p>
      <p>
        But you could ask a human being to do it. They are humanly instructions given to a Martian with no brain. So obviously the human brain can do it, they come from a human brain. They are all within the realms of a human brain!
      </p>
      <p>
        So no matter what, whichever way you put it, if your instructions work for the Martian they work for the human being. 
      </p>
      <p>
        I spent 4 months looking for an algorithm for my program (on paper). I could not do a task and reduce it to simple instructions. I went through 200 roughs. Finally I was able to do it. The programmer was in town and he programmed it in two days.
      </p>
      <hr/>
      <p>
        <em>After that statement, a whole lot of air has been let out of this topic.  Crafting an algorithm and implementing an algorithm are two sides of a coin that cannot be separated.  The first is a perfect Platonic world, and the latter is where all the mistakes are made... hence where all the learning takes place.  One of the fantastic aspects of programming is that it so greatly accelerates human learning.</em>
      </p>
      <hr/>
      <p>
        There are a whole host of applications that aren't possible on paper that are on a computer, simply because those things have no real meaning if you apply them to a non-computer domain:
      </p>
      <ul>
        <li>
           Device control
        </li>
        <li>
           Audio editing  
        </li>
        <li>
           Teleconferencing  
        </li>
        <li>
           Video compression
        </li>
      </ul>
      <p>
        Some of the individual tasks that make up each of these applications might be doable on paper, but they're meaningless in a paper scenario, unless you're talking about just simulating them.
      </p>
      <p>
        This is more than just a nit or a semantic quibble:  the original suggestion was that unless you have a paper method for doing these things, it's difficult or impossible to do them in software.  Some programming activities don't lend themselves well the design pattern of "do it by hand, then automate".
      </p>
      <hr/>
      <p>
        Doesn't this page simply restate the <a href="ChurchTuringThesis.html">ChurchTuringThesis</a>? That is, all universal computers are equivalent, and so any algorithm computable by one is (in principle) computable by all? (And does that mean that a <a href="NeuralNetwork.html">NeuralNetwork</a> is not a universal computer by the Church-Turing definition?)-- <a href="KatherineDerbyshire.html">KatherineDerbyshire</a>
      </p>
      <hr/>
      <p>
        Somewhat off the direction of this page, but I have found that I often can't get a computation quite right working with an editor. Then I finally get out the pad of paper and write the algorithm on paper (and it might just be a few lines), and suddenly it works! This has lead me to believe <a href="TheKeyboardIsTheWorstPlaceToDesign.html">TheKeyboardIsTheWorstPlaceToDesign</a>.
      </p>
      <p>
        <em>Could you provide any insight as to why you believe this to be the case?</em>
      </p>
      <p>
        Code is an expression of <em>implementation</em>. Algorithms are an expression of <em>design</em>. One has to have a design in place before anything below that can happen. The algorithm should have been there in the first place, actually. When one gets to a point where one realizes one doesn't know what the heck one is doing then it's time to go back to the paper.
      </p>
      <p>
        Another aspect of this is that writing it down makes one think about the processing more clearly. Sometimes one may fool one's self into believing that one knows what is going on, but when ya write it down in the clear it's obvious ya ain't got a clue. Luckily nobody else was watching to see you embarrass yersef like that.
      </p>
      <hr/>
      <p>
        <em>If you can do it on paper, you can do it on the computer.</em>
      </p>
      <p>
        I think it depends upon one's definition of "can."  If "can" means that it is possible, given unlimited resources and time, then the statement is probably true.  If "can" means that it is feasible within a reasonable budget and time period, the it really depends.
      </p>
      <p>
        I have been involved for several years with a project to move a paper based process used by multiple offices to a computer based process.  Each office was able to do its job on paper using paper (or word of mouth) guidance at each office.  Getting a computer based set of rules has required a lot of compromise between offices (it was not feasible to produce a customized version for each individual office).  Even now, there are certain unexpected needs that pop up and an office will revert to paper to handle that need.  These occurrences have diminished over the years, but I don't think they will ever go away.
      </p>
      <p>
        Paper provides a high degree of flexibility (i.e., no rules) that can only be mimicked by a computer program, and even then a great deal of effort is often required to handle "simple" options.
      </p>
    </div>
  </body>
</html>