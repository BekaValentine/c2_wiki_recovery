<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Generic Function
      </h1>
      <p>
        <em>This is another one of </em><a href="ThomasKuehne.html">ThomasKuehne</a>'s patterns -- <a href="PhilGoodwin.html">PhilGoodwin</a><em></em>
      </p>
      <p>
        A <a href="GenericFunction.html">GenericFunction</a> implements <a href="ExternalPolymorphism.html">ExternalPolymorphism</a> and <a href="MultipleDispatch.html">MultipleDispatch</a> by maintaining a dispatch table that associates parameter types with <a href="FunctorObject.html">FunctorObject</a>s. When a <a href="GenericFunction.html">GenericFunction</a> is called it uses the dynamic types of its parameters as keys into the dispatch table in order to retrieve a specialized <a href="FunctorObject.html">FunctorObject</a>. The call is then delegated to the <a href="FunctorObject.html">FunctorObject</a>.
      </p>
      <p>
        Of course the implementation of a <a href="GenericFunction.html">GenericFunction</a> is not required to consider only type information in the dispatch. It may consider the values of the parameters or even (in unusual cases) other information about the state of the program.
      </p>
      <p>
        A <a href="GenericFunctionObject.html">GenericFunctionObject</a> is a <a href="FunctorObject.html">FunctorObject</a> for a <a href="GenericFunction.html">GenericFunction</a>. It provides parameterization of <a href="HigherOrderFunction.html">HigherOrderFunction</a>s with polymorphic behavior.
      </p>
      <p>
        <a href="GenericFunction.html">GenericFunction</a>s are the preferred implementation of <a href="ExternalPolymorphism.html">ExternalPolymorphism</a> for use with the <a href="TranslatorPattern.html">TranslatorPattern</a>.
      </p>
      <p>
        <strong>Implementation</strong>
        The attributes of the parameters that are to be used as selection criteria are assembled into a key which is then used to retrieve a SpecializedFunction from a map. The original call is then delegated to the SpecializedFunction. The canonical attribute to use as a selection criteria is, of course, the type of the parameter. Therefore some mechanism is generally needed to retrieve type information from objects at runtime. Some languages have this built in. Others may require potentially intrusive measures in order to implement it by hand.
      </p>
      <hr/>
      <p>
        In the context of the <a href="CommonLispObjectSystem.html">CommonLispObjectSystem</a> the term "generic function" denotes <em>a function whose behavior depends on the classes or identities of the arguments supplied to it and whose parts include, among other things, a set of methods, a lambda list, and a </em><a href="MethodCombination.html">MethodCombination</a> type<em> (quoted from the </em><a href="CommonLispHyperSpec.html">CommonLispHyperSpec</a>). Conversely, within CLOS the term "method" is defined to mean <em>an object that is part of a generic function and which provides information about how that generic function should behave when its arguments are objects of certain classes or with certain identities.</em>
      </p>
      <p>
        Also see the sections "Introduction to Generic Functions" (<a href="http://www.lispworks.com/reference/HyperSpec/Body/07_fa.htm)">http://www.lispworks.com/reference/HyperSpec/Body/07_fa.htm)</a> and "Introduction to Methods" (<a href="http://www.lispworks.com/reference/HyperSpec/Body/07_fb.htm)">http://www.lispworks.com/reference/HyperSpec/Body/07_fb.htm)</a> in the <a href="CommonLispHyperSpec.html">CommonLispHyperSpec</a> for detailed explanations.
      </p>
      <hr/>
      <p>
        These two definitions are basically in harmony. The first describes a "workaround pattern" which gives you something like Lisp generic functions, in a weak OO programming language. Since in the weak language you don't have the "deluxe" object-oriented dispatch mechanism over all of the arguments, you hack it together yourself by creating an object that has registered functors, and selects among them. These are analogous to <a href="CommonLisp.html">CommonLisp</a> methods, which are associated with a generic function.
      </p>
      <p>
        Also, in Lisp, functions are objects, so there is no distinction between <a href="GenericFunction.html">GenericFunction</a> and <a href="GenericFunctionObject.html">GenericFunctionObject</a>. If you define a (defgeneric foo (a b)) you can indirect upon it easily: (mapcar #'foo list-of-objects) and so on. This gives you an instant <a href="VisitorPattern.html">VisitorPattern</a> in a box.
      </p>
      <hr/>
      <p>
        <a href="CategoryObjectFunctionalPatterns.html">CategoryObjectFunctionalPatterns</a> <a href="CategoryCommonLisp.html">CategoryCommonLisp</a> <a href="CategoryPolymorphism.html">CategoryPolymorphism</a>
      </p>
    </div>
  </body>
</html>