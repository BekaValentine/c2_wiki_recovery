<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Java Unit Is Evil
      </h1>
      <p>
        I assert that <a href="JavaUnitIsEvil.html">JavaUnitIsEvil</a> because I'm a <a href="TellDontAsk.html">TellDontAsk</a> kind of developer. Now don't get me wrong I'm completely in favour of test driven development.  I'm just absolutely convinced that <a href="JavaUnit.html">JavaUnit</a> is not the right tool to exploit this strategy.  It offers a FinePromise but delivers a <a href="DeadEnd.html">DeadEnd</a>.  <a href="JavaUnit.html">JavaUnit</a> encourages perhaps even forces developers to violate the spirit of encapsulation and the <a href="LawOfDemeter.html">LawOfDemeter</a>.  
      </p>
      <p>
        All too often I see JUnit tests like the following, and despair.
      </p>
      <code>
        public void testGetSetProperty() {<br/>
        setProperty( 10 );<br/>
        assertEquals( 10, getProperty() );<br/>
        }<br/>
      </code>
      <p>
        -- <a href="MartinSpamer.html">MartinSpamer</a>
      </p>
      <p>
        <em>I don't see how that's a fault of JUnit.  If you don't like tests like that, don't write tests like that.  Write the tests you really need.  If the relevant property is used at all, it will be employed in the context of other tests, and hence tested implicitly.</em>
      </p>
      <p>
        I do write the tests I really need which is why I don't use <a href="JavaUnit.html">JavaUnit</a>.  However <strong>I</strong> do find that most JUnit tests are written like that.  <a href="JavaUnit.html">JavaUnit</a> tests like this require the tested class to expose its internal implementation. <a href="JavaUnit.html">JavaUnit</a> tests therefore redefine the shape of the Class's interface.  That is what 'I find Evil'.
      </p>
      <p>
        <em>JUnit tests only "require" the tested class to expose its internal implementation if a naive developer uses it that way.  There is nothing in JUnit that stops you from writing tests like the following:</em>
      </p>
      <code>
        @Test<br/>
        public void testSplork() {<br/>
        Splork classUnderTest = new Splork();<br/>
        classUnderTest.runTestOfInternalStuff();<br/>
        assertEquals(10, classUnderTest.getTestResult());<br/>
        }<br/>
      </code>
      <p>
        <em>Presumably, such test methods (or some equivalent) would need to exist regardless of what testing framework you use.  Unless there's some characteristic unique to JUnit that you haven't mentioned, I don't see why JUnit would be more evil than anything else.</em>
      </p>
      <p>
        The testSplork example fails the <a href="HollywoodPrinciple.html">HollywoodPrinciple</a> and is not semantically different from the testGetSetProperty example.
      </p>
      <p>
        <em>It is semantically different, because it does not expose any internal structure of Splork except for the test method itself (plus getTestResult()), which can hide a series of internal tests.  Thus, it is a single point of contact with a very specific (i.e., test) purpose, so it does not encourage excessive coupling.  The testGetSetProperty example implies exposure of internal attributes in order to support external tests, which does encourage excessive coupling and effectively violates encapsulation.</em>  
      </p>
      <p>
        <em>If this is a problem, what do you suggest as an alternative?</em> 
      </p>
      <p>
        <em>As for failing the </em><a href="HollywoodPrinciple.html">HollywoodPrinciple</a>, what alternative do you propose?  That every class implement a setTestHarness(...) method, or implement a Testable interface?<em></em>
      </p>
      <p>
        Use <a href="MockObject.html">MockObject</a>s.  That's exactly what they're designed for. For Java you can use jMock: <a href="http://www.jmock.org.">http://www.jmock.org.</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryEvil.html">CategoryEvil</a>
      </p>
    </div>
  </body>
</html>