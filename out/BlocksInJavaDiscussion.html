<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Blocks In Java Discussion
      </h1>
      <p>
        Area to discuss or comment on the Wiki Article <a href="BlocksInJava.html">BlocksInJava</a> -- <a href="RobertDiFalco.html">RobertDiFalco</a>
      </p>
      <hr/>
      <p>
        <strong>Discussion and Suggestions:</strong>
      </p>
      <p>
        Very elegant! I implemented something similar (but simpler) for evolving programs with strongly typed sexual reproduction (aka crossover) in both Java and C++. However, my system was a much more basic use of the Interpreter pattern and didn't include curried functions.
      </p>
      <p>
        One thing I included in my library was type safety. The Java version had reflective capabilities that could be used to ensure type safety when built in to the AST; each function or predicate had a method for querying the Class of the returned value and arguments. The C++ version used templates to ensure type safety at compile time. Have you considered type safety in your library?
      </p>
      <p>
        Finally, are you planning to release this to the public? -- <a href="NatPryce.html">NatPryce</a>
      </p>
      <p>
        Nat, thanks. About type-safety, I've thought about it a bit. One part of me would like to add it explicitly while another part would like the ast package to be a foundation that one <em>could</em> construct a type-safety solution <em>on top of</em> (if needed for their solution domain). I do use <em>some</em> simple error checking in my implementation to ensure, for example, that the <em>Object</em> returned by a <em>Function</em> is a <em>Boolean</em> before retrieving its <em>booleanValue</em> in a <em>Predicate</em>. As you know, this sort of thing is much cleaner with C++ templates. I also started a GJ implementation and that was a joy. However, in actual use I was surprised at how sufficient a job the Java VM did of reporting type problems with un-checked exceptions. While that may be fine in some applications, it wont be in others. 
      </p>
      <p>
        I would like to release it publicly. In a way I have here. -- <a href="RobertDiFalco.html">RobertDiFalco</a>
      </p>
      <p>
        As for releasing the package, how about setting up a <a href="SourceForge.html">SourceForge</a> project? -- <a href="NatPryce.html">NatPryce</a>
      </p>
      <p>
        I finally got around to reading this page, and I am very impressed with the whole presentation. I've wanted something like this in the past - but I didn't have a clear idea as to what kind of infrastructure would work well, and at the time the desire didn't seem strong enough to warrant the work. Please do consider making the package itself available somewhere, and also register my interest in your abstract data types package. -- Brett Neumeier
      </p>
      <p>
        Very Cool. The thought just occurred to me that I should atleast learn Smalltalk so I will know what is missing in Java. -- Venu Thachappilly
      </p>
      <p>
        Wow. I am very impressed. This has given me a lot to think about. I get the gist from the text and code examples, however I've become stuck trying to actually code an <a href="InternalIterator.html">InternalIterator</a> of my own. I would be very grateful if you would publish the AST and ADT packages for others to use and learn from. -- <a href="EricHerman.html">EricHerman</a> 
      </p>
      <p>
        A few of years later, I'm amazed that there was a time when the subject matter seemed at the edge of my understanding. I use blocks "all the time" now, and this page really changed the way I program in Java and thus gave me a window into understanding some of what is so nice about the way some other languages (Ruby, Smalltalk) handle blocks so nicely. This page will remain a wiki clasic for me. -- <a href="EricHerman.html">EricHerman</a>
      </p>
      <p>
        Robert, this is great stuff. Really elegant code. Writing interpreters for predicate trees in java is no fun at all, but this helps take the pain. I really miss prolog for this, but I may have learn some smalltalk now :-) Are you still thinking about making these packages (ast, adt) available? -- <a href="BillDehora.html">BillDehora</a>
      </p>
      <p>
        Robert,  I am too lazy to assemble this document into Java source. You should put this on sourceforge soon. It would really be a significant contribution. -- <a href="ThomasEnebo.html">ThomasEnebo</a>
      </p>
      <p>
        Using this document I've written my own version of these interfaces and classes in about three hours. I didn't go all the way with re-writing the Java collections; I'm using a static utility-type class to encapsulate the iterator mess but it works well and maybe sometime in the future I'll rework the collections for performance. Overall, this is a fantastic page and Robert did a great job summing up his work. Much appreciated, Robert. -- <a href="JeffPanici.html">JeffPanici</a>
      </p>
      <p>
        Fantastic stuff. Unfortunately the ItemSequence interface flew completely over my head. How would one go about using that? I keep seeing Index as an STL iterator, which is probably not what it is at all. Could anyone who understands ItemSequence put up a code snippet that would show it's use, please? -- <a href="JonThoroddsen.html">JonThoroddsen</a>
      </p>
      <hr/>
      <p>
        I keep coming back to this, and I do like it; even though it illustrates the poverty of a language which cannot generate its own code and run it. I was wondering about whether it was worth adding parenthesis? I may be missing something in my partially grokked state, of course. -- <a href="RichardHenderson.html">RichardHenderson</a>.
      </p>
      <p>
        Binders are essentially parenthesis. -- <a href="RobertDiFalco.html">RobertDiFalco</a>
      </p>
      <hr/>
      <p>
        I have a project in <a href="SourceForge.html">SourceForge</a> that is attempting to cover much the same ground. Look at <a href="http://jga.sf.net/">http://jga.sf.net/</a>
        (<a href="JavaGenericAlgorithms.html">JavaGenericAlgorithms</a>)
      </p>
      <p>
        There is also an apache project that seems to be working in the same conceptual area (I just found it today, myself). The apache project is <a href="http://jakarta.apache.org/commons/sandbox/functor/">http://jakarta.apache.org/commons/sandbox/functor/</a>
      </p>
      <p>
        -- <a href="DavidHall.html">DavidHall</a>
      </p>
      <hr/>
      <p>
        For yet-another-set-of-functor-interfaces, these ones with java 1.5 generics and varargs, see <a href="http://www.dishevelled.org/functor">http://www.dishevelled.org/functor</a> -- <a href="MichaelHeuer.html">MichaelHeuer</a>
      </p>
      <hr/>
      <p>
        For those who would prefer true syntax and types for blocks and who can afford to use a Java extension instead of Java itself, you should look at the <a href="NiceLanguage.html">NiceLanguage</a>. -- <a href="DanielBonniot.html">DanielBonniot</a>
      </p>
      <hr/>
      <p>
        Building on <a href="RobertDiFalco.html">RobertDiFalco</a>'s work, I have been using a couple of classes with some success. Admittedly, they do not achieve the performance gains of rewriting collections, but they work well and are conceptually simple. Both classes are wrappers for the existing java interfaces. -- <a href="AnonymousDonor.html">AnonymousDonor</a>
      </p>
      <hr/>
      <code>
        public class <strong>InternalIterator</strong><br/>
        {<br/>
        private Iterator at;<br/>
      </code>
      <code>
        // constructor<br/>
        public InternalIterator( Iterator at )<br/>
        {<br/>
        this.at = at;<br/>
        }<br/>
      </code>
      <code>
        //* eval block for each<br/>
        public void <strong>enum</strong>( UnaryProcedure aBlock )<br/>
        {<br/>
        while ( at.hasNext() )<br/>
        aBlock.run( at.next() );<br/>
        }<br/>
      </code>
      <code>
        //* increment count for each true<br/>
        public int <strong>count</strong>( UnaryPredicate aBlock )<br/>
        {<br/>
        int count = 0;<br/>
      </code>
      <code>
        while ( at.hasNext() )<br/>
        if (aBlock.is( at.next() ))<br/>
        count++;<br/>
      </code>
      <code>
        return count; <br/>
        }<br/>
      </code>
      <code>
        //* remove item for each block that answer true<br/>
        public void <strong>remove</strong>( UnaryPredicate aBlock )<br/>
        {<br/>
        while ( at.hasNext() )<br/>
        if ( aBlock.is( at.next() ) )<br/>
        at.remove();<br/>
        }<br/>
      </code>
      <code>
        //* detect first for block answers true<br/>
        public Object <strong>detect</strong>( UnaryPredicate aBlock )<br/>
        {<br/>
        while ( at.hasNext() )<br/>
        {<br/>
        Object each = at.next();<br/>
        if ( aBlock.is( each ) )<br/>
        return each; <br/>
        }<br/>
      </code>
      <code>
        return null;<br/>
        }<br/>
      </code>
      <code>
        //* inject value into block with each item<br/>
        public Object <strong>inject</strong>( Object value, BinaryFunction aBlock )<br/>
        {<br/>
        Object nextValue = value;<br/>
      </code>
      <code>
        while ( at.hasNext() )<br/>
        nextValue = aBlock.eval( nextValue, at.next() );<br/>
      </code>
      <code>
        return nextValue;<br/>
        }<br/>
      </code>
      <code>
        //* answer new collection for each true<br/>
        public Collection <strong>select</strong>( UnaryPredicate aBlock )<br/>
        {<br/>
        Collection result = new ArrayList();<br/>
      </code>
      <code>
        while ( at.hasNext() )<br/>
        {<br/>
        Object each = at.next();<br/>
        if (aBlock.is( each ))<br/>
        result.add( each );<br/>
        }<br/>
      </code>
      <code>
        return result;<br/>
        }<br/>
      </code>
      <code>
        //* answer new collection for each false<br/>
        public Collection <strong>reject</strong>( UnaryPredicate aBlock )<br/>
        {<br/>
        Collection result = new ArrayList();<br/>
      </code>
      <code>
        while ( at.hasNext() )<br/>
        {<br/>
        Object each = at.next();<br/>
        if (!aBlock.is( each ))<br/>
        result.add( each );<br/>
        }<br/>
      </code>
      <code>
        return result;<br/>
        }<br/>
      </code>
      <code>
        //* answer new collection of non-null results<br/>
        public Collection <strong>collect</strong>( UnaryFunction aBlock )<br/>
        {<br/>
        Collection result = new ArrayList();<br/>
      </code>
      <code>
        while ( at.hasNext() )<br/>
        {<br/>
        Object each = aBlock.eval( at.next() );<br/>
        if (each != null)<br/>
        result.add( each );<br/>
        }<br/>
      </code>
      <code>
        return result;<br/>
        }<br/>
        }<br/>
      </code>
      <hr/>
      <code>
        public class <strong>AstCollection</strong><br/>
        implements Collection<br/>
        {<br/>
        private Collection m_items;<br/>
      </code>
      <code>
        //* constructor<br/>
        public AstCollection( Collection items )<br/>
        {<br/>
        m_items = items;<br/>
        }<br/>
      </code>
      <code>
        //* eval block for each<br/>
        public void <strong>enum</strong>( UnaryProcedure aBlock )<br/>
        {<br/>
        getInternalIterator().enum( aBlock );<br/>
        }<br/>
      </code>
      <code>
        //* increment count for each true<br/>
        public int <strong>count</strong>( UnaryPredicate aBlock )<br/>
        {<br/>
        return getInternalIterator().count( aBlock );<br/>
        }<br/>
      </code>
      <code>
        //* remove item for each block that answer true<br/>
        public void <strong>remove</strong>( UnaryPredicate aBlock )<br/>
        {<br/>
        getInternalIterator().remove( aBlock );<br/>
        }<br/>
      </code>
      <code>
        //* detect first for block answers true<br/>
        public Object <strong>detect</strong>( UnaryPredicate aBlock )<br/>
        {<br/>
        return getInternalIterator().detect( aBlock );<br/>
        }<br/>
      </code>
      <code>
        //* inject value into block with each item<br/>
        public Object <strong>inject</strong>( Object value, BinaryFunction aBlock )<br/>
        {<br/>
        return getInternalIterator().inject( value, aBlock );<br/>
        }<br/>
      </code>
      <code>
        //* answer new collection for each true<br/>
        public Collection <strong>select</strong>( UnaryPredicate aBlock )<br/>
        {<br/>
        return getInternalIterator().select( aBlock );<br/>
        }<br/>
      </code>
      <code>
        //* answer new collection for each false<br/>
        public Collection <strong>reject</strong>( UnaryPredicate aBlock )<br/>
        {<br/>
        return getInternalIterator().reject( aBlock );<br/>
        }<br/>
      </code>
      <code>
        //* answer new collection of non-null results<br/>
        public Collection <strong>collect</strong>( UnaryFunction aBlock )<br/>
        {<br/>
        return getInternalIterator().collect( aBlock );<br/>
        }<br/>
      </code>
      <code>
        //* wrap an Iterator with InternalIterator<br/>
        private InternalIterator <strong>getInternalIterator</strong>()<br/>
        {<br/>
        return new InternalIterator( iterator() );<br/>
        }<br/>
      </code>
      <code>
        /* (non-Javadoc)<br/>
      </code>
      <ul>
        <li>
           @see java.util.Collection#add(java.lang.Object)
        </li>
        <li>
          /
        </li>
      </ul>
      <code>
        public boolean <strong>add</strong>( Object o )<br/>
        {<br/>
        return m_items.add( o );<br/>
        }<br/>
      </code>
      <code>
        /* (non-Javadoc)<br/>
      </code>
      <ul>
        <li>
           @see java.util.Collection#addAll(java.util.Collection)
        </li>
        <li>
          /
        </li>
      </ul>
      <code>
        public boolean <strong>addAll</strong>( Collection c )<br/>
        {<br/>
        return m_items.addAll( c );<br/>
        }<br/>
      </code>
      <code>
        /* (non-Javadoc)<br/>
      </code>
      <ul>
        <li>
           @see java.util.Collection#clear()
        </li>
        <li>
          /
        </li>
      </ul>
      <code>
        public void <strong>clear</strong>()<br/>
        {<br/>
        m_items.clear();<br/>
        }<br/>
      </code>
      <code>
        /* (non-Javadoc)<br/>
      </code>
      <ul>
        <li>
           @see java.util.Collection#contains(java.lang.Object)
        </li>
        <li>
          /
        </li>
      </ul>
      <code>
        public boolean <strong>contains</strong>( Object o )<br/>
        {<br/>
        return m_items.contains( o );<br/>
        }<br/>
      </code>
      <code>
        /* (non-Javadoc)<br/>
      </code>
      <ul>
        <li>
           @see java.util.Collection#containsAll(java.util.Collection)
        </li>
        <li>
          /
        </li>
      </ul>
      <code>
        public boolean <strong>containsAll</strong>( Collection c )<br/>
        {<br/>
        return m_items.containsAll( c );<br/>
        }<br/>
      </code>
      <code>
        /* (non-Javadoc)<br/>
      </code>
      <ul>
        <li>
           @see java.util.Collection#isEmpty()
        </li>
        <li>
          /
        </li>
      </ul>
      <code>
        public boolean <strong>isEmpty</strong>()<br/>
        {<br/>
        return m_items.isEmpty();<br/>
        }<br/>
      </code>
      <code>
        /* (non-Javadoc)<br/>
      </code>
      <ul>
        <li>
           @see java.util.Collection#iterator()
        </li>
        <li>
          /
        </li>
      </ul>
      <code>
        public Iterator <strong>iterator</strong>()<br/>
        {<br/>
        return m_items.iterator();<br/>
        }<br/>
      </code>
      <code>
        /* (non-Javadoc)<br/>
      </code>
      <ul>
        <li>
           @see java.util.Collection#remove(java.lang.Object)
        </li>
        <li>
          /
        </li>
      </ul>
      <code>
        public boolean <strong>remove</strong>( Object o )<br/>
        {<br/>
        return m_items.remove( o );<br/>
        }<br/>
      </code>
      <code>
        /* (non-Javadoc)<br/>
      </code>
      <ul>
        <li>
           @see java.util.Collection#removeAll(java.util.Collection)
        </li>
        <li>
          /
        </li>
      </ul>
      <code>
        public boolean <strong>removeAll</strong>( Collection c )<br/>
        {<br/>
        return m_items.removeAll( c );<br/>
        }<br/>
      </code>
      <code>
        /* (non-Javadoc)<br/>
      </code>
      <ul>
        <li>
           @see java.util.Collection#retainAll(java.util.Collection)
        </li>
        <li>
          /
        </li>
      </ul>
      <code>
        public boolean <strong>retainAll</strong>( Collection c )<br/>
        {<br/>
        return m_items.retainAll( c );<br/>
        }<br/>
      </code>
      <code>
        /* (non-Javadoc)<br/>
      </code>
      <ul>
        <li>
           @see java.util.Collection#toArray()
        </li>
        <li>
          /
        </li>
      </ul>
      <code>
        public Object[] <strong>toArray</strong>()<br/>
        {<br/>
        return m_items.toArray();<br/>
        }<br/>
      </code>
      <code>
        /* (non-Javadoc)<br/>
      </code>
      <ul>
        <li>
           @see java.util.Collection#toArray(java.lang.Object[])
        </li>
        <li>
          /
        </li>
      </ul>
      <code>
        public Object[] <strong>toArray</strong>( Object[] a )<br/>
        {<br/>
        return m_items.toArray( a );<br/>
        }<br/>
      </code>
      <code>
        /* (non-Javadoc)<br/>
      </code>
      <ul>
        <li>
           @see java.util.Collection#size()
        </li>
        <li>
          /
        </li>
      </ul>
      <code>
        public int <strong>size</strong>()<br/>
        {<br/>
        return m_items.size();<br/>
        }<br/>
        }<br/>
      </code>
      <p>
        <em>From the above code... me thinks someone's been looking at </em><a href="SmallTalk.html">SmallTalk</a>'s collection hierarchy, I say that because I <a href="HaveThisPattern.html">HaveThisPattern</a>, and wrote something similar for my own collections.<em></em>
      </p>
      <hr/>
      <p>
        See <a href="BlocksInManyLanguages.html">BlocksInManyLanguages</a>, <a href="BlocksInCsharp.html">BlocksInCsharp</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryObjectFunctionalPatterns.html">CategoryObjectFunctionalPatterns</a> | <a href="CategoryClosure.html">CategoryClosure</a> | <a href="CategoryJava.html">CategoryJava</a>
      </p>
    </div>
  </body>
</html>