<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Rights Amplification
      </h1>
      <p>
        <strong>Rights amplification</strong> is a security mechanism where bringing two or more authorities into one place results in a new authority. That is, the whole is greater than the sum of its parts.
      </p>
      <p>
        Most implementations of <a href="CapabilitySecurityModel.html">CapabilitySecurityModel</a>s support some form of <a href="RightsAmplification.html">RightsAmplification</a>.
      </p>
      <p>
        MarkMiller's <a href="EeLanguage.html">EeLanguage</a> (which supports <a href="ObjectCapabilityModel.html">ObjectCapabilityModel</a>) achieves this via <strong>sealer/unsealer</strong> pairs. That is, you can create a pair of objects such that the 'sealer' can seal the message it receives, and <em>only</em> the 'unsealer' can later unseal the message. This is a <a href="RightsAmplification.html">RightsAmplification</a> mechanism because it takes both the sealed message and the unsealer to have the authority to read the message (which may, of course, contain more capabilities). 
      </p>
      <p>
        <a href="EeLanguage.html">EeLanguage</a> supports this as a primitive; the 'sealer' doesn't perform any encryption unless the sealed message crosses host boundaries. Presumably, a sealer/unsealer could be implemented by pure objects via use of a serialization and encryption algorithm, but doing so is non-trivial (especially when dealing with object names, generic type-safety, and obtaining random bits). 
      </p>
      <p>
        The sealer/unsealer rights amplification can be used for a number of things. One could use it to implement first-class type abstractions, to secure a dataflow, to track 'responsibility' (see <a href="http://www.erights.org/elib/capability/horton/),">http://www.erights.org/elib/capability/horton/),</a> to force a quorum, even to implement (ugh) ACLs, and so on.
      </p>
      <p>
        <a href="PasswordCapabilityModel.html">PasswordCapabilityModel</a>, or at least a few variations of it like <a href="SimplePublicKeyInfrastructure.html">SimplePublicKeyInfrastructure</a>, perform rights amplification by a more direct approach. Basically, you get two certificates. One of them says: <em>"People who have a need to know about Foo also need to know about Bar, signed Alice."</em> Another of them says <em>"John needs to know about Foo, signed Alice."</em> The first certificate provides a rule that amplifies the latter, granting John a right to know about Bar. The potential complexity of such rules depends only upon the language used to describe them.
      </p>
      <p>
        A <a href="RightsAmplification.html">RightsAmplification</a> mechanism goes a long way to allowing developers and users to capture interesting security patterns and policies.  
      </p>
    </div>
  </body>
</html>