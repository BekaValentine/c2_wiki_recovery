<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Pli Language
      </h1>
      <p>
        PL/I is a <a href="ProgrammingLanguage.html">ProgrammingLanguage</a> developed as part of the IBM 360 project, designed by the IBM laboratory at Hursley Park in England in the early 1960s, as an outgrowth of the NPL language.
      </p>
      <ul>
        <li>
           Despite contemporary assumptions that the name should be pronounced "Pee-ell One", as in "Programming Language 1", it is actually "Pee-ell Eye".
        </li>
        <li>
           <em>Not quite; maybe Radin and everyone else at Hursley sayd "Pee-ell Eye", for all I know, but most of the world has always said "Pee-ell-one", since the 1970s at least, and apparently during the 1960s Freiburghouse Multics PL/I development, too. So it's not about "contemporary" nor about revisionism. And indeed, since it abbreviates "</em>ProgrammingLanguageOne", that's only natural.<em></em>
        </li>
        <li>
           <em>The logical place to straighten this out would be </em><a href="http://en.wikipedia.org/wiki/PL/I_programming_language,">http://en.wikipedia.org/wiki/PL/I_programming_language,</a> which disagrees with your pronunciation -- I'm not saying they're authoritative on the subject, just that it would be handy to make them so.<em></em>
        </li>
        <li>
           Given that Intel's 1970s PL/M is mnemonic for "Programming Language <em>for</em> Microcomputers" and Prime Computer's 1970s PL/P was mnemonic for "Programming Language <em>for</em> Prime" and Digital Research's 1970s CP/M was mnemonic for "Control Program <em>for</em> Microcomputers"---all establishing a consistent use of / standing for "for"---, it is not too hard to imagine that some people at the time consistently colloquially referred to PL/I (in the "pee ell <em>eye</em>" sense) as "Programming Language <em>for IBM</em>" although this would certainly be contested by the Multics folks who used PL/I (in the "pee ell one" sense) at MIT, GE, and Honeywell.  In fact therein may lie the explanation:  pee ell eye is IBM-centric whereas pee ell one is eccumenical/nondenominational, especially to Multics.  This is not unlike the vigorously-contested divergent pronunciations inside and outside IBM in various communities of:  CICS (see eye see ess) versus CICS (kicks) and SQL (ess cue ell) versus SQL ("sequel", the SeQueL to the Square query language).  Even in more modern times, the two divergent pronunciations of ATM (ay tee em in 1990s-and-onward telecom industrial usage) versus ATM ("atom" 53-byte AToMs at asynchronous transfer mode's place of origination, Bell Labs, during the 1980s) indicates that insiders/authors/progenitors often refer to an acronym with a wink and a smile, referring to their work by both an official name (suitable for official-sounding defense to the up-the-chain-of-command bureaucracy) and an insider-in-the-know name.
        </li>
      </ul>
      <p>
        PL/I was intended to accompany the IBM (<a href="InternationalBusinessMachines.html">InternationalBusinessMachines</a>) System/360 (<a href="IbmSystemThreeSixty.html">IbmSystemThreeSixty</a>) line of <a href="MainframeComputer.html">MainframeComputer</a>s. Thus PL/I was intended to replace commercially oriented COBOL (<a href="CobolLanguage.html">CobolLanguage</a>), scientifically oriented FORTRAN (<a href="FortranLanguage.html">FortranLanguage</a>), and academic-and-scientifically oriented Algol (<a href="AlgolSixty.html">AlgolSixty</a>). So, PL/I has features from all of these, extending or enhancing many.
      </p>
      <p>
        See:
      </p>
      <ul>
        <li>
           PL/I FAQ: <a href="http://www.faqs.org/faqs/computer-lang/pli-faq/">http://www.faqs.org/faqs/computer-lang/pli-faq/</a>
        </li>
        <li>
           Encyclopedia of computer languages (terse) entry for PL/I: <a href="http://hopl.murdoch.edu.au/showlanguage.prx?exp=185">http://hopl.murdoch.edu.au/showlanguage.prx?exp=185</a>
        </li>
        <li>
           The open source PL/I for GCC (the GNU compiler family with shared back-end) project is in its early stages (version 0.0.10 in Mar 2005) at <a href="http://pl1gcc.sourceforge.net/">http://pl1gcc.sourceforge.net/</a>
        </li>
      </ul>
      <p>
        Although regarded as generally block-structured, PL/I retained--and enhanced--the now-reviled <em>goto</em>, allowing alphanumeric names, and allowing it to exit arbitrarily-nested blocks. The PL/I Optimizing Compiler (PliOpt) from IBM in the early 1970s added a <em>select</em> statement as a <em>switch</em> or <em>case</em>-construct to the language. PL/I remained as <a href="WeaklyTyped.html">WeaklyTyped</a> as FORTRAN and COBOL, except for self-describing arrays and <em>varying</em>-length character strings. IBM developed its symbolic-debugging PL/I Checkout Compiler (PliCkt) as a work-around on a grand scale for the weak typing. PL/I also introduced features then new to high-level languages, notably <a href="ExceptionHandling.html">ExceptionHandling</a>, programmer control of storage allocation and deallocation, and dynamic program loading (PliOpt and PliCkt only). Its explicit multitasking features and data addressing via explicit pointer variables may also have been firsts. With discipline, PL/I can be a very effective language for <a href="StructuredProgramming.html">StructuredProgramming</a> and <a href="ModularProgramming.html">ModularProgramming</a> (but see contrary opinion below by Dijkstra).
      </p>
      <p>
        PL/I was adopted as a U.S. standard by Technical Committee X3J1 of the American National Standards Committee in the late 1970s, apparently minus the <em>select</em> statement.
      </p>
      <p>
        Released at a time when the installed memory for <a href="MainframeComputer.html">MainframeComputer</a>s was comparable to 80286 <a href="MicroComputer.html">MicroComputer</a>s (e.g.: IBM PC AT) gathering dust in many of today's closets, the full PL/I-F compiler (version 5 in 1971) would run in less than <em>40 KB</em> (forty kilobytes, not a typo for four hundred) of memory, albeit using approximately <em>90 compiler phases</em> (ninety, not a typo for nine; the numbers 88 and 92 stick in my mind as candidates for the actual number). At the campus computer center of one large (U.S.) state's premier university, the main memory (a.k.a. RAM) commonly used for smallish PL/I compilations was only 128KB (1/8 MB)--and that was <em>full PL/I</em>, in all its elephantine glory!
      </p>
      <p>
        PL/I is still in use today on <a href="InternationalBusinessMachines.html">InternationalBusinessMachines</a> <a href="MainframeComputer.html">MainframeComputer</a>s, usually running MVS. It is also popular on some VAX/VMS machines (see <a href="VmsOperatingSystem.html">VmsOperatingSystem</a>). 2 PL/I subsets were also available on the Univac 1100 systems in the late 1970s: 1 for teaching (known as PLUM), and  1 for commercial use.
      </p>
      <p>
        Programming-language derivatives of PL/I are discussed in <a href="CategoryPli.html">CategoryPli</a>.
      </p>
      <hr/>
      <p>
        <strong><em>Trivia</em></strong>
        At first it was called NPL: New programming Language.
      </p>
      <p>
        The legend goes that IBM registered PL/1, PL/2, PL/3, ... PL/99 as trademarks,
        but there's no evidence for this. The U.S. PTO doesn't have any record that IBM
        ever had a trademark for "PL/I", "PL/1", or "PL/2".
      </p>
      <hr/>
      <p>
        PL/I received substantial attention from the academic and software-engineering community in the late 1960s and 1970s:
      </p>
      <p>
        George Radin and H. Paul Rogoway: "NPL: Highlights of A New Programming Language". <em>Communications of the ACM</em>, 8(1), pp. 9-17, January 1965.
      </p>
      <p>
        F.J. Corbato: "PL/I as a Tool for Systems Programming", <em>Datamation</em>, Volume 15, Number 5, May, 1969.
      </p>
      <p>
        M. Donald MacLaren: "Tasking in standard PL/I". ACM <em>SIGPLAN Notices</em>, 8(9), pp. 104-108, September 1973.
      </p>
      <p>
        M. Donald MacLaren: "Exception handling in PL/I". ACM <em>SIGPLAN Notices</em>, 12(3), pp. 101-104, March 1977.
      </p>
      <p>
        G. Radin: "The early history and characteristics of PL/I". ACM <em>SIGPLAN Notices</em>, 13(8), pp. 227-241, August 1978; Also same author and title: ACM <em>SIGPLAN Notices</em>, 18(6), pp. 551-599, June 1981.
      </p>
      <p>
        Alas, I suppose if one were to create a Wiki entry, e.g.: SigPlan or SigplanNotices, for the influential but unrefereed Association of Computing Machinery periodical <em>SIGPLAN Notices</em>, someone would append a note griping about namespace bloating.
        --<a href="ClayPhipps.html">ClayPhipps</a>
      </p>
      <hr/>
      <p>
        Its possible that some other programming languages beat PL/I to some of the firsts claimed above as innovations. BurroughsAlgolLanguage, in which systems programming for the Burroughs 5000, 6000, and 7000 series was done, may have had some of PL/I's features. <a href="BcplLanguage.html">BcplLanguage</a>, an otherwise plausible candidate, wasn't finished until 1967: after PL/I had been out for maybe 2 years.  However, BCPL's predecessor: <a href="CplLanguage.html">CplLanguage</a>, clearly predates both, it being described in a 1963 paper.
      </p>
      <hr/>
      <p>
        PL/I is a block structured language, so some claim it is in the <a href="AlgolFamily.html">AlgolFamily</a>. This strikes others like claiming that the monster in Frankenstein's lab is a member of the Frankenstein family.
      </p>
      <hr/>
      <p>
        PL/I for OpenVMS is available and supported by Kednos Corp, <a href="http://www.kednos.com">http://www.kednos.com</a>
      </p>
      <hr/>
      <p>
        Of PL/I, the famously firebreathing computer scientist Edsger Dijkstra (<a href="EwDijkstra.html">EwDijkstra</a>) wrote in 1972: "Using PL/I must be like flying a plane with 7000 buttons, switches, and handles to manipulate in the cockpit. I absolutely fail to see how we can keep our growing programs firmly within our intellectual grip when by its sheer baroqueness, the programming language--our basic tool, mind you!--already escapes our intellectual control. And if I have to describe the influence PL/I can have on its users, the closest metaphor that comes to my mind is that of a drug." [original typescript made accessible (after the fact) as <a href="http://www.cs.utexas.edu/users/EWD/ewd03xx/EWD340.PDF,">http://www.cs.utexas.edu/users/EWD/ewd03xx/EWD340.PDF,</a> p. 9; published in <em>CACM</em> vol. 15 num. 10]
      </p>
      <hr/>
      <p>
        <a href="CategoryProgrammingLanguage.html">CategoryProgrammingLanguage</a> <a href="CategoryPli.html">CategoryPli</a>
      </p>
    </div>
  </body>
</html>