<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Multi Valued Logic
      </h1>
      <p>
        The most general extension of <a href="ThreeValuedLogic.html">ThreeValuedLogic</a> to N-cardinality logic (potentially infinite).
      </p>
      <p>
        A proposition, informally, is a statement that you can make about a world that possesses a truth value in that world.  I.e. "Snow is white", "It is raining outside", etc. are propositions.  The use of <a href="TwoValuedLogic.html">TwoValuedLogic</a> to reason over worlds operates within the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a>; every proposition about a closed world is, by nature, either true or false (or some other duality).  Under the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a>, you either know or can go measure any particular detail you need; you effectively have omniscient access to every detail about the world.  If you can't prove a particular proposition is true, then that proposition must be false.  The use of <a href="ThreeValuedLogic.html">ThreeValuedLogic</a> to reason over worlds operates within the <a href="OpenWorldAssumption.html">OpenWorldAssumption</a>.  By definition, there are some details about an open world that you cannot know (i.e. you don't know, and aren't permitted to measure in the performance of reasoning).  Thus, if a particular proposition cannot be proven true or false, it is unknown (or unknowable).  (The <em>"</em>'cannot<strong> be proven"<em> is literal, and different from </em>"</strong>will not<em>' be proven"</em>.  You may assume you have a processor that is infinitely fast and has infinite space, so it can solve even <em>undecidable</em> questions, operate with impossibly large numbers, etc.)
      </p>
      <code>
        --(propositions require <a href="DependentTyping.html">DependentTyping</a> in a system that carries both open and closed worlds.)<br/>
        type proposition = (closedworld -> true|false) & (openworld -> true|false|unknowable)  <br/>
      </code>
      <p>
        All worlds are either closed or open; that's a complete dual.  Ultimately, any proposition asked of a world will only ever need to return true, false, or (for truly open worlds) unknowable.  
      </p>
      <p>
        Multi-valued logics, thus, are not necessary for reasoning over worlds.  Or, at least they are not necessary for reasoning over worlds <em>directly</em>.  Instead, these logics are generally utilized for <em>indirectly</em> reasoning about <em>other worlds</em> within systems that often contain incomplete, fuzzy, and potentially incorrect information.  In a sense, these systems are epistemic worlds, where the objects consist of knowledge and facts held with varying degrees of confidence.   This epistemic world may, itself, be closed or open... e.g. it might be considered closed while reasoning within one's own mind (since you supposedly know what you believe), and open while reasoning about someone else's (since you don't usually know everything someone else knows).  Thus, questions of the epistemic world return that some proposition is true, false, or unknown.  However, those propositions themselves are generally asking: is <some fact> accepted/known/believed/necessary/possible/etc. in <some other world>.  All propositions are indirect.
      </p>
      <p>
        The most common of such systems is the brain.  As such, <a href="MultiValuedLogic.html">MultiValuedLogic</a> has a very important place in to <a href="ArtificialIntelligence.html">ArtificialIntelligence</a>.
      </p>
      <p>
        The following are in common use across various domains: 
      </p>
      <code>
        type truth_primitive = true         --(boolean logic)<br/>
        | false        --(boolean logic)<br/>
        | believed with <confidence> to be <truth_primitive> --(epistemic logic)<br/>
        | necessary    --(modal logic)<br/>
        | possible     --(modal logic)  (... see many other modal logics)<br/>
        | <probability> likely  --(bayesian logic)<br/>
        | <percent> true        --(fuzzy logic)<br/>
        | unknown      --(open-world inherent logic value)<br/>
        | unknowable   --(open-world theoretic logic)<br/>
        | undecided    --(computation-limited logic)<br/>
        | undecidable  --(computation-theoretic logic)<br/>
      </code>
      <hr/>
      <p>
        <em>The original three-valued logic was invented (by Łucasiewicz around 1920) to accommodate the idea that some assertions are neither true nor false. Not that their truth or falsehood is unknown (to someone or something); that they literally, objectively *are* neither true nor false. Several three-valued logics are based on this idea; some are based on the notion that assertions can be *both* true and false. Some four-valued logics assume that assertions can be true, false, neither xor both. (Why make such apparently strange assumptions? Usually to try to avoid (or to embrace!) some of the paradoxes that afflict </em>ClassicalLogic, or to capture the idea that statements about future events can be neither true nor false.) Conversely, the logics that philosophers *do* generally use to reason about things like knowledge and provability are things like IntuitionisticLogic and flavours of ModalLogic. These are by and large two-valued logics which are provably not equivalent to any finitely-many-valued logic. (Equivalence to infinitely-many-valued logic(s) is a messier story.) Source: <em>An Introduction to Non-Classical Logic</em> by GrahamPriest.<em></em>
      </p>
      <ul>
        <li>
          <em>These are by and large two-valued logics which are provably not equivalent to any finitely-many-valued logic</em> -- that's not really possible, since any two-valued logic must be equivalent to itself, and every two-valued logic is a finitely-many-valued-logic.  In any case, multi-valued logics (including three-valued logics) have existed since long before the 1920s.  Aristotle, for example, was dealing with contingent truths, necessary truths, possible truths, etc.  And he's hardly the only reasoning mind in the last 2000 years that has needed more than 'true' and 'false' to tackle logic problems.
          <ul>
            <li>
               <em>People have been thinking about modality for a very long time. But in general *they haven't been using many-valued logic to do it*, which was pretty much the point.</em>
            </li>
            <li>
               I dunno about that; "True", "False", and "I haven't a friggin' clue", has probably been around far longer than any formalizations of them.
            </li>
          </ul>
        </li>
        <li>
          <em>A many-valued logic has more than two truth values by definition. (Read my "finitely-many-valued logic" as "finitely many-valued logic" if that avoids confusion.) It's still true that you could bolt extra truth values into intuitionistic logic, say, but that's missing the point. On the one hand we have the modal logics, intuitionistic logic and so on, which have funky modal operators and the like but only two truth values. On the other hand we have the many-valued logics, which have multiple truth values but no special operators that don't appear in </em>ClassicalLogic (classical <a href="FirstOrderLogic.html">FirstOrderLogic</a>, at least). It's impossible to take (for example) a standard modal logic and find an equivalent (first-order) logic which has a finite number of truth values and no special operators. So not only do you *not have to* use a finitely many-valued logic to reason about knowledge, belief, provability, etc., you *can't* use a finitely many-valued logic to do the sorts of reasoning you do with epistemic logic, intuitionistic logic and their ilk.<em></em>
        </li>
        <li>
           <em>"Read my "finitely-many-valued logic" as "finitely many-valued logic" if that avoids confusion.</em> -- oh!  That makes much more sense, when read that way.  Really, though, no one logic should be fully equivalent to another logic.  Where that is the case, you really don't actually have two different logics; you just have one logic, likely with two different paradigms.  This often happens with Bayesian vs. Fuzzy logics, when the operators are defined in the same manner.  (IMO, one should probably figure out what's wrong with the operators if two different concepts have the same mechanism for reasoning, especially if one is looking to combine the logics into one working whole.)  
        </li>
        <li>
           <em>"you *can't* use a finitely many-valued logic to do the sorts of reasoning you do with epistemic logic, intuitionistic logic and their ilk."</em> --  I feel there may be a bit of a <a href="LaynesLaw.html">LaynesLaw</a> issue on how we're counting logical primitives.  I count each primitive 'truth' that can be returned from a a proposition (even if a set is returned, like 'necessary' and 'necessarily necessary') just count each value once).  Provable, Not Provable; Necessary, Possible, Impossible, Necessarily Necessary, Possibly Impossible, etc.;  Accepted, Unaccepted; Likely, Unlikely, or something in-between; Decidable, Undecidable; True, False; Unknown, etc.  I count each 'primitive' return value, and this is completely independent of the nature of the reasoning required to <em>find</em> that value.  There are many ways to get infinitely-valued logics (e.g. most modal logics, bayesian probabilities, fuzziness, etc.)  While I count <em>answers</em>, I don't count the reasoning to get those answers; those don't change the 'valued' level of the logic.  e.g. I don't count whether ~~p reduces to p, which does happen in <a href="BooleanLogic.html">BooleanLogic</a> but not in IntuitionisticLogic, but in either, if you ask a proposition, you will only receive true or false (or 'unknown' in an open world).  I also don't count questions asked in return: If the model answers a question with a question; e.g. an answer to a query for "what is <propostion>" with "tell me <p,q, and r>" is 'unknown' with window-dressing.  The set of answers for a proposition is at least somewhat independent of the existence of first-order or higher-order predicates, axioms, etc..  Predicates and abstractions mostly determine the nature of the propositions you may ask, and should be based upon the nature of the world over which you are reasoning.  Ultimately, there is nothing preventing the use of N-valued logics for the tasks described, so long as the operators between propositions of different nature can be reconciled (e.g. what is 'possible' AND 'undecidable'?).
        </li>
      </ul>
      <hr/>
      <p>
        <em></em><a href="BooleanLogic.html">BooleanLogic</a> operates within a <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> (if you can't prove it's true, then it's false).<em></em>
      </p>
      <p>
        <a href="BooleanLogic.html">BooleanLogic</a> does no such thing.  Adding that assumption to <a href="BooleanLogic.html">BooleanLogic</a> would make incomplete systems inconsistant.
      </p>
      <p>
        <em>Your objection is unfounded.  Incomplete systems </em>'are<strong> inconsistent with </strong><a href="BooleanLogic.html">BooleanLogic</a>.  For example, proposition 'p', all by itself, has <strong>no boolean logic value</strong>.  Period.  It's fundamentally inconsistent with boolean logic.  However, by representing 'p' in a ClosedWorldContext, then you can assume either: "if 'p' is not provable as true, then 'p' is false", or "if 'p' is not provable as false, then 'p' is true".  Now 'p' can be given a <a href="BooleanLogic.html">BooleanLogic</a> value (either true or false).  To do this, however, you had to "operate within the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a>".<em></em>
      </p>
      <ul>
        <li>
          <em>In vanilla </em>ClassicalLogic it is absolutely not true that if you assert neither a proposition P nor any other set of propositions which entail P, then you are effectively asserting ¬P. If that's what the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> means, then it doesn't hold in vanilla ClassicalLogic. If it did hold, then P ⊨ ¬Q and P ⊨ P & ¬Q would be valid inferences (again, under vanilla ClassicalLogic). They aren't. More on the standard semantics of ClassicalLogic when I have time.<em></em>
          <ul>
            <li>
               The only thing that is held to be true in a world of pure logic are those things that are necessarily true: tautologies.  The only things that are held to be false in such a world are those things that are necessarily false: contradictions.  The former you can prove to be true, the latter you can prove to be false.  Other propositions are generally held to be variable objects with the value <em>unknown</em>.  As such, it'd be an error to call a world of pure logic a 'closed world', or to assert that the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> actually applies.
            </li>
            <li>
               <em>What do you mean by a "world of pure logic"? The empty language? An interpretation which makes no sentences true? An empty set of premises? It's not relevant in any case: the (putative) inferences I gave above have a non-empty set of premises, imply a non-empty language (containing at least P and Q) and can be given interpretations in which at least one sentence, P, is true. (In fact the empty language is the only language of </em>ClassicalLogic which doesn't defy the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a>, in that there is no set of sentences in the language which does not imply the truth or falsity of every sentence in the language. - Actually, no, I was completely wrong there, because the empty language has contingent propositions too, like ∃x∃y¬(x = y). So it defies the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> as well.<em></em>
              <ul>
                <li>
                   By a "world of pure logic" I mean a world in which nothing (no thing) exists.  Because nothing exists, you can't answer questions about things.  You cannot answer "Is it raining?" because there is no 'it', implicit or otherwise.  However, that doesn't mean you cannot formulate the question.  Worlds do not impose restrictions on the language used to discuss them.  If you ask bad questions, you can't answer them... but that doesn't change the world.  Worlds are, quite fundamentally, separate from the logics used to reason about them.  If you use the wrong logic, you'll end up with bad conclusions, but a failure of reasoning does not change the world.  (That is excepting where reasoning is performed <em>within</em> the world, and the very act of reasoning and computation thus changes the world).
                  <ul>
                    <li>
                       "However, that doesn't mean you cannot formulate the question.  Worlds do not impose restrictions on the language used to discuss them." <em>An interpretation must give a denotation to every constant in the language (and every relation except =). If there are no things in the universe of discourse to denote, then you can't use any language with more than zero constants to talk about it, as there is no interpretation which applies that language to that universe of discourse. So yes, your choice of universe of discourse does impose some restrictions on the language you use to discuss it.</em>
                    </li>
                    <li>
                       As a language theorist, I must heartily disagree.  Choosing the universe of Integers as my universe of discourse does not prevent me from choosing a language to communicate and reason about this universe that includes direct references to each of the 101 Dalmatians, while still managing to exclude direct references to most integers in the range around and above 3^3^3^3^3^3 simply because they are not physically expressible. (Any direct physical expression of an arbitrary such integer requires more atoms than there are in the universe, and expressions in a language must be expressible).  It is not an error to choose a language that is <em>more powerful</em> than the problem domain requires, and yet remains unable to express some things in its universe.  Instead, rather than choosing a weaker language, we simply limit our use of a more powerful language within the context of a particular problem domain.
                    </li>
                    <li>
                       <em>In </em>ClassicalLogic (at least!), every constant in an interpretation denotes something inside that interpretation's universe of discourse. "For a constant c, the denotation c^M is to be some individual in the domain |M|." - /Computability and Logic/, 4th ed., Boolos, Burgess and Jeffrey, p. 104.<em> -- Every formable and meaningful expression in a language is, rather fundamentally, within that language's widest potential universe of discourse.  This does not mean that all formable expressions are meaningful; many complex languages can easily formulate paradoxes.  This also does not mean that all meaningful things are formable -- there may be a gap between what one intends to discuss and what one </em>can<em> discuss with a particular language.  Finally, it does not mean that the </em>widest possible universe of discourse<em> for the language equates to the </em>universe of discourse<em> for the problem domain.  Even when dealing with logic languages, all the above is true.  It is useful to recognize the difference between what one </em>can<em> discuss (which is based on language limits) and what one </em>intends<em> to discuss (the </em>'universe of discourse<strong>, based on the problem domain), because the two are often not entirely matched.  Where there is no universe to discourse, you have such a case -- you can't say or know anything meaningful about a 'Mu' world except its 'Mu'-ness.  However, that doesn't mean you can't say or know anything meaningful.  </strong>
                    </li>
                  </ul>
                </li>
                <li>
                   Of course, even without a world to reason about, you're still capable of performing some rather complex reasoning.  Absent a real world, you're free to imagine one up and ask questions about it, instead.  I.e. in place of "Is it raining?", you may ask, "Supposing that a world exists, and the world has <these many, many properties>.  Is it raining in this world?".  On the other hand, you can only answer affirmatively if the properties you defined about the world necessitate that it is raining.  (There is "no thing" to measure in a "world of pure logic".)  If you're able to answer 'yes, it is raining', you must have a tautology.  The trivial example is: "Suppose that a world exists, and that it is raining in this world.  Is it raining in this world?".  The ability to describe a world and formulate questions about it, of course, requires a more sophisticated language... not a less sophisticated one.
                  <ul>
                    <li>
                       "If you're able to answer 'yes, it is raining', you must have a tautology.  The trivial example is: "Suppose that a world exists, and that it is raining in this world.  Is it raining in this world?"." <em>From the statement that it is raining it is valid to infer that it is raining: P ⊨ P. That is not a tautology. A tautology of </em>ClassicalLogic is a valid inference from the empty set of sentences, for example ⊨ P → P<em></em>
                    </li>
                    <li>
                       <em>"From the statement that it is raining it is valid to infer that it is raining: P ⊨ P. That is not a tautology."</em> -- Indeed.  And, yet, you do not HAVE the statement "It is raining", and you can't even look out the window to check because there is no 'it' and there is no 'window'.  You need to hypothesize the existence 'it' and the property that 'it is raining' prior to indicating that this would implicate that 'it is raining' is, indeed, true.  The ClassicalLogic isn't ideal for hypothesizing the existence of worlds (and thus expressing that certain propositions can hold meaning in a particular world).  However, this task is conceptually closer to  '⊨ P → P'.  You can prove "If it is raining, then it is raining".  It remains a tautology.  It is also similar to ('⊨ (P ⊨ P)') (~You can prove "If you can prove that it is raining, then it is raining".)  This is also a tautology in any <em>consistent</em> logic, though it requires something of a MetaLogic to determine this fact (along with access to the inferencing rules, to prove consistency).  I do not believe the latter is a legal expression in the ClassicalLogic.  I do know that ClassicalLogic is unable to directly express worlds, which is what I stated is really necessary for arbitrary study and language in a world of pure logic.  One modal logic notation I've seen for this task is [P]Q, which essentially reads "In a world defined by property P, test Q".  [R]R is a tautology; (⊨ [R]R) -- from within a world of pure logic, you can prove that, in a world defined by the property 'it is raining', it is raining.  
                    </li>
                  </ul>
                </li>
                <li>
                   You made a statement on the nature of an empty language (in which no propositions can even be formulated).  (<em>"In fact the empty language is the only language of </em>ClassicalLogic which doesn't defy the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a>"<em>)  It is certainly true that you cannot formulate any </em>bad<em> conclusions if cannot formulate </em>any<em> conclusions.  However, to be clear, I'll reiterate: Languages are </em>'not<strong> worlds.  Changing the language does </strong>not<strong> change the world.  If something exists, but you are unable to formulate questions about it, that something <em>still exists</em>.  If something does not exist, but you <em>can</em> formulate questions about it, that something still <em>doesn't</em> exist.  ("What is the height of your pet Unicorn?").</strong>
                  <ul>
                    <li>
                       "You made a statement on the nature of an empty language (in which no propositions can even be formulated)." <em>In fact the empty language has infinitely many sentences. Can you think of one? Nonetheless there is no set of sentences in the language which does not imply the truth or falsity of every sentence in the language. Why? - Actually, my second statement is false, see above.</em>
                    </li>
                    <li>
                       In answer to your first question: sure. 'true or false' is such a sentence; it would be trivial to create a generator for all such sentences.  I'm not sure I understand your second question, but if you are referencing the fact that <em>each</em> possible sentence in the language possesses the value of either <em>true</em> or <em>false</em>, I agree that this is true and may be proven inductively.  I should amend my original statement to properly express my original meaning: You made a statement on the nature of an empty language <em>of classical logic</em> (in which no propositions <em>about a world</em> can even be formulated). It is certainly true that you cannot formulate any <em>bad</em> conclusions <em>about a world</em> if cannot formulate <em>any</em> conclusions <em>about a world</em>.  Of course, you don't need the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> if you can't express anything about a world; in such a situation, both the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> and <a href="OpenWorldAssumption.html">OpenWorldAssumption</a> are vacuously consistent and compatible.
                    </li>
                  </ul>
                </li>
                <li>
                   It is not sane discuss whether a "language" does or does not violate a <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a>.  However, it is sane to discuss whether a particular logic system (including its language, axioms, inference rules, etc.) is compatible or consistent with a particular world.  Informally, the logic system is inconsistent with the world if it can produce erroneous conclusions about the world, and the logic system is incompatible with the world if it cannot even operate within that world.  <a href="BooleanLogic.html">BooleanLogic</a> is incompatible with any open world because, by definition, the correct answer to at least one proposition is 'unknown' in an open world, and <a href="BooleanLogic.html">BooleanLogic</a> <em>cannot operate with 'unknown'.</em>  You can force compatibility by applying the closed world assumption, but the closed world assumption is <em>inconsistent</em> with an open world for the obvious reasons.  You cannot fix this inconsistency.  However, in the more practical sense, you still have a world you wish to reason about.  You are free to either change logics (to a <a href="ThreeValuedLogic.html">ThreeValuedLogic</a>, for example) or to change worlds (to an epistemic world, for example).
                  <ul>
                    <li>
                       <em>The general problem here (as elsewhere) is that you're apparently confusing the question of whether a sentence is true under some interpretation with the question of whether a sentence is a valid inference of some given set of sentences (such as a knowledge base). In </em>ClassicalLogic P is true iff ¬P is false, but it is not the case that Γ ⊭ P iff Γ ⊨ ¬P .<em></em>
                    </li>
                    <li>
                       When you say "under some interpretation", you mean something operationally similar to (but not conceptually equal to) what I mean when I say "in some world".  'Under an interpretation', P might be true and Q might not be given any meaning at all, which causes no problems so long as Q doesn't appear in your sentences.  Worlds are object in reference to which variable propositions may be given truth values, so an 'interpretation' imposes a world.  Entailment and such work from sets of known facts about the world to produce more facts ('a entails b' is about the same as 'if you know a then you can prove b'.)  In most logics ((A → B) ⊨ (A ⊨ B)) is something of an axiom or inference rule over all variables A, B... though in some logics it is expressed directly, and in others it is meta to the logic. I don't believe there is any confusion, here.
                    </li>
                    <li>
                       More complex discussions of worlds (in general) are possible than can be expressed with ClassicalLogic (which lacks any real ability to reference objects, including the world).  In ClassicalLogic, the expression 'P' can only ever be true or false while <em>"under some interpretation."</em>  ClassicalLogic can only ever 'operate' (be utilized to 'evaluate' arbitrary, legal propositions) while under some interpretive context... i.e. while within an imposed world.  As you say, without a context, 'P' is neither true nor false by itself ((⊭ P) and (⊭ ¬P)).  ClassicalLogic fails to operate upon propositions such as 'P' when these aren't included in the interpretation.  This issue can be overcome by stipulating that P be given an interpretation prior to its use in a logical sentence -- to assert that it always be known whether P is true or P is false prior to evaluating a sentence that expresses 'P'.  (In your words: "<em>An interpretation must give a denotation to every constant in the language.</em>")  However, by such a stipulation, you've asserted that the interpretation impose a <em>closed world</em> - everything is known a'priori.  You are operating by your own stipulations within a closed world, so the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> <em>trivially, yet necessarily, applies.</em>  If you ever do move to an open world context for reasoning (which isn't necessarily appropriate for ClassicLogic, but still appropriate for many two-valued logics) you'll need to handle the situation... and some sort of <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> will actually come into play.
                    </li>
                    <li>
                       <em></em>ClassicalLogic assumes that every sentence in a language under an interpretation is true xor false. There's two parts to that. First, it demands that all the non-logical <strong>symbols</strong> have a denotation under the interpretation ('a' might stand for New York, Rxy might stand for the relation expressed by 'x is near y', etc.). Second, it assumes that all the <strong>sentences</strong> you can make up using the symbols of the language (such as Raa and ∀x((x = x) → Rxx) and Rab ∨ Raa) are true xor false under the interpretation. But <strong>that's not the </strong><a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a><strong>. It says nothing about knowing which sentences are true or which are false. The truth value of a sentence under an interpretation might be unknown. It might be profoundly unknowable. All </strong>ClassicalLogic assumes is that in objective reality it <strong>has</strong> a truth value of true xor false, regardless of who knows or could know which.<em>  -- The </em>ClassicalLogic is <strong>operating</strong> under the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a>.  In order to operate under some interpretation, it assumes that every sentence in the language is true xor false... that there are no sentences that, literally, possess the value 'unknown'.  ClassicalLogic does not operate under the assumption that 'unknown' is a correct value for a proposition.  It only operates under the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a>.  If it makes you feel better, though, a great deal of empirical evidence indicates that the real world is, indeed, a Closed World, even if our mental model of it is incomplete.  Open worlds yet abound.  A trivial such world is the one defined in an example, below, in the world described: 'there exists a reference to integer, 'y', with unknown value.'  It seems to be more that you are mentally blurring the distinction between language (which limits expressiveness) and operation (which involves computation and evaluation).  Any <a href="TwoValuedLogic.html">TwoValuedLogic</a> <strong>operates</strong> under the CWA.  This is a necessary truth; it is not possible for a <a href="TwoValuedLogic.html">TwoValuedLogic</a> to operate with propositions or sentences that correctly evaluate to a third value, so the logic must either insist upon operation within a closed world, or accept some inconsistency in order to operate within an open world.  
                    </li>
                    <li>
                       "In order to operate under some interpretation, it assumes that every sentence in the language is true xor false... that there are no sentences that, literally, possess the value 'unknown'. ClassicalLogic? does not operate under the assumption that 'unknown' is a correct value for a proposition." <em>It assumes that none of its sentences have a truth value other than true xor false under any interpretation. That is not the </em><a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a>.<em>  Correct.  The logic and the language used to express it are </em>'not<strong> the CWA, yet still require </strong>operating<strong> under the CWA.  Insistence that any given interpretation have all the answers (a'priori) is insistence that you operate within a closed world.    </strong>
                    </li>
                    <li>
                       <em>Actually </em>ClassicalLogic doesn't really talk directly about knowledge or knowability at all. But given a set of sentences which are all true under some chosen interpretation, you can deem a sentence to be known to be true under the interpretation iff it is a valid consequence of that set of sentences, the knowledge base, and deem it to be known to be false iff its negation is known to be true. (That's a very generous way to define knowledge, as you know, for reasons of performance and decidability which don't matter just now.) But if the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> is the assumption that anything not known to be true is known to be false, then it obviously doesn't hold (for most knowledge bases) under this definition of knowledge. If the language is the zero-place predicate symbols P, Q, R and S, and the knowledge base is the set of sentences {P ∨ Q, R}, then Q is not known to be true (since P ∨ Q, R ⊭ Q) and ¬Q is not known to be true (since P ∨ Q, R ⊭ ¬Q). (If the CWA is the assumption that anything not known to be true is simply false, then it equally obviously doesn't hold here, since P ∨ Q, R ⊭ Q: there are interpretations that make P ∨ Q and R true and Q false.)<em>  -- You have some confusion about what, exactly, the </em><a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> is.  It is, again, the assumption that you know <em>everything</em> a'priori.  That means in the 'P ∨ Q' instance, you'd know whether P is true or not, and whether Q is true or not. This is very useful: <strong>A <em>knowledge base</em> about a world <em>is not that world</em>.</strong>  In this sense, while P ∨ Q might be true, P is unknown (and potentially unknowable), and Q is unknown (and potentially unknowable).  We do not know whether the other world is closed or not... but we do know that, in this sense, ClassicalLogic cannot operate if asked the question: 'S'?.  That said, a knowledge base <em>is also</em> a world of sorts... one containing 'knowledge' objects.  It is 'true' that 'P ∨ Q' is known, and it is 'false' that 'P' is known, and the questions you can ask of a proper knowledge base are always of the form: is <some proposition> known?  Is 'S' known?  Negative.  Is '¬S' known?  Negative.  It's easy to prove that this provides a Closed World in which ClassicalLogic can properly operate.  It gives <em>an interpretation to every sentence that is true xor false</em>.  (I don't advertise this as the only possibility... just <em>a</em> possibility.)
                    </li>
                    <li>
                       "in this sense, ClassicalLogic cannot operate if asked the question: 'S'?" <em>In what sense? P ∨ Q, R ⊭ S and P ∨ Q, R ⊭ ¬S , just like Q. Any well-formed sentence of the language is xor isn't a valid consequence of any set of well-formed sentences of the language.</em>  -- What you discuss here is the evaluation of whole inference sentences <strong>P ∨ Q, R ⊨ S</strong> evaluates to <strong>invalid</strong>, as does <strong>P ∨ Q, R ⊨ ¬S</strong>. Logic over inference sentences is a useful one; you don't need to know 'S' to know 'S ⊨ S'.  All you need to evaluate propositions of this form are the inference rules for the logic you are utilizing... which ultimately forms a logical 'world'.  If you know ALL the correct inference rules, then the world in which you evaluate inference sentences is a closed world by definition.  The <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> applies in that if, under the rules provided by the logic, "P ∨ Q, R ⊨ S" isn't provably valid, then it must be invalid (ignoring computability).  On the other hand, if you don't have all the inference rules for some logic, then you have an open world.  Such is the case with a finite set of axioms for reasoning about arithmetic over natural numbers, as proven by Goedel.  In such a logic, if an inference sentence isn't accepted as valid, it cannot necessarily be rejected as invalid; you'd need to first prove it invalid.  Studying logics can be interesting because different logics accept and reject different inference sentences as valid, just like different worlds accept and reject different propositions as true.  The ClassicalLogic is a closed logic.  However, this is a step removed from (and meta to) the discussion of whether the ClassicalLanguage can operate with the plain and simple proposition 'S'.  'S' isn't true, and 'S' isn't false; 'S' is unknown.  To work with 'S', ClassicalLogic requires that you first impose an interpretation on it, which involves assigning 'S' to either 'true' or 'false', bringing you back into the closed world.
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <p>
        According to what you've just said here, arithmatic on natural numbers is inconsistant.  It uses <a href="BooleanLogic.html">BooleanLogic</a>, and it's provably incomplete.
      </p>
      <ul>
        <li>
          The set of natural numbers is not incomplete.  It's infinite.  There's a huge difference.
        </li>
      </ul>
      <p>
        I'm not talking about the set of natural numbers, I'm talking about arithmatic on natural numbers.  It is provably incomplete (See <a href="GoedelsTheorem.html">GoedelsTheorem</a>.)
      </p>
      <ul>
        <li>
          <a href="GoedelsTheorem.html">GoedelsTheorem</a> is not about arithmetic upon natural numbers.  It is about <em>axioms</em> over arithmetic upon natural numbers.  Thats a different set of things -- a different <em>world</em>.  Further, the theorem doesn't state that the set of truths involving such arithmetic is incomplete... only that any particular <em>finite</em> set of such <em>axioms</em> (things accepted as true) is incomplete.  He proves that there are truths about the world of numbers and operators that cannot be proven from within the world containing the finite set of axioms.
        </li>
        <li>
          <em>I guess I wasn't clear enough.  When I referred to arithmetic upon natural numbers, I was referring to the standard axiomatization of it, </em><a href="BooleanLogic.html">BooleanLogic</a> coupled with Peano's Axioms.  <a href="GoedelsTheorem.html">GoedelsTheorem</a> proves that that is incomplete, inconsistant, or both.  If the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> is part of <a href="BooleanLogic.html">BooleanLogic</a>, we could rule out the first and third options.<em></em>
        </li>
        <li>
          Goedel proved that the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> is violated when operating with a finite set of axioms about the natural numbers.  This shows that the <em>standard axiomatization of arithmetic upon natural numbers</em> to be incomplete with the actual natural numbers and arithmetic.  Such a finite set of axioms is provably <em>not</em> a closed world.  Thus, it is in reasoning as though this set of axioms were a closed world (by using <a href="BooleanLogic.html">BooleanLogic</a>) that inconsistency is introduced -- you're choosing the wrong tool for the job.  Why?  Because <a href="BooleanLogic.html">BooleanLogic</a> is inconsistent with an <em>open world</em>, and when you treat an open world as a closed world, you'll have inconsistency.  
        </li>
        <li>
          Under the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a>, where the world contains only a finite set of axioms, you'd reject as accepted those things that you cannot prove from your axioms.  According to Goedel, among the things you'd reject would be things that are <em>true</em> when applied to the world of natural numbers and arithmetic.  Technically, it is correct to reject those truths as 'accepted', because you defined your world to be a finite set of axioms.  If, instead, you define your world to be the world containing <em>all truths regarding arithmetic over natural numbers</em>, then any finite set of axioms is incomplete.  This is what Goedel's incompleteness theorem makes clear.  It would be wrong to consider this world 'closed', because you don't know everything in it.
        </li>
        <li>
          <em>If the </em><a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> is part of <a href="BooleanLogic.html">BooleanLogic</a>, then that world has to be closed.  <a href="BooleanLogic.html">BooleanLogic</a> is included in the set of axiom.<em></em>
        </li>
        <li>
          The <a href="BooleanLogic.html">BooleanLogic</a> included in the set of axioms is for reasoning about the arithmetic and natural numbers, not for reasoning about the axioms.  Goedel's theorem is about the axioms, not about the arithmetic and natural numbers.  This causes no contradiction; these are two different conceptual worlds: the set of numerical objects and operators, and the set of axioms.
        </li>
        <li>
          More worrisome is the nature of your comment. ... Are you trying to say that the <em>nature of the world</em> changes simply because you decide to use <a href="BooleanLogic.html">BooleanLogic</a> to reason about it?  That is a rather dubious position.  The world is the world is the world; if you make a bad assumption about it, then you're the one introducing inconsistency. 
        </li>
      </ul>
      <p>
        <strong>You need multi-place predicates (and identity) to model arithmetic. </strong><a href="BooleanLogic.html">BooleanLogic</a> is ZeroOrderLogic. If it has predicates (with more than zero places) it's at least <a href="FirstOrderLogic.html">FirstOrderLogic</a>. Call it FregeanLogic if you have to.<strong></strong>
      </p>
      <p>
        <em>In representation of Incomplete Systems, where you wish to have consistency, you must use </em><a href="ThreeValuedLogic.html">ThreeValuedLogic</a>... which allows proposition 'p' to return the value 'unknown'.  In this case, however, there is no excluded middle; <a href="BooleanLogic.html">BooleanLogic</a> no longer applies.<em></em>
      </p>
      <p>
        Now you've switched from the system itself to representing that system.  I agree that unless you are dealing only with complete information, you will need some method of handling the incompleteness.
      </p>
      <ul>
        <li>
          Any utilization of an incomplete world requires the method of handling the incompleteness.  I should have used a better word.
        </li>
      </ul>
      <p>
        <em>This causes less inconsistency than you might believe.  If you can't prove p, then p is false.  Thus, Not(p) is true, because p is false.  Etc.</em>
      </p>
      <p>
        It's not that simple.  For example, lets define (over the natural number)
      </p>
      <p>
        Odd(x) ::= There exists a natural number, n,  such that 2*n + 1 = x.
        Even(x) ::= There exists a natural number, n, such that 2*n = x.
      </p>
      <p>
        Let's y be some unknown value.  Which of Odd(y) and Even(y) is true?  According to the closed world assumption, both are false.  However, we also know that at least one is true.
      </p>
      <p>
        <em>You need to </em><a href="UnaskTheQuestion.html">UnaskTheQuestion</a>, here.  You've made a conceptual error in assuming you have a closed world after you say "let y be some unknown value."  You don't.  'y' isn't a proposition asked of the world; it is, instead, an object within the world.  In a closed world, all such things are known a'priori.  By saying you do not know what 'y' is, you've clearly violated your <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a>.  You may no longer use <a href="BooleanLogic.html">BooleanLogic</a> to answer questions about that world; to do so would be fallacy.<em></em>
      </p>
      <p>
        <em>If you wish, you may wrap an open world within a closed world; to do this, you simply reason about what you know about the openworld.  The set of things you know is, after all, a closed set objects -- a closed world.  (In particular, it is a closed set of </em>data<em> objects.)  For example:</em> 
      </p>
      <code>
        knowledge :: data = { <a href="NaturalNumber.html">NaturalNumber</a>(y) is True in theExampleWorld }<br/>
      </code>
      <p>
        <em>Now you may form propositions to ask of your knowledge regarding theExampleWorld.  Known(Even(y) or Odd(y)) would be true, and you may ask Known(Even(y)) and receive false, and Not(Known(Even(y))) will properly return True.  All of these are correct.  All may be calculated with Boolean logic within the </em><a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a>, given the proper inferencing rules.  Everything about the world of reason is in that simple, closed set of data.<em></em>
      </p>
      <p>
        <em>Asking Odd(y) within this epistemic world isn't even a valid question, because 'y' is not an object of the world.  However, when reasoning -within- the associated open world (theExampleWorld, above), a question such as Odd(y) may be asked directly... it's just that the answer is 'Unknown'.</em>
      </p>
      <p>
        I thought we were discussing situations where we had incomplete information, so I don't think I'll <a href="UnaskTheQuestion.html">UnaskTheQuestion</a>.  The closed world assumption doesn't even come into play when you have complete information.
      </p>
      <p>
        <em>The </em><a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> IS the assumption that you have complete information regarding the world, even if you don't.  It is the assumption that everything that is true is either represented directly or can be derived from the set of things that are in the world.  The <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> comes into play when you ask a <strong>proposition</strong> of the world that cannot be proven.  The <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> insists that it is false.  And such a proposition is <strong>provably</strong> false under this assumption.  The <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> is <strong>violated</strong> when you introduce to the world something that you don't have represented.  The world you presented ('y' is unknown) is NOT a closed world.  This makes your claims that the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> fails to handle this situation rather meaningless.  If the assumption is <strong>violated</strong>, then of course it shouldn't hold.<em></em>
      </p>
      <p>
        Which is pretty much the point.  Including the <a href="ClosedWorldAssumption.html">ClosedWorldAssumption</a> in <a href="BooleanLogic.html">BooleanLogic</a>, breaks just about every theory we use <a href="BooleanLogic.html">BooleanLogic</a> in.  <a href="BooleanLogic.html">BooleanLogic</a> (without that assumption) doesn't have a problem with the situation in question, it simply doesn't prove any of these statements, Even(y), Not(Even(y)), Odd(y), and Not(Odd(y)).  But if we include the closed world assumption, we have to prove two of those, and I don't see any obvious way of picking which ones.  (The only consistant choices are Even(y) and Not(Odd(y)), or Not(Even(y)) and Odd(y), but how do you pick which one of those two?).
      </p>
      <ul>
        <li>
          <a href="BooleanLogic.html">BooleanLogic</a> doesn't provide any <em>value</em> with which to answer those propositions in the context of the example world.  Thus you have a problem -- a proposition upon a world must come back with an answer.  The correct answer is 'unknown'.  This means that you definitely have an open world, and that you should not be using <a href="BooleanLogic.html">BooleanLogic</a> to reason about it.  Your proposed inconsistency arises only from stubborn insistence that you somehow <em>must use </em><a href="BooleanLogic.html">BooleanLogic</a><em> to </em>reason about a clearly open world<em>.  This is not the case.  You should not look at a situation and say: "Well, this assumption is clearly and irrefutably violated.  Let's use it anyway."  If you do, then you are the one introducing inconsistency.</em>
        </li>
      </ul>
      <p>
        In any case, I know what 'y' is.  'y' is a variable that ranges over objects in the world.  y is an object in the world.  (<em>To be clear, y is an object, not a variable.</em>)  Even(y) and Odd(y) are statements about the world.  We cannot prove Even(y).  We cannot prove Odd(y).  According to the closed world assumption, both Even(y) and Odd(y) are false, but we can prove that Even(y) v Odd(y).  This is a problem, and it's caused adding the closed world assumption to <a href="BooleanLogic.html">BooleanLogic</a>.
      </p>
      <p>
        <em>Your proposed Even(y) and Odd(y) are not statements about a closed world.  I've explained this well enough above.  Their use does not provide a relevant argument, and I'll let you be the one to scroll upwards and study why.  Here's a short mental challenge to you:  What is the correct value of Even(y), given only </em><a href="BooleanLogic.html">BooleanLogic</a> (true/false)?<em>  </em>
      </p>
      <p>
        Whatever the model says it is.  It's the model that assigns the truth values, not <a href="BooleanLogic.html">BooleanLogic</a>.
      </p>
      <p>
        <em>It is </em><a href="BooleanLogic.html">BooleanLogic</a> that carries the truth values.  When you ask a proposition of a world, you receive an answer in the form of a truth primitive.  For a closed world, this truth primitive <strong>must</strong> be from <a href="BooleanLogic.html">BooleanLogic</a>.  No other answer is legal.  For other models, you don't need to answer with <a href="BooleanLogic.html">BooleanLogic</a>... but, in those cases, you are simply no longer using <a href="BooleanLogic.html">BooleanLogic</a> (well... no more than <a href="ThreeValuedLogic.html">ThreeValuedLogic</a> "isn't using <a href="BooleanLogic.html">BooleanLogic</a>"; <a href="BooleanLogic.html">BooleanLogic</a> may be subsumed by a wider logic).  Anyhow, you're the one claiming you have a closed world, and you're the one asking a proposition of it.  You can't dodge this question and claim you have a closed world.  So, what. is. your. answer?<em></em>
      </p>
      <hr/>
      <p>
        (See also <a href="BooleanLogic.html">BooleanLogic</a>, <a href="ThreeValuedLogic.html">ThreeValuedLogic</a>, <a href="TwoValuedLogic.html">TwoValuedLogic</a>, <a href="BooleanAlgebra.html">BooleanAlgebra</a>, <a href="DataBase.html">DataBase</a>, <a href="WhatIsData.html">WhatIsData</a>)
      </p>
      <hr/>
      <p>
        <a href="CategoryLogic.html">CategoryLogic</a>
      </p>
    </div>
  </body>
</html>