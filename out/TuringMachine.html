<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Turing Machine
      </h1>
      <p>
        See <a href="http://plato.stanford.edu/entries/turing-machine/">http://plato.stanford.edu/entries/turing-machine/</a> for a full description, or <a href="OnComputableNumbers.html">OnComputableNumbers</a> for the original paper.
      </p>
      <p>
        One of the <a href="ModelsOfComputation.html">ModelsOfComputation</a>, a <a href="GedankenExperiment.html">GedankenExperiment</a> of <a href="AlanTuring.html">AlanTuring</a>, (i.e. they don't really exist), a <a href="TuringMachine.html">TuringMachine</a> is an abstract computing device, traditionally a (finite state) machine reading and writing marks on an infinite paper tape.
      </p>
      <ul>
        <li>
           <em>Not so fast: Turing machines have been implemented as toys, and </em>KarlScherer at <a href="http://www.mathematik.uni-heidelberg.de/index_en.html">http://www.mathematik.uni-heidelberg.de/index_en.html</a> built a <a href="TuringMachine.html">TuringMachine</a> from wood and metal, using ballBearings to record states on its "tape." <em></em>
        </li>
        <li>
           If it can be built, it probably doesn't have an infinite tape. If it doesn't have an infinite tape, it's not really a Turing machine.
        </li>
      </ul>
      <p>
        Turing went on to show that you could create a <a href="TuringMachine.html">TuringMachine</a> which could take input allowing it to simulate any other (i.e. a program - on a 'Universal' <a href="TuringMachine.html">TuringMachine</a>). The <a href="ChurchTuringThesis.html">ChurchTuringThesis</a> is essentially that anything we could reasonably call computable can be expressed as input to a universal Turing Machine, and indeed <a href="AlonzoChurch.html">AlonzoChurch</a>'s <a href="LambdaCalculus.html">LambdaCalculus</a> and Turing's Machines are equivalent in this way.
      </p>
      <p>
        <em>Didn't somebody else discover the thesis independently of Church and Turing?</em>
      </p>
      <p>
        According to <a href="RogerPenrose.html">RogerPenrose</a> in <a href="TheEmperorsNewMind.html">TheEmperorsNewMind</a> an American-Polish logician called <a href="EmilPost.html">EmilPost</a> made an important independent contribution, and Stephen Kleene had a key role in helping Church.
      </p>
      <hr/>
      <p>
        I remember studying in a book with a chapter on PostMachines , other in Godels or Church work, other with <a href="TuringMachine.html">TuringMachine</a>. Can someone name this book?
      </p>
      <hr/>
      <p>
        <em>Real Software Engineers admire Turing machines for the clarity and orthogonality of their instruction set.  It's just too bad they're so poor at I/O.</em> Hmm, of what other paradigm does this remind us?
      </p>
      <p>
        Whaddya mean?  They do *LOTS* of I/O!  ;->
      </p>
      <p>
        Actually a kind of Programmable Logic Array plugged into I/O
      </p>
      <hr/>
      <p>
        See also <a href="GoedelsIncompletenessTheorem.html">GoedelsIncompletenessTheorem</a>
      </p>
      <hr/>
      <p>
        There are some key things about <a href="TuringMachine.html">TuringMachine</a>s that make them interesting.
      </p>
      <ul>
        <li>
           There exists a way of representing any <a href="TuringMachine.html">TuringMachine</a> (TM) as data for a special purpose <a href="UniversalTuringMachine.html">UniversalTuringMachine</a>.  This UTM then acts as an interpreter and simulates the TM perfectly.
        </li>
      </ul>
      <ul>
        <li>
           There exist simple-to-state requirements that no <a href="TuringMachine.html">TuringMachine</a> can meet without error or endlessly looping.
        </li>
      </ul>
      <ul>
        <li>
           Computable numbers are defined by there existing a TM that when it is given a description of the desired accuracy it will calculate the number to that accuracy.  This allows us to claim that <em>pi</em> is computable (but has infinite digits) for example.  On the other hand it indicates that there is an uncountable set of numbers that can not be computed by any algorithm/program/TM (as Turing machines are countable).
        </li>
      </ul>
      <ul>
        <li>
           Turing Machines are surprisingly simple, despite their power, and many other systems are equivalent to them. Conclusions about Turing Machines can be applied to those systems. For example...
        </li>
      </ul>
      <ul>
        <li>
           <a href="TuringMachine.html">TuringMachine</a>s and their properties can be encoded as formulae and equations.  Hence there are equations that can not be solved by any <a href="TuringMachine.html">TuringMachine</a>.
        </li>
      </ul>
      <ul>
        <li>
           Turing Machines can be encoded in <a href="GameOfLife.html">GameOfLife</a> positions. Hence there are questions about Life which cannot be solved by any Turing Machine (eg whether an arbitrary position will ever "settle down").
        </li>
      </ul>
      <hr/>
      <p>
        Here's a simple Turing Machine in Python:-
      </p>
      <code>
        def go(t, s, p):<br/>
        if s == 0 and t[p] == 0:<br/>
        t[p] = 1<br/>
        go(t, s, p)<br/>
        if s == 0 and t[p] == 1:<br/>
        t[p] = 0<br/>
        go(t, s, p)<br/>
        t, s, p = [0], 0, 0<br/>
        go(t, s, p)<br/>
      </code>
      <p>
        Where "t" is the tape, s is the status, and p is the position. All it does is alternate a number between "0" and "1" continually. -- <a href="SeanPalmer.html">SeanPalmer</a>
      </p>
      <p>
        Can anyone write a UTM in Python? How about a TM in RDF?
      </p>
      <p>
        <em>No but here's a TM in XSLT </em><a href="http://www.unidex.com/turing/utm.htm">http://www.unidex.com/turing/utm.htm</a> also Prolog <a href="http://www.donotenter.com/resume/pub/tm2.htm">http://www.donotenter.com/resume/pub/tm2.htm</a> and one in <a href="JavaScript.html">JavaScript</a> that can be run online <a href="http://www.turing.org.uk/turing/scrapbook/tmjava.html''">http://www.turing.org.uk/turing/scrapbook/tmjava.html''</a> You mean "No-one has written one <em>yet</em> (and that's probably wrong as well).
      </p>
      <hr/>
      <p>
        What Turing originally invented was a machine consisting of an infinitely long tape divided into cells. 
        On each cell one of a finite number of symbols can be written. 
      </p>
      <p>
        The head that reads and writes on the tape moves one cell to the left or to the right in each time step. The machine itself is in one of a finite number of states. The state the machine is in determines what the machine should do in each time step via a state transition table. 
        see:<a href="http://mathworld.wolfram.com/TuringMachine.html">http://mathworld.wolfram.com/TuringMachine.html</a>
      </p>
      <hr/>
      <p>
        <em>(as Turing machines are countable).</em>
      </p>
      <p>
        That doesn't sound right to me. My understanding of a Turing machine is that it can be encoded as tape data, and therefore the set of Turing machines maps to the set of all possible tape data, which is uncountable (more than one symbol ^ unbounded length). -- <a href="KarlKnechtel.html">KarlKnechtel</a>
      </p>
      <p>
        <em>As you say, any Turing machine may be encoded by a string of symbols taken from a finite alphabet. The set of all these strings is countable since you can enumerate all strings: There are only finitely many strings of a given length. Now you first write down all strings of length zero, then those of length one, then those of length two, etc. So the strings are in one-to-one correspondence to the natural numbers and therefore countable. See </em><a href="CountablyInfinite.html">CountablyInfinite</a>.<em></em>
      </p>
      <hr/>
      <p>
        Formally a <a href="TuringMachine.html">TuringMachine</a> is a quintuple M = (Q, Sigma, Tau, Epsilon, q0) where:
      </p>
      <ul>
        <li>
           Q is a finite set of states, q0 being the starting state
        </li>
        <li>
           Tau is a finite set (called the tape alphabet) containing a special symbol called B (blank)
        </li>
        <li>
           Sigma is a subset of Tau-{B} called the input alphabet
        </li>
        <li>
           Epsilon is a partial function from (Q x Tau) to (Q x Tau x {L, R}). In other words this is the transition table which, given an internal state in Q and the symbol under the reading head, selects a new state, a new symbol to write at the head, and a 'move left' or 'move right' command.
        </li>
      </ul>
      <p>
        A transition is written as Epsilon(qi,x) = [qj,y,d] where d belongs to {L,R}. It can be drawn as a state diagram with edges looking like:
      </p>
      <code>
        qi---x/y d--->qj	(The edges can loop back to the same node ie when qi=qj).<br/>
      </code>
      <p>
        A transition can also be written as a list 
      </p>
      <code>
        qi x y d qj<br/>
      </code>
      <p>
        Some books write this as two instructions qi x y qi, qi x d qj only allowing one operation per step (either change symbol or move L or R per step).
      </p>
      <p>
        Epsilon can also be thought of as a set of instructions. Each time through the loop, the machine reads a symbol on the tape and compares the current (state, symbol) pair with the instruction set. If a match is found the machine transitions into a new state specified by the right hand side of the function. If no match is found the machine simply halts. It halts when no match is found. An example computation might that accepts a language (a union)*aa(a union b)* below. TM not specified it would be 5 instructions long but to give an idea of what "running one" looks like:
      </p>
      <code>
        q0BaabbB<br/>
        |-Bq1aabbB<br/>
        |-Baq2abbB<br/>
        |-Baaq3bbB<br/>
      </code>
      <p>
        Numeric functions can be specified using a base 1 (unary) representation ie to compute f(2,1) start with Bq0111B11B. B separates arguments instead of "," which is not in the machine's alphabet. An example TM for the succ function s(n)=n+1 (compare the one in <a href="LambdaCalculus.html">LambdaCalculus</a>) is
      </p>
      <code>
        q0 B B R q1<br/>
        q1 1 1 R q1<br/>
        q1 B 1 L qf<br/>
        qf 1 1 L qf<br/>
      </code>
      <p>
        To run it on s(2) we would start with tape Bq0111B. It would terminate with Bqf1111B = 3 base 1. Non numeric functions can also be specified. A TM T2 can be simulated on a TM T1 also by encodings similar to above.
      </p>
      <hr/>
      <p>
        Let's see if I understand...
      </p>
      <p>
        The succ function didn't set the element at the right of (q1, B) blank, so I assume that every cell whose value is not specified has the value "blank". If their content was simply "undefined", then some <a href="TuringMachine.html">TuringMachine</a>s may not work, although they could probably be rewritten in a way which would work. But in the way the definition stands now, the tape's content is defined not by explicitly writing its content but by a rule: "all cells are blank except for those, which have such and such values".
      </p>
      <p>
        Could we use another rule, like "every odd cell has such value", which would use an infinite portion of the tape, or is this forbidden? <a href="WhatDoesHaltingMean.html">WhatDoesHaltingMean</a> discusses the possibility of feeding an infinite input program to the <a href="UniversalTuringMachine.html">UniversalTuringMachine</a>. However that very same machine works by writing down the "complete configuration" of the machine it emulates, and this configuration includes the content of the tape. There are machines which could halt even given infinite non-blank input, but the <a href="UniversalTuringMachine.html">UniversalTuringMachine</a> won't halt trying to simulate it. Since the <a href="UniversalTuringMachine.html">UniversalTuringMachine</a> is supposed to be able to handle all cases, then we cannot use infinite non-blank input.
      </p>
      <hr/>
      <p>
        A lot of skepticism here.  I guess <a href="RealProgrammer.html">RealProgrammer</a>s don't believe in <a href="TuringMachine.html">TuringMachine</a>s, or at least consider them to be a theoretical <a href="RatDance.html">RatDance</a>.  A <a href="TuringTarpit.html">TuringTarpit</a> if you will.
      </p>
      <p>
        <em>It's just self-selection bias: a page like this will be of lesser interest to many who consider it an old known topic, but will attract skeptics, so naturally you see skeptical posts.</em>
      </p>
      <p>
        <em>I was kind of staggered a few years ago, working with some junior programmers with CS degrees, who had never heard of Turing nor Turing machines. Turns out their bachelor's programs, in the country they came from, were primarily general engineering, and included only 3 actual CS courses. The rest of the CS courses were to be taken by Master's candidates. Different system. But it made me realize why such a large percentage of people from that country that I'd previously worked with usually have a Master's degree, whether from back home or from the mid-western U.S.</em>
      </p>
      <hr/>
      <p>
        The <a href="TuringMachine.html">TuringMachine</a> may be an example of how TechnologyEnablesTheory: could Turing have envisaged it if the tickertape had not been invented? Come to that, could NewtonianMechanics have been envisaged if clockwork had not been invented? - <a href="DavidWright.html">DavidWright</a>.
      </p>
      <p>
        <em>Actually </em><a href="AlanTuring.html">AlanTuring</a> s impetus for envisioning TMs was to investigate <a href="GoedelsIncompletenessTheorem.html">GoedelsIncompletenessTheorem</a>. No real machine at the time was adequate but he imagined a hypothetical one with infinite tape. Obviously influenced by what was around him at the time (TickerTape) but also workings of biological cells and other phenomena, he was motivated by something completely abstract. Later on when he worked on decrypting the Enigma codes he was able to create real machines to assist with the calculations, so inventions were the result of his envisionings as much as the other way around. Thereby saving lives although in some cases Churchill had to let bombings take place so as not to divulge the results of Turings real Machines to the enemy<em></em>
      </p>
    </div>
  </body>
</html>