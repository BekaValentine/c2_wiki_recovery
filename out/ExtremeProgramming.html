<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Extreme Programming
      </h1>
      <p>
        <a href="ExtremeProgramming.html">ExtremeProgramming</a> is one of many <a href="AgileProcesses.html">AgileProcesses</a>. It is also known as XP. The names AthlonXP and WindowsXP would appear not to be related to <a href="ExtremeProgramming.html">ExtremeProgramming</a>, but if interested, you could see the <a href="WindowsXpNameDiscussion.html">WindowsXpNameDiscussion</a>.
      </p>
      <p>
        <em>See </em><a href="ExtremeProgrammingRoadmap.html">ExtremeProgrammingRoadmap</a> for an index of information about extreme programming on this site.<em></em>
      </p>
      <p>
        The basic advantage of XP is that the whole process is visible and accountable. The developers will make concrete commitments about what they will accomplish, show concrete progress in the form of deployable software, and when a milestone is reached they will describe exactly what they did and how and why that differed from the plan. This allows business-oriented people to make their own business commitments with confidence, to take advantage of opportunities as they arise, and eliminate dead-ends quickly and cheaply. -- <a href="KentBeck.html">KentBeck</a>
      </p>
      <p>
        "XP is the practice and pursuit of effective simplicity, as applied to software development." -- Victor (from the <a href="XpMailingList.html">XpMailingList</a>)
      </p>
      <p>
        <a href="ExtremeProgramming.html">ExtremeProgramming</a> was best described by <a href="KentBeck.html">KentBeck</a> in his landmark book <em></em><a href="ExtremeProgrammingExplainedEmbraceChange.html">ExtremeProgrammingExplainedEmbraceChange</a><em> (take a quick look at that page for a 'back-cover' summary of XP). </em>
      </p>
      <p>
        <em>This </em><a href="OneTrickPony.html">OneTrickPony</a> ain't no <a href="SilverBullet.html">SilverBullet</a>. And <em>vice versa</em>. -- <a href="PhlIp.html">PhlIp</a><em></em>
      </p>
      <hr/>
      <p>
        Interesting to note that <a href="ExtremeProgramming.html">ExtremeProgramming</a> has emerged as a methodology for programming; it appears to be based in trial and error programming! Without tests and refactoring, it is not workable at all. So why not design first, write tests to that design, then program, test, perform refactoring and iterate?
      </p>
      <p>
        <em>That's exactly what </em><a href="ExtremeProgramming.html">ExtremeProgramming</a> is, friend.<em> Just do it in tiny increments.</em>
      </p>
      <p>
        The differences between XP and trial-and-error are basically two-fold: first, you solve each error as it comes up, so that it doesn't compound with later errors. And second, you meant to do it that way in the first place, rather than being forced to come back and deal with unforeseen complications. <em>(This paragraph would need to be written out more verbosely. I can't understand the point the paragraph is trying to make. </em><a href="PleaseComment.html">PleaseComment</a>)<em> this looks like a development of </em><a href="StepwiseRefinement.html">StepwiseRefinement</a> where the project is broken down into smaller and smaller tasks until each task is small enough to code, the idea being that one task is one module to handle an operation ie input:process:output if a task is too big to code, its split into modules. these modules are iterated to the same criteria
      </p>
      <hr/>
      <p>
        The <a href="ExtremeProgrammingCorePractices.html">ExtremeProgrammingCorePractices</a> constitute an <a href="ExtremeProgrammingProject.html">ExtremeProgrammingProject</a>. 
      </p>
      <p>
        <strong>Why "Extreme"?</strong>
      </p>
      <p>
        "Extreme" means these practices get "turned up" to a much higher "volume" than on traditional projects. XP ignores any other practice (like <a href="BigDesignUpFront.html">BigDesignUpFront</a>) that does not appear on the list. The result is stable, productive, and very rapid because the practices support each other the more they are used together without interference. An Extreme project is typically so stable and sedate it can lead to <a href="FortyHourWeek.html">FortyHourWeek</a>s without any schedule slips. 
      </p>
      <p>
        <strong>What really matters?</strong> 
      </p>
      <p>
        Software is too damned hard to spend time on things that don't matter. So, starting over from scratch, what are we absolutely certain matters? 
      </p>
      <ol>
        <li>
           Coding. At the end of the day, if the program doesn't run and make money for the client, you haven't done anything. 
        </li>
        <li>
           Testing. You have to know when you're done. The tests tell you this. If you're smart, you'll write them first so you'll know the instant you're done. Otherwise, you're stuck thinking you maybe might be done, but knowing you're probably not, but you're not sure how close you are. 
        </li>
        <li>
           Listening. You have to learn what the problem is in the first place, then you have to learn what numbers to put in the tests. You probably won't know this yourself, so you have to get good at listening to clients - users, managers, and business people. 
        </li>
        <li>
           Designing. You have to take what your program tells you about how it wants to be structured and feed it back into the program. Otherwise, you'll sink under the weight of your own guesses. 
        </li>
      </ol>
      <p>
        Listening, 
        Testing, 
        Coding, 
        Designing. That's all there is to software. Anyone who tells you different is selling something. 
      </p>
      <p>
        -- <a href="KentBeck.html">KentBeck</a>, author of <em></em><a href="ExtremeProgrammingExplained.html">ExtremeProgrammingExplained</a><em></em>
      </p>
      <p>
        <strong>The </strong>ExtremeEnvironment<strong></strong>
      </p>
      <p>
        XP is designed to meet the <a href="CustomerBillOfRights.html">CustomerBillOfRights</a> and <a href="DeveloperBillOfRights.html">DeveloperBillOfRights</a>. Participants work in one of the <a href="ExtremeRoles.html">ExtremeRoles</a> (<a href="TheCoach.html">TheCoach</a>, <a href="TrackerRole.html">TrackerRole</a>, etc.). XP is done during a <a href="FortyHourWeek.html">FortyHourWeek</a>, with <a href="AllEngineersInOneRoom.html">AllEngineersInOneRoom</a>, having a daily <a href="StandUpMeeting.html">StandUpMeeting</a>. As <a href="ThereMustBeFood.html">ThereMustBeFood</a>, there are <a href="SnacksForPositiveReinforcement.html">SnacksForPositiveReinforcement</a> in the room where <a href="EngineeringTask.html">EngineeringTask</a>s are carried out with a high <a href="ProjectVelocity.html">ProjectVelocity</a>. If you don't have this kind of ideal environment, you could still attempt <a href="ExtremeProgrammingInEnemyTerritory.html">ExtremeProgrammingInEnemyTerritory</a>. 
      </p>
      <p>
        <strong></strong><a href="ExtremeListening.html">ExtremeListening</a><strong></strong>
      </p>
      <p>
        The <a href="OnsiteCustomer.html">OnsiteCustomer</a> participates in the <a href="PlanningGame.html">PlanningGame</a>. The development team interviews the customer to determine <a href="UserStories.html">UserStories</a> about how the system will work. User stories are combined or split to come up with a story that can be described (<a href="WriteItOnaCard.html">WriteItOnaCard</a>) on one of these <a href="CrcCard.html">CrcCard</a>s, and completed by a pair of programmers during one release cycle (typically about three weeks). The customer prioritizes the cards according to the business value of the <a href="UserStories.html">UserStories</a>, which puts stories into the release schedule based on the development resources available. This lets customers have an accurate <a href="ReleasePlan.html">ReleasePlan</a>. 
      </p>
      <p>
        After each release, the customer has a system that works according to the stories completed so far; they don't have to wait for the whole thing to be done to start using the initial functionality. The development group identifies which stories are risky to complete on time (mainly because of a lack of experience with that type of coding) and does <a href="WorstThingsFirst.html">WorstThingsFirst</a> based on a <a href="SpikeSolution.html">SpikeSolution</a>. Read more about <a href="ExtremeRequirementsGathering.html">ExtremeRequirementsGathering</a>. 
      </p>
      <p>
        Special note on Listening: we do listening in two ways: 
      </p>
      <ol>
        <li>
           <a href="UserStories.html">UserStories</a>. (Similar to "use cases".) On cards, our customers write stories describing how something is supposed to work. A story might say "An employee making $10 an hour works four hours of overtime on Friday and two on Sunday. She should receive $60 for the Friday overtime and $40 for Sunday." We have hundreds of cards describing the product. 
        </li>
        <li>
           <a href="AcceptanceTest.html">AcceptanceTest</a>s. These are typically single use cases with expected answers provided by the customer. 
        </li>
      </ol>
      <p>
        -- <a href="RonJeffries.html">RonJeffries</a> 
      </p>
      <p>
        <strong></strong><a href="ExtremeDesign.html">ExtremeDesign</a><strong></strong>
      </p>
      <p>
        XP relies on <a href="TestDrivenDevelopment.html">TestDrivenDevelopment</a> for its inner loop. This pumps the outer loop, and makes the political end of XP possible. Promises are automatically kept. <a href="ProgrammerTest.html">ProgrammerTest</a>s are written which the successful software will be able to pass. At first, the tests fail because the software hasn't been written yet. A simple design is developed by doing the <a href="SimplestThing.html">SimplestThing</a> which might pass the tests. <a href="BigDesignUpFront.html">BigDesignUpFront</a> is avoided because <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a>. However, once the <a href="SimplestThing.html">SimplestThing</a> is done the programmers <a href="RefactorMercilessly.html">RefactorMercilessly</a>, because in the end things should be expressed <a href="OnceAndOnlyOnce.html">OnceAndOnlyOnce</a>. Read more about <a href="SubsystemsInXp.html">SubsystemsInXp</a>. 
      </p>
      <p>
        <strong></strong><a href="ExtremeCoding.html">ExtremeCoding</a><strong></strong>
      </p>
      <p>
        XP involves pairs of programmers (who <a href="PairPromiscuously.html">PairPromiscuously</a>) working together on code, so that the entire development team achieves <a href="CodeStewardship.html">CodeStewardship</a>. They use <a href="TestDrivenDevelopment.html">TestDrivenDevelopment</a> to <a href="CodeUnitTestFirst.html">CodeUnitTestFirst</a>. 
      </p>
      <p>
        This <a href="PairProgramming.html">PairProgramming</a> leads to <a href="CollectiveCodeOwnership.html">CollectiveCodeOwnership</a>. Programmers follow the <a href="CodingConvention.html">CodingConvention</a>s whenever they write new code, and while they <a href="RefactorMercilessly.html">RefactorMercilessly</a>. 
      </p>
      <p>
        <strong></strong><a href="ExtremeTesting.html">ExtremeTesting</a><strong></strong>
      </p>
      <p>
        After code passes <a href="ProgrammerTest.html">ProgrammerTest</a>s (cf <a href="RelentlessTesting.html">RelentlessTesting</a>), practice <a href="ContinuousIntegration.html">ContinuousIntegration</a> (at <a href="TheIntegrationStation.html">TheIntegrationStation</a>) of <a href="FrequentReleases.html">FrequentReleases</a> and run <a href="AcceptanceTest.html">AcceptanceTest</a>s to verify that the software meets the customer's requirements. <a href="NoBugDatabase.html">NoBugDatabase</a> is needed. 
      </p>
      <hr/>
      <p>
        Several wikis describe/implement Web-based systems that support XP practices:
      </p>
      <ul>
        <li>
           <a href="http://www.program-transformation.org/twiki/bin/view/Transform/GenerativeProgrammingWiki">http://www.program-transformation.org/twiki/bin/view/Transform/GenerativeProgrammingWiki</a>
        </li>
        <li>
           <a href="http://xplanner.sourceforge.net">http://xplanner.sourceforge.net</a>
        </li>
        <li>
           <a href="FitNesse.html">FitNesse</a>
        </li>
      </ul>
      <hr/>
      <p>
        Noted <a href="PerlLanguage.html">PerlLanguage</a> luminary, and mad scientist, <a href="DamianConway.html">DamianConway</a> believes that <a href="ExtremeProgramming.html">ExtremeProgramming</a> is actually a misnomer. Since it embodies many of the good programming practises that programmers are taught but almost certainly ignore, he believes that it should really have been called UltraConservativeProgramming. -- SimonLaw
      </p>
      <p>
        <em>How is XP "best practices" different from other best practices lists? If you have </em><a href="EmpiricalEvidence.html">EmpiricalEvidence</a> beyond anecdotes, I would like to see the data!<em> </em>
      </p>
      <p>
        I do not have data to publish, but I've done several projects this way and it sure makes projects go faster, way faster, although programming goes slower. Think about that, it makes lots of sense, since you are programming only a 10% of the time.
      </p>
      <p>
        And since there are so many practices, if you skip one, you will think you are going faster, then when you fail, you will realize you were not going as fast as you thought. Another way of saying it is that you were going fast, but in the wrong direction, or you were going fast but you hit a wall (it depends on which practice did you skip).
      </p>
      <p>
        The last project I worked on, was achieved with half the estimated people and half the time. The quality was not so good because we skipped functional testing during the whole project. When everything was coded and seemeingly functioning with a lot of defects, we wrote functional tests for all user stories (full use cases in our case). It just took 2 months to completely stabilize the system of around 300 use cases.
      </p>
      <hr/>
      <p>
        XP is spreading like wildfire in the industry, which is good("change is good"). There is one big danger, people always misunderstand XP as jumping right into the code and getting the code out, and figure out what the code needs to do later. This is not leaving us in any better position than we are today. I wish XP gurus will advocate more on listening and understanding of the problem before trying to solve it. If you are advocating to understand the problem while (well) after writing the solution, then that is wrong and ought to be illegal.
      </p>
      <hr/>
      <p>
        I think some coding should occur while you are understanding the problem. How many times when talking to an end user, have you thought you understood what they wanted and they thought something very different? How many times were details glossed over by the client that made a huge difference on the project? The client just assumed those features would be included but "forgot" to mention them! How many times was the customer incapable of visualizing the benefits of the system, you describe to them? You verbally describe it because it is too expensive to create it and then have them not like it. If you can get agreement on what a customer wants by them looking at a very quickly made example, you avoid 1) misunderstanding what is needed 2) the customer doesn't have to visualize something they have no expertise at visualizing. The trick is to show something useful enough to get across a concept that can be created very quickly. If you can create something for them to see while they looking over your shoulder, you are on the right track, although all problems aren't solved that easily. Breaking the problem into very small deliverable pieces, getting user buy-in all the time, having the system work at all times while you are creating it, are all features that contribute to XP programming success. Having a system that can be changed quickly and often, and a set of configurable tools where you don't have to start from scratch, makes XP programming practical. Most languages and development systems can't implement XP programming for these reasons. -- <a href="DavidClarkd.html">DavidClarkd</a>
      </p>
      <hr/>
      <p>
        I'm unconvinced of <a href="ExtremeProgramming.html">ExtremeProgramming</a>'s utility when it comes to the design and construction of platforms for other software (e.g. programming languages, frameworks, message protocols, library APIs, operating systems, security models, concurrency models, etc.) - too often, the need to maintain backwards compatibility, especially to support the 'quirks' and 'bugs' of previous modes, quickly becomes an enormous burden against any attempt to <a href="RefactorMercilessly.html">RefactorMercilessly</a>.  However, I think it works fine for situations where the programmers DO possess full authority to muck around with all code and repair any dependencies broken as a consequence of refactoring.  <a href="BigDesignUpFront.html">BigDesignUpFront</a> vs <a href="YagNi.html">YagNi</a>, <a href="ProgramInTheFutureTense.html">ProgramInTheFutureTense</a> vs <a href="DoTheSimplestThingThatCouldPossiblyWork.html">DoTheSimplestThingThatCouldPossiblyWork</a> - I believe that each have their place in design and construction of software.
      </p>
      <p>
        Discussion moved to <a href="ExtremeProgrammingForPlatformSoftware.html">ExtremeProgrammingForPlatformSoftware</a>.
      </p>
      <hr/>
      <p>
        I vote to drop the <em>Extreme</em> and <em>Ultra</em> things. I understand that is <em>swiftly</em> abbreviates to something like XP, but this is the future of programming. It is. So why name it like the next non-evolution of washing agents. To me, all I have read in <a href="CategoryExtremeProgramming.html">CategoryExtremeProgramming</a> pages, <em>is</em> about programming. No more no less. Anything else than that doesn't <em>earn</em> the name programming with me, at most <em>coding</em>. -- <a href="StijnSanders.html">StijnSanders</a>
      </p>
      <p>
        See <a href="WhyExtremeWasUsed.html">WhyExtremeWasUsed</a>
      </p>
      <hr/>
      <p>
        <a href="SimplifiedProcess.html">SimplifiedProcess</a> seems to have been an <a href="ExtremeProgramming.html">ExtremeProgramming</a>-like practice from <a href="GermanyCountry.html">GermanyCountry</a>.
      </p>
      <hr/>
      <p>
        <strong></strong><a href="ExtremeProgramming.html">ExtremeProgramming</a> Not<a href="QuickQuestions.html">QuickQuestions</a><strong></strong>
      </p>
      <p>
        <strong>Q</strong>: For "simple" programming language (e.g. CICS-COBOL/DB2) on <a href="BigIron.html">BigIron</a> (e.g., ZOS) development projects, would XP practitioners agree that <em>XP approach is not really suitable</em> because 
      </p>
      <ol>
        <li>
           nobody benefits from <a href="PairProgramming.html">PairProgramming</a> with these environments (no reuse / pattern applicability discussions needed)
        </li>
        <li>
           it's not realistic to have users participate in the team because enterprise tasks (e.g.. ERP integration) have organization-wide impact and are not suited for small but <a href="FrequentReleases.html">FrequentReleases</a>
        </li>
        <li>
           <a href="PairProgramming.html">PairProgramming</a> does not improve productivity as complexity is in the business and not in the technical environment
        </li>
        <li>
           of inertia, and no one wants to be the first shop that does <a href="MainFrame.html">MainFrame</a> development in XP. See also <a href="XpAndHierarchies.html">XpAndHierarchies</a>.
        </li>
      </ol>
      <p>
        -- <a href="DavidLiu.html">DavidLiu</a>
      </p>
      <p>
        <strong>A</strong>: It may be arguable that XP would be difficult simply because it would be such a radical change from the existing practice and most people doing it have so much inertia/experience with their current approach. But two people could certainly pair and benefit from it without having to change the whole culture. The benefits would come precisely because the existing app is already mature and complex that it greatly helps to have two pair of eyes watching every change.
      </p>
      <p>
        I have two junior programmers, fresh out of school, breaking out the UI from the business logic of a legacy app. They are buying into the value of pairing and writing tests. The old guard are stunned at how fast they are tearing through. Working together works. 8:-) -- BradWhite
      </p>
      <p>
        <em>Language used for that </em><a href="LegacyApplication.html">LegacyApplication</a>?<em></em>
      </p>
      <hr/>
      <p>
        Just considering the Extreme<em>Programming</em> aspect, this is exactly how programmers want to work, without necessarily knowing it. Coders like coding, not documenting, and coders like seeing code they've written work. I love it - no more huge <a href="DesignDocumentation.html">DesignDocumentation</a>, and rapid feedback from ProgrammerTests. It makes programming fun again, like when you were a kid (or when you were hacking some <a href="OpenSource.html">OpenSource</a> piece where no one demands a 90-page design doc complete with full <a href="UnifiedModelingLanguage.html">UnifiedModelingLanguage</a> models).
      </p>
      <hr/>
      <p>
        About documentation: I recently started to put my documentation (UML snippets, method signatures and other remarks) inside my unit tests. I must off course admit that that is easy to do in a web-oriented language (PHP in my case). I use a lot of shared components and these components usually have some idea behind them that can be expressed in UML nicely. I thought that the unit tests were the best place for the documentation, as you will see it a few times a day anyway. And you <em>really want</em> to see it when that particular unit tests breaks.
        For a demo, see the tests at <a href="http://www.w-p.dds.nl/storyboard/admin/rununittests.php">http://www.w-p.dds.nl/storyboard/admin/rununittests.php</a> -- <a href="WillemBogaerts.html">WillemBogaerts</a>
      </p>
      <hr/>
      <p>
        Maybe not design docs but how about help docs? You have to document at some time, because it's how customers actually use those features that you thought up. It'd be selfish just to code and never document or comment on how the software works. But I'm sure you mean just reduction of design docs, right? Any documentation is tough for a programmer since he can never explain the software in less than ten words. More like ten thousand words. (I think you'll see <a href="VideoDocumentation.html">VideoDocumentation</a> in the future as more popular.. and it's easier to 'write up' for a programmer) <em>(See </em><a href="UserDocsInXp.html">UserDocsInXp</a>)<em></em>
      </p>
      <hr/>
      <p>
        I've been an admirer of XP ever since learning of it at MIT in '01. However, it seems wedded to a development model <em>outside</em> of my "tribe" which is more the world of <a href="OpenSourceCulture.html">OpenSourceCulture</a>. That is, my tribe codes without customers, without a budget, for personal use and for fun. Much of the Internet has been built from it. XP concepts are still amenable, but I would like to help re-work the idea for a <strong>culture of coders</strong> rather than a programming team answering to the Industrial Economy.
      </p>
      <p>
        For <a href="OpenSourceCulture.html">OpenSourceCulture</a>, new coders need to be able to come and go freely. This means tools like <a href="TestDrivenDevelopment.html">TestDrivenDevelopment</a> become primary, over <a href="UserStories.html">UserStories</a>, for example. The <strong>test</strong> becomes the <a href="UserStory.html">UserStory</a> because the customer is the coder-community! In Python with DocTests this is perfect because DocTests encourage the story to be filled out with prose. In other, write DocTests code for all the functionality you hope for and wait for the community to make the tests pass.
      </p>
      <p>
        As a quick attempt, the takeaway concepts of XP I see are these: <a href="PairProgramming.html">PairProgramming</a>, <a href="TestDrivenDevelopment.html">TestDrivenDevelopment</a>, and <a href="ReFactoring.html">ReFactoring</a>. Thanks!
      </p>
      <p>
        -- Mark Janssen
      </p>
      <hr/>
      <p>
        See <a href="ExtremeProgrammingRoadmap.html">ExtremeProgrammingRoadmap</a>, <a href="ExtremeProgrammingPrinciples.html">ExtremeProgrammingPrinciples</a>, <a href="ExtremeProgrammingTopics.html">ExtremeProgrammingTopics</a>, <a href="ExtremeProgrammingLinksOutsideWiki.html">ExtremeProgrammingLinksOutsideWiki</a>, <a href="ExtremeProgrammingForDummies.html">ExtremeProgrammingForDummies</a>, <a href="ExtremeProgrammingProjects.html">ExtremeProgrammingProjects</a>, <a href="WhoIsUsingExtremeProgramming.html">WhoIsUsingExtremeProgramming</a>, <a href="ExtremeProgrammingArticles.html">ExtremeProgrammingArticles</a>
      </p>
      <hr/>
      <p>
        <a href="AprilZeroEight.html">AprilZeroEight</a>
      </p>
      <p>
        <a href="CategoryExtremeProgramming.html">CategoryExtremeProgramming</a> <a href="CategoryExtreme.html">CategoryExtreme</a> CategoryExtremeOpenBusiness
      </p>
      <hr/>
      <p>
        <a href="BiLinks.html">BiLinks</a>:
      </p>
      <code>
        <-><br/>
      </code>
      <ul>
        <li>
           <a href="ExtremeOpenBusiness.html">ExtremeOpenBusiness</a> <em>(is a generalization of </em><a href="ExtremeProgramming.html">ExtremeProgramming</a>, applying experiences and principles to the Business Process. It is especially interesting for the <a href="CreativeCommons.html">CreativeCommons</a>.)<em></em>
        </li>
      </ul>
    </div>
  </body>
</html>