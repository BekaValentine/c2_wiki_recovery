<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Business Object Notation
      </h1>
      <p>
        <a href="CategoryMethodology.html">CategoryMethodology</a>:
      </p>
      <p>
        Applying Object-Oriented Analysis and Design, Jean-Marc Nerson, <em>Communications of the ACM</em>, vol 35, no.9, Sept. 1992, pages 63-74.
      </p>
      <p>
        and <a href="SeamlessObjectOrientedSoftwareArchitecture.html">SeamlessObjectOrientedSoftwareArchitecture</a> ([ISBN  0-13-031303-3])
      </p>
      <p>
        <a href="BertrandMeyer.html">BertrandMeyer</a> has this spin on it: <a href="http://www.eiffel.com/products/bon.html">http://www.eiffel.com/products/bon.html</a>
      </p>
      <p>
        Main emphases:
      </p>
      <ol>
        <li>
           Seamlessness
        </li>
        <li>
           Reversibility
        </li>
        <li>
           Software Contracting (aka <a href="DesignByContract.html">DesignByContract</a>)
        </li>
      </ol>
      <p>
        Despite having the word "notation", it is a notation and a <em>method</em>.
      </p>
      <hr/>
      <p>
        See...
      </p>
      <p>
        <strong>"An introduction to BON."</strong>
        <em>(A really nice summary.)</em>
      </p>
      <code>
        <a href="http://www.elj.com/eiffel/rp/bon-intro.pdf">http://www.elj.com/eiffel/rp/bon-intro.pdf</a>   (dead link) try<br/>
        <a href="http://www.cse.yorku.ca/~paige/Bon/bon.html">http://www.cse.yorku.ca/~paige/Bon/bon.html</a><br/>
      </code>
      <p>
        A Comparison of the Business Object Notation and the Unified Modeling Language.
        <em>(Another introduction to BON, with comparisons to UML.)</em>
      </p>
      <code>
        <a href="http://www.cs.yorku.ca/techreports/1999/CS-1999-03.html">http://www.cs.yorku.ca/techreports/1999/CS-1999-03.html</a><br/>
      </code>
      <p>
        A very brief overview:
        <em>(Ovals for classes.  More detail in a class than UML.  Can be done in text, in addition to 2D graphics.)</em>
      </p>
      <code>
        <a href="http://www.elj.com/elj/v1/n2/bm/bon/">http://www.elj.com/elj/v1/n2/bm/bon/</a><br/>
      </code>
      <p>
        A note on using BON -- the sequence of steps.
        <em>(BON groups classes into "clusters.")</em>
      </p>
      <code>
        <a href="http://www.cs.usask.ca/homepages/grads/moa135/856/OO/node4.html">http://www.cs.usask.ca/homepages/grads/moa135/856/OO/node4.html</a><br/>
      </code>
      <hr/>
      <p>
        <em>Based on reading "a Comparison of the Business Object Notation and the Unified Modeling Language" (referenced above)...</em>
      </p>
      <p>
        Being "reversable" and "seamless" focuses the notation on <a href="ReverseEngineering.html">ReverseEngineering</a> of existing code:
        They're arguing that anything not automatically derivable from the source code should not allowed be in the modeling language.
        Their argument would be correct if the only way to do design was to reverse engineer existing code.
        But in real systems there can be substantial practical benefit to having a way to express concepts that are abstract, even if they map into similar language constructs as other concepts.
      </p>
      <p>
        For example, BON forbids one-to-one relationships because the static class definition that supports them is indistinguishable from that for a one-to-many.
        One may as well forbid C "for" loops because a "while" loop to do the same work will produce the same machine code.
      </p>
      <p>
        The fact that one cannot easily and automatically reverse-engineer designer intent from source code is not an adequate reason to forbid the designer from having intent.
        -- <a href="JeffGrigg.html">JeffGrigg</a>
      </p>
      <p>
        <em>(...shades of </em><a href="TheSourceCodeIsTheDesign.html">TheSourceCodeIsTheDesign</a>.  ;-)<em></em>
      </p>
      <hr/>
      <p>
        Now for the nit-picking:
      </p>
      <p>
        See figure 5 on page 15 for a sample BON "object communication diagram, with scenario box," and figure 6 on page 16 for a comparison of a UML collaboration diagram with a BON communication diagram (with scenario box).
        I find the UML diagram simpler, more expressive, and easier to read; the opposite of their conclusion.
        The BON diagrams require too much manual cross-referencing between graphical and textual documents to figure out what's going on.
      </p>
      <p>
        For all their criticism of state machines (as not being automatically reverse-engineerable from source code), section 3.3.1 (end of page 16) recommends that you use UML state transition diagrams (or something similar) if you want to model that kind of behavior.
        -- <a href="JeffGrigg.html">JeffGrigg</a>
      </p>
      <p>
        I don't see how people can compare BON and UML since BON is a methodology and UML is a family of modelling languages.
      </p>
      <p>
        BON might have started life as a notation for Eiffel programmers but
        any serious reader of the BON book will recognise 
        that the BON book has a strong
        emphasis on process. 
        The BON book contains charts showing the dependencies
        between what developers must do.
      </p>
      <p>
        I can't see any reason why BON can't be performed using UML. (We can easily
        use a limited subset of UML and adopt stereotypes and tagged values 
        for BON-specific constructs.)
      </p>
      <hr/>
      <p>
        See also: <a href="BertrandMeyerAndHisOpinions.html">BertrandMeyerAndHisOpinions</a>, <a href="BonVsUml.html">BonVsUml</a>
      </p>
    </div>
  </body>
</html>