<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Abuse Of Utility Classes
      </h1>
      <p>
        Too many <a href="UtilityClasses.html">UtilityClasses</a> and too many operations in such classes is one of the <a href="ClassicOoAntiPatterns.html">ClassicOoAntiPatterns</a>.
      </p>
      <p>
        A large number of such classes (particularly those with only a single method) indicates that the designers are thinking upside-down, ie. thinking of that which can be done to an object rather than that which can done by the object. -- <a href="ChanningWalton.html">ChanningWalton</a>
      </p>
      <p>
        On the other hand, <a href="ScottMeyers.html">ScottMeyers</a> argues that Non-Member Functions Can Improve Encapsulation <a href="http://www.ddj.com/dept/cpp/184401197">http://www.ddj.com/dept/cpp/184401197</a>
      </p>
      <p>
        In multi-paradigm languages which support both OO and functional styles, the benefits of isolating pure functions are more apparent.  While <a href="ScottMeyers.html">ScottMeyers</a> notes that the use of non-member functions can result in inconsistencies of access, language features such as C#'s extension methods can remove this stylistic drawback.
      </p>
      <p>
        It is a fundamental breach of encapsulation to give functions more access to private state than they require.  Utility methods that are left as members of a class are often granted more access than they require, making it harder to identify and enforce design invariants.  If a method's functionality can be expressed in terms of a class's public interface, then writing it as a non-member function increases overall encapsulation.
      </p>
    </div>
  </body>
</html>