<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Programs To Read
      </h1>
      <p>
        This is a list of programs/collections of code worth reading.  Some are <a href="GreatProgramsToRead.html">GreatProgramsToRead</a> and some are not. What they should have in common is some educational merit. One should benefit from having read the programs listed here.
      </p>
      <ul>
        <li>
           <a href="JavaUnit.html">JavaUnit</a>. It's small, well written, crammed with ideas and popular to the point of ubiquity.
        </li>
        <li>
           <a href="JaxorFramework.html">JaxorFramework</a>. It's a small, pattern-driven (lots of the patterns are from Fowler's Enterprise Patterns book)  O/R mapper with reasonably high-level of test coverage.
        </li>
        <li>
           <a href="AxionDatabase.html">AxionDatabase</a>. It's a database written in Java with good unit tests and <a href="ShortMethods.html">ShortMethods</a>. It's worth reading because databases are such a fundamental tool everyone should learn how they work.
        </li>
        <li>
           The standard Java APIs. The code for whatever JDK you're using is available in a file called src.jar. Open it with a zip tool and read. Some bits are very good and some bits are terrible but it won't hurt to understand the code that your code depends upon.
        </li>
      </ul>
      <ul>
        <li>
           The source for INN (InterNetNews - "a complete Usenet system"): <a href="http://www.isc.org/products/INN/">http://www.isc.org/products/INN/</a>
        </li>
      </ul>
      <ul>
        <li>
           Resin web server: <a href="http://www.caucho.com">http://www.caucho.com</a>
        </li>
      </ul>
      <ul>
        <li>
           The Linux kernel sources <em>and the educational merit in this is...??</em> Everyone should read at least one OS.  It's a fast-track to understanding the whole pile from the hardware up to the apps, you learn the most vital design decisions underlying a platform, and you'll be able to reason about how they affect your own code. The coding techniques are different and noteworthy too. (not the original proponent)
        </li>
      </ul>
      <ul>
        <li>
           <a href="TexTheProgram.html">TexTheProgram</a>: a large-ish, hairy, and exceptionally unbuggy program written using the technique of <a href="LiterateProgramming.html">LiterateProgramming</a>. Available in book form. Contains many interesting algorithms. Unfortunately it's written in Pascal. MetafontTheProgram is similarly interesting, and to at least one reader's mind it has a larger density of neat algorithms.
        </li>
      </ul>
      <dl>
        <dt>	 </dt>
        <dd><em>Anent the "exceptionally unbuggy" assessment: for over 13 years, Knuth kept a log of all the errors he found (or received reports of) in </em>TeX, with notes as to how he fixed them.  (He may still be keeping the log for all I know, but it had over 13 years of entries in it when it was published in 1991.)  I can only say that I wish I had as short a bug list in some of my major systems after even just 5 years.  Naturally, Knuth attributes his low rate of errors to his use of <a href="LiterateProgramming.html">LiterateProgramming</a> techniques.  He published a paper, "The Errors of TeX", on this subject in 1989.<em></em></dd>
      </dl>
      <ul>
        <li>
           ApacheLucene. A brilliant example of API usability. High-level and low-level access, every piece sub-class-friendly and replaceable.
        </li>
      </ul>
      <ul>
        <li>
           Anything written by your friends! Reading and appreciating someone's program is a very nice thing to do.
        </li>
      </ul>
      <ul>
        <li>
           Would <a href="MozillaFirefox.html">MozillaFirefox</a> be something valuable to read and study?	<em>There would be merit in studying the </em><a href="MozillaBrowser.html">MozillaBrowser</a> suite in order to get a feel for <a href="LargeScaleCppSoftwareDesign.html">LargeScaleCppSoftwareDesign</a>. On the other hand the KDE libraries would be a better example assuming one was prepared to overlook the QT macro-based language extensions.<em> [Actually, Mozilla exhibits a bit of </em><a href="AlternateHardAndSoftLayers.html">AlternateHardAndSoftLayers</a>: while various low-level components are C++, much of the UI and other code is written in <a href="MozillaXul.html">MozillaXul</a> and <a href="JavaScript.html">JavaScript</a>. It's not really a joy to read though, and has a reputation for being a bit hairy.]
        </li>
      </ul>
      <ul>
        <li>
           <a href="BoostLibraries.html">BoostLibraries</a>, the <a href="CeePlusPlus.html">CeePlusPlus</a> template libraries, for some really advanced template stuff. Advanced reading, but <a href="TemplateMetaprogramming.html">TemplateMetaprogramming</a> is just a thing of beauty!
        </li>
        <li>
           One way to start on this would be the book <a href="CppTemplateMetaprogramming.html">CppTemplateMetaprogramming</a>.
        </li>
      </ul>
      <p>
        (It would be helpful if people adding items to this list would include some commentary explaining what makes the programs worth reading, and to whom.)
      </p>
      <p>
        <em>And why the choice of Pascal is unfortunate, or is that bit just flame bait?</em>
      </p>
      <dl>
        <dt> </dt>
        <dd><em>You're free to disagree, but there's more than just flame bait to this comment.  See </em><a href="BrianKernighan.html">BrianKernighan</a>'s article <a href="WhyPascalIsNotMyFavoriteProgrammingLanguage.html">WhyPascalIsNotMyFavoriteProgrammingLanguage</a> for some cogent objections to Pascal -- at least, the dialect of Pascal that was available when Knuth was writing TeX.  Many of Kernighan's objections, which were derived from his experience porting his book <em>Software Tools</em> from Ratfor to Pascal, are (not coincidentally) also things for which Knuth felt it necessary to provide workarounds in Web, the <a href="LiterateProgramming.html">LiterateProgramming</a> system he invented specifically for the implementation of TeX and Metafont.  Knuth and Levy's later tool, CWeb, which is based on C an C++ rather than Pascal, omits certain features of the Pascal-based Web precisely because C, a more expressive and powerful language, doesn't need them.<em></em></dd>
      </dl>
      <hr/>
      <p>
        See also <a href="LiterateProgramming.html">LiterateProgramming</a>
      </p>
    </div>
  </body>
</html>