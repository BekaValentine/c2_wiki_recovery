<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Anti Creation
      </h1>
      <p>
        <em>A programmer does not need to have babies each time he needs to get something done. Stop having children, daughters, sons.. just command your computer to do something.  This obsession with becoming pregnant with instances who inherit from their parents has gone too far. Programs are not people.</em> --MopMind
      </p>
      <p>
        <a href="AntiCreation.html">AntiCreation</a> is an idea that humans do not think as in "creating objects" in life and in programming. In fact we hate the very thought of creating yet another child who will just be a maintenance nightmare with all sorts of inherited diseases and bad behavior problems.
      </p>
      <p>
        When a man creates a vehicle in a factory, this is hard work. When a human has a baby, this is hard work. <em>We should dread creating life forms</em>.  In fact the vehicle or baby is not created in actuality, but just merged with other existing materials on this planet. There is no creation exactly.
      </p>
      <p>
        Man does not want to create anything if he doesn't have to - he'd rather just grab it and use it (or command that it be done). Especially if it is a <a href="FreeLunch.html">FreeLunch</a>.  
      </p>
      <code>
        grabLunch() <br/>
        eatLunch()<br/>
      </code>
      <p>
        Creating the lunch would be silly - that's for the maid to do - and even the maid doesn't make the lunch, they just getTheLunchIngredients() from the store or the fridge. Making lunch is more work - disposing of the lunch and its wrappers and <em>garbage</em> is even more hard work.  Disposing and creating lunches causes more hassles than if the lunch was just there.. as a command. giveMeLunch() and eatLunch().
      </p>
      <p>
        With computer systems, we should reduce any creation work. We should just be able to command the computer in a <a href="SlaveOrientedProgramming.html">SlaveOrientedProgramming</a> manner. 
      </p>
      <p>
        This means that programmers should not create their objects (unless absolutely necessary, such as if the sandwich just isn't good enough in the <a href="FreeLunch.html">FreeLunch</a> and we have to initialize it with some mustard - but even initializing it doesn't mean creating and freeing it.). 
      </p>
      <p>
        <strong>Computers are Slaves</strong>
      </p>
      <p>
        We should be able to command anything we want out of our computer without creating anything or disposing of anything (but in some cases we will dispose if it means getting to the store faster.. for example disposing of the person that is in your way blocking you from leaving the house).  In some cases creation and disposable is useful, but in most cases we just should be able to commandHim to doThatNow. For example if we really want to do hard labour and work in a factory and create cars.. then we can do so.. but if possible it would be better just to getCar() and driveCar(). Even buyCar() is not required in <a href="SlaveOrientedProgramming.html">SlaveOrientedProgramming</a> because I can just stealCar().
      </p>
      <p>
        This comes from a ModularWeenie and ProceduralWeenie. I use objects when I have to, and I use the heap when I have to.. but the stack is also great and some simple "commands without instances" at times are also <em>great</em>.  
      </p>
      <p>
        Jokingly, it also means that <em>most life on earth was really not created</em>... someone just commanded sh*t to happen and it did. Okay, only in some cases where absolutely necessary might have there been an instance - such as an atom.  But maybe this atom was composed of other things and just commanded together, possibly.
      </p>
      <p>
        <strong>Imagine, that you actually had to make breakfast as an instance?</strong> 
      </p>
      <code>
        stealIngredients() <br/>
        if makeMeBreakfast == false then cookBreakfastMyself() <br/>
        eatIt() <br/>
      </code>
      <p>
        There is no creation of the breakfast.... there is no freeing of the breakfast.  Even stealing the ingredients isn't necessary since we already have all of them (stored in a fridge module, and they never run out.. they only contain bugs and diseases at times).  <a href="BreakFast.html">BreakFast</a> contains the word "fast" in it and is a command itself. <a href="BreakFast.html">BreakFast</a> isn't even a noun. It's an action. Break Fast. Break Now.
      </p>
      <p>
        When you tell someone in real life to make you break fast, do you first have to create that person? No. A computer should make you breakfast without any hassles such as first the comptuer becoming pregnant and having a child in order to make breakfast for you. That's complex. 
      </p>
      <p>
        <strong>Creating Code</strong>
      </p>
      <p>
        The only thing I'd argue we need to create.. is the code itself (but even that is just thoughts commanded on to paper).  We have <em>enough creating and hard work to do</em> so stop requiring so many instance creations and freeings please.  We spend enough time creating code, so why create instances if we don't need them?
      </p>
      <p>
        <strong>Garbage Collection</strong>
      </p>
      <p>
        Garbage collection helps half of the time.. but even better is something that doesn't require freeing or creating.. just declare and use. As a bonus, in many cases these declare and use (stack items or reference counted items) are faster than any other type out there. Wait, I get a <a href="FreeLunch.html">FreeLunch</a> that is also better? How can a <a href="FreeLunch.html">FreeLunch</a> be better than one that I have to make myself?  In some aspects, the one you have to make yourself can offer more customization.. but half the time I just need to eat the good <a href="FreeLunch.html">FreeLunch</a> since it is <a href="GoodEnough.html">GoodEnough</a> and. For super customization of your own instancee.. many times <a href="YouArentGonnaNeedIt.html">YouArentGonnaNeedIt</a>.
      </p>
      <p>
        Consider this situation where we just need a fricking list of strings:
      </p>
      <code>
        program mylist;<br/>
      </code>
      <code>
        var <br/>
        s: StackStringList;<br/>
      </code>
      <code>
        begin<br/>
        s.add('item1');<br/>
        s.add('item2');<br/>
        s.add('item3');<br/>
        for i:= low(s.items) to high(s.items) do writeln(s.items[i]);<br/>
        end;<br/>
      </code>
      <p>
        Compare the above simple code to this nonsense:
      </p>
      <code>
        program mylist;<br/>
      </code>
      <code>
        var <br/>
        s: TStringListObject;<br/>
      </code>
      <code>
        begin<br/>
        s:= TStringListObject.Create; <em>// dangling pointer! Dangerous</em><br/>
        s.add('item1');<br/>
        s.add('item2');<br/>
        s.add('item3');<br/>
        for i:= low(s.items) to high(s.items) do writeln(s.items[i]);<br/>
        s.free;  <em>// how does this help us? the instance does what for us?</em> <br/>
        s:= nil; <em>// how does this help us? the instance does what for us?</em><br/>
        end;<br/>
      </code>
      <p>
        Thread programmers will argue <em>the instance helps! it does!</em> which is nonsense. Put the item in a command. Garbage collection programmers will argue that there is no dangling pointer so garbage collection solves the worlds problems. True to an extent except that the above solution <em>doesn't even require the garbage collection</em> and doesn't require any instance. <a href="JustDoIt.html">JustDoIt</a> for crying out loud. Put the item in a command:
      </p>
      <code>
        procedure threadSafe_SoThere;<br/>
        var <br/>
        s: StackStringList; // or reference counted<br/>
        begin<br/>
        s.add('item1');<br/>
        s.add('item2');<br/>
        s.add('item3');<br/>
        for i:= low(s.items) to high(s.items) do writeln(s.items[i]);<br/>
        end;<br/>
      </code>
      <p>
        Encapsulation? Need to initialize something within the list of strings? Fine. Do so. Say so. You don't have to shove that code into a Create() constructor.. you can put it in a more descriptive Init() procedure.  Encapsulation doesn't just exist in OOP.
      </p>
      <p>
        Inheritance? Some times you just need the damn stringlist. Sometimes you need an integer list with sort capabilities (as opposed to an Array which is just too simple). But a stringlist doesn't have to have babies and children all the time. If it does, you can wrap it and extend it.... either by reusing the existing one and adding more to it (using an object without an instance on the stack, which some argue isn't a real object.. so let's call it a good useful structure that can be extended).
      </p>
      <p>
        <strong>Memory Creation</strong>
      </p>
      <p>
        We do have to allocate memory sometimes, but it can be wrapped and abstracted. We shouldn't be creating it over and over and over again. Machines and tools are reused.. not recreated over and over again. Databases are reused.. not recreated from scratch over and over again. Memory allocation can be wrapped into modules and commands (and reference counted types).  
      </p>
      <p>
        Creating and freeing memory in production code is <a href="NeedlessRepetition.html">NeedlessRepetition</a> and can cause bugs. Better instead wrap it into safe commands and modules.  Garbage collection isn't always even needed if the stack is used or if the memory allocation is wrapped into a command that one can use over and over again, or if  reference counting is used. 
      </p>
      <p>
        <strong>Bad Influences</strong>
      </p>
      <p>
        Java has bastardized programming by obsessing over <em>instances of this</em> and <em>instances of that</em>, without any stack, nor VAR (by reference) or OUT params, and no simple reference counted types.   The joke in Java is that one can do <em>functional programming</em> if he just creates more object instances.. which defeats the purpose of functional programming just <em>being there</em>. The other joke in Java is that one can do <em>imperative programming</em> if he just creates more object instances.. which defeats the purpose of imperative programming which is to have commands that are just there ready to use.
      </p>
      <p>
        See also 
      </p>
      <ul>
        <li>
           <a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html">http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html</a>
        </li>
        <li>
           <a href="http://en.wikipedia.org/wiki/Imperative_mood">http://en.wikipedia.org/wiki/Imperative_mood</a> (good influence)
        </li>
      </ul>
      <p>
        <strong>Database</strong>
      </p>
      <p>
        Thankfully, each time we connect to our databases we do not need to create instances and childrens of the databases. The database is <em>just there</em>. 
      </p>
      <hr/>
      <p>
        Another way of looking at it: when you do need to allocate memory,  it isn't <em>creating</em> any memory. It is just <em>getting</em> some available memory. We <em>cannot create memory chips</em> inside our computers. If we could, though, that would be interesting.
      </p>
      <hr/>
      <p>
        Another thought: a database table is created once.. and reused over and over again... querying it through relations. Not everything needs an instance which is continually recreated and freed over and over again.  For example if you have a database to access, just access it.. skip the nonsense of instantiating stuff first to access something that already exists!  <em>Creating tables</em> is fine, when you need them.. but instantiating an object to access the database is ridiculous, considering <em>the database is already there</em>. 
      </p>
      <hr/>
      <p>
        The whole creation idea is abstract.. and has been taken too far. It's become a hyped buzz to now "have an instance" of pretty much anything and everything.
      </p>
      <hr/>
      <p>
        Functional programming makes use of tricks so there is less New() Create() Dispose(). 
      </p>
      <p>
        See <a href="FunctionalInImperative.html">FunctionalInImperative</a> for some tricks on functional programming using imperative languages.
      </p>
      <hr/>
      <p>
        <em>Should we have abortions before our objects are born (created)?</em>
      </p>
      <p>
        Objects (structures) should be initialized.  A baby is initialized by mixing a few existing ingredients but you can't literally <em>create</em> one from thin air.  
      </p>
      <p>
        <em>Babies live, and then they die... are structures destroyed?</em>
      </p>
      <p>
        They are just moved elsewhere.. and forgotten about. Someone I know lives in a coffin, for example, whom no one visits any more. Matter is not <em>destroyed</em>.
      </p>
      <hr/>
      <p>
        See also: <a href="TableOrientedProgramming.html">TableOrientedProgramming</a>, <a href="ModularProgramming.html">ModularProgramming</a>, MopMind
      </p>
    </div>
  </body>
</html>