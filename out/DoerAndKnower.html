<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Doer And Knower
      </h1>
      <p>
        <a href="DoerAndKnower.html">DoerAndKnower</a> <a href="AntiPattern.html">AntiPattern</a> represents a lack of encapsulation. 
      </p>
      <p>
        This can often first be detected by looking at class names and their contents. Often seen when classes with "verb" names that are full of code that operate on other simple struct-like classes that have the knowledge.
      </p>
      <p>
        And what is this antipattern? This page fails to define it, so I have no idea what's being discussed. --<a href="MarnenLaibowKoser.html">MarnenLaibowKoser</a> 20 June 2011
      </p>
      <p>
        <em>I think what is meant is the </em><a href="AntiPattern.html">AntiPattern</a> of not doing OOP. Instead traditional <a href="StructuredProgramming.html">StructuredProgramming</a> is OOP-ified and the data structures are operated on by specialized methods.<em></em>
        <em>This can be the right way if the data structure is hidden behind a facade and the data structure is complex (think of a GIS data structure with lots of wing pointers for geometric neighbors).</em>
        <em>But if the </em>objects<em> are simple data holders to be used by client code this </em>is<em> an </em><a href="AntiPattern.html">AntiPattern</a>. -- <a href="GunnarZarncke.html">GunnarZarncke</a><em></em>
      </p>
      <p>
        Imagine the following: The class OrderProcessor has no internal state, but an awful lot of methods that accept and give out OrderEntry objects. On the other hand, the class OrderEntry contains nothing but member variables, perhaps with some simple getFoo and setFoo methods for each (if you're lucky). The OrderProcessor class makes no sense without an OrderEntry, whilst an OrderEntry makes no sense without an OrderProcessor. A more OO approach would be an Order class with the same member variables as OrderEntry and the same methods as OrderProcessor, thus the implementation of an order is encapsulated in the Order class.
      </p>
      <p>
        Note: if a there is a real "order processor", for example a server, then it is not an <a href="AntiPattern.html">AntiPattern</a> to model this with a class. Such a class would encapsulate the communication to and from the "order processor" though, and would not perform all Order manipulation. Orders should know how to take care of their own state.  In the above example, the separation of Order and OrderProcessor serves no purpose other than to keep state (Knower) separate from code that manipulates that state (Doer). This destroys encapsulation.
      </p>
      <hr/>
      <p>
        In C++, certain classes (namely PODs and now standard layout classes), have extra guarantees about the layout.  Using something like this can allow one to get around the restrictions on those classes while still gaining those gaurantees.  Most likely, you would have the OrderEntry class be private or protected.
      </p>
      <hr/>
      <p>
        This smells a little bit like a <a href="DataOriented.html">DataOriented</a>-<a href="AntiPattern.html">AntiPattern</a> / <a href="InformationOriented.html">InformationOriented</a>-pattern. I just don't have enough experience to be able to tell. -- <a href="JonGrover.html">JonGrover</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryArchitectureAntiPattern.html">CategoryArchitectureAntiPattern</a>
      </p>
    </div>
  </body>
</html>