<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Really Big Numbers
      </h1>
      <p>
        I just got done creating some really big numbers with my kids (see <a href="http://alistair.cockburn.us/crystal/articles/frbn/fugareallybignumbers.html).">http://alistair.cockburn.us/crystal/articles/frbn/fugareallybignumbers.html).</a> Had fun coming up with the brand-new function
        <em>fuga(-)</em> to get a faster growing function than any I knew of, so we could say "Fuga(googolplex)."
        <em>Fuga</em>(N) is N to the Nth power N times, so
        <em>fuga</em>(2) is 2^2, <em>fuga</em> (3) is 3^3^3, etc.
        You can see how this grows. -- <a href="AlistairCockburn.html">AlistairCockburn</a>  
      </p>
      <p>
        Since the ^ operation is not associative, i.e. (x^y)^z != x^(y^z), this begs the question whether Fuga(3) means (3^3)^3 = 19683 or 3^(3^3) = 7625597484987. Probably the latter, since the goal is to get big numbers. Otherwise the name could be <<Megafuga>> -- <a href="StephanHouben.html">StephanHouben</a>
      </p>
      <p>
        Thanks, Stephan, I had in mind (3^3)^3, which is in line with building a big number from the bottom up. You deserve a neater name than Fuga for the computing in the other order (I'm curious as to how old my kids will have to be to understand it). My coffee buddy suggested Megafuga. I put in Megafuga in your text above... change it if you come up with something better. -- <a href="AlistairCockburn.html">AlistairCockburn</a>
      </p>
      <p>
        (p.s. after reading the appends that showed up within hours of my posting, I am humbled, amazed and in awe of math again for the first time in decades. Thanks, folks.) 
      </p>
      <p>
        (p.p.s. In an interesting turn of events, the American Physical Society found and published the article in their April 2001 (!) online news bulletin, <a href="http://www.aps.org/apsnews/0401/040111.cfm)">http://www.aps.org/apsnews/0401/040111.cfm)</a>
      </p>
      <hr/>
      <p>
        according to Perl 5.6
      </p>
      <code>
        fuga(1) = 1<br/>
        fuga(2) = 4<br/>
        fuga(3) = 19,683<br/>
        fuga(4) = 3.40282366920938 e+38 (340282366920938463463374607431768211456)<br/>
        fuga(5) = Infinity (Too long expand out... ~7.18 e+436)<br/>
      </code>
      <p>
        -- <a href="AndyJewell.html">AndyJewell</a>
      </p>
      <hr/>
      <p>
        <em>I have a faster function: start with 2, then do fuga(2) get your answer, in witch case is 4 , then do fuga((your answer)) (in this case fuga(4))witch, would give you 340282366... then do fuga of that huge number! And so on)</em>
      </p>
      <hr/>
      <p>
        Given that definition, I get the following numbers using Python's bignums:
      </p>
      <code>
        Megafuga(1) = 1<br/>
        Megafuga(2) = 4<br/>
        Megafuga(3) = 7,625,597,484,987<br/>
      </code>
      <p>
        Megafuga(4) = 4 ^ 13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084096 = approx. 4 ^ 1.34e+153
      </p>
      <p>
        <em>(I note that Megafuga(4) is somewhat larger than 4^googol.)</em>
        The number 1.34e+153 is considerably larger than estimates about the number
        of electrons, protons and neutrons in the visible part of the universe (the number of protons is only estimated to be 1e80 [<a href="NickKeighley.html">NickKeighley</a>]).
        Since the number 4 ^ 1.34e+153 will require a number of digits in the order
        of 1.34e+153, we can safely say that computing all digits of megafuga(4) will
        never happen.
      </p>
      <p>
        -- <a href="StephanHouben.html">StephanHouben</a>
      </p>
      <hr/>
      <p>
        What would be the biggest number that could be represented in full using all the particles, photons and space in the known universe? I would have thought that each particle can represent a fir number of bits using its velocity, spin and locations dimensions. -- <a href="AndyMorris.html">AndyMorris</a>
      </p>
      <hr/>
      <p>
        <em>Never happen? Nonsense! Here they are: 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9. (Some assembly required.)</em>
      </p>
      <dl>
        <dt> </dt>
        <dd>That's a very Platonic idea. However, all information must have some corresponding representation in reality. They aren't just "floating in the aether." If the number requires more bits than there are particles in the universe, there is no way to express it directly. However, that being said, the format we use to represent numbers is really just a vector function. It might be legitimate to say that the number is represented by such and such function with so and so parameters. If you can express the function and its parameters in far fewer bits of information, say in the few dozen bits used above, then the number itself is information light. That is, you can "compress" it by expressing it as the function with the parameters.</dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd>On the other hand, there is some amount of information that's being hidden by mathematical convention. This is where the <em>Principia</em> comes into play. But even then, how do you represent an axiom? -- <a href="SunirShah.html">SunirShah</a></dd>
      </dl>
      <hr/>
      <p>
        KenMulligan, my coffee buddy, said that he notices this big-number-competition between boys of all ages, but not girls. He says he thinks its an early gender related competition (already in place by age 5). -- Alistair
      </p>
      <hr/>
      <p>
        The <a href="AckermannFunction.html">AckermannFunction</a> generates functions and applies the generated function to numbers. Officially:
      </p>
      <code>
        ack(i,j) =<br/>
        j + 1		 if i = 0,<br/>
        ack(i-1, 1)		if i > 0 and j = 0,<br/>
        ack(i-1, ack(i, j-1)) otherwise.<br/>
      </code>
      <p>
        Just try to compute ack(4, 4). You are allowed to use a computer.
        Not that it will help you much...
      </p>
      <p>
        <em>Got it! Grokking the </em><a href="AckermannFunction.html">AckermannFunction</a>. Just lousy variable naming conventions, that's all. The first argument describes the <em> level </em>of the function being described. Relabeling and Currying, we get a function generator operating on a function-level argument, and the resulting function applied to a specific number. This is great - I actually have been looking for such a thing for a looonnng time. -- <a href="AlistairCockburn.html">AlistairCockburn</a><em></em>
      </p>
      <code>
        Ackermann(level,n) =  Ackermann[level](n)<br/>
      </code>
      <code>
        Ackermann[0] (n) is increment(n), actually  (n+1)<br/>
        Ackermann[1] (n) is add2to(n), actually  (n+2)<br/>
        Ackermann[2] (n) is double(n), actually  (2*n+3)<br/>
        Ackermann[3] (n) is 2exponentiatedBy(n), actually  2^(n+3)-3<br/>
        Ackermann[4] (n) is tetrate(n) or similar to Megafuga(n)<br/>
        Ackermann[5] (n) is quintate(n)<br/>
        etc., so<br/>
        Ackermann[100](n) is centate(n),<br/>
        whatever wicked function centate(_) turns out to be<br/>
      </code>
      <p>
        <em>(Alistair -- you might want to see a </em><a href="JayLanguage.html">JayLanguage</a> exposition of the <a href="AckermannFunction.html">AckermannFunction</a> at:<em></em>
      </p>
      <code>
        <a href="http://www.jsoftware.com/papers/ack.htm">http://www.jsoftware.com/papers/ack.htm</a><br/>
      </code>
      <p>
        <em>And if you want a complete copy of J, it is now available free for the downloading from the same site!)</em>
      </p>
      <p>
        <em>(And after reading that exposition, I withdraw any claim I might have made about grokking Ackermann functions!! -- </em><a href="AlistairCockburn.html">AlistairCockburn</a>)
      </p>
      <p>
        Redefining with these unconventional but more comprehensible labels:
      </p>
      <code>
        Ackermann[level] (n) =<br/>
        if level = 0	then n + 1<br/>
        elseif n=0	then Ackermann[level-1] (1)<br/>
        else		Ackermann[level-1] (Ackermann[level](n-1))<br/>
      </code>
      <p>
        For level=4, Megafuga and Ackermann are still in the same league. But for larger
        numbers, Ackermann grows much much faster than Megafuga. Megafuga is just
        repeated exponentiation (called tetration by <a href="SunirShah.html">SunirShah</a>). But for level = 5,
        Ackermann starts doing "quintation" (repeated tetration). and for level = <a href="GoogolPlex.html">GoogolPlex</a>, it does the googolplexation.
      </p>
      <p>
        see my fast grower near the top of the page where it says (.pps. I would like to use mega fuga in sted of fuga to help in my function
        <a href="KevinKostlan.html">KevinKostlan</a> made this function.
      </p>
      <p>
        From a theoretical computing science point of view, Ackermann is really in
        a different league than Megafuga. Megafuga is still primitive recursive,
        whereas Ackermann is computable but not primitive recursive anymore.
      </p>
      <p>
        -- <a href="StephanHouben.html">StephanHouben</a>
      </p>
      <p>
        If you have a lisp system and some memory to burn, you can play with this using something like (there are more efficient ways to do this)
      </p>
      <code>
        (defun ack (m n)<br/>
        (cond ((zerop m) (1+ n))<br/>
        ((zerop n) (ack (1- m) 1))<br/>
        ((ack (1- m) (ack m (1- n))))))<br/>
      </code>
      <hr/>
      <p>
        Consider tetration (verb <em>to tetrate</em>), from the Greek for four (tetra) as it is fourth in order: addition, multiplication, exponentiation, tetration. It is traditionally rendered as
      </p>
      <code>
        y<br/>
        x<br/>
      </code>
      <p>
        Just as in exponentiation, except you put the superscript to the left. It is associative top down, so 2 tetrated to the 4th is:
      </p>
      <code>
        4<br/>
      </code>
      <ol>
        <li>
           = 2^(2^(2^(2))) = 2^(2^(4)) = 2^(16) = 65536
        </li>
      </ol>
      <p>
        -- <a href="SunirShah.html">SunirShah</a>
      </p>
      <p>
        With this notation, the closed form of Megafuga becomes simply:
      </p>
      <code>
        n<br/>
        Megafuga(n) =	n<br/>
      </code>
      <p>
        Similarly, plain old fuga is just:
      </p>
      <code>
        (n-1)*n<br/>
        Fuga(n) = n<br/>
      </code>
      <hr/>
      <p>
        <strong>Question:</strong> Isn't Fuga(n) actually
      </p>
      <code>
        n^(n-1)<br/>
        Fuga(n) = n<br/>
      </code>
      <p>
        That's what I get. -- <a href="AlistairCockburn.html">AlistairCockburn</a>
      </p>
      <hr/>
      <p>
        <em>Gadzooks! I feel totally outdone (although, how, of course, could I possibly compete with professional mathematicians who spent decades playing with really big functions)! That my </em> Fuga(-) <em>is so lowly as to not deserve a name, being a mere approximation to n^(n^2), is a shock, but actually a pretty happy one, since it points to the next embellishment.</em>
      </p>
      <p>
        <em>That the </em> Megafuga <em>not only already has a name but even already a fixed notation is wonderful. And it doesn't reduce flat as Fuga suddenly did.</em>
      </p>
      <p>
        <em>The </em><a href="AckermannFunction.html">AckermannFunction</a> bothers me, because it is a function of two variables, and we'd be interested in functions of one variable. Surely there must be a name for Ackermann(n,n) for whatever n. Knackered_Man(n) = Ackermann(n,n)?? Or,<em> Gag(n) </em>for short? And that +, *, ^ progression... does it generate new functions as it goes? Is that what tetration and quintation mean? Thanks for all this<em> -- </em><a href="AlistairCockburn.html">AlistairCockburn</a>
      </p>
      <hr/>
      <p>
        Consider the progression addition, multiplication, exponentiation, tetration. First, consider addition:
      </p>
      <ol>
        <li>
           + 2 + 2 + 2
        </li>
      </ol>
      <p>
        This can be written 2 * 4. Next, consider multiplication:
      </p>
      <ol>
        <li>
           * 2 * 2 * 2
        </li>
      </ol>
      <p>
        This can be written 2^4. Next, consider exponentiation:
      </p>
      <ol>
        <li>
          ^(2^(2^(2))))
        </li>
      </ol>
      <p>
        This can be written 2 tetrated to the 4th. Similarly,
      </p>
      <code>
        2<br/>
        2<br/>
        2<br/>
        2<br/>
      </code>
      <p>
        can be written 2 quintated (*) to the 4th. Working top down, we have
      </p>
      <ol>
        <li>
          	 2
          <ol>
            <li>
              	(2 )	4
            </li>
          </ol>
        </li>
        <li>
          	=	2  = ( 2)  = 65536  = a really huge number
        </li>
        <li>
          	 2	2	2
          <ol>
            <li>
               quintated to the 3rd is 65536, by the way.
            </li>
          </ol>
        </li>
      </ol>
      <p>
        We can go further, working with the progression to sextation (**) and further. But who really wants to go further than sextation? -- <a href="SunirShah.html">SunirShah</a> (*) 5 = quinque in Latin; (**) 6 = sex in Latin.
      </p>
      <p>
        P.S. Notice how 2 [operation] 2 = 4 always. Cool!
      </p>
      <p>
        <em>One nitpick. The prefix tetra- comes from Greek, not Latin. So we should stick to Greek. I learned the following table, not during Greek, but during Chemistry: mono = 1, di = 2, tri = 3, tetra = 4, penta = 5, hexa = 6, hepta = 7, octa = 8, ennea = 9, deca = 10.</em>
      </p>
      <p>
        <em>See </em><a href="NumericalPrefixes.html">NumericalPrefixes</a><em></em>
      </p>
      <hr/>
      <p>
        How about something like this:
      </p>
      <code>
        F(n) =	1	  for n=1<br/>
        n^(F(n-1)!)	for n>1<br/>
      </code>
      <p>
        A witless program I wrote spits out:
      </p>
      <code>
        N	F(N)<br/>
      </code>
      <ol>
        <li>
          	1
        </li>
        <li>
          	2
        </li>
        <li>
          	9
        </li>
        <li>
          	Infinity (really a mere 4^362880)
        </li>
      </ol>
      <p>
        Call it the expostfacto function. Not quite in the Megafuga league by N=4, but it does grow quickly. -- <a href="TomKreitzberg.html">TomKreitzberg</a>
      </p>
      <p>
        <em>I love the name, "expostfacto", I almost think you thought up the function just to fit the name! -- </em><a href="AlistairCockburn.html">AlistairCockburn</a><em></em>
      </p>
      <hr/>
      <p>
        (I can't let this one go. Why bother with something puny as factorial(n) when we have Gag lying around (besides the cute name)? Playing the five-year-old game, what's Mag(n) = Gag(Gag(...(n))? As many Gags as N, to get it back to a function of one variable. Or as many Gags as Gag(n), or as many Gags as Mag(n)...)
      </p>
      <p>
        <em>The game is more interesting if you can do it without referring to another non-elementary function, or at least not another function mentioned previously at </em>any<em> time previously during the game.</em>
      </p>
      <p>
        OK. much tougher. I'll learn to withhold primitive recursive retorts.
      </p>
      <hr/>
      <p>
        A function that grows much faster than Gag is Rado's Sigma-function, also known
        as the busy beaver function. See: <a href="http://www.drb.insel.de/~heiner/BB/">http://www.drb.insel.de/~heiner/BB/</a> for an explanation.
      </p>
      <p>
        Rado's Sigma is, however, uncomputable. It can be shown to grow faster than any computable function.
      </p>
      <p>
        -- <a href="StephanHouben.html">StephanHouben</a>
      </p>
      <p>
        "Grows faster" is an interesting turn of phrase. The initial numbers are way smaller than what Ackerman produces. Once the tape gets long enough to replicate Ackermann's function, then it grows as least as fast, rather by definition. So, yes, it grows faster.
      </p>
      <p>
        (From the cited page: <em>The function Sigma(n) denotes the maximal number of tape marks which a </em><a href="TuringMachine.html">TuringMachine</a> (TM) with n internal states and a two-way infinite tape can produce onto an initially empty tape and then halt.<em></em>
      </p>
      <code>
        Sigma(1) = 1<br/>
        Sigma(2) = 4 <br/>
        Sigma(3) = 6 <br/>
        Sigma(4) = 13 <br/>
        Sigma(5) >= 4098<br/>
        Sigma(6) >= 2,537,699,363,594,175,843,063<br/>
        Sigma(8) >= 8*10^44 <br/>
      </code>
      <p>
        Unverified results claim that Sigma(6) > 6*10^462
      </p>
      <hr/>
      <p>
        Is that really an infinite tape? Or is it just an unbounded one?
      </p>
      <hr/>
      <p>
        Something else that might amuse aficionados of <a href="ReallyBigNumbers.html">ReallyBigNumbers</a> is what's
        called "Graham's number". It's defined like this.
      </p>
      <ol>
        <li>
          	<em>a</em>^<em>b</em> means "<em>a</em> to the power <em>b</em>".
        </li>
        <li>
          	<em>a</em>^^<em>b</em> means "<em>a</em> to the <em>a</em> to the <em>a</em>..., <em>b</em> times" (grouped as for "Megafuga")
        </li>
        <li>
          	<em>a</em>^^^<em>b</em> means "<em>a</em>^^<em>a</em>^^..., <em>b</em> times". And so on.
        </li>
        <li>
          	Now, write <em>N</em>1 = 3^^^^3. (This is already frighteningly huge.)
        </li>
        <li>
          	Write <em>N</em>2 = 3^^...^^3, with <em>N</em>1 ^ signs.
        </li>
        <li>
          	Write <em>N</em>3 = 3^^...^^3, with <em>N</em>2 ^ signs. And so on.
        </li>
        <li>
          	Graham's number is <em>N</em>64.
        </li>
      </ol>
      <p>
        This staggeringly large number is an upper bound, found by R L Graham and B L Rothschild, for the answer to the following mathematical problem: What dimension does a hypercube graph need to have in order that, if you colour its edges in two colours, there will be four vertices connected by edges of a single colour?.
      </p>
      <p>
        Oh, and it's generally believed that the actual answer (the one for which <em>N</em>64 is the best known upper bound) is 6.
      </p>
      <p>
        -- <a href="GarethMcCaughan.html">GarethMcCaughan</a>
      </p>
      <p>
        <em>I love it! I use this story as a party joke! (at the right kind of parties, of course)</em>
      </p>
      <p>
        <a href="RamseyTheory.html">RamseyTheory</a> is full of theorems like that. For instance, see <a href="VanDerWaerdensTheorem.html">VanDerWaerdensTheorem</a>.
      </p>
      <hr/>
      <p>
        In BON (<em>Book of Numbers</em> by Conway & Guy, ISBN 038797993X) Knuth's <strong>arrow notation</strong> is extended to their <em>chained arrow</em> notation.
      </p>
      <code>
        <em>a</em> --> <em>b</em> --> <em>c</em> stands for <em>a</em> ^^...^^ <em>b</em>, <em>c</em> times a  ^<br/>
      </code>
      <p>
        Furthermore
      </p>
      <code>
        <em>a ... x</em> --> <em>y</em> --> <em>(z+1)</em><br/>
      </code>
      <p>
        is defined as
      </p>
      <code>
        <em>a ... x</em>							if <em>y</em>= 1,<br/>
        <em>a ... x</em> --> <em>(a ... x</em> --> <em>(y - 1)</em> --> <em>z</em>) --> <em>z</em>		if <em>y</em>> 1.<br/>
      </code>
      <p>
        Then they show that
      </p>
      <ol>
        <li>
          , 2 --> 2, 3 --> 3 --> 3 
        </li>
      </ol>
      <p>
        agree with the first 3 Ackermann numbers, but
      </p>
      <ol>
        <li>
           --> 4 --> 4 --> 4  = GC(4)
        </li>
      </ol>
      <p>
        is very much larger then Ack(4) which is only
      </p>
      <ol>
        <li>
           --> 4 --> 4.
        </li>
      </ol>
      <p>
        Their sequence CG(n) equals
      </p>
      <code>
        n --> ...--> n  <em>n</em>times <br/>
      </code>
      <p>
        delivers extremely large numbers. Graham's number for example is less than
      </p>
      <ol>
        <li>
           --> 3 --> 3 --> 3, 
        </li>
      </ol>
      <p>
        so definitely less than CG(4).
      </p>
      <p>
        -- R.E. BOSS
      </p>
      <hr/>
      <p>
        Some definitions:
      </p>
      <code>
        exp(r,n) = r exponentiated n times, left-associative<br/>
        fuga(n+x) = exp(n+x,n) ^ ((n+x) ^ x) where n is integer and 0 <= x < 1<br/>
        fugarithm(a) = b iff fuga(b) = a<br/>
      </code>
      <p>
        What is the fugarithm of 1000?
      </p>
      <p>
        -- <a href="SteveHowell.html">SteveHowell</a>
      </p>
      <p>
        I computed it to be ~2.824793.
      </p>
      <hr/>
      <p>
        How about this one: (a bit hard to render in ASCII though)
      </p>
      <ul>
        <li>
           <em>n</em> written in a triangle = <em>n</em> ^ <em>n</em>
        </li>
        <li>
           <em>n</em> written in a square = <em>n</em> in <em>n</em> triangles
        </li>
        <li>
           <em>n</em> written in a circle = <em>n</em> in <em>n</em> squares.
        </li>
      </ul>
      <p>
        For example:
      </p>
      <ol>
        <li>
           in a square = 2 in 2 triangles = 2^2 in a triangle = 4^4 = 256
        </li>
      </ol>
      <ol>
        <li>
           in a circle = 2 in 2 squares = (2 in 2 triangles) in a square = ((2^2) in a triangle) in a square = (4^4) in a square = 256 in 256 triangles = an extremely big number.
        </li>
      </ol>
      <p>
        -- <a href="TristanSeligmann.html">TristanSeligmann</a>
      </p>
      <p>
        <em>One thing that delighted me when I was younger is that even though it's impossible to compute that exact value of 2-in-a-circle, and nobody will ever have a clear idea of how big it is, because it's just Too Big, it is quite trivial to show that it must end in the digit "6".</em> -- <a href="MarkJasonDominus.html">MarkJasonDominus</a>
      </p>
      <hr/>
      <p>
        Ahh the beauty of the Internet! I started out this rainy Sunday morning looking for a particular watch on the Internet, when 10 or so hyperlinks later I found myself smack in the middle of reading about extremely large numbers on this very page.
      </p>
      <p>
        After intently reading down through it, I began to scribble numbers on a scrap of paper while looking through the various posts. As I neared the bottom of the webpage, I noticed the statement "Rado's Sigma is, however, uncomputable. It can be shown to grow faster than any computable function." Followed by the various levels and growth patterns:
      </p>
      <code>
        Sigma(1) = 1<br/>
        Sigma(2) = 4 <br/>
        Sigma(3) = 6 <br/>
        Sigma(4) = 13 <br/>
        Sigma(5) >= 4098<br/>
        Sigma(6) >= 2,537,699,363,594,175,843,063<br/>
        Sigma(8) >= 8*10^44<br/>
      </code>
      <p>
        After scratching and scrawling numbers for a few minutes, I had come up with my own functions, one of which is virtually uncomputable by the second level. The two functions are "ban(n)" and "rban(n)" - (Big Ass Number and Really Big Ass Number... I know, not likely to make it into the annals of Mathematics history with a naming convention like that but it's just for fun anyway).
      </p>
      <p>
        Ok, here goes...
      </p>
      <p>
        ban(n) = n to the nth tetration OR: 
      </p>
      <code>
        n<br/>
        n<br/>
        n<br/>
      </code>
      <p>
        ban(2) would look like the following:
      </p>
      <ol>
        <li>
                
        </li>
      </ol>
      <code>
        2<br/>
        2<br/>
      </code>
      <p>
        Which equals 2^(2^(2^2)) = 2^(2^4) = 2^16 = 65,536
      </p>
      <p>
        Similarly..... ban(3) = 3^(3^(3^(3^3))) = 3^(3^(3^9)) = 3^(3^19683) = 1.5054164145220926243143298033399e+9391
      </p>
      <p>
        To take this to another level, we use "rban".
      </p>
      <p>
        rban(n) = n to the nth tetration n times
      </p>
      <p>
        rban(2) would look like the following:
      </p>
      <code>
        (2<br/>
      </code>
      <ol>
        <li>
          )
        </li>
      </ol>
      <code>
        2<br/>
        2<br/>
        2<br/>
      </code>
      <p>
        The closest I can get to computing rban(2) is....
      </p>
      <code>
        (16<br/>
      </code>
      <ol>
        <li>
          )
        </li>
      </ol>
      <code>
        2<br/>
        2<br/>
      </code>
      <p>
        The resulting number is larger than any app on my PC can compute, by just the second level!!!!!
      </p>
      <p>
        rban(3) would look like the following:
      </p>
      <code>
        (3<br/>
      </code>
      <ol>
        <li>
          )
        </li>
      </ol>
      <code>
        (3<br/>
      </code>
      <ol>
        <li>
          )
        </li>
      </ol>
      <code>
        3<br/>
        3<br/>
        3<br/>
      </code>
      <p>
        ....and so on and so on.
      </p>
      <p>
        Let me know what you think, and again thanks for making me think!!!
      </p>
      <p>
        Matt Leach (mjleach@swbell.net)
      </p>
      <hr/>
      <p>
        Your definitions of ban(n) and rban(n) are not completely clear to me. Could you attempt to write it a bit more formally. As far as I understand,
        "rban(n) = n to the nth tetration n times" means n^(n quintated with n).
      </p>
      <p>
        With that definition, I find that rban(2) = 16, but this is clearly
        not what you are getting. The expression
      </p>
      <code>
        (2<br/>
      </code>
      <ol>
        <li>
          )
        </li>
      </ol>
      <code>
        2<br/>
        2<br/>
        2<br/>
      </code>
      <p>
        is presumably to be parsed as 2 ** ( tetra(tetra(2,2), tetra(2,2) )), i.e.
      </p>
      <ol>
        <li>
           ** (tetra(4,4)) = 2 ** (4** 13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084096).
        </li>
      </ol>
      <p>
        Anyway, as far as I understand it, ban and rban are "simple" compositions of
        tetration  and quintation, which means that they are still primitive recursive.
        They cannot really compete with Ackermann, I'm afraid...
      </p>
      <p>
        -- <a href="StephanHouben.html">StephanHouben</a>
      </p>
      <hr/>
      <p>
        So I was thinking about large number which actually could possibly somehow correspond to actual real physical world phenomena. Like this. So take the entire space of the universe, and imagine that it was filled *solid* with atoms or subatomic particles. The number of those particles would be huge, I wonder what it'd be. But, now, what about all possible permutations of those particles in space. I guess that'd be N! where N is the number of particles. Someone figure out the number! It's gotta approach or exceed Googol, or even Googolplex. Yathink?
      </p>
      <hr/>
      <p>
        So how's about factorials? If we define x!n (the nth level factorial of x) as x!n-1 * x-1!n-1 * ... * 2!n-1 * 1!n-1, and x!0 = x, then regular factorials are of the 1st level. Calculating factorials of 4 for the first couple of levels, we get:
      </p>
      <ol>
        <li>
          !0 = 4
        </li>
        <li>
          !1 = 4 * 3 * 2 * 1 = 24
        </li>
        <li>
          !2 = 4! * 3! * 2! * 1! = 4 * 3 * 2 * 1 * 3 * 2 * 1 * 2 * 1 * 1 = 24 * 6 * 2 * 1 = 288
        </li>
        <li>
          !3 = 4!2 * 3!2 * 2!2 * 1!2 = 4! * 3! * 2! * 1! * 3! * 2! * 1! * 2! * 1! * 1! = 288 * 12 * 2 * 1 = 6912
        </li>
        <li>
          !4 = 4!3 * 3!3 * 2!3 * 1!3 = 6912 * 24 * 2 * 1 = 331776
        </li>
      </ol>
      <p>
        Also note that x!n = x-1!n * x!n-1
      </p>
      <p>
        Of course we could define a function called the Torian, where T(x) = x!x, which would give pretty big numbers as well, but my math is not good enough to prove that it's faster or slower than any of the other functions on this page. --<a href="AalbertTorsius.html">AalbertTorsius</a>
      </p>
      <hr/>
      <p>
        It appears that content of this page has been picked up elsewhere... at <a href="http://michaelhalm.tripod.com/mathematics_beyond_the_googol.htm">http://michaelhalm.tripod.com/mathematics_beyond_the_googol.htm</a> on a page called Googology, and with the subtitle <em>Andr� Joyce Fan Club (rated #1 googology website by Ask Jeeves/Teoma and Netscape and given 4 stars by ixquick.com)</em> we find the section 
      </p>
      <p>
        <em>"Young Kieran Cockburn named a googolplex googolplex or googolplex squared a "gargoogol" = 10^200. His father, Alistair Cockburn added the prefixes fuga-, gag- and mag-. and named Stephan Houban's prefix megafuga-." </em> , and <em>"Stephan Houban estimated megafugafour = 4^^^2 = 4(3^)2 = 4^^4 = 4^4^4^4 > 10^10^153 and claimed "We can safely say that computing all the digits of megafugafour will never happen.",  to which Sunir Shah responded with "Never happen? Nonsense! Here they are: 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9. (Some assembly required.)" "</em>
      </p>
      <hr/>
      <p>
        See also <a href="http://www-users.cs.york.ac.uk/~susan/cyc/b/big.htm">http://www-users.cs.york.ac.uk/~susan/cyc/b/big.htm</a> for representation of Ackeman's function using both Knuth's and Conway's funny arrow systems (and the triangle system).
      </p>
      <hr/>
      <p>
        in response to
        "
        So I was thinking about large number which actually could possibly somehow correspond to actual real physical world phenomena. Like this. So take the entires space of the universe, and imagine that it was filled *solid* with atoms or subatomic particles. The number of those particles would be huge, I wonder what it'd be. But, now, what about all possible permutations of those particles in space. I guess that'd be N! where N is the number of particles. Someone figure out the number! It's gotta approach or exceed Googol, or even Googolplex. Yathink? "
      </p>
      <p>
        to who ever wrote this, I happily report that the permutation N! well exceeds a Googolplex, and furthermore, with probability and all the possible histories of a finite time, you can easily produces Googolplex's that describe real physical things(if you believe in parallel universes.). In any case, Googolplex is within the realm of things of practical scientific use, which means, it's not so big as we once thought.
      </p>
      <p>
        This is how I solved his permutation problem. I packed the entire universe solid with strings, the smallest possible physical objects, they are only 10^-35 metres long. The plank length is the smallest unit of physical space, and is at the same order of magnitude, so by determining the volume of the universe in cubic plank lengths, I am determining the maximum number of strings that can fit.
      </p>
      <p>
        the diameter of the universe is roughly 10^26 metres.so the difference in magnitudes is 
        (10^26) / (10^-35) = 10^61. cube this and we get 10^183, which exceeds a googol. so all the possible arrangements of these strings in distinct spaces, (with no overlaps) would be 
        (10^183)!
      </p>
      <p>
        using a special factorial approximation [<em>Stirling's Approximation</em> -- see <a href="http://mathworld.wolfram.com/StirlingsApproximation.html]">http://mathworld.wolfram.com/StirlingsApproximation.html]</a> I learned
      </p>
      <p>
        N! ~ [sqrt:(2pi)] x  [ e^(-N) ] x [N^(N + 1/2)]
      </p>
      <p>
        Note: N! < N^N upperbound. The first term in the equation is a constant: sqrt:(2pi)~ 2.506628
        the second term is a very small number, which drags the function down, however the third term is a very very large number and easily cancels out the small number of the second term. This is because the third term contains 2 variables while the second only has one, thus the equation grows just under the function N^N.
      </p>
      <p>
        The answer comes out roughly to
      </p>
      <ol>
        <li>
          5
          <ol>
            <li>
              82565705518 x 10
              <ol>
                <li>
                  50662827463 x 10
                </li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
      <p>
        which is basically 10^(10^185) which exceeds the googolplex 10^(10^100).
        Now here's the fun part. Although the number on the left doesn't seem that much bigger than googolplex, there is a huge gulf between them and googolplex becomes point sized in comparison.
      </p>
      <p>
        Imagine a humongous endless seemingly infinite universe which has a Googolplex particles in it, (you can think of it packed solid.) this would dwarf our own universe unimaginably. we call this The Googolplex universe.
      </p>
      <p>
        Now imagine that this huge endless infinity is only a mere particle in another even more grand universe with a googolplex such particles! We call this the Googolplex universe of the second order. Now imagine the second order universe as a mere particle in a third order googolplex universe. Now imagine a 4th order a 5th, a 6th, a 7th , a 8th, 9,10,11,12,13,14,15,16,17,18,19,20, ... ... ,100,101, ... ... 999,1000,1001,1002, .... 2000, .... ... .... 10,000 ..... 99,999 , 100,000 , ... ... dizzy yet ... .. .    .....     .....         .....          .....
      </p>
      <ol>
        <li>
          0
        </li>
      </ol>
      <p>
        order googolplex universe. The googolplex has been humbled by itself countless times, it's a point, or rather a point contained within a point. You have to remember that the first exponent has this same deceptive property. 10^267 might not seem that much more than 10^232 but the former is 10^35 times larger than the former. well the second exponent is ever more so deceptive. in general though it should be understood that 10^10^(x+1) is greater than 10^10^x. like this, the latter number raised to the tenth equals the former.
      </p>
      <p>
        Actually, I went even further then the original writer went in terms of creating the ultimate "practical Number" I wanted to find all the possible universal histories from the Big Bang to the ultimate end of everything (Big Crunch or ever-expansion).
      </p>
      <p>
        So the permutation N! is but a single possible moment, a single plank time, 10^-43 seconds. So 2 plank times would be another set of N! thus, (N!)^2. Now I let the universe run for 500 Quadrillion years (about a million times longer than the whole history so far.) the end result is
      </p>
      <ol>
        <li>
          ^(10^245)
        </li>
      </ol>
      <p>
        this number represents all imaginable histories you could ever create in the history of the whole universe, it is the ultimate reality upper bound, the ultimate practical number. I've even coined a useful name for this value, and I would like it to be known as it's originator. I termed this number as "Promaxima" which refers to "Probability Maximum". Promaxima is more a scientific number than mathematical, and therefore it's true exact value is yet to be known, my estimate of 10^(10^245) is an upper bound for Promaxima, since it makes many simplified assumptions (mainly for calculation reasons) which break the rules of physics. For example, let's say during some plank time a string is at one point in the universe then in the next it to a point one million light years away. That means that the string was traveling faster than the speed of light, which is impossible. Also there are much less than 10^183 strings in the universe(packed solid), when it's probably more like 10^80(less than a googol sadly). So Promaxima is most definitely less than my value. Still my value has the practical purpose of creating (a slightly blurly) dividing line between practical numbers, and boundless large numbers that are purely imaginary. 
      </p>
      <p>
        The interesting thing though is, the Googolplex is not a Chimera, it actually exists. The googolplex's days are numbered.
      </p>
      <p>
        -- Sbiis Saibian
      </p>
      <hr/>
      <p>
        Today, I wrote that thing:
      </p>
      <p>
        Let f<sup>n</sup>(a)=f(f(f(f(....a....)))) , f recursively repeated n times. <sup>something</sup> stands for superscript,like in html. (sorry, have no time, that's my last edit)
      </p>
      <p>
        f[1](a)=a<sup>a</sup>
      </p>
      <p>
        f[2](a)=f[1]<sup>f[1](a)</sup>(a)
      </p>
      <p>
        f[3](a)=f[2]<sup>f[2](a)</sup>(a)
      </p>
      <p>
        and so on.
      </p>
      <p>
        f[1,1](a)=f[0,a]<sup>f[0,a]</sup>(a)
      </p>
      <p>
        f[1,2](a)=f[1,1]<sup>f[1,1]</sup>(a)
      </p>
      <p>
        and so on.
      </p>
      <p>
        f[1,1,1](a)=f[a,a]<sup>f[a,a]</sup>(a)
      </p>
      <p>
        g[1](a)=f[a,a,a,a,a... a times]<sup>f[a,a,a,a,a... a times](a)</sup>(a)
      </p>
      <p>
        and so-on for h,i,j....z
      </p>
      <p>
        (hope it was clear enough what I mean by "so-on".)
      </p>
      <p>
        My number is z[1](1e6) or z[1](Googolplex), who cares. 
        Shortly after writing it, I searched the web to find what big numbers others have defined, and have found that great page.
      </p>
      <p>
        So, have I defined biggest number ever defined, and fastest-growing function? 
        f[n,n,n](n) for n=Googolplex (or even n=2) looks __a lot__ bigger than anything I can see there. I can define even bigger numbers, unimaginably bigger. (say, instead of f,g,h...z I can use numbers (and then use some really big number instead of z). I can repeat method of making functions grow bigger on itself, then repeat repeating, and so-on (some big number times so-on). )
      </p>
      <p>
        I originally wrote that thing in response on some other unrelated forum, where everyone started playing "name big number" game, and it reminded me some idea I had long ago (when I was a child), about defining fastgrowing function, repeating it on itself many times, repeating such repeating many times (using it to define "many"), and so-on (so-on really many times ,and so-on again :-) )
      </p>
      <p>
        Excuse my English.
      </p>
      <p>
        -- Dmytry Lavrov.
      </p>
      <hr/>
      <p>
        <a href="RubyLanguage.html">RubyLanguage</a> handles unusually large integers - 
      </p>
      <code>
        def factorial (number)<br/>
        if number > 1 then<br/>
        number = number * factorial(number - 1)<br/>
        end<br/>
        return number<br/>
        end<br/>
      </code>
      <code>
        factorial 511<br/>
      </code>
      <p>
        => 67915816272121198501621990577062592031098645618037393952001461553742390860670948114711129889443403391490672521683866122127930019935560354
      </p>
      <ol>
        <li>
          1
        </li>
        <li>
          1
        </li>
        <li>
          9
        </li>
        <li>
          7
        </li>
        <li>
          8
        </li>
        <li>
          6
        </li>
        <li>
          0
        </li>
        <li>
          0
        </li>
      </ol>
      <p>
        (fact 512 blows the stack)
      </p>
      <hr/>
      <p>
        For numbers with a large but 'sensible' number of digits, the Unix mathematical language 'bc' - also known as GNU bc - is handy for calculations:
      </p>
      <p>
        define factorial(x) {
      </p>
      <code>
        auto i,xx<br/>
        if(x<0)return(0)<br/>
        if(x<2)return(1)<br/>
        xx=1;for(i=x;i>=1;i--)xx*=i<br/>
        return(xx)<br/>
      </code>
      <p>
        }
        factorial(1000)
        factorial(1000)
      </p>
      <ol>
        <li>
          0
        </li>
      </ol>
      <p>
        You can do the same in <a href="DeeCee.html">DeeCee</a> (I have written factorial in it), but it has no looping and a platform-dependent limit on recursion. -<a href="JesseMillikan.html">JesseMillikan</a>
      </p>
      <p>
        PuffyJon: A World Of Large Numbers:
      </p>
      <p>
        So, Sbiis Saibian created Hyper-E, eh? (lol, get it?) Well, I made a better version, that extends beyond it, as well as changing the beginning!
      </p>
      <p>
        Hyper-E Notation is defined as:
      </p>
      <p>
        Ea#b = (10^a)^(10^a)^(10^a)...^(10^a) w/ b (10^a)s
      </p>
      <p>
        Examples:
      </p>
      <p>
        E1#1 = 10
        E1#2 = 10^10 = 10,000,000,000 = diamom
        E1#3 = 10^10^10 = 10^10,000,000,000 = diamomplex / triamom
        E1#4 = 10^10^10^10 = 10^10^10,000,000,000 = diamomduplex / triamomplex / tetramom
        E1#5 = 10^10^10^10^10 = 10^10^10^10,000,000,000 = diamomtriplex / triamomduplex / tetramomplex / pentamom
        .....
        E1#10 = 10^10^10^10^10^10^10^10^10^10 = diamomoctaplex / triamomsepttaplex / tetramomsexplex / pentamomquinplex / hexamomquadraplex / heptamomtriplex / octamomduplex / ennamomplex / decamom
        To Be Continued...
      </p>
      <hr/>
      <p>
        TEST
      </p>
      <hr/>
      <p>
        See also: <a href="FloatingPointCurrency.html">FloatingPointCurrency</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryMath.html">CategoryMath</a>
      </p>
    </div>
  </body>
</html>