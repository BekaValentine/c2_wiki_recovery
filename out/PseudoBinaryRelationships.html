<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Pseudo Binary Relationships
      </h1>
      <p>
        This is referring to <a href="WilliamKent.html">WilliamKent</a>'s <a href="DataAndReality.html">DataAndReality</a>, he outlines his simultaneous preference for irreducible n-ary relations and irreducible pseudo-binary relationships. It may shed some light on the <a href="ObjectRelationalPsychologicalMismatch.html">ObjectRelationalPsychologicalMismatch</a>.
      </p>
      <p>
        <a href="DataAndReality.html">DataAndReality</a>, though written in the 1970's, speaks mainly from a generic "record-oriented" model of data, and argues about tradeoffs between the record approach and other approaches (hierarchical, relational, etc.) I think it's pretty clear the Object Oriented "data model" is really a record-oriented data model with data/type inheritance.
      </p>
      <p>
        In a pure-binary relationship, the pointer is a relationship, and it denies the existence of relationships involving more than two things at a time. In a pseudo-binary approach, the pointer is just... well, a pointer. It becomes just glue, and the relationship itself becomes an intersection record.
      </p>
      <p>
        Let me quote (he probably explains it better than I):
      </p>
      <dl>
        <dt> </dt>
        <dd><em>It's really simple: out of all this assortment, I prefer one model - which is simultaneously the pseudo binary and the irreducible n-ary. Let me try to explain why I see negligible difference between them, at least in the essential structure of the model of a ternary relation.	In the pseudo binary model, we link four objects to model a relationship among a part, a warehouse, and a supplier. In the irreducible n-ary relational model, we also have four objects. There is one record each for the part, the warehouse, and the supplier, containing information about those entities. And there is the intersection record with three fields, containing the keys (identifiers) for that part, that warehouse and that supplier.</em></dd>
      </dl>
      <dl>
        <dt> </dt>
        <dd><em>We can make the geometries of these two representations look alike. We are only dealing with differences in the portrayal of the linkages. In the pseudo binary model, we draw explicit lines, suggesting some kind of internal pointer mechanism in the implementation. In the relational model, on the other hand, linkages are discovered by matching symbols (in this case, the identifiers in the intersection record match the keys of the other records). If we draw lines between the matching symbols, we see a topology quite identical to that of the pseudo binary model. Thus if we ignore the specific technique for achieving linkages, the two models look quite alike.</em></dd>
      </dl>
      <p>
        On the other hand, the problem with pseudo-binaries is that they are potentially not conceptually scalable. Just think:
      </p>
      <ul>
        <li>
           for every N in N-ary, we require N binary relationships
        </li>
        <li>
           that implies N cardinality constraints, arguably dispersed
        </li>
        <li>
           and if these are bi-directional, you have to figure out how to handle updating both sides of the relationship.
        </li>
      </ul>
      <p>
        But note all of the above is mainly an implementation limitation of database management systems and/or object relational mapping frameworks today. The there are two practical alternatives to this "pseudo-binary tarpit":
      </p>
      <ul>
        <li>
           Forego modelling such data in an object model and to directly use SQL's declarative constraints, triggers, and procedures to maintain the integrity of such a structure.
        </li>
        <li>
           Build a general set-oriented relational integrity layer inside your domain model support framework or on top of your object database.
        </li>
      </ul>
      <p>
        Neither are completely satisfying solutions.
      </p>
      <p>
        For modelers, there's the <a href="HigherOrderEntityRelationshipModel.html">HigherOrderEntityRelationshipModel</a> (HERM). A discussion of it vs <a href="PseudoBinaryRelationships.html">PseudoBinaryRelationships</a> is here: <a href="http://www.informatik.tu-cottbus.de/~thalheim/HERM/hermdiscussion/.">http://www.informatik.tu-cottbus.de/~thalheim/HERM/hermdiscussion/.</a>
      </p>
      <hr/>
      <p>
        See also: <a href="MultiParadigmDatabase.html">MultiParadigmDatabase</a>
      </p>
    </div>
  </body>
</html>