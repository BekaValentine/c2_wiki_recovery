<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Recursive Descent
      </h1>
      <p>
        See <a href="RecursiveDescent.html">RecursiveDescent</a>.
      </p>
      <p>
        See <a href="AiKoans.html">AiKoans</a>
      </p>
      <p>
        One day a student came to the <a href="LispMaster.html">LispMaster</a> and said: "Please explain recursion to me, oh Master."  The master looked at him and and patiently told the student the following story: 
      </p>
      <p>
        "One day a student came to the <a href="LispMaster.html">LispMaster</a> and said: 'Please explain recursion to me'....." 
      </p>
      <hr/>
      <p>
        A top-down parsing technique in which each non-terminal is represented by a subroutine written to match symbols that make it up. For the grammar rule
      </p>
      <code>
        <term> ::= <factor> ('+' | '-') <factor><br/>
      </code>
      <p>
        one could write (in a very simplified fashion):
      </p>
      <code>
        Parse_Term() : Boolean begin<br/>
        var op:token;<br/>
        if Parse_Factor() then<br/>
        case Next_Symbol() of<br/>
        '+': op := ADDITION;<br/>
        '-': op := SUBTRACTION;<br/>
        default: ERROR;<br/>
        esac<br/>
        if Parse_Factor() then<br/>
        SUCCESS;<br/>
        end<br/>
      </code>
      <p>
        In effect, TheSourceCodeIsTheGrammar
      </p>
      <p>
        <em>Or the other way around use </em><a href="CodeGeneration.html">CodeGeneration</a> to derive the source code from the Grammar. A hand made <a href="RecursiveDescent.html">RecursiveDescent</a> (meta) parser could take the rule above as input and create the code as output. The benefit is once the metaparser is made it can generate <a href="RecursiveDescent.html">RecursiveDescent</a> parsers for as many languages as you can define rules for.<em></em>
      </p>
      <p>
        <a href="RecursiveDescent.html">RecursiveDescent</a> compilers work best in languages which require, at most, one symbol lookahead to resolve which construct is happening.
      </p>
      <p>
        Tools exist to automatically generate <a href="RecursiveDescent.html">RecursiveDescent</a> parsers, as well as ShiftReduce parsers.  Yacc and its derivatives (such as Bison) are the most well-known (basic Yacc generates ShiftReduce parsers only; bison can generate both).
      </p>
      <p>
        [ Lex generates scanners, YACC generates parsers.  While lex can be told to accept grammars that are mildly non-regular (via various hacks), Lex cannot be used to generate parsers for context-free grammars of any complexity.  Yacc (and its cousins such as Bison) doesn't generate top-down (recursive-descent) parsers, it generates bottom-up (shift/reduce) parsers--a different category of parser altogether, and one which (unlike recursive descent) is difficult to generate by hand.  Newer versions of Bison can generate recursive descent parsers. ]
      </p>
      <hr/>
      <p>
        See <a href="http://www.cs.uu.nl/~jeroen/article/parsers/parsers.ps">http://www.cs.uu.nl/~jeroen/article/parsers/parsers.ps</a> for an introduction to writing recursive descent parsers in a functional language. Heady stuff.
      </p>
    </div>
  </body>
</html>