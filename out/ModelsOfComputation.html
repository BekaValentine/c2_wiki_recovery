<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Models Of Computation
      </h1>
      <p>
        <a href="ModelsOfComputation.html">ModelsOfComputation</a> are abstract specifications of how a computation can progress, and they are often expressed as the description of some kind of conceptual automaton. <a href="ModelsOfComputation.html">ModelsOfComputation</a> are very distinct from <a href="DecompositionParadigms.html">DecompositionParadigms</a>, which are strategies for structuring <em>programs</em>, not the <em>computations</em> that executing those programs may occasion.
      </p>
      <p>
        The single most important theoretical aspect of a model of computation is its <em>power</em>, which is the class of (mathematical) functions it can compute. Another important pragmatic, qualitative, aspect is its <em>expressiveness</em>, which is related to the ease with which it is possible to express computations in it.
      </p>
      <p>
        A classic example of a model of computation is the Turing Machine model, which has great power even if its expressiveness is very limited, because of how awkward it is to express computations in it.
      </p>
      <p>
        From <a href="http://www.cs.umbc.edu/~squire/reference/computable.shtml">http://www.cs.umbc.edu/~squire/reference/computable.shtml</a>
      </p>
      <p>
        <strong>Church's hypothesis, </strong><a href="ChurchTuringThesis.html">ChurchTuringThesis</a><strong></strong>
      </p>
      <p>
        This is a mathematically unprovable belief that a reasonable intuitive definition of "computable" is equivalent to the list provably equivalent formal models of computation:
      </p>
      <ul>
        <li>
           <a href="TuringMachine.html">TuringMachine</a>s (specifically, Turing "A" machines)
        </li>
        <li>
           <a href="MarkovAlgorithm.html">MarkovAlgorithm</a>s
        </li>
        <li>
           stack automata with two stacks
        </li>
        <li>
           <a href="LambdaCalculus.html">LambdaCalculus</a> (and the related combinatorial calculi -- see <a href="EssAndKayCombinators.html">EssAndKayCombinators</a>)
        </li>
        <li>
           PostFormalSystems
        </li>
        <li>
           <a href="PartialRecursiveFunctions.html">PartialRecursiveFunctions</a>
        </li>
        <li>
           UnrestrictedGrammars (SemiThueGrammars, <a href="RewriteRules.html">RewriteRules</a>)
        </li>
        <li>
           <a href="RecursivelyEnumerable.html">RecursivelyEnumerable</a> languages
        </li>
        <li>
           State machine with a queue to store state, that is, a forward-only TM with looping tape and intuitively what is computable by a computer program written in any reasonable programming language.
        </li>
      </ul>
      <hr/>
      <p>
        For a contrary view suggesting that interactive computation models, such as <a href="ActorsModel.html">ActorsModel</a>, <a href="PiCalculus.html">PiCalculus</a>, <a href="CommunicatingSequentialProcesses.html">CommunicatingSequentialProcesses</a>, etc., are more powerful than Turing a-machines and the pure <a href="LambdaCalculus.html">LambdaCalculus</a>, see
        <a href="InteractiveComputationIsMorePowerfulThanNonInteractive.html">InteractiveComputationIsMorePowerfulThanNonInteractive</a>.
      </p>
      <p>
        [Much content moved there]
      </p>
      <hr/>
      <p>
        Even for sequential computation, a <a href="TuringMachine.html">TuringMachine</a> is considerably "lower-level" than the <a href="LambdaCalculus.html">LambdaCalculus</a>, which explains why there are programming languages based almost directly on the latter, but not the former.
      </p>
      <p>
        <em>With regards to expressiveness; nobody ever claims </em><a href="TuringMachine.html">TuringMachine</a>s are an expressive model. There isn't any modern useful high-level language which limits itself to "turing machine" features; even modern procedural languages - the lowest "level" type, arguable - borrow much from the <a href="LambdaCalculus.html">LambdaCalculus</a> (they have functions, etc.... even if they aren't full <a href="FunctionalProgrammingLanguage.html">FunctionalProgrammingLanguage</a>s). In fact, we have a rather derogatory term for languages whose chief selling point is that they are <a href="TuringComplete.html">TuringComplete</a> - we call them <a href="TuringTarpit.html">TuringTarpit</a>s. The raw <a href="LambdaCalculus.html">LambdaCalculus</a> isn't a particularly programmer-friendly model either (though some functional languages provide little more than a thin veneer on top of it.)<em></em>
      </p>
      <p>
        <em></em><a href="TuringMachine.html">TuringMachine</a>s are not useful as high-level programming models.<em></em>
      </p>
      <p>
        Right; that was all I was trying to say with the 'a <a href="TuringMachine.html">TuringMachine</a> is considerably "lower-level"' comment. Note that it is independent of the arguments about interaction and encapsulation given in <a href="InteractiveComputationIsMorePowerfulThanNonInteractive.html">InteractiveComputationIsMorePowerfulThanNonInteractive</a>, which deal with power, not expressiveness.
      </p>
      <p>
        <em>They are useful for two reasons: 1) they are easy to reason about mathematically; much research and knowledge in computational theory is based on the concept, and 2) virtually all computing hardware that is built resembles </em><a href="TuringMachine.html">TuringMachine</a>s. Building hardware that directly evaluates the <a href="LambdaCalculus.html">LambdaCalculus</a> isn't economical; it's more feasible to emulate such on a von-Neumann architecture (which, due to years of R&D and numerous economies of scale, are both fast and cheap these days).<em></em>
      </p>
      <p>
        Virtually all computing hardware that is built has considerable support for interactive computation, and that support does not resemble anything provided by a <a href="TuringMachine.html">TuringMachine</a>.
      </p>
      <p>
        <em>But discussing the "expressiveness" of a low-level computational model is a </em><a href="RedHerring.html">RedHerring</a> anyway. This is why programming languages exist; to provide reasonable abstractions on top of the models that are easier for humans to program and reason about. Speaking of the "expressiveness" of a low-level computational model misses the point completely; expressiveness is more important as a figure of merit of a language (or other tool used by programmers). And as all modern languages are Turing-equivalent, expressiveness has almost nothing to do with computational power.<em></em>
      </p>
      <p>
        <em>And keep in mind. Unless you have very esoteric hardware, any program you write is ultimately getting run on a </em><a href="TuringMachine.html">TuringMachine</a> - more specifically, a finite-memory approximation of one.<em></em>
      </p>
      <hr/>
      <p>
        And I seem to recall that ConcurrentSystemsTheory (maybe in <a href="RobinMilner.html">RobinMilner</a>'s <a href="PiCalculus.html">PiCalculus</a>) does not necessarily rely on any of the automata classes above, but generalizes them in the sense that everything/anything can happen at once.
      </p>
      <p>
        See also <a href="http://www.cs.brown.edu/people/mph/HerlihyRu00/focs.pdf">http://www.cs.brown.edu/people/mph/HerlihyRu00/focs.pdf</a>
      </p>
      <p>
        In the introduction, they say: "<em>Unlike sequential notions of computability, in which all reasonable models are essentially equivalent, concurrent computability is highly sensitive to the underlying model.</em>" and then go on building a hierarchy of models that can be built on top of others.
      </p>
      <p>
        The paper is based on an approach whose basis was laid in <a href="http://www.cs.brown.edu/people/mph/HerlihyS99/p858-herlihy.pdf">http://www.cs.brown.edu/people/mph/HerlihyS99/p858-herlihy.pdf</a> (which seems to be later than <a href="PiCalculus.html">PiCalculus</a>).
      </p>
      <hr/>
      <p>
        Note that <em>reasonable</em> here is related to how powerful a language is, not whether anyone can actually use it. Some commonly used languages are not in fact <a href="TuringComplete.html">TuringComplete</a>, and some <a href="TuringComplete.html">TuringComplete</a> languages are far from what any sane person would call "reasonable". See <a href="EsotericProgrammingLanguage.html">EsotericProgrammingLanguage</a>.
      </p>
      <hr/>
      <p>
        <a href="SlashDot.html">SlashDot</a> recently ran an article (<a href="http://developers.slashdot.org/article.pl?sid=03/06/18/127214)">http://developers.slashdot.org/article.pl?sid=03/06/18/127214)</a> about a book which describes several models of computation. See <a href="ConceptsTechniquesAndModelsOfComputerProgramming.html">ConceptsTechniquesAndModelsOfComputerProgramming</a>.
      </p>
      <p>
        Awesome book.
      </p>
      <ul>
        <li>
           <a href="TheOzBook.html">TheOzBook</a> primarily discusses programming paradigms (dataflow, OO, functional, logic, constraint-based, etc.) and not theoretical models of computation (<a href="TuringMachine.html">TuringMachine</a>s, <a href="LambdaCalculus.html">LambdaCalculus</a>). While it may touch on the <a href="ChurchTuringThesis.html">ChurchTuringThesis</a>; it is a minor topic. I highly recommend <a href="TheOzBook.html">TheOzBook</a>, but not for the topic discussed on this page.
        </li>
      </ul>
      <ul>
        <li>
           But dataflow is a model of computation, because it is about how things happen at runtime, not how programs are structured into parts.
        </li>
      </ul>
      <hr/>
      <p>
        Other models of computation, weaker than those given above, include (from weaker to stronger):
      </p>
      <ul>
        <li>
           <a href="FiniteAutomata.html">FiniteAutomata</a>
        </li>
        <li>
           Deterministic stack automata
        </li>
        <li>
           Non-deterministic stack automata
        </li>
      </ul>
      <p>
        Note that deterministic and nondeterministic <a href="TuringMachine.html">TuringMachine</a>s are equally powerful, and so are deterministic and nondeterministic <a href="FiniteAutomata.html">FiniteAutomata</a>. But nondeterministic stack automata are more powerful than deterministic ones.
      </p>
      <hr/>
      <p>
        I seem to remember from University that PrimitiveRecursionTheory is also one of the <a href="ModelsOfComputation.html">ModelsOfComputation</a>.
      </p>
      <p>
        Correct. Primitive recursion is recursion where the number of recursive calls is bounded a priori. Therefore, termination properties of primitive recursive functions are computable by a <a href="TuringMachine.html">TuringMachine</a>. However, there are things (such as AckermannsFunction) which can be computed by a <a href="TuringMachine.html">TuringMachine</a>, but not by PrimitiveRecursion (Ackermann's is recursive, but not <a href="PrimitiveRecursive.html">PrimitiveRecursive</a>). Primitive recursion is <em>less</em> powerful than a Turing machine.
      </p>
      <hr/>
      <p>
        Let us look at the models of computation that have been influential in the design of Programming languages: the most influential: the von-Neumann machine, a conventional CPU with only one register (called the accumulator) and load and store instructions. At most one memory cell changes during any one machine cycle, but machine cycles are fast.
      </p>
      <ul>
        <li>
           Except perhaps for assemblers I can't imagine any popular programming language that is based on a CPU/accumulator/load/store model of computation. Essentially all popular programming languages are based on the environment/references model of computation, and most are based on the contour model specialization of the environment model. Admittedly very few people seem to have ever heard of either. Compilers and virtual machines map the environment model and the contour model in terms of which (most popular) programming language computations are defined onto the (usually extended) Von Neumann model in terms of which mode hardware systems are defined.
          <ul>
            <li>
               <em>Once again, we are discussing models of abstract computation, not programming models. The Random Access Machine model (the formalism which underlies the Von Neumann architecture) is a way of expressing computation as an abstraction; its usefulness as a model for physical hardware is more or less coincidental. I doubt you'll find many </em>programming<em> languages based on Post Formal Systems as a computation model, but they too are thought to be equivalent to the UTM model. Programming languages are </em>not<em> mathematical formalisms - they are transformation systems for conveying concepts from an informal system (the thoughts of the programmer) into an </em>engineering<em> formalism (the machine code). It is useful to base programming languages on mathematical formalisms, but most programming languages historically have not been. -- </em><a href="JayOsako.html">JayOsako</a><em></em>
              <ul>
                <li>
                   It is possible to interpret programming languages as models of computation; it's not a guiding principle in designing the language (unless it's a proof-of-concept exercise), but beyond the obvious fact that the syntax of a programming language is necessarily a formal language there's the usable interpretation that a programming language together with its semantics (constraints that aren't expressed explicitly but would get trapped by a compiler) as a model of computation. In this interpretation, a program becomes a proof that a certain computation is possible in the given model. (The fun begins when you have a proof but it's for the wrong theorem.)
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <p>
        The second most influential model of computation underlying programming languages is the one where state is sequestered in objects. If you consider a variable as "in reality" a simple object that responds to get and set messages, you are definitely using the <a href="ObjectOriented.html">ObjectOriented</a> model (or the <a href="ActorsModel.html">ActorsModel</a>).
      </p>
      <ul>
        <li>
           The <a href="ObjectOriented.html">ObjectOriented</a> style is a decomposition paradigm, and not a model of computation. Languages like C++, Java, or SIMULA are definitely OO, but certainly their model of computation is not the <a href="ActorsModel.html">ActorsModel</a> whose main characteristic is not having shared state.
        </li>
      </ul>
      <p>
        The third most influential model is the lambda calculus, the conceptual foundation of <a href="FunctionalProgramming.html">FunctionalProgramming</a>. Fourth most influential has been the PredicateCalculus, aka, predicate logic. Expressions in predicate calculus are closer to <a href="NaturalLanguage.html">NaturalLanguage</a> than expressions in the other models are, which is an advantage, but IMO we do not yet know how to implement PLs based on the PredicateCalculus model well.
      </p>
      <hr/>
      <p>
        See also: <a href="ModelsOfComputationAndFormalLanguages.html">ModelsOfComputationAndFormalLanguages</a>, <a href="PrincipleOfLeastPower.html">PrincipleOfLeastPower</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryModels.html">CategoryModels</a>
      </p>
    </div>
  </body>
</html>