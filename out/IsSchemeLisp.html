<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Is Scheme Lisp
      </h1>
      <p>
        One of the interesting debates in Lisp circles is the question of whether or not <a href="SchemeLanguage.html">SchemeLanguage</a> should be considered part of the <a href="LispLanguage.html">LispLanguage</a> family. There are more than a few Lispers (and perhaps a few schemers) who think that the <a href="LispSchemeDifferences.html">LispSchemeDifferences</a> are sufficiently large that Scheme should <em>not</em> be considered to be a "Lisp". This topic has spread across many pages, so this page has been created to quarantine this particular <a href="HolyWar.html">HolyWar</a>.
      </p>
      <p>
        The <a href="LispSchemeDifferences.html">LispSchemeDifferences</a> page should be limited to discussion of observable differences between Lisp (particularly <a href="CommonLisp.html">CommonLisp</a>) and <a href="SchemeLanguage.html">SchemeLanguage</a>; not commentary on the topic of <a href="IsSchemeLisp.html">IsSchemeLisp</a> or not.
      </p>
      <p>
        Naturally, this topic gets at the heart of WhatIsaLisp--what does it mean, precisely, to be part of the Lisp family of languages.
      </p>
      <p>
        Note that the fact that <a href="CommonLisp.html">CommonLisp</a> (and other Lisp dialects) is a different <em>language</em> than <a href="SchemeLanguage.html">SchemeLanguage</a> should be beyond dispute--non-trivial Scheme programs won't run on <a href="CommonLisp.html">CommonLisp</a> implementations and vice-versa. And the differences between the two languages in many cases are fundamental - neither language can be turned into the other with clever macros or other application of <a href="SyntacticSugar.html">SyntacticSugar</a>.
      </p>
      <hr/>
      <p>
        <strong>Arguments why Scheme is a Lisp (should be considered part of the Lisp family)</strong>
      </p>
      <ul>
        <li>
           Both are dynamically-typed, strict <a href="FunctionalProgrammingLanguage.html">FunctionalProgrammingLanguage</a>s (more or less--both languages readily allow SideEffects) with markedly similar syntax (<a href="EssExpressions.html">EssExpressions</a>, similar special forms/keywords)
        </li>
      </ul>
      <ul>
        <li>
           Both uses lists (chains of <a href="ConsCell.html">ConsCell</a>s) as a fundamental data structure; much of the programming culture of both languages derives from this. (Both languages support more complex data structures as well).
        </li>
      </ul>
      <ul>
        <li>
           <a href="SchemeLanguage.html">SchemeLanguage</a> is based in part on early Lisps, in part on <a href="AlgolLanguage.html">AlgolLanguage</a>. <a href="CommonLisp.html">CommonLisp</a>, in turn, is based on many early Lisps (<a href="MacLisp.html">MacLisp</a>, <a href="InterLisp.html">InterLisp</a>, etc.)...and <a href="SchemeLanguage.html">SchemeLanguage</a>.
        </li>
      </ul>
      <ul>
        <li>
           Many idioms are similar (if not identical) between the two languages.
        </li>
      </ul>
      <ul>
        <li>
           If you learn one, learning the other is simple.
        </li>
      </ul>
      <p>
        <strong>Arguments why Scheme is not a Lisp</strong>
      </p>
      <p>
        Note that this section does not (necessarily) argue that <a href="SchemeLanguage.html">SchemeLanguage</a> is bad or inferior (or superior for that matter), just that it's different enough from other Lisps that it should be considered a wholly separate language (though specific arguments may advance such claims.)
      </p>
      <ul>
        <li>
           The technical <a href="LispSchemeDifferences.html">LispSchemeDifferences</a> are sufficiently large that the two languages cannot be considered parts of the same family (to say so is tantamount to saying that C++ and Java are part of the same "family"--extended family, perhaps).
        </li>
      </ul>
      <ul>
        <li>
           The purpose of <a href="CommonLisp.html">CommonLisp</a> is to <em>unite</em> the Lisp community; portions of <a href="SchemeLanguage.html">SchemeLanguage</a> went into the formulation of <a href="CommonLisp.html">CommonLisp</a>. Now that <a href="CommonLisp.html">CommonLisp</a> exists (and has existed for many years), continued use of any other Lisp dialect, other than in research or in legacy applications (such as use of <a href="EmacsLisp.html">EmacsLisp</a> in <a href="EmacsEditor.html">EmacsEditor</a>), undermines that unity and fractures the community. In other words, <a href="CommonLisp.html">CommonLisp</a> ought to subsume further development on other Lisp dialects--including Scheme. Nobody uses <a href="MacLisp.html">MacLisp</a> any more for production code; nobody should use Scheme anymore either. If the Scheme community wishes to develop separately from the Lisp community and continue to be an actively-supported production language, they should do so without enjoying the benefits of association with Lisp, as they aren't contributing anymore.  In other words, this argument is saying that "Lisp" is exactly "Common Lisp", anything else is excluded.  (And since Common Lisp is unlikely to evolve in any substantial way, this means that Lisp is forever frozen at what CL is now.)
          <ul>
            <li>
               The above might be the most fascist statement I have read on this wiki. --<a href="RobMandeville.html">RobMandeville</a>.
            </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
           Conversely, <a href="SchemeLanguage.html">SchemeLanguage</a> is a better language foundation going forward--it's a cleaner, more orthogonal design, spared from the need to be compatible with now-archaic early dialects of <a href="LispLanguage.html">LispLanguage</a>.
        </li>
      </ul>
      <ul>
        <li>
           The philosophies of the Lisp and Scheme communities have diverged quite a bit. <a href="SchemeLanguage.html">SchemeLanguage</a> focuses much more on <a href="FunctionalProgramming.html">FunctionalProgramming</a>; <a href="CommonLisp.html">CommonLisp</a> on metaprogramming and multi-paradigm programming (especially OO with <a href="CommonLispObjectSystem.html">CommonLispObjectSystem</a>).
        </li>
      </ul>
      <ul>
        <li>
           The confusion between the two is mainly in the minds of laypersons, who think Lisp/Scheme is all about application of functions on lists, and little else.
        </li>
      </ul>
      <p>
        <strong>Arguments why it doesn't matter</strong>
      </p>
      <ul>
        <li>
           The whole <a href="IsSchemeLisp.html">IsSchemeLisp</a> argument is a pointless distraction, an unfortunate <a href="HolyWar.html">HolyWar</a> waged by a small set of tool-worshippers, and a silly spat over who has "rights" to a coveted and desirable brand name. (Much like the debate over the <a href="DefinitionsForOo.html">DefinitionsForOo</a>). Both <a href="CommonLisp.html">CommonLisp</a> and <a href="SchemeLanguage.html">SchemeLanguage</a> are excellent languages, insistence that one is deserving of the name "lisp" and the other is not (or insistence that both have equal rights to be called "lisp") is childish behavior.
        </li>
      </ul>
      <ul>
        <li>
           It doesn't matter because having two high-quality, production-grade descendents of <a href="LispLanguage.html">LispLanguage</a> is <em>better</em> than having only one. There are problems more easily solved in <a href="CommonLisp.html">CommonLisp</a> than in <a href="SchemeLanguage.html">SchemeLanguage</a> and vice versa; the benefits of choice far outweigh the disadvantages of redundant/wasted development work on two incompatible platforms, and the associated splitting of mind and market share.
        </li>
      </ul>
      <hr/>
      <p>
        <strong>Discussion</strong>
      </p>
      <hr/>
      <p>
        <strong></strong><a href="ThreadMess.html">ThreadMess</a> moved from elsewhere<strong></strong>
      </p>
      <p>
        [moved from <a href="LispSchemeDifferences.html">LispSchemeDifferences</a>]
      </p>
      <p>
        <em></em><a href="SchemeLanguage.html">SchemeLanguage</a> and <a href="CommonLisp.html">CommonLisp</a> (CL) are about as similar as Java and C++.<em></em>
      </p>
      <p>
        I would argue that Scheme and CL are <em>further apart</em> than Java and C++. Not on the language level per se, but by the "psychological distance" of their user communities (if you see what I mean). I think most Java and C++ programmers could switch languages without much trauma, which is not true of lispers and schemers. This is competently exposed in <a href="ParentheticallySpeaking.html">ParentheticallySpeaking</a>. -- <a href="AlainPicard.html">AlainPicard</a>
      </p>
      <p>
        <em>I am a Common Lisp programmer and I switch between both languages easily. And I like to use Scheme, too. The differences are overrated. The distance of the user communities are mostly in the heads of a few people.</em>
      </p>
      <p>
        A certain subset of the older <a href="CommonLisp.html">CommonLisp</a> community goes absolutely BatshIt anytime someone so much as mentions Scheme, and tries to claim that the languages have nothing to do with each other based on strained sociological arguments. Sadly, this includes some prominent people. The reverse does not seem to be the case. -- <a href="AnonymousDonor.html">AnonymousDonor</a>
      </p>
      <p>
        The difference is: schemers effectively act like a community. The Common Lisp community has a bad track record on sharing stuff. Many great softwares done in CL just disappeared into oblivion. That's why you have a bunch of wonderful useful stuff on Scheme (GUI toolkits, top-class profilers like in Bigloo, web stuff, etc) that you only get in proprietary Common Lisp environments (and the unexplainable fact that you still don't have that stuff in the <a href="FreeSoftware.html">FreeSoftware</a> Common Lisp implementations). I guess this explains the much smaller mindshare Common Lisp has wrt to Perl (and Python, and Java, and C++, and...).
      </p>
      <p>
        <em>So what? I can switch between C++ and Bourne Shell programming easily.</em>
      </p>
      <p>
        "So what? I write the same style in Scheme and Common Lisp. Easily. Without bending my mind. Good luck with C++ and bsh."
      </p>
      <p>
        If you write the same style in Scheme and CL, you are abusing both of them. Regarding C++ and bsh: you'd be surprised. ;)
      </p>
      <p>
        "I'm not abusing them. I like to use a heavy functional programming style. That's nicely supported by both languages."
      </p>
      <p>
        I agree with Alain in that I think Scheme and CL are on opposite ends of the scale when it comes to abstract similarity. I tend to compare Scheme to C and CL to Java, which has its own set of problems, but seems more correct to my mind. However, I disagree with the notion that switching between Scheme and CL is hard. I use both Scheme and CL and like them both as Lisps. They have different areas of applicability and particular traits that are unique from one another, but I find this only enhances my appreciation of each. Indeed, in many cases, I write Scheme and CL code together in a given application for different tasks and abstractions. -- <a href="DanMoniz.html">DanMoniz</a>
      </p>
      <p>
        <em>Further, I get the impression that most Schemers could use </em><a href="CommonLisp.html">CommonLisp</a> with no problem, but that a lot of common lispers have trouble with Scheme. Thus, I'm banging my head on scheme to I learn it well before I go back to CL, but maybe I'm just being excessive here.<em></em>
      </p>
      <p>
        That's because Lisp is more forgiving; the Scheme design is to disallow things for no good reason other than just to be a bitch to the user. Like accessing the nonexistent portions of an empty list gives good defaults (FIRST NIL) -> NIL, etc. So the Scheme programmer can write a naive program in Lisp which will just work, but if he had written it in Scheme, she would have to go back and debug all those cases where empty lists are not dealt with properly, list is used as a variable name instead of lst, etc. On the other hand, she will probably have to add a liberal sprinkling of funcalls to get her code working. ;)
      </p>
      <p>
        [Well, most Schemers can use CL to write Scheme code. Schemers who can write CL code that looks like CL, rather than Scheme, are the rarest of creatures. On the other hand, I suspect most CLers can write Scheme indistinguishable from a Schemer's Scheme]
      </p>
      <p>
        Once you start thinking in tail recursion, going to CL can be a *real*
        pain. On the other hand, CL-ers going to Scheme can still use
        `do'.
      </p>
      <p>
        <em>But CL-ers want to use LOOP and all of the other advanced CL idioms</em>
      </p>
      <p>
        Besides which, Scheme's `do' and CL's `do' really aren't the same. Scheme's is really recursion, not iteration - try capturing closures over some loop variable for several "iterations" and looking at the values afterwards.
      </p>
      <p>
        <em>The difference you observe is correct. However, it is not really a result of iteration vs. recursion, since a Scheme version of CL's do can easily be written, as follows. Observe that this version explicitly uses (tail) recursion to perform the iteration.</em>
      </p>
      <code>
        (define-syntax parallel-set! (syntax-rules ()<br/>
        ((_) (if #f #f))<br/>
        ((_ (var value) rest ...)<br/>
        (let ((temp value))<br/>
        (parallel-set! rest ...)<br/>
        (set! var temp)))))<br/>
      </code>
      <code>
        (define-syntax cl-do (syntax-rules ()<br/>
        ((_ ((var init update) ...) <br/>
        (stop-condition final ...)<br/>
        body ...)<br/>
        (let ((var init) ...)<br/>
        (let loop ()<br/>
        (begin body ...)<br/>
        (if (not stop-condition)<br/>
        (begin<br/>
        (parallel-set! (var update) ...)<br/>
        (loop))))<br/>
        final ...))))<br/>
      </code>
      <hr/>
      <p>
        [moved from <a href="WhatIsNull.html">WhatIsNull</a>]
      </p>
      <p>
        This (suggestion that the different meanings of "null" ought to be broken up into different values) is a strange position to take, given that the Lisp community has happily, and without any problems whatsoever, been punning on the multiple meanings of NIL for forty years. Perhaps the real problem lies elsewhere? -- <a href="AlainPicard.html">AlainPicard</a>
      </p>
      <p>
        <em>It bugged enough Lispers that </em><a href="SchemeLanguage.html">SchemeLanguage</a> finally completely split the boolean concept and list concept. Then there's the oddity of <a href="CommonLisp.html">CommonLisp</a> GETHASH, which has to return two values to tell apart "NIL-as-undefined" from any other use of NIL. Overloading NIL seems to indicate an inadequate type system.<em></em>
      </p>
      <p>
        This is the standard disingenuous position of a schemer, who wants to be associated with the <em>lisp</em> label, but then wants to also be able to condemn it. Lisp and scheme may have historical ancestry, but they are <em>not the same language</em>. To wit: Lispers are (still) very happy punning on NIL, Schemers think that's ugly. In other words, the <em>it bugged enough lispers...</em> means it bugged those people who didn't <em>want</em> to be lispers. Fine. So they created their own language. Fine. How does this affect how <em>lispers</em> see NIL? (Hint: it doesn't.) -- <a href="AlainPicard.html">AlainPicard</a>
      </p>
      <p>
        Not only that, GETHASH returning two values is not an example of punning NIL so much as it is an example of returning false instead of throwing an exception.  Most Schemes I've seen choose the latter, but if they didn't, they would be forced to return two values just like CL.  It'd be the only way for #f to be both a return value and a valid atom for storing in a hash table.  You might argue that not raising an exception is ugly and impure, but that's a whole other story that has nothing to do with an "inadequate type system" or punning NIL as false and empty list.  -- A anonymous schemer.
      </p>
      <hr/>
      <p>
        [moved from <a href="SocialProblemsOfLisp.html">SocialProblemsOfLisp</a>]
      </p>
      <p>
        Re "I think Lisp suffers from.... eternal confusion with the Scheme community (as demonstrated, yet again, on this page). Lisp, in real life, has very little to do with Scheme. Much less than, say, Java has to do with C. To outsiders, both languages look the same (lots of parens) but the goals of the communities are almost completely at odds." (from <a href="AlainPicard.html">AlainPicard</a>):
      </p>
      <p>
        I think the Scheme/Lisp dichotomy is one of the social problems of Lisp. Saying that Scheme has less to do with Lisp than Java with C strikes me as a bit preposterous. Interesting stuff is happening in the Scheme world that doesn't get into the Common Lisp world (module systems and hygenic macros are two good examples). There seems to be a violent reaction against Scheme from some members of the Lisp community; I haven't observed the reverse in the Scheme community. -- <a href="NoelWelsh.html">NoelWelsh</a>
      </p>
      <p>
        Although there's quite likely some interesting stuff happening in Scheme that a Common Lisp-like language might benefit from, I think you may be missing the essential point that Alain is making - or at least that I believe he's making: it's not about the <em>languages</em> as much as it is the <em>communities</em>. Yer average CL programmer has a package system which is usable with a bit of care, two namespaces which largely does away with the need for hygenic macros, and is more likely to want to get on with writing an application program using Common Lisp than he is to take the entire language implementation apart again for an incremental gain which is unlikely to outweigh the cost of rewriting all his previous applications. The average Scheme programmer is (my impression only) far more likely to be interested in incompatible development of the language itself - because after all, it's probably not incompatible with the core standard Scheme itself, just with whatever his favourite implementations previously did. There is a big gap for a community somewhere that could be playing with new language features for "big" Lisps, but 
        welding together the existing Scheme and CL communities is not going to produce it. They have different priorities.
      </p>
      <p>
        Personally, I think that "disdain for easy problems" is a much bigger issue for CL: CLiki is all <em>about</em> code that solves the easy problems. After all, just because you can build and manage an entire country's rail system in a quarter the time in Common Lisp doesn't mean you <em>have</em> to start by inventing the wheel every single time.
      </p>
      <p>
        On the other hand, as a contributor to and original author of the <a href="CommonLispWiki.html">CommonLispWiki</a> referred to above, I am not only clearly too obnoxious to contribute to this debate, but also too thick-skinned to realize it. So, YMMV -- <a href="DanBarlow.html">DanBarlow</a>
      </p>
      <p>
        See <a href="LispSchemeDifferences.html">LispSchemeDifferences</a>.
      </p>
      <hr/>
      <p>
        [moved from <a href="LispLanguage.html">LispLanguage</a>]
      </p>
      <p>
        The notion of <a href="LanguageFamilies.html">LanguageFamilies</a> and especially of such a thing as the <a href="LispFamily.html">LispFamily</a> of tools may be tricky for beginners at best, and perhaps useless to mainstream discourse.
      </p>
      <p>
        Take for example the <a href="IsSchemeLisp.html">IsSchemeLisp</a> question which sometimes generates too many boring, useless words. In many general discussions on Lisp, it is trivial to find people tripped up believing <a href="CommonLisp.html">CommonLisp</a> is only about lists and <a href="FunctionalProgramming.html">FunctionalProgramming</a>, without macros. Because Scheme is always taught that way, which they learn in school. But without macros, <a href="CommonLisp.html">CommonLisp</a> increasingly becomes a silly language with way too many (((parentheses))). So clearly, we encounter evidence of unfortunate misunderstandings generated by this taxonomy.
      </p>
      <p>
        Of course, people should create taxonomies which suit their particular situations, so mindlessly going the other extreme (Scheme can never be a Lisp) is certainly an authoritarian overreaction.
      </p>
      <p>
        To some extent, the anti-scientific worldview of computer "science" (<a href="ComputerScienceIsaSoftScience.html">ComputerScienceIsaSoftScience</a>) can be blamed. People are encouraged to make hazy (and lazy) handwavings, they don't check their sources, and come down hard on one side or the other like pro wrestling. Just for the sake of some tool. So flamewar circuses result, and thoughtfulness is punished.
      </p>
      <hr/>
      <p>
        Scheme and Lisp are like two biological populations that are in the midst of the evolutionary process of speciation.  Whether "total speciation" has occurred is debatable, but I think in making that determination, one must look at the languages themselves and not the intentions or goals or even opinions of the communities WRT each other (us versus them). As trivial as this may seem, I think that one of the big psychological reasons that people feel justified in saying that Scheme is not a Lisp is that it was named "Scheme" and not "SchemeLisp".  Somehow that naming distinction seems to make it possible for CommonLispers to deny Scheme's place as a Lisp dialect despite its obvious similarities, its historical legacy, and the aspects of each other that each has taken for itself.  It's the latter that suggests that the two have not completely "speciated" (to continue extending that metaphor), because in a sense they are still exchanging genes. -- MikeStone
      </p>
      <hr/>
      <p>
        Asking the question , to me, at least, is a bit silly:  we just need to look at definitions.  Paul Graham wrote an essay (I can't remember its title) where he lists eight or nine core elements of the LISP ideal, and then points out that, once a language has all these elements, it is a LISP.  It doesn't matter what people call the lanuguage, or what the commiunity's goals are, or even what the origin of the language is!  Python, for example, has six or seven elements, and once it obtains the last couple, it will be just as much a LISP as Common Lisp, or Scheme, or <a href="MacLisp.html">MacLisp</a>, or Dylan, or even LISP 1.5.  Of course, since one of the requirements is macros, and Python's syntax tree is a pain to use, Python almost certainly won't become a LISP (and even if it did, it will likely be like Dylan, where macros are so darn difficult to use, they are used rarely)...but that is irrelevant to the definition!  --Alpheus
      </p>
    </div>
  </body>
</html>