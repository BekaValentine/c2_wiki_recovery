<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Enterprise Application Construction Set
      </h1>
      <p>
        A system is built with the purpose of building other systems to solve business problems.
      </p>
      <p>
        It is constructed in such a way to make strong assumptions on data persistence, UI design/layout, object model/entity relationship, and technology used. Instead of using a real object model to represent domain concepts, everything is stored as generic meta data, pushing what would be compile time bugs into difficult to debug runtime bugs. 
      </p>
      <p>
        In the end, it may be easy to do the things it was specifically designed to do, but when a unique business problem presents itself, it's hard to adapt this rigid framework to solve this task, requiring the engineer to 'hack' around the system to achieve the goal.
      </p>
      <p>
        Often this approach falls into the easy trap of "I'd rather build / re-create technology instead of focusing on the business requirements".
      </p>
      <hr/>
      <p>
        I agree with the spirit of this <a href="AntiPattern.html">AntiPattern</a>. However, I detect a slippery slope in the second paragraph and I think that some of the argument is self-contradictory. If you know the requirements beforehand and can construct a framework that makes satisfying them easy, then by all means do so. Don't throw away a good solution because it doesn't solve every problem. There will always be new problems because the number of cheeseburgers in the universe is increasing.
      </p>
      <p>
        <em>Maybe I'm being obtuse, but what's the connection with cheeseburgers?</em>
      </p>
      <hr/>
      <p>
        Is this also potentially an example of <a href="AbstractionInversion.html">AbstractionInversion</a>, in the sense that authors of the <a href="EnterpriseApplicationConstructionSet.html">EnterpriseApplicationConstructionSet</a> are trying to create something generic to solve very specific (business-oriented) problems? Or is this simply a case of <a href="PrematureGeneralization.html">PrematureGeneralization</a>?
      </p>
      <hr/>
      <p>
        In the age of autogenerated code and strong reflection, it is not strictly correct to suppose that this pattern automatically causes compile time bugs to become runtime bugs.  If the system partially or fully leverages generators, then there is every reason to believe static analysis tools can verify some or all of the generated system's components.
      </p>
      <hr/>
      <p>
        See also: <a href="KitsAsCompromiseToBuyOrBuild.html">KitsAsCompromiseToBuyOrBuild</a>
      </p>
    </div>
  </body>
</html>