<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Slate Language
      </h1>
      <p>
        <a href="http://slate.tunes.org/">http://slate.tunes.org/</a>
      </p>
      <p>
        <a href="http://slate.tunes.org/wiki">http://slate.tunes.org/wiki</a>
      </p>
      <p>
        Derived from <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> and <a href="SelfLanguage.html">SelfLanguage</a>, borrows ideas from <a href="CommonLispObjectSystem.html">CommonLispObjectSystem</a>.  A couple of its big features are <a href="PrototypeBased.html">PrototypeBased</a> <a href="MultipleDispatch.html">MultipleDispatch</a> (a trait it shares with <a href="CecilLanguage.html">CecilLanguage</a>), MacroMessageSends, SubjectiveDispatch and <a href="SoftTyping.html">SoftTyping</a>.
      </p>
      <hr/>
      <p>
        It's still in a very early stage, but already it shows a lot of promise, and if you're a language geek like me, I highly recommend downloading the latest tarball, reading through the docs and source, and lurking on the #slate channel on <a href="FreeNode.html">FreeNode</a>. -- <a href="TimMoore.html">TimMoore</a>
      </p>
      <hr/>
      <p>
        I like it just for the slogan:  "Less talk, more rock."  --<a href="NickBensema.html">NickBensema</a>
      </p>
      <hr/>
      <p>
        Anyone have details on how lookup is done?
      </p>
      <p>
        <em>That's described in </em>LeeSalzman's thesis: <a href="http://tunes.org/~eihrul/pmd.pdf''">http://tunes.org/~eihrul/pmd.pdf''</a>
      </p>
      <p>
        The semantics guide is pretty skimpy. And what about that other good stuff like keyword parameter passing?
      </p>
      <p>
        <em>Smalltalk-style syntax is already very similar to </em><a href="KeywordParameterPassing.html">KeywordParameterPassing</a>, even though the order of parameters is fixed. See "Keyword Messages" at <a href="http://slate.tunes.org/syntax.html">http://slate.tunes.org/syntax.html</a> .<em></em>
      </p>
      <p>
        And does Slate implement a proper message eating Nil, or Smalltalk's exception throwing Nil?
      </p>
      <p>
        <em>See comments at </em><a href="NullIsBenign.html">NullIsBenign</a> for why a "message eating Nil" would be a bad idea.<em></em>
      </p>
      <hr/>
      <p>
        I find it very interesting that Slate's method definitions look quite a bit like <a href="HaskellLanguage.html">HaskellLanguage</a>'s pattern-matching function definitions. Are object-oriented and functional programming converging? Could they by chance be <em>equivalent</em> when developed to the extreme? I already find it very interesting that <a href="SmalltalkLanguage.html">SmalltalkLanguage</a> and <a href="LispLanguage.html">LispLanguage</a> use a lot of the same idioms (using closures as <em>the</em> element of structure). -- MatthiasBenkard
      </p>
      <p>
        I have found that object-oriented code that uses <a href="TellDontAsk.html">TellDontAsk</a> and ImmutableValueObjects is not very different in style from <a href="PurelyFunctional.html">PurelyFunctional</a> code using monads.  The OO code calculates values functionally, because the value objects are immutable, and then pushes calculated values out to other objects through polymorphic interfaces.  The monadic functional code calculates values functionally and then pushes calculated values to other monadic computations through lambda abstractions which are therefore polymorphic.
      </p>
      <p>
        Both functional and OO advocates a few common architectural good practices:
      </p>
      <ul>
        <li>
           Separating stateful computation from stateless calculation
        </li>
        <li>
           Encapsulating stateless calculations inside stateful computational components
        </li>
        <li>
           Making stateful computations communicate through polymorphic connections 
        </li>
        <li>
           Minimising the amount of stateful computation
        </li>
      </ul>
      <p>
        --<a href="NatPryce.html">NatPryce</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryProgrammingLanguage.html">CategoryProgrammingLanguage</a>
      </p>
    </div>
  </body>
</html>