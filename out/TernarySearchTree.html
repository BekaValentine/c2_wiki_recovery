<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Ternary Search Tree
      </h1>
      <p>
        At first glance, a <a href="TernarySearchTree.html">TernarySearchTree</a> may not seem to gain much over a Binary Search Tree [<a href="BinaryTree.html">BinaryTree</a>]:  it just seems to use more space and algorithmic complexity.  In the BST you just stick at the current node if the n'th character matched, although you can't advance <em>n</em> right away when you go left/right.  Likewise, it may seem to simply be a <a href="StringTrie.html">StringTrie</a> where the data structure to look up individual letters is a <a href="BinaryTree.html">BinaryTree</a>, rather than an array.
      </p>
      <p>
        In a TST, each comparison is much simpler than in a BST, and more complex than in a naive <a href="StringTrie.html">StringTrie</a>.  Each node requires only a constant amount of storage (one character, for a TST containing strings of characters), and that comparison is a constant-time operation (in most cases, a single op).  The recursion is truly trivial.  Compare this to a binary search tree, where you may have to compare multiple characters at any node, each node must contain an entire string, etc. Think of it this way: a BST containing the set { "foo", "bar", "foobar" } must contain those three strings, as such (standard sorting, given insertion order):
      </p>
      <code>
        foo<br/>
        /   \  <br/>
        bar   foobar<br/>
      </code>
      <p>
        The corresponding TST (which is, less sensitive to insertion order) is (with $ as the end-of-string character, less than any other character):
      </p>
      <code>
        f<br/>
        /|<br/>
        b o<br/>
        | |<br/>
        a o         // This comment is here because<br/>
        | |\       //  trailing backslashes<br/>
        r $ b     //   can confuse wiki.<br/>
        |   |<br/>
        $   a<br/>
        |<br/>
        r<br/>
        |<br/>
        $<br/>
      </code>
      <p>
        Many more nodes, but
      </p>
      <ul>
        <li>
           the nodes are much simpler,
        </li>
        <li>
           the comparisons are much simpler,
        </li>
        <li>
           redundant prefixes are automatically eliminated,
        </li>
        <li>
           no double-dereferences are necessary.
        </li>
      </ul>
      <p>
        For tree-based sets, you have three common options.  The two most often considered are the Binary Search Tree and <a href="StringTrie.html">StringTrie</a>s (the type of thing where to find strings of alphabetic characters, you start at a root node representing the string of length zero, which has 26 children, which all have 26 children, which...). They have different space and time properties of course, and there are places where each belongs. The TST is a good tradeoff, often offering better performance than the BST on certain data sets, without the ballooning storage space of a full trie. 
      </p>
      <p>
        TSTs broadly offer better performance than a BST, and takes up less space that a Trie. One can refer to that as an average. Or one can refer to it as a solution to two problems with the BST and the <a href="StringTrie.html">StringTrie</a>.
      </p>
      <p>
        References:
      </p>
      <ul>
        <li>
           <a href="http://www.codeproject.com/cs/algorithms/tst.asp">http://www.codeproject.com/cs/algorithms/tst.asp</a>
          <ul>
            <li>
               A reasonably good paper on TSTs, with quite good example code in <a href="CeeSharp.html">CeeSharp</a>.
            </li>
          </ul>
        </li>
        <li>
           <a href="http://www.octavian.org/cs/software.html">http://www.octavian.org/cs/software.html</a>
          <ul>
            <li>
               A great example of ternary search tries written in <a href="CeeLanguage.html">CeeLanguage</a>
            </li>
          </ul>
        </li>
        <li>
           <a href="http://www.javaworld.com/javaworld/jw-02-2001/jw-0216-ternary.html">http://www.javaworld.com/javaworld/jw-02-2001/jw-0216-ternary.html</a>
          <ul>
            <li>
               Nice diagrams in this article.
            </li>
          </ul>
        </li>
        <li>
           <a href="http://citeseer.ist.psu.edu/bentley97fast.html">http://citeseer.ist.psu.edu/bentley97fast.html</a>
          <ul>
            <li>
               "Fast Algorithms for Sorting and Searching Strings" by Bentley & Sedgewick (1997).
            </li>
          </ul>
        </li>
      </ul>
      <p>
        Contributors: <a href="AdamBerger.html">AdamBerger</a>, <a href="GuyMurphy.html">GuyMurphy</a>, <a href="KarlKnechtel.html">KarlKnechtel</a>, <a href="WilliamUnderwood.html">WilliamUnderwood</a>, and others
      </p>
      <hr/>
      <p>
        <a href="CategoryDataStructure.html">CategoryDataStructure</a>
      </p>
    </div>
  </body>
</html>