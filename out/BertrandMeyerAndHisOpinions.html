<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Bertrand Meyer And His Opinions
      </h1>
      <p>
        <a href="BertrandMeyer.html">BertrandMeyer</a> is noted for his strong opinions...
      </p>
      <hr/>
      <p>
        <strong>C/C++ Programmers</strong>
      </p>
      <p>
        See the discussion of Meyer's article <a href="BewareOfCeeHackers.html">BewareOfCeeHackers</a> ("But in general you should be cautious about including C hackers in your projects").
      </p>
      <hr/>
      <p>
        <strong>C++ language</strong>
      </p>
      <p>
        Meyers thinks that it is utterly broken, since it messes up <a href="MultipleInheritance.html">MultipleInheritance</a>, it does not have automatic <a href="GarbageCollection.html">GarbageCollection</a>, it does not have ConstrainedGenericity, it uses type casts, it uses overloading.
        He also think <a href="CeePlusPlus.html">CeePlusPlus</a> goes against a basic methodological principle by providing lots of features together with "Never Do This" suggestions.
      </p>
      <p>
        <em>Can he provide a language that stretches so far, from super-tight compilation to a wide range of flexible expressions?</em> --<a href="PhlIp.html">PhlIp</a>
      </p>
      <hr/>
      <p>
        <strong>Multiple Inheritance</strong>
      </p>
      <p>
        Meyer always sustained that <a href="SingleInheritance.html">SingleInheritance</a> is dumb, for example:
        "<em>The absence of multiple inheritance in Java precludes using many of the most useful patterns of object-oriented development, which combine several abstractions into a new one</em>".
      </p>
      <hr/>
      <p>
        <strong>"Never Do This" suggestions</strong>
        Meyer goes at great lengths in <a href="ObjectOrientedSoftwareConstruction.html">ObjectOrientedSoftwareConstruction</a> to highlight why approaches like "you should never use this feature of the language/tool" are wrong. 
        The basic idea is that you should either
      </p>
      <ul>
        <li>
           make this hint part of the language/tool
        </li>
        <li>
           remove the features
        </li>
        <li>
           use another tool
        </li>
      </ul>
      <p>
        Examples of this may include C/C++ type casts, complex hierarchies in environments with <a href="MultipleInheritance.html">MultipleInheritance</a> without clean disambiguation, or without a good method lookup algorithm, eval-like functionalities, case sensitivity (since it allows <em>Foo</em> and <em>foo</em> to be different but this is considered bad), <a href="GoTo.html">GoTo</a> statements,
        possibly public member variables always made private with accessor methods, and many others.
      </p>
      <p>
        <em>Some of Meyer's criticisms of C++ in this regard strike me as a bit specious. The issue with case sensitivity, for instance - this strikes me as similar to arguing over which endianality is "better". (That said, I suspect that internationalization will ultimately drive languages towards case-sensitivity; as case conversion of many international character sets gets quite tricky). Some of the other things - "C++ type casts", for instance, are present in the language for backwards compatibility, or are only intended for specific applications (and come with implicit "warnings" attached, i.e. reinterpret_cast.) "Eval" is, of course, not present in C/C++. Et cetera...</em>
      </p>
      <p>
        Note that the examples are not specific critiques to C/C++, for example they extend to Java, Python, C#, Scheme. Notice that he *is* guilty of this, since the convention used in naming for Eiffel (CAPITAL_CASE for classes, snake_names for methods and variables) is not enforced but you are suggested to always use that.
        The "implicit warning" is obviously a proof of Meyer's view, you are providing a feature and telling people to not use it, so why did you provide it in the first instance? 
        (The answer of "backwards compatibility" is not a good one since Meyers' Eiffel can work with old C libraries without allowing unsafe type casts.)
      </p>
      <p>
        He surely hates C++, but I think he does since he found this kind of reasons, not that he found reasons since he'd been hating C++.
      </p>
      <hr/>
      <p>
        <strong>UML (</strong><a href="UnifiedModelingLanguage.html">UnifiedModelingLanguage</a>)<strong></strong>
      </p>
      <p>
        <a href="BertrandMeyer.html">BertrandMeyer</a> has a go at UML: <a href="http://www.eiffel.com/doc/manuals/technology/bmarticles/uml/page.html">http://www.eiffel.com/doc/manuals/technology/bmarticles/uml/page.html</a>
      </p>
      <p>
        ...but seriously, in defense of UML:
      </p>
      <ul>
        <li>
           You don't have to blow the budget on <a href="CaseTool.html">CaseTool</a>s - <a href="UmlIsForPeople.html">UmlIsForPeople</a>.
        </li>
        <li>
           Inflexible, dictatorial methodologists have caused an enormous amount of unnecessary confusion - saying "no, use my notation!" isn't a solution - it's the cause of the problem that the UML attempts to solve.
        </li>
        <li>
           A standard notation was long overdue. Real world standards are messy - could anybody produce a simple standard notation with the same goals?
        </li>
        <li>
           The <a href="BusinessObjectNotation.html">BusinessObjectNotation</a> (BON) uses <a href="CrcCard.html">CrcCard</a>s, but it takes exactly the sort of dictionary approach that is criticized in "<a href="TheAlmightyThud.html">TheAlmightyThud</a>".
        </li>
        <li>
           If Walden and Nerson (of the <a href="BusinessObjectNotation.html">BusinessObjectNotation</a> methodology) wanted to contribute to the UML I'm sure they could have made submissions to the OMG. (Don't whinge about the UML - improve it!)
        </li>
      </ul>
      <p>
        Maybe more people would embrace <a href="BertrandMeyer.html">BertrandMeyer</a>'s ideas if he didn't make such extreme statements.
      </p>
      <p>
        (With all due respect to <a href="BertrandMeyer.html">BertrandMeyer</a> who has made a number of useful contributions to our field.) 
      </p>
      <p>
        More debate at <a href="BonVsUml.html">BonVsUml</a>.
      </p>
      <hr/>
      <p>
        On <a href="SmalltalkLanguage.html">SmalltalkLanguage</a>:
      </p>
      <dl>
        <dt> </dt>
        <dd>The lesson is clear: it would not, in my opinion, be reasonable today for a company to entrust a significant production deployment to Smalltalk. -- <a href="ObjectOrientedSoftwareConstruction.html">ObjectOrientedSoftwareConstruction</a>, volume 2, page 1130</dd>
      </dl>
      <hr/>
      <p>
        <strong>Anonymous Refereeing</strong>
      </p>
      <p>
        <a href="BertrandMeyer.html">BertrandMeyer</a> is opposing the anonymous refereeing process that is standard in the scientific community. He always signs his reviews and makes the conference organizers forward this signature with this review to the authors.
      </p>
      <p>
        See: <a href="http://www.inf.ethz.ch/personal/meyer/publications/online/whysign/">http://www.inf.ethz.ch/personal/meyer/publications/online/whysign/</a>
      </p>
      <hr/>
      <p>
        The one thing we can all expect from <a href="BertrandMeyer.html">BertrandMeyer</a> is his strong ideas and <em>extreme statements</em>. I, for one, think they are refreshing (even when I don't agree).
      </p>
      <p>
        I start to worry when everybody is <em>toeing the line</em>. Every once in a while I need that smack up side the head by those with dissenting ideas. -- <a href="ToddCoram.html">ToddCoram</a> (raised on <a href="ChuckMoore.html">ChuckMoore</a>'s radical Forth ideas).
      </p>
      <hr/>
      <p>
        I just came across this in TheLiterature; it made me literally laugh out loud, and I thought I would share:
      </p>
      <p>
        <em>Eiffel borrows quite heavily from some earlier programming languages and I am sure that if we had found a good programming construct in C we would have used it as well.</em>
      </p>
      <p>
        Funny, but snide. Goes hand in hand with his "But in general you should be cautious about including C hackers in your projects"
      </p>
      <hr/>
      <p>
        From the website:
        <em>Is it true that Eiffel Compiles into C?</em>
      </p>
      <p>
        <em>Yes. The Eiffel compiler generates an internal form known as "bytecode". The bytecode can be interpreted directly, but it can also be translated into other forms.</em>
      </p>
      <p>
        <em>To generate the final version of a system, the bytecode is optimized and translated into C, to take advantage of the presence of C compilers on just about every platform under the sun. This is the process known as "finalization", which performs extensive optimizations (routine inlining, static calls, array optimization), permitting performance achievements.</em>
      </p>
      <p>
        Hrmm. so it was created by hackers, in C, but it's not for hackers?
      </p>
      <p>
        <em>Correct. The C code is the output of an optimizer. If someone suggests you shouldn't hack machine code directly, you can't criticize her for using a compiler.</em>
      </p>
      <hr/>
      <p>
        B. Meyer used to be a fairly visible OO evangelist. But, he has been quiet lately. What's up?
      </p>
      <p>
        <em>Easy. He neglected to pay attention to </em><a href="TypeTheory.html">TypeTheory</a> while designing <a href="EiffelLanguage.html">EiffelLanguage</a>, and as a result, committed one of the famous <a href="LanguageTypeErrors.html">LanguageTypeErrors</a>. <a href="EiffelLanguage.html">EiffelLanguage</a> has not been the success he hoped. That's one theory.<em></em>
      </p>
      <p>
        But he still says it's choice is right. "The world is covariant" is still written in a not-so-old paper:
      </p>
      <ul>
        <li>
           <a href="http://se.ethz.ch/~meyer/ongoing/covariance/recast.pdf">http://se.ethz.ch/~meyer/ongoing/covariance/recast.pdf</a>
        </li>
      </ul>
      <p>
        <em>Or he could be busy doing teaching and research, and not have time to be a high-profile advocate for Eiffel.</em>
      </p>
      <hr/>
      <p>
        In my opinion it is all about ambiguity and encapsulation and finally re-use. In C we find that we have to try hard to encapsulate or re-use something to make it work multi-threadingly or multi-processingly. In C++ we find that we have multi-threading-support and multi-process-support along the way because of the runtime environment of what the compiler creates.
      </p>
      <p>
        Yet, in C++ we also find much ambiguity or rather side-effects resulting from that "ambiguity" in respect to for example references to objects that have been destroyed (deleted) and other instances of objects still requiring these objects to be available. As such, the runtime environment of the C++ language was never really absolutely fail-safely defined, at least in my opinion.
      </p>
      <p>
        Next we have the templates that are not compatible in derivation and casting, as each template being concretized (correct word/spelling? - correct me!) cannot be cast to another template of the same base template or a template in a hierarchy in templates without losing context, i.e. dynamic_cast to void or other types.
      </p>
      <p>
        Yet, I am no expert in C++ but I have found out that I'd rather not use this language anymore unless it becomes more dis-ambiguous in language terms.
      </p>
      <p>
        The same with constness in C++. You can always const_cast something to be finally mutable. But how would one consider something to be const_cast to be finally mutable, the term in itself is ambiguous and finally misleading.
      </p>
      <p>
        Yet, I still think that Bjarne Stroustrup did a great job, yet he failed when it came to language in itself.
      </p>
      <p>
        And, yet, still more I feal that C is inherently less ambiguous than C++ because of the above and that C can be much more rewarding than using C++ and finally debugging C++ which is finally a trial&error experience.
      </p>
      <p>
        But I also don't think that Eiffel is the cure to all programmers pains. At least in my opinion.
      </p>
      <p>
        -- <a href="CarstenKlein.html">CarstenKlein</a>
      </p>
      <hr/>
      <p>
        See also <a href="UniformAccessPrinciple.html">UniformAccessPrinciple</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryObjectOrientation.html">CategoryObjectOrientation</a>
      </p>
    </div>
  </body>
</html>