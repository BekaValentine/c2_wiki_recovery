<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <base href="/mount/ultralaser_home/Projects/c2_wiki_recovery/out/">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="page">
      <h1>
        <img src="wiki.gif" />
        Crash Test Dummy
      </h1>
      <p>
        Test error code by invoking it with a <a href="CrashTestDummy.html">CrashTestDummy</a> object that throws an exception instead of doing real work.
      </p>
      <p>
        One of the <a href="TestingPatterns.html">TestingPatterns</a> in <a href="KentBeck.html">KentBeck</a>'s book, <a href="TestDrivenDevelopment.html">TestDrivenDevelopment</a>.
      </p>
      <p>
        Also described in <a href="JbRainsberger.html">JbRainsberger</a>'s book, "JUnit Recipes: Practical Programmer Testing Methods" (Summer 2004)
      </p>
      <hr/>
      <p>
        Simulating an exception is much easier than recreating it. This generally implies that the exception thrower and the exception catcher are different objects and that one constructs the catcher by passing it a thrower as a parameter. If the thrower is represented as an interface, then one can easily substitute a "crash test dummy" implementation -- one that always throws the desired exception -- in the required test. -- <a href="JbRainsberger.html">JbRainsberger</a>
      </p>
      <hr/>
      <p>
        <a href="CategoryTesting.html">CategoryTesting</a>
      </p>
    </div>
  </body>
</html>