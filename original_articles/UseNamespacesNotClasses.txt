Another CppHeresy. See also UseStructsNotClasses.

I have this funny system level project hooking under Win32 API. It's a little bit more complicated but to cut it short it goes like this: ByeByeObjects. 

The little data that I have is shared between the instances of the DLL and it has to go in a static data segment, and it has to be static, and of course the linker will cry foul if you want to put objects in a shared data segment of a DLL. It cried fouled even when I tried to put structs and in some other place I instantiate a function template with the struct type as parameter. For whatever reason it thought that structs are objects, although technically they shouldn't be. If I don't pass the struct type to the bloody template, it's happy to initialize the structs as usual structs. So, bye-bye templates. Plain good old C. Very trusted and solid language.

There's a little controlling application where you can put all the objects you want, but once you got the thrill of going back to your good old C habits, you ain't going back. Especially, you start asking yourself question, why the hell you need to create classes for singletons ? You just put static data and a bunch of functions, you're even more flexible.

But after all too many years of Java programming, I got some deviant habits of trying to see the code organized hierarchical, well partitioned looking through the class browser and stuff like that. When Viusal Studio shows me a long list of functions on one level (no packages, no classes), I realize I'm hopeless. In my youth when I was programming TurboPascal I used to put at least 30 functions in one file, work with at most 3 files open, keep all the structure in memory and be happy with it. All my sharpness has gone down the drain following bloody Java APIs.

So, how do you get a bastardized Java programmer like me to find his way through a C project ? My first idea was to create some classes with singletons, then to create classes with static methods (in the controlling application it worked, in the DLL no way). But then I realized I was bastardizing the trusted procedural programming style with OO heresy. And it wasn't particularly helpful in this situation, I needed more than procedural programming, I needed a little bit of functional programming in C. Passing pointer to member functions instead of passing pointers to C functions seems ridiculous.

Luckily there's another solution: group related functions and static data by namespaces. 

Now all looks nice and clear and the little class browser is perfectly happy to show you namespaces, my deviant mind of Java programmer now feels safe and secure, and in the meantime I didn't pollute the design with objects. Namespaces look like java packages in the class browser, smell like classes with static methods and data, work like big singleton objects and you still have '''no objects'''. Ain't it cool ? You can always use your C++ compiler as a convenient C compiler. It can't handle all that C++ anyways :)