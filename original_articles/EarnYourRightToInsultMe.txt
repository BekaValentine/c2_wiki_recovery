 *** WARNING: Rant Ahead ***

A WikiZen or two have threatened to delete my contributions and engage in rude behavior because they are very certain that my content is allegedly very wrong and potentially misleading to readers. I receive more harassment than a sample-carrying box-cutter salesman at the TSA booth. 

* '' Such as objective proof you are a hypocrite?  You decry others for suggesting something should be deleted but are quick to deleting something things you don't like. -- BottomMind''

* {Actually, to Top's credit, I don't recall seeing him ever delete something he didn't like.}

* I have never intentionally deleted anyone else's content. If I move stuff, I leave a link to the new page. (There is a vandal(s) that has deleted pages whose content I was involved in, but it doesn't appear to be motivated by topic so far.) -t

I personally believe that BeingRightNotExcuseForBeingRude and that to DisagreeByDeleting is also wrong. You have a right to state your counter viewpoint, but not a right to delete and harass others for merely "being wrong" on IT subjects. However, others don't share this behavioral code.

'''You have no right to be so rude until you earn the right via clear objective evidence''' (preferably with ItemizedClearLogic), not vague, notion-y, round-about reasoning and unverifiable personal anecdotes. I know you personally feel the strength of your convictions deep in your bones, but your reasoning steps have to first be publicly documented and clearly objectively correct on this wiki before acting on your convictions to "shut down the guy who's wrong". '''Your internal conviction is not sufficient.'''

--top

''Not only have I earned the right to insult you, I have earned the right to poke you with a stick.  It's a small stick, and not particularly pointy, and it bends a bit much, but it's still a stick.  Hoorah!''

I can suggest a place to rapidly store your stick.

''Shut up top. When I did my master's thesis I looked up to you. Now I can look down from where I am and say you're weak. I have dared to imagine something so far beyond your patterns that you could not grasp it.''

Vague, typical of youses. What did I say earlier that turned out to be objectively wrong?

''I meant to insult you, not debate with you.''

Good, staying with your strong-point then.

---------------

This page asking for objective evidence of hypocrisy comes from the same person who argues ObjectivityIsAnIllusion. Reach your own conclusions.

* ''Ultimately the reader will decide if a proof is any good, such as agreeing with the givens. Often times there are a good many UsefulLie''''''s a group can agree on in order to move on to the next stage. Thus, universal objectivity would be nice, but is not a prerequisite to coming to an agreement. -t''

Anyhow, I don't believe any sort of "right" is involved with insulting people. But, if there was, you certainly wouldn't be obliged to convince such a biased judge as the ''recipient'' of the insult. 


-----

Hypersensitivity to imagined insults (http://en.wikipedia.org/wiki/Narcissism#Traits_and_signs)

(Moved. Note it's usually consider bad manners on this wiki to insert comments at the very top of existing topics; roughly comparable to cutting in line. Imagined? It's real now: you just labelled me a "narcissist". http://en.wikipedia.org/wiki/Irony)

---------

If you stand up people will shoot at you. You know that. Let it rest and try to focus on ClearCommunication. 
And do not forget what Jesus said about casting the first stone.
-- ChaunceyGardiner

''He stood up, and the Romans "shot" him, and probably cast stones at him also. And, I find it personally satisfying to cleanse the bullshit out of the software design and education industry. Greed and protecting entrenched interests corrupt them. This cleansing sometimes requires asking tough and unpopular questions. Jesus also booted the money changers out of the temple such that if I model my life after his, I have to boot the money changers out of the eTemple, or at least expose them as phonies or having excessive unconscious bias.''

{"I find it personally satisfying to cleanse the bullshit out of the software design and education industry."

Let us know when you start doing that.}

''I imagine it's probably un-Christ-like to tell someone to shove off.''

{Feel free -- you're clearly insufficiently Christ-like for it to make a difference.}

''I suspect you are one of those protecting your entrenched interests, and that's why the derogatory remarks. Oh, and shove off. ''

{Which of my remarks were derogatory?  Surely you don't think you're actually Christ-like or successfully managing to "cleanse the bullshit out of the software design and education industry", whatever that is?}

* If you can't answer the first question, you are socially clueless.

* {If you really believe either of your claims, you are deluded, uncommonly arrogant, or both.}

* Projection.

* {I don't think so.  I do not claim Christ-like attributes, nor do I claim the power to "cleanse the bullshit out of the software design and education industry".  Those appear to be your claims, confirmed by the fact that you consider denial of those attributes to be "derogatory".}

* It was in reference to "deluded, uncommonly arrogant", not Christ, for Christ's sake!

* {I know what it was in reference to.  Which of my remarks did you find to be derogatory?}

* "Let us know when you start doing that" -- I interpreted that as sarcasm, and sarcasm is generally considered a form of or a variation of derogatory (http://thesaurus.com/browse/derogatory ).

* {You think a grandiosely over-the-top claim like, "I find it personally satisfying to cleanse the bullshit out of the software design and education industry. Greed and protecting entrenched interests corrupt them. This cleansing sometimes requires asking tough and unpopular questions", doesn't deserve a little sarcasm?  Do you genuinely believe you're managing to "cleanse the bullshit out of the software design and education industry"?  Do you really think you're asking "tough and unpopular questions"?}

{Protecting my "entrenched interests" from what?  My only "entrenched interest" is in ComputerScience, and it doesn't appear to be under threat so there's no need to protect it.  I do have a certain opposition to ignorance; perhaps you've confused that with protecting entrenched interests?}

* "Computer science" is a fraud name outside of hardware concerns. It's built up a body of bullshit over the years that need to be flushed.

* {So you claim.  It reflects far, far more on you than it does on ComputerScience.}

* Others have made similar observations. I didn't create the topic DisciplineEnvy, for example. I guess we are all deluded and you have the special gift for seeing everything right. Your garbage does NOT look like the scientific process I learned. Maybe science is different on Planet Stubborntower? You believe your hardware-centric models to be some canonical truth outside of machine performance. We'll so far that's fucking pseudoscience and you are too fucking stubborn to see it. "I don't need science and formal logic because I'm smart and I feel it's right, and that's sufficient evidence". You think the universe orbits your bloated head, making your head the reference source of truth. Well, the universe does not give a shit about your head and it's arbitrary models. Your arrogant little brain is just dust in the wind from its perspective.

** Re: "Others have made similar observations. I didn't create the topic DisciplineEnvy, for example."

** {What in DisciplineEnvy claims that ComputerScience is "a fraud name outside of hardware concerns" and/or "a body of bullshit"?}

** They don't use those words, but a lot of what's under "computer science" is really soft science in an immature state, as described there. Related: IsComputerScience.

* {Projection.}

* I don't claim "canonical" etc. I realize some things are relative and '''don't elevate my personal preferences to universal truths'''. Thus, it cannot be projection. '''I welcome alternative models''' of both heads and tools instead of belittle them for not being sanctioned by The Church of Overpaid Protectionist Academic Pseudoscientists. If I claimed canonical-ness, I too would be obligated to prove it's universal and not head-specific.

* [This page is an example of you elevating your personal preference to universal truth. It's also one you intend to only apply to your opponents as evidenced by your repeated use of insults in the various discussions about semantics you are currently involved in. I also find your claim to "welcome alternative models" to be unlikely as you consistently complain about any "models" that aren't of your own devising.]

* What exactly did I elevate? And I usually only insult back as retaliation. I do sometimes slip out of frustration, but I don't try to dress is it up as constructive criticism, like you guys often do. And without specific "complaints" identified, I cannot comment. Criticism of models is fair game (such as grokkability). And so are criticisms of claims that a given model is "canonical" without sufficient evidence. '''I don't claim my models are canonical'''.

** "slip out of frustration" - that is simply untrue. There is no slip. You deliberately hit the save button after painstakingly entering the thought-bubble. That is not a slip, it is a deliberate action.

** ''Your literal-gland is working overtime, Bub.''

* [The "need" to earn the right to insult. And no, you did not typically insult in response to your opponents insults. It usually occurred when someone countered one of your points. Of course criticism is fair game, no one has said otherwise. However, consistently complaining about competing models, especially when the criticism is trivial (Whining about "do", "have", and "is" come to mind), does indicate an unwillingness to "welcome alternative models".]

* I disagree about the context of my insults. And what do you mean "trivial"? Those words ARE vague; meant for the human world, not the virtual world of machines. That's a problem with English, ''not'' me. Your explanations ''pivoted'' on such words such that they were not "trivial" in our discussion. I didn't invent irrelevant problems out of the blue, YOUR explanations relied on such fuzz words. (See also LaynesLaw). You guys even '''admitted''' English (as typically used) was too vague for rigorous or detailed analysis, and proposed a different notation instead if precision was the true goal. (Search "There's an inevitable point where" in TypesAndAssociations.) If I had made a big deal out of NON pivot-able words, your complaint may have been legitimate. But, that's not the case. Even if you ask regular people whether "do work" means the process (go through the motions) or the "results", you'll probably get a roughly even split, and many saying "both". These words are '''ambiguous even in the human world'''. Much of the time the difference doesn't matter much. However, for detailed science and analysis, those differences do matter, such as whether programming languages are defined/compared by their processing or results (I/O). Therefore, defining them verbally by "what they '''do'''" is not clear.

** [You can disagree all you want, but the context is still there and you clearly are not insulting others in response to their insulting you. By "trivial" I meant what is usually meant by "trivial", "Of little value or importance." As for the amount of rigor, for the purposes of our discussions here, the amount of rigor supplied by the English language is usually sufficient. There certainly wasn't any problems with the words you complained about. We even offered to use a more rigorous language than English if you preferred. You never took us up on it. (BTW, "do work" couldn't possibly mean either "process" or "results". Both of those are nouns, while "do work" is not.)]

** You guys were the ones who made big deals about such words. You said it was "wrong" that I had values "in" variables. First, you didn't say where that no-in rule came from exactly, and second, it looked like your "values" were ALSO "in" variables, per normal interpretation of "in" per XML. And, no, English is NOT sufficient for our needs, especially around anal and nit-picky people. I gave plenty of examples in TypesAndAssociations of English ambiguities. Frankly, I doubt most programmers care that much about an official or "proper" definition of "value". But you claimed it would kill mental puppies if I used it in the alleged wrong way I did. Thus, the whining over words is from you. I try to avoid dependence on words because they are messy.

*** [You certainly claimed vagueness. Only once did you make any attempt to show vagueness, and that one failed.]

*** I did not fail. You did not prove that alternative interpretations I provided were objectively or survey-wise "wrong". You appeared to give up defending the One Right Way interpretations and conceding that English, as commonly used, was indeed vague. That's my interpretation of the debate, but I'm satisfied to LetTheReaderDecide. The evidence is publicly available and I'm confident most readers will agree with me on that.

*** [It most certainly did. I can only find one instance where you even bothered to give an alternative interpretation. It was shot down immediately.]

*** You are wrong and blind. There are at least 3. (See just above PageAnchor human_languages_26). It's there and not logically refuted. Deny all you want, wrong biased stubborn human. How can you refute when you changed the subject after the ambiguities were pointed out? Illogical. There is no "there" there.

*** {I'm afraid I find the text immediately above PageAnchor human_languages_26 to be incomprehensible.  I don't know what to refute if I can't understand it.  Where was the subject changed?}

*** Why did you wait until now to complain about it? If you have questions about it, you should have asked there.

*** {You wrote half the text yesterday; I hadn't reached it yet.  I got to this first.  The other half I hadn't seen before.  I'm sure there are other bits I've missed amid various edits from various people.}

*** I only added clarification to existing points, I did not add new points. 

*** {You added at least 390 characters, in a whole paragraph.}

*** That doesn't contradict my statement.

*** [RecentChanges does though. You added the point about "But your use of "a" in "has a reference to type" suggests there only be one type".]

*** I felt that I didn't clearly explain why "interpretation path produces a different [second] result" was a problem produced by your text in the original, so I fleshed out exactly why it was a problem. In the first version, I successfully identified a duality, but one could come back and say, "So what? What's wrong with duality?" The revision answers that better. We discussed a similar example elsewhere before such that at the time I may have felt a brief version was good enough, but if one encounters such text without that history or memory of, then it could be confusing. -t

** {Actually, we said it is wrong that the structure you use to represent variables has an explicit 'type' attribute.  You turned that into a peculiar quibble over "in", "has", etc.  It had nothing to do with "values 'in' variables".}

** Fine, "has". But that's equivalent to "in" as I interpret it in that context, and you never provided proof it's not equivalent, nor defined a way to validate if has-ness is taking place or not. A non-falsifiable definition is not useful (meaning there must be a clear way to say something is "not an X" or does not qualify, such as "X does not have a Y".). Saying it was "has" instead of "in" does not change the fundamental problem. '''The real problem seems to be that you mistake your personal interpretation of such words for external truths.''' You are willfully blind to subjectivity, mistaking your mind for the center of the universe. You have a problem. (I'm in the process of reviewing and clarifying my descriptions of the identified ambiguities in TypesAndAssociations to ensure they are clear.)

** And I'd bet money that with the XML: <x><y></x>, most programmers would agree that "x '''has''' a y". I'd then wave the money in your face to shock your stubborn brain into the reality of popular usage and your minority subjectivity. Maybe social embarrassment would wake up your stubborn mind to the fact you are out of touch with the field. (Neither answer is clearly "wrong", since there is no established or enforced usage pattern for such context. However, it's STUPID to keep assuming and insist to others there is such a language rule without collecting solid evidence of usage first. That's why I believe you to be a stubborn dumbass. You hallucinate canonicality to match your pet subjective models of BOTH language and IT.)

** {Insults, again?  You appear to resort to insults whenever you're caught making an error.  Yes, given the XML "<x><y></x>", I'm sure most programmers would agree that "x '''has''' a y".  However, that wasn't what the debate was about. You define variables as <variable type="..." value="..." name="..."/>, so your variable has an explicit 'type' attribute.  I've pointed out that as dynamically-typed languages are conventionally understood, variables don't have a type and values do.  In other words, an appropriate definition would be <variable name="..."><value representation="..." type="..."/></variable>.  In response, you claim that a variable still "has a type" because it contains a value, and a value has a type attribute.  I disagree, because a variable does not have (nor does it need) an explicit "type" attribute.  So, the debate was about whether variables "have a type" or not.  However, it's a completely irrelevant debate, because dynamically-typed languages never need make reference to a variable's type, regardless whether "a variable's type" is an explicit attribute in variables (which your model has), or obtainable from any variable via the value it contains.}

** Fallacy, it's perfectly possible in this universe to insult AND be right.

** {Of course it's possible, but I don't think I've ever seen you insult when you were right.}

*** That's a UselessTruth because according to you, I'm always wrong. There's never a case where I am insulting AND right at the same time because there is never a case where I'm right (per your view of the universe).

*** {Where have I said that you're always wrong?}

*** You imply it often.

*** {You appear to be inferring something that I did not imply.  I only take issue with specific statements.  It would be pure speculation to state that you are always wrong.}

*** Either way, you have not given enough info for the reader or I to verify your association claim of insults versus correctness. Further, if you feel I'm right on an issue, maybe you end the sub-topic and move on, reducing frustration. If you obsess on point that seems either clearly wrong or unverifiable or whacky world-play to me, then I'll get frustrated and insult. Thus, the cause may be something else than correctness. Agreement doesn't generate the long battles. You are making cause-based conclusions even though there are many valid alternative cause possibilities here. It's similar to your interpretation of text: you fail to consider alternative interpretations; instead assuming your pet interpretation path is the One and True. It appears your mind "bets the farm" on your earliest interpretation, and stubbornly defends that version despite any new evidence. Whether this is ego protection or some other personality flaw, I cannot tell yet.

*** {If I feel you're right on an issue, I say so.  If I feel you're wrong on an issue, I say so.  If it appears I've ended a sub-topic without comment, it's either because I've missed it (and so may return to it later) or because it appears the discussion has reached a resolution or conclusion -- which isn't necessarily agreement -- that no longer warrants a response.  I suggest that if you feel compelled to employ insults, please try to resist, as they add nothing to the discourse and reflect poorly on your credibility.  As for considering alternative interpretations et al, I certainly do.  I have considered your alternative model of interpreters, and I feel strongly that it promulgates confusion, and therefore I object to it.}

*** You've rarely agreed I was right about anything such that the "testing problem" remains. As far as "promulgates confusion", you appear to be using your own mind as a reference specimen to study "confusion", which is probably a very poor choice of test specimen. You don't think or talk like regular programmers, and you've had too much exposure to hardware-centric issues and specific interpreter implementations, which creates experience that does not match the experience profile the target audience, regardless of your general intelligence or lack of it.

*** {Really?  I work with "regular programmers" on a daily basis, and none of them write like you.  They write like me and the others who debate with you.}

*** And the relationship between "variable", "value", and "type" is NOT clearly established in app language manuals (not interpreter/compiler writing books). If there was a clear relationship established, and you gave several examples from actual sources, and they clearly contradicted my model, you may have a point. As it stands, you have failed to do that kind of "word usage mining" to establish a clear-cut and common usage pattern of those 3 things. (This includes the total surveyed. It's poor practice and bad science to only report on or keep the samples that match your preconceived notions.)

*** {Sure it's clearly established.  See, for example, http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html and http://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Data-Types and http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf }

*** Sorry, I don't see unambiguous relationships established between those 3 items in there.

*** {Between them?  Not sure what you mean.  Within each, types, values and variables are clearly distinguished.  Unfortunately, the definitive work in this area is not available on-line:  Each edition of Date and Darwen's TheThirdManifesto has gone to considerable lengths to define and clearly distinguish values, variables, and types, because Date and Darwen believe lack of clarity in defining and distinguishing them has resulted in some confusion.  Your own confusion over the three is characteristic.}

*** The "relationship between them" would be typical things like "every X has one or more Y's associated with it and zero or one Z associated with it" and "If an Q has an R associated with it, then it must have at least two S's associated with it". Those quantity rules are easy to describe and expected from good docs. I don't know why so much writing on related topics skips such simple yet powerful info. Baffle. And D&D's model may be a functional model (it produces the right answers) but that by itself does NOT make it canonical. There are probably many "valid" models, per the I/O profile test. (Note that quantity rules per specific model and/or language are not necessary quantity rules per canonical model/definition. But I doubt there is any such canonical associations. Also "has relationship" can be messy if the property is calculated, such as parsing to see if a "value" can be interpreted as a number. But it may not be necessary to "calculate" such. It can be tracked with a tag-like indicator in some situations, such as from parsed literals, and display behavior identical to parse-based determination. Thus, making a distinction between a "calculated" type and an explicit type (tag) imposes an arbitrary implementation assumption into the wording. This is not the same as D1 versus D2, but more like D2 partially implemented with D1-like techniques when certain info is available, perhaps for speed. One cannot tell the difference from the I/O profile. Calling it parse-based (calculated) just may be the simpler UsefulLie. Mentioning "parsing" needs to be done with care. We can only safely say an object "has the property of" something, and not describe whether it's from an attribute or calculation without imposing implementation assumptions. In both D1 and D2 languages, a given variable can be said to "have" or "produce" multiple types at the same time in some situations (such as "0" being used as a Boolean, Integer, and String). However, D1 languages have a ''single'' "primary type" (per scalar variable) regardless of the potential for having secondary types. This "primary type" has typically more influence than secondary types, and the existence of this single "special" type is what separates D1 from D2. But the difference between primary and secondary types can often be subtle, and this is the main source of confusion. One can usually ignore the existence of the difference and still get the right results a vast majority of the time; and thus programmers usually don't dwell on the differences, making spot fixes for any problems encountered. They don't dwell on specifics of value packaging. In my model, I chose to model the primary type as a single explicit attribute of a variable, and secondary types are modeled via parsing. That does not mean that parsing actually has to take place, but it's the simplest UsefulLie and I do it to keep the model simple. It's good enough to match the I/O profile of the reference interpreters.)

*** {The relationship between values, variables and types is so simple that those who understand it often assume everyone does, or only mention it in passing.  It's this:  A type is a set of values; a variable contains a value.  Furthermore, a literal is a string of symbols that denotes a value, so some values -- those belonging to the type 'string', for example -- can encode literals of other types.  That's why "0" can denote boolean, integer, and string values.}

**** In dynamic languages, it's not simple, or at least not clear. It's possible for something to "be" a Boolean for one operator but "not be" for another. "Belonging to" is determined by the operator, not a "set of values" in a general '''global''' sense. Your description is fuzzy on when a set of values is what to who. You skip scope issues, leaving it vague, assuming people just magically know via the Semantics Ghost or something poorly explained. The devil's in the details. Explicitness in quantities and association application (scope) matters, IF you want to be clear to a wide audience.

**** {The fact that a value can be treated as boolean in one operator but be (say) numeric in another is fully accounted for by the fact that (as I wrote above) some values -- those belonging to the type 'string', for example -- can encode literals of other types.  That's why "0" can denote boolean, integer, and string values.  I'm not sure what you mean by "scope issues".}

*** {Date and Darwen's writings go to considerable effort to explain values, types and variables in general; it is not just applicable to their description of the relational model, their type system, or their proposed languages.}  

*** Then borrow their wonderful descriptions/techniques instead of your round-about, obtuse stuff.

** Your XML structure of a variable "has a type" per common usage of "has", period. Levels of nestedness don't de-has-ify in common usage. You insisted repeatedly that's false, when it's not. And my model of variable is NOT objectively wrong. If you want to provide linguistic usage statistics to show otherwise, please do. But so far it appears to be yet another AnecdoteImpasse. '''You make up interpreter rules and English rules willy nilly without solid evidence, insisting people just trust you''', claiming it's part of some fake ghosty "common semantics", bullshit pseudoscience. I'm okay with allowing multiple models to live, as long as they fit the proper I/O profile. Whether the internals use variables, values, or foozglips is not something I'm going to get my panties in a knot about, unlike you. Let the models use whatever the hell they want internally.

** {Yes, that's what we were debating.  Thank you for repeating it.}

** That's what summary accusations from existing debates tend to result in. My main point is that you are the one who quibbles about words because my model does not hinge on words and your complaints about it ''does'' appear to hinge in words (although I'm not quite sure because you refer to difficult to measure phenomena).

** {For something that doesn't hinge on words, I note that TopsTagModelTwo is surprisingly verbose and inclined to employ peculiar phrases (which appear to consist of words) like "type tag" and "anonymous constant" and "hidden variable".  However, my complaints actually hinge on your abstractions, which regardless how they are named, are incorrect.  You treat time-varying slots (variables) and the result of evaluating expressions (values) as the same thing.  That's wrong.}

** Your model has model-specific vocabulary or phrases also, such as "D1". That's usually acceptable. (If you don't like the words I use for my internal parts, you are welcome to suggest alternatives, but so far I have not liked your suggestions for reasons already given.) As far as second part being "wrong", you've made a very poor case for that, but this is not the place to reinvent all that.

** ''"D1", "D2" are just convenient labels.  They aren't part of the descriptions.  Your distaste for my terminology is noted, but I'll ignore it; I'm using familiar terminology and standard definitions.''

** Then "tag" is just a "convenient label".

* ''Well we will all have to learn to speak in hex then.''

* Sorry, I don't get the joke. Computer languages and math notion were invented to reduce ambiguity, at least for certain kinds of tasks. And that's largely why the tag model uses familiar imperative pseudo-code and XML to "describe" type processing instead of using English or an odd self-rolled set-theory like notation.  If you can come up with a better notation that regular developers can follow, be my guest.

* ''ClearEncapsulation''

* I'm a little skeptical of its clarity, especially for "shared state", but you are welcome to build a model in that way to demonstrate it.

* "Of course. It does nothing for your model"

God knows I try -- Chauncey
----
See Also: ItemizedClearLogic
----
DecemberThirteen