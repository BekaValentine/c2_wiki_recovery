First, there's the DefinitionOfMeta.

-----

MetaData may be a more well-defined term.
-----

The MetaLevel architecture is one of the architectural patterns covered by PatternOrientedSoftwareArchitectureOne. It's also known as Reflection or OpenImplementation.

-----
Meta-programming is the art of developing methods and programs to read, manipulate, and/or write other programs. When what is developed are programs that can deal with themselves, we talk about ReflectiveProgramming. 

From what is known of technical evolution, it can be advanced that most probably, like any technological activity, the art of ComputerProgramming will be done more and more by machines themselves instead of humans; Much like people don't hand-compute astronomic or physical stuff anymore, or wash their linen by hand, or have portraits painted to transmit their picture, and have machines do in their place. This way, they can focus on more interesting stuff, be it manipulating astronomical equations, building washing machines, shooting photographs, etc, or anything else that gained free time allows. And even the activities that replaced the former will one day be semi-automated if it brings valuable enough enhancements. So computer programming, which was once done at the level of electronic components, then at the level of binary representation of machine programs and data, then at that of human readable transcript of the former, then at that of simple languages that are more abstract while still mapping the underlying computer architecture, then at that of more and more abstract languages, will achieve such state that most usual work can be done entirely automatically from functional specifications, while most of the interesting work will lie in meta-programming. 
----
Forgive me for doubting, but I have been hearing this kind of argument advanced for more years than I care to think about.  Back in the (earlier) days of Apple II's there was a program called "TheLastOne" (or something very similar).  It wasn't.

Yes, lots of programming has/will become more automated, but it seems that the languages required for expressing functional specifications exceed the complexity and comprehensibility of languages for expressing functional procedures (a.k.a. programming languages) by a good deal.  People have been chasing this chimera since the dawn of computing and seem to be no closer today...
-- MikeMorris

We may be no closer to the destination, but we are a long way from the starting point. This is only possible if the target is an infinite distance away. In the beginning, computers were programmed by physically re-wiring, or
by setting switches. Compare modern languages to the early days and it is obvious that they offer a much higher level of abstraction. Modern languages find new ways to integrate old ideas; and occasionally add something new. But the job of the programmer is unchanged: how to do something using the available capabilities. --DaveWhipp
