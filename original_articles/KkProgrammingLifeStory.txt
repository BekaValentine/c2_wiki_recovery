KarlKnechtel here, describing my life experiences with programming (moved from my HomePage):

I've been playing around with the stuff ever since I can remember, it seems. My earliest memories of using a computer include being enrolled in a programming class (extracurricularly; the same way any of you might have taken a musical instrument or sport as a child). Of course, I have no idea how my parents came upon that idea; today they have no real concept of computers and could not be trusted (would not trust themselves?) to do the simplest of tasks with them.

Anyway. Those first lessons were in BASIC and later Turing; and near the end the teacher made an effort to teach me C (when I was 9 or 10, or thereabouts). I didn't Get It. Around the same time (I think) was when I had a TrashEighty Model III at home (I had an Apple][* at some point too - I think ][e specifically), and my brother-in-law handed me some manuals and a disk with some assorted utilities and encouraged me to try to learn the Z-80 AssemblyLanguage. I '''definitely''' didn't get that, and didn't really try either. But (earlier on) he also introduced me to structured programming, by showing how to use GOSUB rather than GOTO in basic for some bit of calculation. And I '''did''' get that - which made Turing rather easier to deal with, I think.

My remaining memory of CeeLanguage from the early days: Trying to compile something simple, and having one error reported. I couldn't find anything wrong with the line in question, and didn't really comprehend the text of the error message; I could only think of one thing that *might* be it (something to do with the punctuation I think), so I changed it. 11 errors. Okay, so that clearly wasn't it, so I changed it back. 13 errors now, for something that I was certain was identical to what reported a single error before. At that point I gave up trying to learn the language - for that time around.

By this time I was already studying combinatorial logic on my own and trying to figure out how you get from the primitive OR/AND/NOT gates to a machine that can take arbitrary input and perform complex calculation. I remember drawing simple models of computer architecture, along with writing out various trivial programs.

Later on, I think around the age of 11 or 12, I discovered HyperCard and the associated HyperTalk scripting language. I was hooked. I stuck with it for about 8 years, until I finally replaced my old computer (I went straight from my Mac Classic to a G4, which I'm still using now - hard to believe that '''this''' computer is nearly four years old itself! I feel so old myself :( ) Near the end, I started working on all kinds of tweaks to get better-performing graphics and animation. Unfortunately, my favourite and most successful of these only works under System 6.

(''For those who are interested: Use ResEdit to edit the stack and add a new FONT resource. Make every character the same height and width - I typically used 32x32, to match button icons - and set ascender and descender height to zero. Then you can manipulate the graphics by editing the text of a field - which, while it sounds rather slow, turned out to be '''much''' faster in general than changing icon numbers on a grid of buttons, or invoking the painting tools in a script, or anything else I tried.'') [Oh damn, I never thought of that - we always used button grids. -- PanuKalliokoski]

And then at some point in high school I picked up C again, and had a couple years' experience with it by the time I went off to high school. In university came my first experience with CeePlusPlus (which incidentally I hate - mainly because GnuCpp seems to hate '''me''') and JavaLanguage. Meanwhile, the desire to have interactive elements on a webpage drove me to pick up PerlLanguage on my own. Eventually, I got in to the OO features of Perl 5, which I happen to like. (While they seem as much like a clumsy hack as the rest of Perl, and expose many of the things they hope to fix in Perl 6, they integrate very nicely with the rest of the language paradigm. Arrays and hashes are almost like having that part of the C++ STL, or Java's collections framework, built into the language; and constructing an "object" from a hash feels natural, while also giving you some "reflection" ForFree.) I've recently found myself unable to get started on personal projects because, bizarre as it sounds, I could not decide whether Java or Perl (unlikely pairing no?) would be a better tool for the job.

----
CategoryStory