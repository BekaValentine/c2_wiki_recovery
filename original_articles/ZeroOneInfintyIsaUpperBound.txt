ZeroOneInfinity refers to your UPPER BOUND of how many.  To rephrase, given any resource which you may have UPTO n of, n ∈ {0, 1, ∞}.
Again:
	let ''R'' = number of given resource you are actually using.
	At any time, 0 ≤ ''R'' ≤ ''n''
	where ''n'' ∈ {0, 1, ∞}
Not to say that the ZeroOneInfinityRule ONLY applies to this sort of situation, but I defy people to challenge when it DOESN'T apply to this situation.
Actually, the other example might be SupportOneOrWhateverConfigurations.
Or maybe this could all just be refactored into subtypes of EasilyExpansibleCodeBase--the counterpart (but not the enemy) to YagNi, combined to say YamNil, which expands to YaMightNeedItLater, which expands further to EncapsulateAndModularizeYourCodeSoYouCanAddStuffLaterWithMinimalPain, but that one's just too long for a good WikiPage.

Examples:
*How much RAM should I support--or your OS will soon be left in the dust, or (if you somehow get a monopoly) people will sue for making RAM expansions worthless.
*IP addresses:  There WILL be more internet connections later, no matter what.
*Screen size:  Hardware limits don't apply to ZeroOneInfinity.
Really, the upper bound is for how much you can ''support,'' not how much is ''practical.''  Just because I CAN install 16GB of RAM on my system and have it be recognized, doesn't mean I WANT to.  However, now that I have said that, by Moore's law combined with the Law of Technological Obsolescence, in ten years (or less!) I'll look back at this page and think ''Really?  Huh!  Nowadays, you can't even boot Linux without a good 50GB, and a TB or two for games.''

NOT examples:
*Bicycle wheels:  I need TWO wheels on my bicycle.  My upper bound is two ''and my lower bound is two.''  In this case, it makes sense to hard-code two wheels.  (There are also other points against this one.)
*Tricycle wheels: I need THREE wheels on my tricycle...

-------------------------

ZeroOneInfinity is hyperbole. The estimated number of protons in the universe is only on the order of 10^80. If we had 256-bit IP addresses (~10^77), running out simply won't be a problem... and, though we couldn't quite give an IP address to every proton, we could quite possibly have one for every OO-level object. When developing communications protocols, cryptography, filesystems, etc., knowing about real, physical upper-bounds can be quite useful.
