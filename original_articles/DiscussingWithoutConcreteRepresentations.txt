I suspect a main cause of heated debates is that the debating '''parties must agree on a concrete representation''' to talk about language parts, such as types and values, in a meaningful and clear way. Without a concrete representation, the discussion is too "notion-y" to "process" in an objective way. It degenerates into "my notions are better than your notions because I read more ComputerScience books". Even if such were true, it's not objectively measurable or verifiable. Do you agree? 

Does the field of math ever have a comparable problem, or is the symbology there well enough developed that all debates are settled via symbol manipulation (except where the size of the processing job is too large to digest). -t

''I think the term you're looking for is "axioms".''

You still need symbols to clearly represent axioms.

''That's a FormalLanguage.''

I.E. a "concrete representation".

For example, one can propose an axiom that "clouds are not part of land". But that still leaves open the definition of clouds and land. For example, if the micro-water-droplets of a low-lying cloud make contact with the water in a stream, are those droplets part of the cloud or the stream? And what is "make contact"? Exchanging electrons? If the axiom is true, then we must put such droplets only in one category or the other. In a computer game, we can define (represent) clouds and land in a way such that both parties agree on what "clouds" and "land" are in the game and there is never a conflict as long as the symbolic conventions (implementation representations) are agreed on.

''Yup, that's a FormalLanguage.''
-------


''What do you mean by "a concrete representation"?  A set of axioms?''

A set of symbols and rules for combining (or not combining) those symbols.

''That's a FormalLanguage.''

Okay then, both parties have to agree on a FormalLanguage (or close-enough approximation) to get away from the "notion fight" problem. The problem is there is no proven canonical FormalLanguage for the language parts of controversy. One side can insist their chosen representation is "accurate", but insisting strongly is not evidence of canonically nor accuracy of fitting terms. I can turn my preferred head notions into a FormalLanguage, but nobody is obligated up front to accept/use that "model" to define public terms. -t

''Welcome to ComputerScience!  Finally!  It's taken a long time for you to get here, but '''now''' do you see why mathematics -- i.e., formal languages and formal systems -- are important?  Perhaps you can revisit the work of Reynolds et al., because precisely what he and his colleagues do is use FormalLanguage and FormalSystem''''''s to describe what would otherwise be "notions."''
  
It's '''a''' model, not necessarily THE model. Plus, converting specific programming languages into Reynold's model is still a subjective process.  If "types" are classifications, then just about anything can be viewed/defined as classifications. But that doesn't necessarily mean that "everything is types", at least not in a way acceptable to everybody. There are multiple competing EverythingIsa ways of viewing/representing notions/languages.

''No one says you have to agree with Reynolds et al., but perhaps now you appreciate why such work is presented the way it is?''

Appreciation doesn't solve anything. It's good to have models to test and play with, but the "fit" problem remains.

''Solve?  No, but it's a start.  If you feel there's a "fit" problem, feel free to define a notation and a system to solve it.''

It would rely on assumptions about WetWare, and neither side will have concrete evidence to confirm or dispute stated assumptions (competing head-models), and it will end up in a looping and ugly repetitive AnecdoteImpasse. TopsLaw.

[Maybe. But at least you will have clearly stated such assumptions. As things stand now, I'm not entirely sure what you mean by "the 'fit' problem". BTW, when dealing with formal languages you need to be careful how you use the word "model". It has a technical definition that is at odds with the way you are using it here.]

If by "clearly stated assumptions" you mean a FormalLanguage and "rules" stated based off of that language, I agree that a FormalLanguage is probably a prerequisite, which was my original point.

But even if one does such, there are at least two problems: first, that the FormalLanguage accurately represents the concept of contention (such as "types" or "values"). And second is that any rules based on that formal language accurately reflect "actual" notions. For example, the formal language may have a representation for "nested inside" (i.e. it's clear what "nested inside" means in terms of that working language, such as parenthesis patterns). One can then make a rule that "all values in dynamic languages must have a type nested within the value". One may not agree that such a rule reflects "reality" or "common notions" of values or types. One can make up a rule that "all values are green on Tuesdays", but people don't have to accept that rule as reflecting reality or common notions about values. The stater of the rule needs to tie it to "reality" somehow. (Unless perhaps it can be derived directly from other "rules" the other party ''already'' agreed to. Then one has caught the other party in a contradiction if they don't agree with the derivation.)

[I'd be surprised if any formal language could help with those two problems (it's actually one problem, but that's not particularly important here). It will, however, help identify where such assumptions differ. You will now be able to point to axiom 3 and say, "I don't think dynamic languages have types nested in their values.", and point out why (hopefully). Regardless, we will know that anything that we can prove from such a system will be true for anything that meets the axioms and rules.]

Past attempts at such were not really helpful. Two models were presented and none were clearly wrong based on language "run" tests and written documentation from the language authors (although using language authors as the authority is questionable as they may be biased toward machine-side issues after their implementation focus). It's largely because commonly-used English is ambiguous and overloaded. There did appear to be a close association between preferred head model and the interpretation choices when ambiguity was encountered in the English descriptions.

[What past attempts? And if you're using a formal language, why would it matter if English is ambiguous?]

I meant in terms of seeing if the target model matches what language documentation authors describe in text. In other words, how such text authors define (or appear to define) terms such as "types" and "values".

[What past attempts? (I'll leave the other question alone for now, since I no longer have even a guess as to what you are talking about. Maybe the context will clear it up.)]

Not sure I want to re-stir that pot today. -t

------

Does the field of math ever have a comparable problem, or is the symbology there well enough developed that all debates are settled via symbol manipulation (except where the size of the processing job is too large to digest). -t

''Of course math has such problems, but it has absolutely nothing to do with concrete representations or how well defined symbols are. It happens because mathematicians are still human, and humans just aren't very logical.''

------
CategoryCommunication