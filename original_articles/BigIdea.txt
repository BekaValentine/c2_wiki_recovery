''A language should be designed around a powerful metaphor that can be uniformly applied in all areas. . . . [L]arge applications are viewed in the same way as the fundamental units from which the system is built.''

-- DanIngalls, from DesignPrinciplesBehindSmalltalk

Agreed.  So what languages have statements that function as BlackBox data transformations?  And what are those statements composed of?
----

Some BigIdea''''''s (new and old, good and bad):
* DeclarativeMetaprogramming
* ExtensibleProgrammingLanguage
* GrandParadigmUnification
* EverythingIsa
* ActorModel
* FirstClassTypes
* KeyLanguageFeature''''''s
* RelationalModel
* GreatAbstraction
* LanguagesAreOperatingSystems
* DontModeMeIn
* StructuredProgramming
* YouAintGonnaNeedIt
* ObjectOriented


Related to GroundBreakingLanguages, many of which are governed by a BigIdea, best defined by example:

* LispLanguage, in which programs are manipulated as data.
* AplLanguage, with its powerful generalization of array manipulation.
* ForthLanguage, where EverythingIsa''''''n occurrence on the stack.
* PrologLanguage, in which EverythingIsa relation.
* SmalltalkLanguage, EverythingIsa''''''n object.
* RebolLanguage, EverythingIsa dialect.
* HaskellLanguage (et al), EverythingIsa function.
* BondageAndDisciplineLanguage''''''s
* OBJ -- the first language to implement parameterized programming and its module system influenced the designs of the Ada, C++ and ML module systems
* UserTalkLanguage in UserLand's Frontier where every variable not declared ''local'' is automatically made persistent in a hierarchic object database.
* CasMl -- every picture has a purpose.
* ExtremeArchitecture -- every component has a purpose.
* ExtremeProgramming -- all programming is maintenance.
* Add your own examples here... (but check EverythingIsa first)

EricRaymond describes languages like this as "extremely powerful and elegant within [their] ProblemDomain, but weak outside it (there also seems to be a law that such languages must have obscure syntax). "

----

Dunno if the BigIdea is limited to languages; surely Unix's "Everything is a file" counts?

----

I might agree that Lisp is weak outside its ProblemDomain if someone can tell me where its ProblemDomain ends.

''Outside the LispMachine. HaHaOnlySerious.''

Also, I think Lisp has more than one big idea:
* EverythingIsa list.
* EverythingIsa function.
* Code = data.
Where the last unifies the previous two. 
------

"Any time you have "one overriding idea", and push your idea as a superior ideology, you're going to be wrong. Microkernels had one such ideology, there have been others. It's all BS. The fact is, reality is complicated, and not amenable to the "one large idea" model of problem solving. The only way that problems get solved in real life is with a lot of hard work on getting the details right. Not by some over-arching ideology that somehow magically makes things work."

--LinusTorvalds (quoted)

Source: http://meta.slashdot.org/story/12/10/11/0030249/linus-torvalds-answers-your-questions


----

See also SystemMetaphor. In both cases we have a UnifyingConcept. 

----

See also EverythingIsa, TooMuchAbstraction, ThereAreExactlyThreeParadigms, YinYangVersusSinglism, GodLanguage
----
CategoryIdeaForm