A SoftwareMasterpiece is just that. As in art, architecture, whatever, the main 
criterion is to withstand the test of time.
''In a field that is only a little more than half a century old (give or take a decade, and not counting Babbage), can we truly say that anything to date qualifies?''
----
There seems to be some disagreement over the definition of SoftwareMasterpiece; 
see SoftwareMasterpieceCriteriaDiscussion.  I (Anonymous) propose factoring 
this page into three separate pages as follows, in the hope of clearing up the 
confusion. 
* CodeMasterpiece
* SpecificationMasterpiece
* UserExperienceMasterpiece

----
SoftwareMasterpiece(s):
	* EmacsEditor
	* TexTheProgram ''and MetaFont?''
	* SchemeLanguage (a thing of beauty) 
** Is it about the externals or internals?
	* VmsOperatingSystem
	* MumpsLanguage "Are you kidding? Please explain."
	* ZorkGame
	* LispLanguage (The original, HomoiconicLanguage with a MetaCircularEvaluator)
	* SmalltalkLanguage
	* PythonLanguage
	* cmForth and ColorForth
	* EclipseEditor (In the surface it might not look it. But the way it uses OSGi and builds LateBinding onto the JVM is magical)
	* sed (Original from Lee McMahon Bell Labs)
	* RubyLanguage
You can vote on these.  Add new ones only if you've dealt with their source.
* Huh? I've read the original source to ZorkGame on DEC 10s, I've read the source to both TecoEditor and C/elisp emacs, TexTheProgram, MetaFont, and lots of Scheme/Lisp interpreters, but whoever said that...vanishingly few have, so I doubt you have! So why the requirement? 
See also ProgramsToRead

I don't think we should talk about external properties of the programs, because 
they exist independently of the programs.  I think we should talk about the 
beauty, cleanness, design and buglessness of the source. 
I refactored away everything that talks about ideas, not actual pieces of 
software, because things that are not software are discussed in more detail 
elsewhere and cannot be software masterpieces. 
----
Vote exclusion of SchemeLanguage (I added LispLanguage above). What makes 
Scheme a masterpiece? Seeing as it's basically just another LISP... Some new 
stuff, some changes, sure, but does that make a SoftwareMasterpiece innovation 
compared to the original (JohnMcCarthy) LISP? Granted I haven't read any Scheme 
source, but ''would an improved version of a Picasso, no matter how much 
"improved", ever count as a masterpiece?'' I think not. -- SimonBrenner

----
IMHO, UnixOs ranks as a SoftwareMasterpiece. It has inspired so many and it 
refuses to die or even become obsolete. -- JavaSchrod 
TheUnixHatersHandbook tells you otherwise.  I'm a long time Unix user, but I 
think their criticism hits the point.  -- PanuKalliokoski 
It's a funny book, with lots of on-target criticism, but they're all about 
(highly annoying) side issues, not about Unix per se. The things that make Unix 
a SoftwareMasterpiece are unrelated to the complaints in that book. -- 
DougMerritt ----

''TetrisGame. The game concept has been ported (to almost everything - including buildings! http://www.blinkenlights.de/arcade/games.en.html ) and cloned more times than you can count (look out for the cheap LCD copies in every toyshop), and has spawned innumerable variants, if not an entire genre of games. I'd say it's a SoftwareMasterpiece if only for the fact that I've been playing it since 1991, and I still enjoy every single game. --EarleMartin''

----
If "time" was the test, then surely FortranLanguage and CobolLanguage belong on this list too. -- BillZimmerly 
''Which implementation?''
* Just wait a few more years and FortranLanguage will make it to the list, it already almost qualifies.

How about SmallTalk?

Smalltalk-80 sure was one. As was Xerox's InterLisp-D environment.

Functionality, utility, and art are not particularly the same things. These 
terms shouldn't be loosely thrown around. Just because software is long lived 
and useful does not mean it is a ''masterpiece''. 
----
There are two definitions that I use regularly in my own thoughts. A 
masterpiece is either the best thing you have ever done, or (more importantly) 
the specific piece of work that proves you are a master. Perhaps this would be 
more of a "MasterWork" :), with the distinction being important only to me.

Being a "master", to my mind, is when your peers consider you to be a master, 
preferably when they judge you based on your work. -- JeffBay
----
So, what qualifies EmacsEditor as a masterpiece?

It has withstood the test of time, and it has proven itself to be quite 
extensible, to say the least. 
----

What do you think of the MathematicaPackage? Isn't it a masterpiece?

Not if you use MaximaPackage. --Anonymous

Maxima isn't a masterpiece. Just look at its source code.

''Mathematica isn't a masterpiece either, just look at the source code...  you 
can't?  oh, never mind then.'' 
What about the MathematicaLanguage?

----

One candidate is sendmail.  Ignore the horrible sendmail.cf syntax -- the 
program handled and continues to handle a huge stream of email every day.  
Possibly more than any other mail transfer agent.  One of the earliest 
widely-used parts of ArpaNet (later the Internet), email may be said to be the 
foundation upon which remote collaboration was built, and sendmail can be 
credited for being the software that made it happen. It deserves recognition 
for its longevity and power. --StevenNewton 
Sorry, please not sendmail.  See chapter 4 of the TheUnixHatersHandbook, or at 
least the small part of it that discusses the sendmail program itself and not 
the major portions that discuss all sorts of other mail-related software 
behaving badly, but not having anything to do with sendmail other than trying 
to lay blame there because ''sendmail is the ubiquitous MTA on the Internet'' 
and just about every mail message with a problem somewhere will have touched a 
sendmail daemon. 
''It may not be beautiful, but it enabled email to grow to the prominence it 
has today, and it continues to handle massive volumes of messages (Sadly, most 
of them are spam).  So what are the criteria? Can we call something a 
masterpiece because of its place in the genre? Would the Model T be a 
masterpiece? Why not?'' 
Because popularity doesn't equal masterpiece.  Being a masterpiece is about 
aesthetics, it's about beauty, it's about elegance and simplicity.  If it isn't 
beautiful, it isn't a masterpiece no matter what it accomplished.  A 
masterpiece should inspire the viewer, it should make you want to do something 
just like that, it should serve as a model of perfection or near perfection.  
Windows dominates the computer OS market, no competitor is even close, but it 
isn't a masterpiece of OS design.  Masterpiece's aren't always the winner, or 
the most popular, WorseIsBetter for the masses.  But the masterpieces inspire 
and influence future designs far more than reqular stuff.  As a language, Lisp 
is a masterpiece, and you can see that by how many of it's features have made 
it into other languages over the years.  Most languages are still in the 
process of reinventing Lisp.  I'd say SmallTalk is a masterpiece for the same 
reason. 
No, not sendmail.  But the QmailSystem is a masterpiece.  sendmail works, but 
qmail not only works better, it is beautiful.  -- RalphJohnson

IMNSHO, sendmail is the #1 example of a program that is very far from being 
software masterpiece.  BIND is another high candidate.  Qmail might be a 
software masterpiece in reliability (I don't know), but not usability - its 
configuration and weird magical e-mail addresses (or were those from ezmlm?) 
are a hairy ball. 

sendmail is an anti-masterpiece in that it inspired me to write my own mail server because that would be easier (it proved to be *much* easier, in fact) than getting sendmail to work correctly for a very typical network. So, it inspired, but not in the way a masterpiece should.

----
Software Masterpiece: A program in the developer's mind before the first line 
of code is written (It goes down hill from there). 
''Just wanted to say that the above definition of a Software Masterpiece is a 
masterpiece in itself. You really nailed it, in a very deep way. Sorry for the 
interruption, back to your regular programming.'' ----
Someone placed RubyLanguage on the list. I'd disagree on the grounds that it's 
too young and perhaps unproven to merit being considered a masterpiece. Perhaps 
when they're on version 10? 
Ruby was created on February 24, 1993, according to WikiPedia, making it over 
10 years old now.  Is that too young? 
''Compared to something like Emacs, yes.''
Any language that breaks itself between updates and flip-flops between syntactic systems from ''minor version to minor version'' is absolutely not a candidate for inclusion in a list of software masterpieces. Inclusion of Ruby is laughable. I don't see Perl up there and its got a far more glorious and storied history than Ruby. I don't know that Python belongs, either, though perhaps its successful and consistent use of limited syntax is worthy of honorable mention (and perhaps some CPython implementation bits are themselves masterpieces, but this does not extend to the entire project).
----
Some possibilities in various genre:
* rsync (no way, the handling of lost connections was abysmal yet in 2002)
* Adobe Photoshop (no way, the last time I used photoshop is was very flaky - that was quite some time ago, but no way can this be a software masterpiece) 
** you must try the present iteration of Photoshop - it is truly a masterpiece for PersonalUseComputing. -- 2008
** ''It's too cluttered and confusing.''
----

The deepest meaning of this page is that there is little agreement on which software are masterpieces, perhaps because as a field software 
engineers/programmers pay little respect to learning from the past.
* It is more than that, it is what is and what continues to be used because ItWorks, it is Useful, Useable and Used.

LiterateProgramming would encourage us to read good programs like books.  But 
which good programs are these?  As a profession we need clarify what our 
'scriptures' are.	-- RobinChauhan 
----

I would say PostScript probably fits the bill.  I haven't really read the 
source code of any implementations, but it works so well that you generally 
don't see that it's there.  I'd say that's a good indication of mastery.

----

ColorForth is a masterpiece.  It embodies ChuckMoore's decades of experience in 
refining the ForthValues of minimalist design. Reading it is like seeing an 
Aikido master effortlessly deflect half a dozen attackers; what Chuck achieves 
seems impossible in the tiny amount of code involved. 
----
I believe LuaLanguage qualifies because it is a very compact implementation of a simple and elegant language, written in a very portable style of C. Not only is it production quality, shipping in many products, but it is an exemplar learning tool. It has a one pass parse that directly emits the IL, a unique implementation of closures using a technique called upvalues, and several other innovative features. The authors are also very open about explaining and documenting their work. It's a real contribution to the art.
----
* X11 XwindowProtocol, whilst the implementation may be arguably inelegant, the design and extensibility definitely are elegant. 
* telnet, it is inconceivable that such ugly programming forms the basis of networking over 20 yrs. (I find that ugly coded programs can be regarded as a masterpiece; masterpieces have undeniable effects in the computing world and technical merit, rather than to depend on the taste for coding style of various Wikipedia contributors.)
* PostScript definitely.
* Google; no need to download! ''Which of the various GoogleTechnology are you referring to?'' 
* xv, once ubiquitous image viewer
* WordPerfect 5.1, best word processor ever.

----
GNU ScreenMultiplexor is definitely a masterpiece in usefulness. It is simple, 
easy to learn and allows lots of activities otherwise impossible over an SSH 
link (or in a console that gets interrupted when quitting and restarting X11). 
I haven't had a look at the source though. 
----
I'd vote in DirMagic (the DOS utility that is still better/faster than windows 
explorer) and several of the TSR's I used to use. What about the original 
Norton DOS defrag? or PartitionMagic? Those were so useful and powerful they 
were revolutions. 
----
GREATEST SOFTWARE EVER:

*VI, versions 1.0-1.2 only, please.
*Ed.
*Mugwumps.
*Lynx.
*Top.
*Did I mention EdIsTheStandardTextEditor?
*The portion of EMACS that quotes Zippy the Pinhead.
----
SQLite. Most widely deployed sql database engine in the world. As powerful as other database engines ten times the size. Clean, nicely-commented sourcecode.

* ''SQLite can't really be compared to most other database engines, because it's an embedded DBMS.  There is no free-running server, nor are there the networking, security and concurrency control mechanisms required in a free-running server, nor does it support stored procedures.  Foreign key constraints are recognised but ignored, though they can be awkwardly implemented with triggers.  As such, it can't really be compared to the Oracle DBMS, MySQL, PostgreSql, and so on.  It would be more appropriate to compare it to other embedded database engines like the Berkeley DB, which are not ten times the size.  From SQLite's own Web site: "Think of SQLite not as a replacement for Oracle but as a replacement for fopen()."''

Colorforth: I want to believe. But I couldn't find any help or documentation. When I tried it, it just gave me a place to type. Clueless, I tried typing random characters...and it crashed. Tried again, same. How do I grok the colorforth?  ''First, become familiar with ForthLanguage (e.g., via GForth) so you have some understanding of Forth to start off with.  ColorForth assumes you grok Forth first.  Then, basically, read the source.  As indicated above, ColorForth is a very, very minimalist system.  It is essentially an interactive assembly language for a hypothetical dual-stack virtual machine that maps very closely to real hardware; unlike GForth, ColorForth imposes ''no protections'' for you (otherwise, it's not minimal!), so yes, you can crash the system trivially if you don't know what you're doing with it. --SamuelFalvo''

XMMS - less bugs than anything I know, spectacularly clean code, useful comments, lightweight, and handy.  
----
If you've got VMS there, you should consider Plan 9 as well.	Very elegant design and a clean way to solve many problems.  9P is a fabulous idea which spawned FUSE.  The C source code is also well written and available for reading.  http://plan9.bell-labs.com/plan9/about.html
----
I elect SmlLanguage, as per The Definition of Standard ML.  Or would this be more of a SpecificationMasterpiece?


----

I (NatPryce) suggest the GitVersionControl.  The command-line tools are clunky but the model underlying them is a beautiful example of elegant simplicity.