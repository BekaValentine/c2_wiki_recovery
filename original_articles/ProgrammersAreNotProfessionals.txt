RealProfessionalsGetSued but programmers don't accept legal responsibility for their actions.

Well, if programmers are neither scientists, nor engineers, nor even professionals. Then just what the hell are programmers?

The term that comes to mind is mechanics. Are programmers satisfied with this status?

Have they done anything to set up:
* professional associations
* professional accreditation boards
* professional licenses, with continuing education requirements
* professional ethics

'''In the UK we have the BritishComputerSociety which is trying to bring a degree of professionalism into IT in general and aims to address all the points above. It is possible to obtain accreditation similar to that of a Chartered Arhictect or Engineer.'''

'''The main issue as I see it is that its not just that Programmers aren't professional (and there are many that aren't) its also that Programming is seen (by other professions) as easy - just because they can create a database in Access or some functions in Excel they assume that everything to do with programming is similar.'''

''See ProfessionalLicensingIsPremature.''


See also HowToProfessionalizeProgramming
----
The most obvious association for programmers is the ACM. Accreditation and licensing happens just the same as other engineering disciplines. Licensing varies by state, but a growing number have it. I live in Texas; the Texas Board of Professional Engineers does licensing for software engineering just the same as electrical, civil, etc. But IMO the software industry is too young for licensing to be required. It is too different than other engineering disciplines; we can't just blindly apply the same roles and expectations. The roles will sort themselves out after lots of time, just like other disciplines have. -- MichaelSparks

The software industry is certainly not too young for licensing to be required. I'll agree that it's too different for accreditation to be governed by the same old rigid bodies. Two things concern me. First, there's no good reason why an international license shouldn't be acceptable. Second, excluding the tiny subfield that practices formal methods, programming isn't engineering and asking a bunch of engineers to license programmers, or lumping programming in with engineering, is inviting trouble. I have nothing against a software engineer license ''separate from'' a software programmer license, but not if they're supposed to be identical. -- RK

What do they test you on? Are there sample questions we can look at? -- Someone

Last I checked, they hadn't developed an exam they were pleased with.  The only way to get a license is to qualify for an exam waiver, which means something like 12 years experience plus an engineering degree.  There is an informative article about the waivers, and licensing of software engineers in general, here: http://doi.acm.org/10.1145/581571.581603.  If you don't have access to read that, I can summarize it here for you.  -- MichaelSparks

See ProposedExamQuestions -- Someone

The ACM has an informative document called "A Summary of the ACM Position on Software Engineering as a Licensed Engineering Profession".  Read it at http://www.acm.org/serving/se_policy/selep_main.html.  -- MichaelSparks

----
When the AmericanMedicalAssociation was founded in the 1870s or so, one of its stated goals was to get people to regard physicians as god-like figures. To some degree, they have succeeded. -- AnonymousCoward

''Programmers briefly had that status also in the late 90's.''
----
In the mid-80s I was a consultant and was involved (on the plaintiff side) in a lawsuit against another consultant. We were both programmers and had previously worked together when we were employees of [company x].

Our side won the suit, but the damage caused by the time bomb written into the application was so great that its cumulative effects made the company vulnerable to specific competition, and they wound up folding.

''Time bomb? What was the suit over - did the other consultant intentionally place a time bomb into the code, in an attempt to hold the plaintiff hostage? That sort of activity goes well beyond unprofessionalism, if that's what occurred.''

As a ''professional'' consultant, I was acutely aware that, to the degree my work could cause financial harm to a client, to that same degree I was exposed for liability. Some of us actually took out OmissionsAndErrors insurance.

Now, as an ''employee'' every company I've worked for has taken steps to indemnify themselves against these same liabilities. We agree to "HoldHarmless" the company that employs us (who treat us like furniture) and they in turn retain expensive legal counsel to erect a ShieldOfIrresponsibility to cover the several programmers that work there.

''It goes beyond this; it's a matter of basic labor law. Employers - at least not in the US - cannot sue employees for unintentional damages/breakage that occurs during the normal course of employment. ('''Intentional''' damage/breakage is another matter). Employees may get fired for such, but if you are a production line worker and you literally drop a wrench in the works accidentally, knocking a factory offline for a day - you don't owe the employer a dime. Employers have the responsibility to adequately train and supervise their employees. (Some employers will try and violate this law, and dock wages they think they are owed - but doing so is illegal).''

If we screw up, we get fired (sometimes), but not sued. The customer, of course, signs "you can't sue us" forms just for the privilege of buying our (hopefully bug-free) product.

I would suggest that it is not so much that programmers aren't professional (some of us really are) but that the DomesticatedProgrammer may quite possibly not be. In fact, you may actually find this phenomenon applies to other "professions" when the practitioners are DomesticatedProfessionals.

-- GarryHamilton

This would be false. Even consultants or contract programmers aren't professionals. Real professionals wouldn't simply cave in to clients who demand the use of substandard parts and work practices. It would be unethical and they would lodge some kind of protest.

Garry, this is the second time you've trying to defend the status quo and put sticks in the wheels of progress. Are you really so attached to your view of programmers, or at least yourself, as brave and noble souls? -- RK

''Real Professionals'' do this all the time. They rarely get sued for it. Both lawyers and doctors are the best example, although it happens with engineering and architects, too. You've got a platonic ideal of a professional, which is not bad, but I don't think it's reasonable to castigate programmers for not living up to that ideal. I know this sounds a lot like "well, everyone else sucks too", which is an argument I normally despise, but the issue I'm taking here is your extremism. It's unreasonable to *expect* a standard of professional programmers which is not expected, and met, of all professionals. -- CM

There are lots of "serious" programmers and consultants out there who try to say things like it is, tell clients what they should use, and generally try to give their best to make a quality product. ''They do not get jobs.'' I've diligently informed clients that they shouldn't use product X, or base their project in Java because it'll take 5x as long. They say, "This is what we want and we're willing to pay for." I've even offered to make the software work with my tools, and showed them it'd cost them less for '''more''' functionality. I've done this twice, and both times I didn't get the job. Why? "We can't maintain that."

Not only is the corporate definition of "professional" different from what this page suggests, but in fact this definition is likely to gain you significant enmity in the corporate world. Businesses are comfortable with the 'Big Tall Bulding' way of making things, which is to have someone design it from afar, then have the grunts go and do the actual work. This approach fails horribly for software (and is only marginally okay for hardware, but that's a different problem). In reality, programmers need to be more than poorly trained mechanics. They need to do everything that is listed above (and then some). But, because Big Business is still moving its ponderous behind to glom over software, lots of wageslaves have flocked to the numerous jobs.

''What does "glom over" mean?''

There is a world of difference between the wageslave-class coder and the people who really want to be software developers. The former drags down the latter because managers and people in High Places have trouble distinguishing the two from each other. These days, the only motivation we have for trying to protest the stupidity of modern software engineering practices is our professional pride. There is scarce economic incentive unless you can get a startup going. 

Even then, your goal as a startup is to be bought. In that case, you succeed early on with top-of-the-line tools and state-of-the-art practices, then jump ship and wait for a big company to pull the husk into the nightmarish whirlpool of corporate/government software development. -- DaveFayram

----
RealProfessionalsGetSued is nonsense. The whole point of professional organizations is to make it hard if not impossible to sue professionals - as long as you can claim "industry standard" you're in the clear. The only exception I can think of right now is doctors and malpractice suits, where there's so much fraud and speculation and failure to define what "correct" is that it's a major factor in crippling our healthcare system entirely. Engineers of any stripe are never (well, hardly ever) sued as individuals.

Software, of course, through the magic of moronic copyright law (yes, yes, contract of adhesion, no consideration, etc. I agree, but for whatever reason courts have upheld this stupid things even where UCITA hasn't explicitly empowered them) doesn't need an "industry standards" copout. 

Most software is in-house bespoke stuff anyway. That which is contracted out could certainly have reliability guarantees written into it. You know it doesn't? Because no sane development house is going to accept such a contract without an iron clad and explicit requirements document, and producing one of those for most software would cost more than the development. Honestly, if you look at numbers, I think the failure rate of software and hardware isn't that different. Sure, your computer crashes. Sure you lose some data. But precisely because there's no responsibility involved, "software error" is an easy PR spin on any sort of problem. This is why so many people go with expensive proprietary solutions - if/when the shit hits the fan, they can point to MS or IBM or whoever and say the software failed, even if the real cause is some guy who wasn't trained screwing up. Even when the software does fail, look at the failure rate *before* the software. If the software is better, then it's still succeeded. In all conversations like this, software gets held to an impossible standard that hardware and other products are not. -- ChrisMellon

Discussion moved to SoftwareIsLessReliableThanHardware

''Richard, this seems to sum up as 1) things aren't perfect 2) you want them to be 3) it's somebody else's job 4) you don't care what they have to do to make it perfect, just "shut the fuck up and make it so" (tm).''

''Dammit, Richard, quit whining and learn to program. I learned fencing from a guy who was an expert fencer. I learned driving from a guy who was an expert driver. I learned English from - you guessed it - an expert. I learned electronic from (oh boy!) another expert. You're not a programming expert. I'm sure as hell not likely to take my lead from someone who a) is not an expert but attempts to wear the mantle b) makes it his business to tell me how incompetent I am in a field where I actually am an expert. Experts don't pontificate, they do the work.''

-- GarryHamilton


FYI, when your work involves dealing with the experts in another field on a day to day basis, yeah you kinda tend to develop opinions about them. -- RK

''I'd suggest that the problem may lie with your poor abilities at communication and human empathy, rather than any sort of conspiracy of programmers to marginalize designers, but hell, what do I know. Tell you what. Go design cars instead. Or bicycles. I'm sure you'll get a totally different response from all the people in those industries.''

* I had a choice of going into CS, math or physics. Math has tens of thousands of mathematicians and a thousand year old history so it's excruciatingly difficult to come up with anything new. Physics is similarly well-established and you need to be a math genius to do anything new in superstrings now anyways. And then I took one look at CS and given its utterly sorry state I knew this was the field where I could do the most good. Didn't you use a similar process when choosing your direction in life, or do you enjoy wasting your life and your talents?

You cannot design software without also programming some of it. No design, even user interface design, is perfect enough to stand up when it's time to meet user requirements. That's one of the major points of this entire wiki, it's the home of ExtremeProgramming. If you cannot iterate, your designs will '''always''' be flawed.

''Design-up-front philosophies '''do not work''' for software.'' Even just saying, "This is the calculator I want," is a good way to make a useless piece of software. Inevitably, you'll realize that you omitted something, and then have to fix it. History is full of people who believed they thought of everything, and paid the price for their arrogance. -- DaveFayram


''Design up front isn't working for you, either, since it's taken you 10 years to produce jack all. How about you prove your competence as a designer before we take any more crap about how every single programmer is incompetent and brain damaged and actively works to make hateful software?''

The problem with your attitude and your mindset, Richard, is that the devil is often in the details. Any ArmchairArchitect (the building kind) could go to his drafting table, and draw up a blueprint for a suspension bridge across the English Channel. However, such a thing would be impossible to build given current state-of-the-art building practices - '''real'' architects know this. It's only the quacks and frauds who would suggest that it's the fault of the (incompetent) engineers and construction workers and materials scientists and geologists that their "vision" of a suspension bridge 'cross the Channel isn't being realized - and that the other architects who ''don't'' propose Channel bridges are too incompetent, timid, or cowardly to have such visions themselves. Such arguments are complete crap. Most of your "proposals", sad to say, are utterly nothing new. Such systems have been proposed before; the literature is filled with them. Some even have been prototyped. Yet you have the TedNelson-esque arrogance to paint yourself as a "visionary", a giant among your peers, just because you're good at recycling cool-sounding ideas that a) are incredibly simplistic (and have been found, numerous times, not to scale to the RealWorld) or b) are impractical or impossible to build using current technology. -- ScottJohnson

I'd be more worried that you were onto something if you hadn't demonstrated an ability to persistently misunderstand what I say.

In an important sense, what you say is true. A great deal of my ideas have already been embodied elsewhere in decades past. And that really doesn't bother me. Quite the opposite in fact, it proves they work. Because the designs were ''successful'' even if they weren't adopted by the perfect all-knowing marketplace.

* Then it might behoove you to quit peddling them as ''your'' ideas. Even if you discovered the ideas independently, they aren't "yours" if someone else thought of them first. You often act as though you and you alone hold the keys to the ComputerScience kingdom. Which puts you in the same company as folks like StephenWolfram and TedNelson - except the latter two gentlemen have actually ''produced'' things beyond VaporWare.


Now you may talk all you want about the problem with my attitude but the problem with your attitude and your mindset is that you assume the programming profession is utterly perfect. If something isn't being used then that's because it doesn't work. If an idea hasn't been adopted then it's because it wasn't practical. If nobody ever came up with some idea before then that's because it's too simplistic. In your mindset, there must always be some perfectly legitimate reason why programmers haven't done something that they should have done on its face.

* Except that I assume no such thing. Programmers, like anyone else, are fallible and frequently screw up. So do InteractionDesigner''''''s. Read the note above. Many of your ideas have been tried - '''and they were found to not work.'''. Or else they require lots more horsepower/memory/storage to work effectively. Or they work on an isolated desktop, but they don't scale. '''Lots''' of people are working on capabilities, OrthogonalPersistence, pervasive OO systems, exokernels, social software, and whatever else you like. And they're making progress. But such projects have a ways to go before Aunt Millie can use them as productively as she can use her Mac or her $600 Dell PC with WindowsWhatever installed on it.

* ''This of course is not true. Capabilities, orthogonal persistence, pervasive OO systems, were all found to work and to work well. There haven't been any negative reviews of ErosOs for example. And while everybody whines about Smalltalk's performance, it's perfectly acceptable for the majority of applications. Look, I know you want to be able to snow everyone else (and yourself) into thinking that there are good reasons why these things weren't adopted but I know better. There never was any reason why ErosOs was produced now instead of 25 years ago. The only reason was that someone bothered to do it now. That's all.''-- RK

* Oh, bollocks. There are lots of scientists, hackers, engineers, programmers, etc. who LOVE exploring the IdeaSpace and stretching the bounds of ComputerScience. Most do so on their own free time. You are hardly alone or unique in your quest for knowledge and discovery. -- sj

----
''Now, you can whine all you like that I should do your job for you ''in addition'' to doing my job, but that's quite egotistical, don't you think?''

It doesn't matter how good you think you are (and quite frankly, how do you know you're not UnskilledAndUnawareOfIt? You certainly don't get much praise around here). What matters is the quality of your product. You've pointed out that there is a serious problem with unskilled people programming, and I say the same is true for software design. How do we know that you're not just another poser, like all the others who've come promising revolution and delivering nothing? I'll say it again. History is rife with examples of people who thought they could anticipate every detail in advance. These people paid for their arrogance, in some cases with their life. Software cannot be designed entirely up front for several reasons, but here are the big ones:
* Requirements for software, even interface software, change as you use it and realize its potential. This is a social aspect. You cannot solve social problems with technical solutions in an adequate fashion. Any level of technical acumen is powerless to handle this.
* In order to design something, you must have a more precise medium in which to describe its exact definition. Otherwise, the only way to design it is to simply build it (perhaps to scale). Software is essentially prepackaged logic. We have no medium in which to design software and user interface that is more concise and powerful than the computer languages we use. There may eventually be such a medium (the improvement of computer languages over time, towards more powerful abstractions, suggests that such a language is possible), but it is not here yet.
* Software exists in a rapidly changing world of hardware and environments. Today's cutting edge is tomorrows eMachine. Software is one of the only engineered products that must evolve at such a rapid pace, without starting over from an earlier stage. Bridges are retrofitted on the timescale of decades, cars make minor evolutions and corrections once a year, software can need to change every week, in some cases. 

''You know, you really ought to try adjusting your responses to what the other guy is saying instead of just repeating your own irrelevant dreck all over again. It's called having a dialogue instead of a soliloquy.'' -- RK

You're claiming that your job is rightfully and meaningfully divided. I'm saying that it is not. I'm saying your entire methodology sucks. Your rebuttal seems to be (and correct me if I'm wrong here), "Those other people who tried weren't smart enough, I am." You really ought to try meaningfully addressing dissenting points. It's how dialogs move towards meaningful conclusions instead of bogging down into a massive fucking flamewar. 

Unless, of course, this entire page is flamebait. I can't help but get the feeling that you're ranting on this page about bad programmers you have met. Maybe what you really mean to say - after all the spicy compounds have been removed - is that ThereAreGoodProgrammersAndBadProgrammers. You seem to have decided that everyone here should suffer for the sins of the average wageslave coder. It is both unjustified and unfair, if that is the case. -- DaveFayram

Functional division doesn't imply time-wise division you fool! If you think design and programming aren't functionally divided then why don't you argue it on ProgrammingVsDesigning, where it's actually relevant?! The whole design-first vs anti-design-first idea came entirely out of your imagination. I take no stance whatsoever. For hell's sake, I've already stated that I'm a fan of XP!

Second, why the hell ''shouldn't'' the group take responsibility for its miscreants. That's what real professionals do. Real professionals go out of their way to ensure that fakes and amateurs can't practice, at all. They don't '''whine''' about one star programmers, they '''do''' something about it. So why ''shouldn't'' I decide that everyone here should suffer for the sins of the average wageslave coder? It's perfectly fair and justified! Just along a dimension you're not used to. -- RK

I do not think they are functionally divided, and I will go to ProgrammingVsDesigning to discuss it further at some point. However, this debate isn't in my imagination. You brought it up when you said that you found it arrogant for someone to suggest that you do "my job" (i.e., programming) and "your job" (i.e., designing). It is not arrogant at all, it's entirely natural. Our debate just kinda moved that way, you know how debates tend to be fluid and all. Let's move that debate there when it suits us.

* I don't think so since I've resisted the debate "moving that way" at every step and I finally just put a stop to it.

* There's nothing natural about design and programming being done by the same person or at the same time or in the same place. It's an artificial situation constructed out of present economic realities.

* It is quite egotistical for someone to ''demand'' that a designer do programming in order to prove they're a good designer or have something to say about programmers. It amounts to saying "my job is the most important one, my skill set is the most important one, my knowledge is the most important one, my understanding is the most important one, my way of thinking is the most important one, and my values are the most important ones, people who don't prove they're a strict superset of myself are automatically inferior".

* Great, now I guess I'll have to re-explain what designing is and how it differs from modeling.

But, as we've discussed on other pages, I am utterly powerless to change the state of the software industry significantly. The industry ''wants'' these bad programmers. They ''need'' them because they want to churn out sub-standard software to make a buck. I can dictate my terms in my consulting (and my most recent consulting job has several clauses in which I don't get paid my full rate until I deliver, and I make scope-limited promises about the quality of my work), but I can't tell MicroSoft or SomeDumbJavaCompany what to do.

* Yes, this may all be true but you still have a choice of trying to change the industry or trying to change your workplace. You COULD create a revolutionary cell in your workplace. I don't know how but I could probably help you find out. Humankind has centuries of resistance to oppression for you to learn from.

Should I hold you responsible for the stupid designers here where I work? Their solution to everything is fucking keypad-lookalikes. I think one day I may get to use a graph someday. My UI designs are superior in every way, and when I went behind the back of my organization and showed my prototype to the customers, they went with my design. So, why aren't you fixing them? You have a responsibility to solve their problems, right? No. It was wrong of me to even insinuate that on my homepage when I ranted that one day, and I apologized and recanted noisily because it's irrational, unreasonable, and dishonest to do so. -- DaveFayram

Doctrines of responsibility are a very subtle thing. In fact, I *am* responsible for all the incompetent designers out there. And *I* am doing what I can about it. Presently, that's explaining what design is and what it is not to programmers so that ''they'' may in turn do something about it. In future, I may be able to do more and I'm planning for it too.

Now, if we ask what you're individually responsible for, for the state of programming then it is this. You are responsible for collectivizing with like-minded programmers. You're responsible for setting up and developing revolutionary cells. There are plenty of very good programmers here on wiki and elsewhere who could get together. Are there enough to make a force to be reckoned with? What strategies could they use? Which ones would be effective? I don't know these things but I know that the first step is getting together and deciding to do something about the problem. Nothing will ever get done by atomized individuals. -- RK

Well then I don't feel so bad. If my job is to educate my peers, I am doing that slowly. Now if I could just get them away from CORBA. :\ -- DaveFayram

Design up front isn't working for you, either, since it's taken you 10 years to produce jack all. How about you prove your competence as a designer before we take any more crap about how every single programmer is incompetent and brain damaged and actively works to make hateful software?

''If you're not interested in what's wrong with the programming industry then it's easy enough for you to avoid reading it. Don't be an asshole by trying to tie together completely unrelated issues. People who have nothing meaningful to say shouldn't prevent others from doing so. -- RK''

You have nothing meaningful to say, RK. That's what several people have been trying to tell you. The two issues are very much related. You have accused others of being unprofessional and criminals for not conforming to your "vision" of how software should be done. But your vision suffer the obvious flaw that it has led nowhere fast. So if you do not see how the two are related, you really have a problem. 

Simply put, you have no standing whatsoever in this discussion, unless you can prove that either by yourself or as part of a team, you contributed the least useful working piece of software. -- CostinCozianu

And let you deface wiki with stupidities like ProgrammersAreCriminal and ProgrammersAreNotProfessional? I'd rather let you succumb to one more of your depressions. -- CostinCozianu
----
Could you guys slow down? I'm still working on what the definition of "is" is. I don't work on the idea of "idea" until next week. -- gh
----
This page is TooLargeToGrasp. If ''you'' don't refactor it, I will try a SurfaceRefactoring. -- .gz 

''What about a SortRefactoring?''

* Perhaps all the material on OperatingSystems could be moved elsewhere?  It's an interesting discussion, but not very relevant to this page (which has become a ghastly ThreadMess)


----
This whole topic is reminding me why ProgrammersBuildingBuildings is not a good idea.
----
See: SoftwareEngineeringCriticism, MayZeroFive, RichardKuliszFanClub

CategoryProfessionalism, CategoryRant