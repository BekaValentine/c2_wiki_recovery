A ComputationalLanguage, if one were to exist, would be a language that makes primitives of the fundamental components of computation (as opposed to FunctionalLanguage''''''s, which make primitives of values and calculations, and ImperativeLanguage''''''s, which make primitives of actions and schedules).

Computation is the process of calculation, and is the fundamental thing done by computers.  Processes are series of actions, and calculations are transformations over values -- substituting equals for equals.  Since all actions are based upon communications, and the content of any communication is a value, a ComputationalLanguage needs to make primitives of both communications and calculations.

----

From BadEngineeringPropertiesOfFunctionalLanguages

EwDijkstra once said: '''Computing science is no more about computers than astronomy is about telescopes.''' Functional languages make a point of '''not being''' about computers.
* Unfortunately, functional languages aren't even about computing. ''Computation'' involves both '''calculation''' and '''communication''', and functional languages only describe half the job. While such a language is useful for mathmaticians, it's not a redeeming feature for forays into computing science.
* ''You have a peculiar notion of "computation" -- you speak above about CPU and electrical impulses, as if they matter (- as per Dijkstra they don't). Also a peculiar notion of computing science. So what are your sources ?''
*I had an issue with someone calling a CPU an ''emulated'' computational environment. The electrical impulses, CPU, hardware etc. create a ''real'' computational environment. It has all the necessary components -- communication, storage, transformation, values, and value representation. If it were emulated, the CPU would need to be running on top of something else. CPUs, Human Brains, and many Human Systems (e.g. paper-pushing bureaucracies, ChineseRoom), all qualify as true computational environments. As far as my sources: look to a dictionary. ''Computing'' is the '''process''' of ''calculation''. A ''process'' is a ''series of actions'', and the only actions any closed process may ever perform are ''communications'' with an environment that said process can't even deductively proves actually exists (read up a little on Solipsism). ''Calculation'', itself, boils down to its natural mathematical foundation -- simple transformation of ''value to value'', substituting ''equals for equals''. Computing science, naturally, is the empirical study of computing: the study of the process of substituting equals for equals. As such, it is a study of both '''calculation''' and '''communication'''. This is all obvious, natural, and fundamental. I expect that your own notion of computing science isn't in conflict with mine... but it might be incomplete and/or from a different perspective.

