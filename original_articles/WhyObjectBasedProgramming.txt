''Part of the ObjectBasedProgramming pattern language'' 
*** http://msdn.microsoft.com/en-us/library/dd460654.aspx
----

Although procedural languages do not provide special support for the fundamental object-oriented concepts such as encapsulation, inheritance and polymorphism, they generally do not preclude the implementation of such concepts. As a testimony to the flexibility of the some common procedural languages, the earliest C++ implementations are typically C++ to C translators (CFront) coupled with some additional libraries to provide the necessary run-time support. 

There is nothing to stop a programmer in any non object-oriented language to do the same, to extend the language so to speak. However this holistic and generic approach does not address the issues also associated with a full-fledge object-oriented programming languages. Even with the significant advances in the compiler technology, there is still an obvious performance and code-size penalty associated with object-oriented programming languages.

A different approach to implement an object-oriented design is to use abstract data types (ADT). ADTs offer encapsulation and abstraction. Programming using ADTs is also known as object-based programming. Even though ADTs do not directly support inheritance and polymorphism, these concepts can be layered on top of a ADT implementation with some minor effort. In other words all important OOP concepts can be implemented in OBP. Translating an object-oriented design into an OBP implementation can be straight-forward, as there is typically a one-to-one mapping between a class and the corresponding abstract data type. However as performance is usually an important factor in embedded software development, a naive implementation may not be sufficiently efficient. Some optimisation may be required. It is here OBP shows a critical advantage over OOP in an object-oriented programming language for embedded software development, as an implementer is given much more freedom. The OBP implementers is free to select appropriate underlying mechanisms to support the object-oriented concepts (especially polymorphism and inheritance) to match the domain characteristics. An OBP implementation can be as efficient as a traditional procedural implementation. 

Discussion occurs on WhyObjectBasedProgrammingDiscussion.
