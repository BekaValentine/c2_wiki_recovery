I am bothered by what I see as a lack of precision in software engineering, yet see practitioners promoting concepts as if they were mathematical proofs. My favorite techniques are not in style right now, yet when I complain, I am given vague justifications for the in-style stuff. 

It is one thing to say that I was simply outvoted by alleged popular demand, but another to '''pretend''' there is any rigorous science behind it. I expect that from managers used to fuzzy logic and buzzword-based persuasion techniques, but not from well-educated professional technicians.

----
An assertion like this is easy to make, but it sounds a lot like the "vague justifications" you're talking about.  Would you care to back it up with some examples?

''Examples of specific people saying specific things? That would risk a FlameWar. I don't want to point fingers if possible. Browse some HolyWar topics if you want some examples. Most of these seem like personal preferences, but some seem to insist that one position is objectively superior.''

Not specific people per se, but it seems ironic to me to make a vague complaint about fuzzy thinking without backing up your premise at all.  "People are doing bad things, and I don't like it."  True, perhaps, but it can hardly lead to a useful discussion or strategy without more specifics.

''Well, okay, I will go out on a limb and say that many UML and XML buffs are an example of such.''

----

(I don't believe the deletion was justified...)

I'll step in.  I happen to agree; I've recognized a great deal of buzzword-based movements in programming paradigms.  Among them is 'ObjectOriented', which still lacks any rigorous meaning, and 'XML', which is a cheap and voluminous approach to structured data encouraged largely due to its similarity to HTML and marketing buzz.  

The greatest advances I've seen in the computer sciences do, indeed, arise from true mathematical proofs: lambda calculus, pi calculus, actors model, category theory, typing systems and type-inference, and the relational model.  Luca Cardelli and others have done some work on truly understanding objects and their inherent partner (views of objects), but that is still in the preliminary stages.  For now, I'm stuck with C++ and XML in my workplace, and left desperately wishing that C++ had a turing-complete macro-system with support for true functional programming and partial-evaluation-optimization in place of its current templates.  -sigh-

On the other hand, I think it's wonderful to be part of this young field and seeing it grow.  C++ is popular now, flaws and all, but it has come a long way with its template support.  In fifteen or twenty years I imagine my tools will have advanced much further.  There are so many jobs where the tools are pretty damn close to what they were a hundred years ago.  In Computer Science, this is not the case, and I can remain quite optimistic about the future.

----
See also: DisciplineEnvy
