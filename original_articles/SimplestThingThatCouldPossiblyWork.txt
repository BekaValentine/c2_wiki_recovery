See: DoTheSimplestThingThatCouldPossiblyWork


Quoted from 1X Forth by Chuck Moore...

http://www.ultratechnology.com/1xforth.htm

Don't Complexify ''[in British English that would be: "Don't '''Complicate'''", which is a less complex word, I think]''

''--I think "complexify" was intended irony''

Simplify the problem you've got or rather don't complexify it. I've done it myself, it's fun to do. You have a boring problem and hiding behind it is a much more interesting problem. So you code the more interesting problem and the one you've got is a subset of it and it falls out trivial. But of course you wrote ten times as much code as you needed to solve the problem that you actually had.

Ten times code means ten times cost; the cost of writing it, the cost of documenting it, it the cost of storing it in memory, the cost of storing it on disk, the cost of compiling it, the cost of loading it, everything you do will be ten times as expensive as it needed to be. Actually worse than that because complexity increases exponentially.

10x Code

10x Cost

10x Bugs

10x Maintenance

Ten times the bugs! And ten times the difficulty of doing maintenance on the code as is amply illustrated by the Y2K bug. In fact it curious the fixes that I see people making the COBOL programs to fix the Y2K bug make the programs signifigantly more complex and larger and introduce spaghetti code that can't be maintained and is probably going to fail again in fifty years they are just using windows. They are not increasing the range of the date they are merely shifting it so that is going to lead to another problem when that window runs out.

This is why we are still running programs which are ten or twenty years old and why people can't afford to update, understand, and rewrite these programs because they are significantly more complex, ten times more complex than they should be.

Unfortunately, life is NOT simple, almost any real world problem requires a complex solution.  Just because something works today, doesn't mean it is going to work tomorrow, and complex code which is equipped to handle the problems of tomorrow is better than simple code that works today but fails tomorrow. . . I'm playing the devil's advocate -- but seriously.  
----
CategoryOrganization
