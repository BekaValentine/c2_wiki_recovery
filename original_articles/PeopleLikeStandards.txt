PeopleLikeStandards with a definite structure:

Standards are not always the best solution though.

This trait of liking standards with a structure usually means a technology will become more mainstream, faster if:
*it has a major website where users can swarm to and read the manual. One place. Not lots of places (PHP, HTML (W3C), XML). 
*Walmart is another example. One store, one place. People like this, rather than having to go to 6 different stores to get what they need.
*it has one major tool that people use. Examples: Visual C++, Excel, PHP (one major installation), Windows (not several distros like Linux), RTF, DOC format.

Examples of structured standards that people gladly swim to and crawl all over:
*PHP
*HTML
*XML
*C++
*Win32 API
*Windows.
*Linux Kernel 
*Doc format (microsoft word).
*RTF format 

Some of the standards are better being standards, due to the fact that we need some structure in order to be anything. Example Linux Kernel.. without this, people would be disorganized. Without HTML maybe we wouldn't have all this information on Google. But there are disadvantages since people have this trait. For example, due to this human trait of falling for structured standards, too many people get sucked into PHP, XML, html, windows when they could have looked into the more unstructured CGI, general parsing, alternatives to HTML, Linux distros, etc.

Examples of standards or methods that people do not crawl all over, because they are too general (but useful and sometimes better solutions):
*CGI
*Parsing files (instead of always using XML)
*Linux Distros. Too many to choose from. Windows only has one major consumer release, not several distros.  But once you find one distro..
*Compiler. Most times a compiler is generic enough to make a tool that you need quickly, but instead people resort to a scripting languages because the scripting language has more rules and structure, and probably one major online manual. It's quicker in the short term to use a quick scripting language, but in the long term maybe a generic compiler will be more advantageous.


----
EditHint: Perhaps merge with WhenAreStandardsRestrictive

''We could, but this also focuses on discussing the "human trait" of falling for standards, rather than discussing solely the restrictions of standards. --Lars''