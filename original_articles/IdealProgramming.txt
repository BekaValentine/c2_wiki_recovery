That fantasy project each of us carries around inside our head where we work with:

'''A team of people just like us'''
	*Who know how to use the tools and know why our favorite tools are the best.
	*Who write code others can actually read and not mistake for stream of conscious.
	*Who never check in their "small change" without running the full set of Unit Tests.
	*Who don't confuse "simplest" with "easiest."
	*Who don't get defensive (or offensive) when something is broken; they just fix it, if possible.
	*Who really like programming.
	*Who appreciate a strange sense of humor (and understand the difference between "strange" and "dangerous").
	*Who are strong enough to stand up for their ideas but flexible enough to get along with others (no CowboyCoder''''''s!).
	*Who would never, never, never write smelly code.
	*Who are different and interesting in some way when we're down the pub. 

'''Sane users'''
	*Who know exactly what they want and how to communicate it.
	*Who never change their minds, or at least avoid going in circles.
	*Who don't mind waiting while we finish that "one last tweak."
	*Who know when to say "Wow, how did you do that?"

'''Good management'''
	*Who fight for the resources the team needs rather than fight the team.
	*Who appreciate "good clean source code."
	*Who don't need hourly status reports to believe that I know what I am doing.

'''Perfect tools'''
	*Which never crash just before I save (or, even better, don't crash at all!).
	*Which operate just like the manual (and marketing material!) said they would.
	*Which work with me rather than forcing me to do it their way.
	*Which remove ALL of the drudge work (but leave the good stuff).
	*Which understand what I meant (no matter what I said).
	*Which don't require too much effort to learn but do reward experience.

IdealProgramming is often synonymous with "the way we will do things NextTime."

Feel free to add your own elements to this fantasy (within the bounds of good taste of course :-))!

----

I'd add or modify some of the above. Some of them I don't need, such as a specific editor, or a team with a better-integrated psyche than my own. On my team we would:

	* Write code that expresses every idea it needs to express (definition of DoTheSimplestThingThatCouldPossiblyWork)
	* Keep all UnitTest''''''s running at 100% for every developer releases
	* Welcome user changes because we can program anything
	* Give ourselves minute-by-minute status reports using the UnitTest''''''s GUI
	* Give management continuous status reports with FunctionalTest graph, ReleasePlanning, ExtremeReporting
	* Use tools that allow us to change how they work and fix their crashes if any. (Can you say Smalltalk?)
''Hopefully you will forgive me for pointing out that your "fantasy" sounds a little bit like bragging (although the two are often related :)).  I'm afraid that if I did all of the stuff you have suggested I would have to get a new fantasy  :-o. -- JeffShelby''

----

Okay, this is fantasy, but it's not realistic to assume that nobody will make mistakes. Am I looking for a realistic fantasy? Is that a paradox? In any case, I'd replace the stuff about people being perfect with something along the lines of:
	* Everyone uses unit tests and everything gets tested
	* Nobody gets defensive when something is broken; we just fix it
	* Even if we have different ideas about what works or is best, we all buy into whatever process is used to make decisions, and stand by those decisions.

Also:
	* Everyone has the same approach (a good one!) to documentation
	* We use the documentation continually (what good is it if you don't?)
	* Everyone is different and interesting in some way when we're down the pub (i.e. team is cohesive even away from work)
-- NeilGall

OK, I can see that a fantasy needs to be (marginally) plausible in order to be enticing.  Maybe I just had my tongue a little too firmly planted in my cheek with the original list.  How do you like the updated version?  -- JeffShelby

----

And, we never have to deal with bugs in
	* the IDE
	* the compiler
	* third-party libraries
	* the operating system
	* the networking code
	* the server

-- KeithRay

Keith, are you writing your own (see above)?  Or are you severely optimistic? -- WyattMatthews

How about just: we never have to deal with bugs in anything we don't have the source code for? -- DougKing