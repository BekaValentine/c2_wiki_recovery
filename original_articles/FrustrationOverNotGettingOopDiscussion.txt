TopMind claims to be frustrated by the popularity of ObjectOrientedProgramming and what is seen as the lack of evidence supporting it. OO fans say there is plenty of clear evidence, but to others the evidence seems to be: vague, based on faulty assumptions or extrapolations about how the human brain works, or about how the real world changes over time.

''Why do we keep humoring TopMind? Seriously. What is it we feel we need to prove? I'm so tired of watching this fight (and it didn't start here). And, in the end, what do we gain? TopMind ''is not interested'' in changing his views. This should be ''obvious'' by now. I will grant to TopMind that ''a plurality'' of business applications are nothing more than data pushers. He's right: an RDBMS is the best fit for this type of application. As OO programmers, we ''do'' sometimes make these applications more complex than they need to be. But I also know that I can't use an RDBMS to build the PDF toolkit I'm currently working on, or the pre-press systems I'm designing. I don't ''care'' if TopMind knows this. He has ''admitted'', on several pages, the domain he's knowledgeable in is ''custom business applications''. Let him live in this world. I'd rather see the energy devoted to these fights redirected to more meaningful discussions. Just my opinion after having watched this for several months. -- JeffPanici''

After having done this for the last several months. I now agree. Truth is he fooled me into thinking he just didn't understand several times, so I kept coming back trying to clarify. I can't help but help people when they seem interested in learning. I now realize he's just a troll and has zero interest in learning anything. I'm done with him; this mess has been deleted.

''Well, Oracle isn't written in PL/SQL, is it?''

It is probably written in C. I never said P/R is ideal for systems software.

''It is written in C, according to a friend who worked there. Originally limited to 6 character function names as well. They have made some changes since then. Apparently, they started using COM a lot, and have also gone into Java in a very big way.''

{Incidentally, being written in C is sometimes considered one of the reasons that Oracle beat its early competitors: it allowed Oracle to migrate to different platforms faster than its competitors. I have not verified this, however.}

Minor addition: at the time that Oracle was initially implementing an RDBMS based on the IBM white papers, external C symbols were '''required''' to be no more than 6 characters; that is not some kind of weird practice on the part of Oracle, it was just the nature of the language at the time. I'm not sure why mentioning "6 character function names" is apropos here, considering that. I have no axe to grind here, I'm just reporting history that I lived through. I don't really see what PL/SQL, C, nor 6-char identifiers have to do with any of this, though, and I DO understand all of these topics, so maybe somebody should just trim all these topics down. I think the underlying issue was the usual: that relational thinking is not identical to OO thinking; but be that as it may, 6 char identifiers in the early history of C have nothing to do with that. It is utterly unrelated.

''Some people seem to believe that a language or technique should be applicable to everything in order to be considered "good". In other words, if approach A is bad at domain X, then it is probably bad at all domains. I don't agree with that, nor am I sure that is what they meant, but that is how I interpret it.''

----
Delete - Corrupted by vandals
----
if you wish to regurgitate this page, visit http://c2.com/wiki/history/FrustrationOverNotGettingOopDiscussion
I don't think it was vandalized, it sounds to me like someone got fed up with the "Yes It Is" "No It Isn't" style discussion present on this page.

It was an attempted discussion, which never panned out and created no useful information. I should know, I wrote about a third of it, and I deleted it. Had it created any signal I would have left it, but it didn't, and it led to many other pages, all adding noise not signal.

----

Copied from OoPeaceAccord:

There were some valid points in the topics deleted. If the deleters don't want to spend the time cleaning up the material, then they should leave it alone. You cannot just take a shotgun to everything you don't like. '''Be a fixer, not a complainer, nor a destroyer'''. 

------

'''Topmind's Side of the Story'''

Regarding the recent deletion mob, it is clear that I am not liked on C2. This is not surprising because C2 is a pro-OO group by design, and being a minority in ANY such group is asking for arrows in the back. A fundamentalist in a pro-evolution group (and visa versa) will receive very similar treatment. It is the same pattern. Thus, I don't take it personally. But, GroupThink usually wins out in such situations. The minority is usually pummeled with personal attacks and character assassinations.

''Your choice of "a fundamentalist in a pro-evolution group" is a supremely appropriate choice (and '''not''', I might add, vice-versa). The "pro-evolution group" works from "science" as best it can. It perhaps imperfectly comes to a consensus that evolution is good science and that fundamentalism is not. A fundamentalist who continues to repeat the fundamentalist dogma, who appears to be unable or unwilling to accept the theory of evolution accepted by the group, and who proceeds to endlessly harp and rehash the same ground over and over - contributing no new information and blocking the rest of the group from moving on - will, sooner or later, receive the same treatment Top has been receiving. As the members of the group grow weary of the exercise, they will sooner or later ask the fundamentalist to please be quiet - and will, if ignored, eventually summarily exclude them and stop listening. This appears to be what this community is doing with the handful of anti-OO agitators. I, for one, am similarly weary of seeing the same tired ground rehashed over and over again. I think it is time to clean house, delete the obstructionist material, and move on.''

{Science is not on the side of OO. Back to the analogy, though. Being a pro-evolutionist myself, I still see the Christians mistreated from time to time using "majority" bullying techniques. They get locked into "contests" over whose motivations are most biased rather than focus on the evidence itself. Being right does not necessarily make the evolutionists fair nor good at diplomacy.}

I have noticed that Wiki tends to be anti-open-evidence, or "anti-science" for short, preferring authoritative and anecdotal evidence instead. I don't expect math equations and test tubes to demonstrate its power, just typical scenarios and code. But, anecdotes and wikizen votes seem to dictate content in the end. "Why won't you respect my experience?" was a frequent complaint. If wiki wants to be authoritarian instead of scientific, that is fine with me as long as you understand and face this nature. The danger is that different ways of thinking will tend to get pounded down over time.

I honestly tried to focus on specific code and requirements examples, but the topic always somehow drifted away from the examples and into "mantra fights". I don't know why there was always such a drift. Perhaps it is my fault, perhaps yours, perhaps mutual fault. I don't know yet. I will go back and analyze prior discussions to see if I can find the point where things got derailed.

There are certain patterns to some of the accusations against me, and I will address the common ones below:

'''I Won't Listen''' - I am not sure exactly what you guys mean by this. I read over many of your examples, descriptions, and claims multiple times. They were generally not usable information from my perspective. Often it was just the same OO mantra over and over. Repetition of mantra only works to a point. Yet when I countered with my own mantra, the room erupted with "troll! troll! troll!" chants. Double standards abounded.

'''I Ignore Concrete Examples''' - No, I did not. There were none. Either your point about them was not clear, or you assumed change patterns that I don't find that likely. That is not ignoring them. Some of you would also make claims and then never come back to see my counter reply. If there was a solid point in your examples, I honestly truly did not see them. Swear to God, Buda, and all the good deities. Several times I asked for clarification or a rewording without response.

'''I Only Want To Stir Up Trouble''' - You are not mind readers. You don't know my internal motivation. If I truly wanted to stir up trouble, I would randomly change small bits and pieces of signed text in multiple topics or join the Booger Club. I truly want to figure out why you guys think OO is so great. I see nothing special about it. It has clever mantra, but it does not float upright in the real world as I see it. Its mantra often assumes too simple patterns to a complex world.

A typical example of the type of treatment I received at this wiki went something like this:

Me: "Polymorphism often requires a stable sub-type taxonomy to work well."

You: "Polymorphism and inheritance are two different things. That fact that you confuse the two demonstrates how ignorant you are of OO".

Me: "There are multiple kinds of polymorphism. I did not say ''all'' polymorphism required sub-types."

You: [Change subject without any apology.]

If I did a similar thing, I would be verbally lynched. Again, a double standard. Often I was trapped in no-win situations. Some complained when I repeated similar ideas, yet others complained when I created new topics so that I could reference instead of repeat them. Second, some complained that "table oriented programming" was not defined well enough (neither is OO, I would note), yet another said that it is really "just common procedural with databases" and does not deserve its own paradigm name. When one is slugged for being black, kicked for being white, and shot for being gray, you know you are in a rotten town.

You guys pull this kind of crap on me often, and then expect me to believe you when you suggest all the problems surrounding my opinions and content are my entire fault?

I have concluded that OoIsInTheMind. It does not readily produce concrete, quantifiable benefits such as less code, less repetition, and less change-points per change request under real-world conditions. After many years of debates here and elsewhere, nobody has produced a concrete business example of quantifiable benefits (perhaps in systems software such as device drivers, but not biz). When pressed, your examples or claims almost always ended up pointing toward "mental conventions". The only conclusion I can draw from lack of quantifiable improvements is that either OO rots the articulation lobes of the brain, or OO is just something that makes your mind feel comfortable, for whatever reason. Why it makes your mind happy and comfy, I have yet to figure it out.

One of these days a new paradigm "fad" will come along with all kinds of clever mantra to challenge OO. I don't think OO will be able the weather it because it does not stand up well to non-anecdotal scrutiny. If you don't stretch your science muscles, they will eventually rot and wither. Good evidence would be independent of me and my alleged vast personality faults.

''Can you specify a business domain you feel would be a fair comparison to your techniques? Banking, insurance, trading, manufacturing? Pick one of these and then perhaps we can talk.''

{I have proposed CampusExample, being that it is something most readers can all relate to.}
----
My $.02, because I'm avoiding working on something else right now...

I won't debate over whether "OOP" is good or bad. Deconstruct the goop called OOP and I'll be happy to give you opinions on its common aspects. Polymorphism -- good. Behavioral inheritance -- see polymorphism. Structural inheritance -- handy. Syntactic association of data and related behavior -- useful. Encapsulation -- mixed bag. Object identity -- chimerical. (Address == key, but local to process. When you need persistence or sharing, it's not good enough, otherwise it's handy.)

They're all tools for organizing code. More tools is more good. Woodworkers know this. :)

* Not necessarily. Ideally we want a compact tool kit due to training issues, installation simplicity/costs, etc. Thus, our tools should be as orthogonal as possible. We don't want five ways to turn bolts when one or two will do. See MixingParadigms.
** Sure we do.  I've got sveral pairs of pliers, a set of fixed wrenches (English and metric units), monkey wrenches, socket wrenches, a pair of pipe wrench, a torque wrench, and a can of WD40.  Of course, it all depends on what you do--if all you need to do is loosen the occasional rusted nut, then one or two of the above will work fine.  If you're a professional plumber, mechanic, or carpenter; you'll likely need all of the above and numerous others I didn't bother to mention.  Most of us, I think, are professional programmers; having multiple tools with overlapping uses, but opimtimized to a specific task, shouldn't faze us in the slightest.
** ''But the analogy ends there because in software the "tools" stay in place. It is hard to master 10 paradigms. Plus, one cannot fit all those in a portable tool kit very well.''
** Heh, you can criticize the analogy, but not based on fitting tools in a toolkit. Software tools weigh nothing and require no space. :) The differences between most of these tools do not constitute "paradigms", but rather techniques. You should have dozens and dozens of techniques in your repertoire after a few years of programming.
** ''But I feel it is better to master a few paradigms than to stumble around in 10. Maybe some people are capable of mastering all 10 before they retire, but that is probably a minority of developers.''

Quantification of the advantages of these small tools is difficult. Like any tool they might work well or poorly for a given task. And some people will find the application of a given tool intuitive, or not, depending in part on their familiarity with the tool. It also really, really depends on the task at hand, and how to arrange code for both understandability and maintainability (which don't ''always'' go hand in hand.)

BTW: The best tools are the ones that make it easy to build more tools. :)

''Further, nobody agrees on WhenToUseWhatParadigm.''

Nor do they need to.

''If one claims there are objective benefits to each for certain situations, then consistency would certainly help that argument.''

-------------------

(Moved from DatabaseNotMoreGlobalThanClasses)

Some very revealing statements:

''"OO and XML is something people give lip-service too in order to look hip. What they really want deep inside are web apps that are built and run like VB, for good or bad."''

First, let's keep OO and XML separate. They have nothing to do with each other. Second, who are these people that want apps that are built like VB? What about the rest of us, who have used VB and never enjoyed it? Are you really saying that no-one actually prefers OO, they have just been brainwashed by hype, or worse, are actively conspiring to hype this paradigm?

* ''I am just saying that OO has more lip service than production code. Even may OO proponents make the same complaint. They will say something like, "The vast majority of programmers think they know OO, but really don't."''
* [That's true, but you can't blame OO for ignorant developers who think they're doing OO.]
** I blame lack of consistency (OoLacksConsistencyDiscussion).
* You're saying much more than that. You're saying that "people" (implying all people) "want web apps that are built and run like VB", but they are unwilling to admit it. Where do you get this information? Where is your proof?
* ''The preference observations are based on personal anecdotes. I don't have objective surveys, and neither do you. Thus, we should just AgreeToDisagree on that.''


''"As long as OO keeps acting like it is better, I will continue to pressure it to produce objective benefit evidence."''

OO can't act like it is better than anything else. It's just a programming paradigm. Some of it's evangelists act like it's better than anything else, but it's easy to ignore them.

It sounds like you've been personally, perhaps emotionally, injured by an OO evangelist. Have you?

''Irrelevant. Where is the evidence that OO is objectively better and/or less global than databases? Next to Saddam's WMD?''

[The evidence is in personal experience, since you don't do OO, and don't practice OO, you'll never have the experience necessary to see for yourself. You keep wanting someone to prove it to you, but that's not how it works, like any other skill, OO takes practice and experience to grasp. The light only comes on via practice, build 4 or 5 production applications in OO and you might start to get it, until then, you have no place to criticize something you clearly don't understand. Having worked on many applications both procedural and OO, and having started out a procedural programmer doing all the same stuff you always preach, I can tell you, I'd choose the OO app every time, they're simply better as far as I'm concerned. In my experience, they are easier to work with, less buggy, easier to change and evolve, and require less hand written code, easier to enforce business rules on, I could go on and on and on... but it'd make little difference, because you don't have the OO experience to get it, and you never will because you refuse to open your mind and simply try it out for a while.]

''So, you are saying that you cannot provide printed evidence with change-scenario impact analysis, etc? It is ONLY a feeling and can ever only be a feeling? I get email all the time from people who tried OO for a good while hoping they would finally "get it" but don't feel it. But, then find my website looking for answers to their OO blues and realize that its the paradigm, not them that is lacking. I have also lived with the DocumentObjectModel for years, and I still would like to flush it. After 50 years will I finally like DOM? If I ever finally "get" OO, but cannot articulate its benefits clearly, then I deserve to get trolled by someone like me. F*ck feelings, I want to see science, dammit! What has software engineering turned into?''

[My god man, you call yourself a programmer? You should learn every single paradigm simply for the fun of it, you should enjoy radically changing the way you think about things for the insights different points of view can offer, and also for the fun of it. You've got to get over this evidence and proof thing, and start programming more, it's not all business man, it's also a hobby, and you gotta learn em all, and enjoy using them all in their appropriate contexts. You gotta learn multiple languages as well as multiple paradigms, don't you ever just want to try everything out?]

If you're willing to fund change-scenario impact analysis, I'd love to work on that. Until then, I've got code to write and I'll use the techniques that work for me. I've articulated OO's benefits repeatedly, as have many others on this site. You don't want to see science. You want to vent your frustration.

* Most of their evidence either boil down to non-natural change pattern assumptions or personal psychology. Do you have any favorites you would like me to review?

(moved material to IsDeclarativeLessExpressive.)

''So all you kings and horses CANNOT produce external evidence, such as code and change impact scenarios, that clearly shows OO's benefits? It just plain cannot be objectively demonstrated to any significant degree? Don't you find that odd? Have we abandoned science and don't care??? I find it bizarre that you all tolerate such a situation. '''What use is wiki if all we have is "feels better", "does not feel better", "does too feel....".''' Might as well just put up a voting form and cut to the chase. ''

[Programming has never been science, it's a craft, and it's a craft limited only by the programmers mind, the fact that some want it to be a science doesn't change the reality that it isn't a science. With all the effort you've put into trying to discredit OO, you could have learned several new languages and several new paradigms by now. If you'd done so... you wouldn't be having these silly arguments. Open your mind man and learn, learn OO, learn functional, learn smalltalk, learn lisp, learn ruby, learn java/chsharp, see how they all use different subset's of the same few features, see why some are more expressive that others, why the futile effort to discredit OO, a paradigm that dominates the industry and you have no hope of changing?]

* And you could spend some time trying to come up with a non-anecdote way to objectively demonstrate your favorite choices. Articulation is just as useful a skill as knowing 20 paradigms. I have had enough of OO. It is nothing but a BigSoupOfClasses with nothing beyond the "class" for organizational purposes, except "patterns" which are usually trivial under relational techniques. If I explore further, it will be FP, CollectionOrientedProgramming (outside of RDBMS), TCL or the like, not more OO. I have already given it long enough. Time for other paradigms. Why should OO deserve a long try at the expense of others? OO would fail in a courtroom if one claimed it the best general purpose paradigm. You have no real evidence, only anecdotes.

I find it bizarre that you ignore the published evidence and fail to see what is obvious to everyone I've worked with for the last 15 years.

* ''What published evidence? Why is it not listed under OoEmpiricalEvidence? OO projects fail just as often as non-OO ones. Your colleagues may not be representative because CompaniesHireLikeMinded.''
* Where are you getting your data on project failure? Why is that your only criteria?
* ''In chapter 3 of "The Rise & Resurrection of the American Programmer" (1997?), page 63, Edward Yourdon gives some statistics about IT manager satisfaction surveys. OO scored no better than the average.''
* The book was published in 1996. Do you have more recent data? And why is that your only criteria?
* ''There are not a lot of decent studies around. That is just the state of things. The Jones study, which claims to show OO results in less code, did not release the source code. Plus, SQL scored pretty high in it.''

You seem obsessed with the popularity of OO. If you don't like it, ignore it. No-one is going to make you use it. If they try, tell them to go away.

''They'll just say, "If you are not going to be a team player, then we might as well outsource your position to Timbucktoo for 5 cents an hour."''

[Sounds like you're just pissed off that you don't get it, and can't do OO. Learn it or be replaced, seems fairly simple. If you have any talent whatsoever, you'll simply learn it, like it or not, it's what people are willing to pay for, so if you want their money, give them what they want.]

* This seems to contradict the "don't let them force things on you" suggestion above. Now it is "buck up and swallow your bitter pills". However, this is all irrelevant. There is no evidence OO is globally objectively better. So, why shove black arts down people's throats?
* ''Who is shoving black arts down your throat and why are you letting them?''
** It's real simple top, you say companies want you to use OO, you either convince them otherwise, or don't take the job. If they want OO, then they've seen convincing evidence, if you can't convince them otherwise then that's your problem, and if you need the job, then you do OO because that's what they are willing to pay for, period. If you don't like it, then don't take the job. I build many stupid things because people think they want it, even when I know better, because they can't be convinced it's not needed. That's standard business practice IMHO. I do my best to present the truth to the client, but in the end, it's their money, and they will get what they want, even if what they want isn't what they need.
** ''PointyHairedBosses don't give a rats ass about logic. Look how long it took DrCodd to get IBM to buy into relational. If Oracle didn't start eating into IMS sales, IBM probably would have never budged. I am trying to sell TOP concepts to the (hopefully) intellectual crowd.''

Then go someplace that doesn't use OO or start your own company. No-one can make you use object-oriented programming.

''And if Donald Trump says "Use OO or you are fired!"?''

-------
See also: GoodMetricsProduceNumbers
----
CategoryDiscussion