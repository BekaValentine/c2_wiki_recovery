The opposite of SuperOverGeneralized. Hard wired, no configuration parameters, numeric literals scattered throughout the code. Difficult to specify (in excruciating detail), too much (and probably ill-understood) problem domain knowledge built in, expensive to develop, hopelessly difficult to evolve, unlikely to meet original specifications before the real world changes ahead of it. --JimRussell

Contrast: DataDrivenPrograms


Rather than defining extremes, I think we should recognize that software programs contain both over- and under-generalization.  This is sort of the basis of refactoring, the recognition that we will never have the correct balance, but we can continually adjust the software as we see fit.