''NOT a language for a RealProgrammer.''

A programming language that meets some minimum standard of practical usability for writing 'real-world' software. Examples: CeeLanguage, CeePlusPlus, CeeSharp, JavaLanguage, SmalltalkLanguage, CommonLisp, PythonLanguage, PerlLanguage, RubyLanguage, RpgLanguage, CobolLanguage, FortranLanguage.

Languages that aren't considered 'real' typically fall into one of these categories:

* EsotericProgrammingLanguage''''''s -- InterCal, BrainfuckLanguage, etc.
* Non-TuringComplete languages -- there are some things these languages just can't do.
* TuringTarpit''''''s -- A Turing complete language, so it can do everything. It's just very hard to get it to do anything useful.
* TeachingLanguage''''''s that are only really useful for teaching, e.g. QuickBasic, LogoLanguage, MmixMachine.
* 'Academic' languages intended only to explore a concept, prove a theorem, form part of a thesis, etc, like some of the early pure FunctionalProgrammingLanguage''''''s. However, there are examples of such languages that eventually became 'real' -- e.g. MlLanguage -> ObjectiveCaml.
* Once-popular but now 'dead' languages. A language might be dead if the only people who use it are grizzled old hackers and shell-shocked-looking maintenance programmers. Sometimes these grizzled hackers realize that their "dead" language is technically superior to popular new languages -- see http://c2.com/cgi/wiki?search=smug .
* Special-purpose languages, e.g. word processor scripting languages or shell-scripting languages, that aren't realistically usable for writing significant software. ''Though that hasn't stopped many from doing so!''
* Very LowLevelLanguage''''''s -- (plain) Assembler, Machine code, (any other examples?)

----

Another common meaning of the term "real programming language" is "the language I use", with the implied put-down that "only an idiot would fail to see its inherent superiority to that lame language that you use".
See
SeriousVersusScriptingLanguages,
WhatsaPissingMatch
.

More mature programmers realize no one ProgrammingLanguage currently in existence is the best for every one of TheManyTypesOfPrograms.
But that doesn't stop the more idealistic of them from hoping that such a language might someday arrive.
Some programmers even develop new, improved languages on their QuestForThePerfectLanguage.
If that language ever does arive, one hopes that it will become the FirstTimeLanguage.

* Smart programmers go on to develop a language that isn't perfect,  since EverythingSucks. Trying to develop something perfect leads to an infinitely incomplete project that never gets completed.

Mature programmers realize "the" best language to develop a particular application
is often some combinations of languages:
AlternateHardAndSoftLayers, SymbioticLanguages.


----
CategoryProgrammingLanguage
