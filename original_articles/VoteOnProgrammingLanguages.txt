I've read too many pages describing how awful one language over another is. It's to the point where it seems to ''all'' suck, but what I'm not seeing is a debate on what languages you all prefer and why? What are the high points of these languages? Forget what you don't like about them for a moment and give a vote on your favorites:

''I'll take that as an indication that one may vote multiple items.''

[if one is missing then please add it]

 AbapLanguage -1
 AbcLanguage 0
 ActorLanguage 0
 ActorLanguages 1 (not a specific language, but I'll vote for all of them)
 AdaLanguage 2 -1
 AllaireColdFusion 1
 AlephLanguage 1
 AplLanguage 1
 AspectJavaLanguage 1
 AssemblyLanguage 8 -1
 AwkLanguage 5
 BasicLanguage 3
 BetaLanguage 1
 BistroLanguage 0
 BourneShell 3 -2
 BrainFuck -2
 BrainLanguage 0
 CeeLanguage 22 -3
 CleanLanguage 1
 CobolLanguage -1
 CeePlusPlus 17 -11
 CsharpLanguage 8 -4
 CurlLanguage 0
 DeeLanguage 1
 DelphiLanguage 3 -2
 DylanLanguage 2
 EeLanguage 1
 EiffelLanguage 3
 ErlangLanguage 6
 EuphoriaLanguage 4
 FactorLanguage 1
 ForthLanguage 21
 FortranLanguage -2
 HaskellLanguage 15
 HtagLanguage 1
 IconLanguage 0
 InteractiveDataLanguage 1
 IoLanguage 2
 JavaLanguage 18 -7
 JavaScript 6 -4
 JayLanguage 3
 JoyLanguage 3
 KayLanguage 2
 LavaLanguage (GMD) 1
 LingoScriptingLanguage 0
 LispLanguage 35 -1
 LuaLanguage 6
 LxLanguage 0
 MirandaLanguage 1
 MlLanguage 7
 ModulaTwo 3 -1
 ModulaThree 0
 MortranLanguage 0
 MumpsLanguage 5
 NetRexxLanguage 0
 NiceLanguage 4
 OberonLanguage 4
 ObjectiveCee 5
 ObjectiveCaml 9
 OhScript 0
 OccamLanguage 1
 PascalLanguage 1  [Note: is this ''really'' different from Delphi any more? Should these two be lumped together?]
 PerlLanguage 12 -5
 PhpLanguage 2 -5
 PikeLanguage 0
 PrographLanguage 2
 PrologLanguage 7
 PythonLanguage 37 -4 
 RationalFortran -1
 ReActorLanguage 0
 RebolLanguage 1
 RefalLanguage 1
 RexxLanguage 2
 ArrLanguage (R) 2
 RubyLanguage 36 -1
 SalsaLanguage 0
 ScalaLanguage 0
 SchemeLanguage 20
 SelfLanguage 5
 ShellScripts 3  (if you don't write these in BourneShell you're a heretic)
 SimulaLanguage 0
 EssLanguage (S) 0
 SmalltalkLanguage 26
 SnobolLanguage 2
 StructuredQueryLanguage (SQL) 4 -4
 SuneidoLanguage 1 -1
 ToolCommandLanguage (Tcl) 19 -2
 TomLanguage 0
 VisualBasic 3 -12
----
Please add your opinion after you vote and maybe even link a relevant page:

I suppose the reason I'm so interested in C++ is because I've had my eye on it for five years now.  Only lately have I had the time to sit down and learn it and so far it looks fine to me.  I'll put the arguments against it to the test for certain, not that I know how far that will go.

----
Ultimately I only found satisfaction when I created my own language. Anything it doesn't do, I simply add. I like different features of different languages, I combine them into my own. Maybe what we need is a MetaLanguage that gives everybody their own extensible ProgrammingLanguageFramework enabling them to align features and syntax to their own preferences. Ultimately all the languages are mainly differentiated by '''syntax''', '''features''' (compiler magic, such as objects or delphi's properties) and '''tools'' (such as the IDE). because if it supports primitive constructs you can emulate all these. You can do objects in a non-oop language by records and function pointers, you can do garbage collection in a non-GC language (add it to a common descendant in Delphi and presto.). So it's all about the feature set "out-of-the-box" and syntax preference, really. ''Please Discuss'' -- SvenNeumann

''You should take a look at LispLanguage - it's one of Lisp's strengths that people are able to seamlessly create their own domain-specific languages in Lisp.''  [Note: the same is true of Forth]

''I'd like to work in a team, where everybody uses their own language. I'd love to write the coding conventions :-)''

Gee, there are ''already'' good and standard coding conventions for Lisp. One of the advantages of not having syntax, you know.

Also, it's not as confusing as you might think.  In ''any'' reasonably large programming project, you're going to have to invent a custom language of sorts, in the form of functions and classes and libraries and APIs (unless you're planning to stick to GoTo and CopyAndPasteProgramming).  The difference with Lisp is that ''everything'' in the language can be expressed with a few primitive functions - part of JohnMcCarthy's original paper was that given just car, cdr, cons, atom, and cond, you could construct a whole programming language.  So in a sense, the language is one big library.  That's why it's so easy to construct domain languages in Lisp - you don't have to put up with arbitrary restrictions the compiler imposes on you, and your functions have the same status as the rest of the core language.

----
I'm not meaning to bring this page into a big debate, but the question is demanding an answer or two: doesn't C++ allow extensibility with other languages through the use of libraries?

''C++ was designed to be easily linked with C code, but this is not a unique feature of C++.  Many programming language implementations can call external code using "C linking conventions" or some other "native code interface" mechanism.''

----
<mode="advocate">I like the OberonLanguage. Oberon is an extremely simple imperative language, which seems to have exactly these constructs you need.  Nothing less, and especially, nothing more. Since it is so simple, Oberon is a very readable  language, and writing let's you express your ideas clearly. </mode> However, I must say that object orientation is not so  good in Oberon, and also it only comes together with an OberonOs, which is nearly unusable. If you really want to have a look at it, I recommend ComponentPascal. -- ThomasHolenstein

----
Well, it seems the majority is falling upon C, C++, Lisp, Python, and Smalltalk.  Python has the lead with 5 votes.  Still, I thought there would be more voters than this, but I suppose that's what I get for being so thoughtless as not to think this vote hasn't occurred many times before.  Anyway, thanks for the attention!

----
I like different languages for different reasons. For instance, I voted for C because it was the first language I really mastered even though I'd never use it on a real project. I voted for Prolog because it was the first language where I could write something that worked the way I expected on the very first try. I voted for Perl because of its pragmatism, and Smalltalk and Ruby because they both taught me about the purpose of a language (to be an extension of the programmer's mind, rather than merely to provide a mechanism to instruct the computer).

----
Smalltalk was my first exposure to OOP, and is still my overwhelming favourite.  For various reasons (generally economic) I've been using mostly Java lately.  I'm in the process of learning Ruby, which promises to be very interesting.  And, LISP is always fun to play with.  I spent a fair bit of time (in academic & self-learning environments) hacking LISP... fond memories.  -- DaveAstels

''Agree with the lisp sentiments.  I have often wished there was (post AiWinter, that is) any mainstream (i.e. manager friendly) language with a tenth the power of lisp :(''

Python fits that description very well; it's quite mainstream these days,
and has approximately 1/10 the power of Lisp. -- GarethMcCaughan

----
My favourite language was also Smalltalk for a long time, and I like Ruby a lot too, but I've come to like the SelfLanguage even better. I'd definitely recommend Self to anybody who likes Smalltalk; it's simpler and more uniform and more flexible than Smalltalk (believe it or not :), and has a really cool development environment. It's rough and unpolished in a lot of areas, but Self feels to me like it ought to be the next step in the evolution of Smalltalk. -- AdamSpitz

----
I've found that the whole question of a language's suckiness depends mostly on the type of application being written.  If I have to write a Windows-based stopwatch application, it'll be quickest and easiest to build in VisualBasic.  If I have to write a Linux-based file parsing tool, I'd much rather use a bash script or the PerlLanguage.  If I'm going to write a robust e-mail client, I'd want to use CeePlusPlus.  It's better to be familiar with a variety of languages than to use only one exclusively (though expertise in one language is a GoodThing, too). -- BrentNewhall

----
I have entered the BourneShell as a favorite of mine.  A shell script, once saved, becomes a reusable tool, that's effective extensibility.  I recently found that refactoring a large suite of tools was quite simple. -- ChrisGarrod

----
Wouldn't the list be more interesting if it was sorted by votes (descending)? Every reader mentally sorts it anyway... . Or at least splitting it into two lists, the first for languages for which there already are votes, the second for languages with zero votes.

How about adding another column, with negative votes? Like so:
 AbapLanguage 0 -1
 AbcLanguage 0 0 
 ...
 VisualBasic 2 -2
? This would allow to discern between uncontroversially good or bad languages, controversially good or bad languages, and languages not many people have an opinion about one way or another.

----
I'm finding that these votes don't mean much to me without some indication of which ''other'' languages the voter knows. A vote for Python from someone who also knows Ruby, Smalltalk, and Lisp would be a lot more significant to me than a vote for Python from someone who only knows, say, C, Java and Perl. Please feel free to add a little blurb telling us why you like the languages you like; those are much more useful than the simple vote counts.
----
I voted for LispLanguage, though I discovered DylanLanguage last night and am seriously considering changing my vote to it.  There're still things in Lisp - like LispMacro''''''s, CompilerAtRunTime, MethodCombination, and MultiMethods - that don't exist in any other languages (well, I guess AspectJavaLanguage has MethodCombination and Dylan has MultiMethods, but it's often not done as well).  Plus, Lisp has a bunch of other features (SoftTyping, LexicalClosure) that are only found in other state-of-the-art languages.  And the whole thing is unified in a very elegant framework instead of being feature and feature piled on top of each other, each with a different syntax (a la CeePlusPlus).

What's swinging my vote to Dylan is the practical difficulty of learning Lisp.  It's a huge language - the HyperSpec is close to 1000 pages, I believe - and it holds the accumulated cruft of 40 years.  I like dealing with pair instead of CONS, head instead of CAR, tail instead of CDR.  Plus all the Lisp functions that might or might start with "n" if they're destructive, or might or might not end with "p" or "-p" if they're predicates.  HungarianNotation is just as distasteful with Lisp as it is with CeeLanguage.  Then add in that Dylan actually managed to get rid of the parentheses and introduce InfixNotation without (completely) breaking macros, and I'm impressed.

I view Dylan as Lisp with 80% of the functionality and 20% of the hassles.  Sure, I'll miss fully-functional macros, and MethodCombination (is this possible in Dylan?  I haven't seen any examples...), and maybe once in a while CompilerAtRunTime, but I learned most of the essential parts of Dylan in a day.  I've been working on Lisp for about 8 months and still don't quite have the syntax down.

As for the other choices...I took a look at the PythonSample page but didn't like it.  I think it may be the large amount of underscores (things like __init__), or that the code looked unstructured to me.  Ruby seemed much cleaner syntax-wise.

I think SmalltalkLanguage and HaskellLanguage are really interesting, but I prefer multi-paradigm languages.  I like the flexibility to combine different programming styles as appropriate.

CeeLanguage, JavaLanguage, CeePlusPlus, and PhpLanguage are all quite fine for most programming projects, but I sometimes find myself really wishing they had some of the more advanced language features like LexicalClosure, EverythingAnObject, SoftTyping or DynamicTyping, or HigherOrderFunction.  Plain imperative languages are fine for most purposes, but once in a while I find I wish I could just define a lambda instead of creating a whole new class. 

-- JonathanTang

''Try googling for Boost Lambda -- its amazing what C++ can do!''  Except that Boost Lambda is an ugly kludge.  There are much better examples in Boost of stretching c++ in ways that are more suited to c++.  The language constrains the lambda library from being particularly useful, or idiomatic.

----
I adore Tcl and tend to think it is one of the most underrated languages available today. With the Sun->Scriptics->Ajuba mess people seem to have forgotten about it. I know C, Java some Perl, C++ and even less Python (just the bare concepts). For me there's a certain charm to Tcl. The syntax is incredibly minimalistic and there are no language constructs as such, yet you can pretty much extend it to provide absolutely any kind of programming style you wish. No language is perfect, but that would be, for my tastes, the ultimate achievement: absolute power, with pure simplicity. I honestly believe it has far more to offer than just Tk and deserves more attention than what it has received in recent years. -- Setok

You might be the kind of person who'd like the SmalltalkLanguage (or, even better, the SelfLanguage). I like those for the same reasons you like Tcl - they're ridiculously simple and (as a consequence :) very powerful. You also might like LispLanguage or SchemeLanguage, though I don't much. -- AdamSpitz (who doesn't know Tcl, and is interested in learning it now)

Actually I do find Smalltalk interesting and I very much like the principles behind Self, although I admit to never having coded anything with it. On paper it looks like a very nice language. Lisp is more familiar and I do make a comparison between Lisp and Tcl as there are obvious similarities. For me, Tcl is just a tad easier to get to grips with, but YMMV, as always. -- Setok

----
Nice page, I am also tired of language wars and gratuitous bashing.

I too find Tcl to be the language of choice for most of my programming tasks, supplemented by a C code extension if needed.  Lately I'm doing quite a bit of work in Java.  Jacl (Tcl interpreter in Java) is my trusty companion, allowing me to easily test and script Java objects.

BrianKernighan was the keynote speaker at the 1997 Tcl Conference;  his parting comment was that ''Tcl is the best kept secret in the industry'' (or words to that effect.)

My other favs are: C, Smalltalk, APL, Shell, Awk. Others that I've programmed in: ASM, Basic, C++, Cobol, Forth, Java, Lisp, PL/I, Pascal, Perl, Postscript, Python, R, SAS, Scheme.

All of them are worthy.

----
I chose Tcl as my first (and, so far, only) programming language because it's simple and comprehensible; it's oriented more toward text and graphics (with the Tk toolkit) than toward math and logic; it doesn't require the programmer to spend any time on loathsome tasks such as compiling; and yet you can do a whole lot of things with it. -- David McClamrock

----
Tcl is by far the simplest of the major scripting languages to extend with C modules. Especially using critcl. However, they all have their place. Even vbscript :) -- Pat Thoyts

----
Every time I have to do another project in Tcl/tk I'm amazed at how easy it is to get my ideas into code quickly, and more importantly, correctly!

----
I don't like C++, as everything is sooo complicated. I do like Tcl/Tk, because it's not. -- Philipp

----
Hey, um, weren't there supposed to be plus and ''minus'' grades for the different languages? What happened to all the negative marks for Lisp? And how did the count on C/C++ end up back down in the low teens? Has somebody been playing with this page? Do we need instructions for use of the poll at the top of the page?

----
OK, I have cast several votes, because I do like different programming languages for their usefulness and insight. Lisp because it is gorgeous, and Scheme because it's so elegant and friendly. Perl is the imagination made power (and pay my bills!) and Ruby because it's much more elegant and consistent than Python. Ocaml is very interesting and offers a lot of power packed in the language, while Erlang is a powerhorse in concurrent programming and very insightful. Lua packs a lot of power in a very simple language and it's very easy to embed, JavaScript because it has a very interesting object system, and Tcl/Tk because it's amazing what you can do with such a simple language (shame there aren't real closures) and its instrospection abilities. Didn't vote C++ because it could be better than it is: I like it but I won't vote for it. And voted VB down because it's such a kludge and has given me such headaches in the past I think it should be criminally punishable. -- DavidDeLis

----
Well, please give me the task first and I will select a language. Doing functional programming I'd probably go with Scheme, logical Prolog (some variant), palmos-programming C of course, if I do have to do OOP I'd go with ADA, gui-programming (Tcl/)Tk, scripting Tcl... The right language is out there for every specific task, but perhaps mostly for every different programming paradigm. I do prefer a language that was written for one specific purpose or paradigm, JAVA - the almighty encompassing language that wants to do everything - gives me the hickups. It will take enormous skill and experience to write good programs in java I would think. Perhaps the problem is that a lot of the people using it is not doing pure OOP, but rather some pseudo-procedural programming... -- VeronicaLoell

I agree with the sentiment that languages often tend to be better suited for some tasks that others.  I can't claim to have coded a lot in anything besides FORTRAN 77, but of the other languages I've used (a little C, Perl, Tcl, sed, [G]AWK, csh, bash, DOS batch, Java, JavaScript/JScript, VBScript, a little C++, Ruby), Ruby stands out as the easiest in which to express my thoughts in the form of code.  I am still fascinated by the concept of macros in Lisp/Scheme and continue to try to learn at least one of the two (I'm glad I'm taking a more serious look at ''StructureAndInterpretationOfComputerPrograms'', which I'm now better able to appreciate, and hopefully will get something valuable out of Paul Graham's ''On Lisp'' someday relatively soon, but I still always grimace at the seemingly inconsistent/un-unified syntax in both Lisp and Scheme).  Ruby continues to surprise me with its power, elegance, comprehensibility, conciseness, and amazingly powerful yet short third-party libraries that already exist. -- AlbertDavidsonChou  ''Lisp/scheme syntax is both elegant and consistent.  There is almost none of it, though, so don't get hung up on interpreting semantics as syntax.''

----
I do not have very much programming experience. I don't even know one language reasonably well. In high school I took C++, and knew there must be a better way, so right now I am learning LISP, OCaml, and Aleph all at once. And once I am done with those perhaps I will consider Smalltalk and Prolog... Note that my decision to learn these particular languages came mainly from remarks made on this website, namely on pages like this one. -- self-signed AnonymousLurker

----
I just voted RubyLanguage. I did not do this because I think ruby is more powerful or simple than the others. It just happens to better fit my way of thinking. I find this a huge advantage, but YMMV. -- GabrieleRenzi

See also: OoBestFeaturePoll

----
I voted Lisp for its power and elegance. And -1 for Java for being clumsy and yours truly being forced to use it. Background: I used C, C++ and Java for several years. Of these three I like C++ best. Then I got interested in more dynamic languages, Perl, Python, Lisp. Perl is powerful, but I couldn't get past my disdain for it, so I went for Python that seemed much nicer. Having spent 15 years learning new languages (and editors for that matter) I decided it was time to choose one that I will not outgrow or dump when the fashion changes. I've found Lisp.

----
C/C++ is still THE system language.

We use C# for major projects because C++ was used before I arrived.  Because we work in statistics, C# is better-suited over Java which has certain data type limitations.  R is also good for numbers--yes, I consider it a language (based on S).  Others in the department used it extensively--I'll learn more eventually.  I use Python for minor jobs because it's quick and easy and also nice for a wiki. -- WillGray

----
Yeah, C++ is complicated, and a lot of C++ gurus will give you a really hard time if you don't know every knook and cranny of it (they expect you to read and memorize the whole standard).  That's what sucks about it.  Unless you're doing heavy OO though, you only really need to know like 4 or 5 things about it.  The main beuty of C++ is that you can some of the tough parts in C++ (heavy string stuff, maybe) in your implementation and then export those to C functions and you won't have any real overhead.  Remember that as long as you don't put any virtual functions and whatnot in a C++ class you can make a struct in C representing it as a tool-free bridge.

Basically though, my favorite way is just to use C with simple C++ wrappers (no not STL-types :)), one or two for an array class, a string class, and the rest in C.  This way you generally have programs on practically any compiler in the last 15 years, and as fast as assembly/object code - but much much easier to make :).  Out of the intrepreted languages Java is my favorite.  It forces some style guidelines which I think are good, and the API is really nice.  Interpreted languages like that are nice because they are easy to learn and easy to develop on at first.  However, once you've become accostomed to c++ and/or built your own class library with C++ over time the advantages of the other languages like this start to fade away. -- RyanNorton
----
And once again, IoLanguage gets ignored.  Until now. --SamuelFalvo
----
My votes were for PHPLanguage, for its extreme flexibility and simplicity, EuphoriaLanguage, although it's currently behind the times, because it was a strong influence on me in terms of allowing me to make things what they could/should be, and ForthLanguage, because it is just incredible how much power can come from such unbelievably elegant simplicity.
----
There's lots wrong with SelfLanguage, but it's heart is in the right place. --RussellAllen
----
Voted against PHPLanguage as it's just so clunky and stiff. Voted for ForthLanguage and SmalltalkLanguage for their flexibility and expressiveness.

----
CategoryProgrammingLanguageComparisons
