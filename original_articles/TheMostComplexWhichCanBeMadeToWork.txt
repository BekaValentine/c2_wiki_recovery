Nominate your favorite consumer software product here as something so complex that everyone should have known it would never work.
----
'''Parlay'''

The Parlay API: IDLs are too technology-specific, let's abstract some more. By the time you map the spec to an IDL (CORBA or DCOM), and then once more to an implementation language, you can't make heads or tails of anything anymore. This is supposed to be the new open standard to connect to communication networks (voice or data).

'''Windows 2000''' -- ''does this work? seems to spend all its time swapping even with 128 mb of memory. Don't leave it running when you go for lunch - it swaps everything out - its faster to shut it down and power back up when you get back<g>).'' Windows 2000 needs at least 192 MB RAM. 

''I use Windows 2000 at work in 128 MB RAM, and it's quite comfortable. Also, it's at least as stable as the Linux workstations I used at my previous job and at home. It is awfully complex, though.'' -- RobertChurch

A friend installed Windows 2000 on our Win98SE NEC desktop. The computer had 48MB of RAM, it was a little slow. --MAC

''Win2K was my OS of choice for several years, even long after WinXP came out, even after I started using various flavors of Linux on desktop machines, even after getting into fistfights over operating systems for development stations. It worked quite well for me. -- MartySchrader''

Related: MicrosoftWindowsBeyondRepair

'''VMS'''

'''Internet Explorer''' Version ''n'' (for large values of ''n'') For *odd* values of n (3, 5, and presumably 7). ''If you think *odd* values are bad, try *odd*.*odd* values!
 (version 5.5 is in beta)''

'''Cross Browser JavaScript'''/DHTML *cough*cough* Netscape

'''The C++ programming language'''

Using '''CommaSeparatedValues''' as a programming language. (A previous employer of mine used this to do batch data loads. However, it had no flow control or looping constructs [creating 1000 document objects meant a 1000 line file - at least!] and the command syntax was irregular [half the time, the developers couldn't remember the commands].) ''This wouldn't have been BancStarLanguage by any chance?''

'''JCL''' (JobControlLanguage) Hours of fun.

'''The MS Chart OCX''' Seems well done, well structured and easy to use. The truth is, it is pure madness condensed into one OCX.

'''COM''' ''[Lengthy comments moved to ComIsHard.]''

'''NIS+''' NIS was OK, but NIS+ is insane.

'''J2EE''' standard API.

'''Oracle 8i''' manuals.

WS-*

The '''Apollo''' airline reservation system

'''Perl''' (...especially the "object-oriented" code. I wonder what AlanKay would say.)

'''Makefiles'''

'''SNMP''' (which, ironically, stands for ''Simple'' Network Management Protocol)

It is simple compared to the alternative: X.700 Network Management (CMIS/CMISE/CMIP). Now there's a nice example of something built to be as complex as could be and still work. Has anyone ever used it seriously? And are they still using it? I betcha they are not.

(Indeed, manageability is an extremely complex area and, although SNMPv3 is complex by itself, it is a more simplified approach than other previous approaches... watch XML and SOAP developing to see some really incomprehensible complexity!)

'''The Space Shuttle'''

I think that the space shuttle only seems very complex because it is built of many parts. I guess that no person ever needed to care about the WHOLE space shuttle. By splitting the project in three-four parts many times (like a tree structure) would make it a whole lot easier to comprehend (given that you don't care about more than your parts, and the parts you need to interact with).

The biggest problem really is the amount of money needed.

And that gdb does not yet support debugging of nuts-and-bolts(TM) ;-)

'''SGML''' (StandardGeneralizedMarkupLanguage). Maybe it's the poorly written SGML books. ''Maybe it's that nobody ''reads'' the poorly-written books.''

A donut -- HomerSimpson

'''LaTeX''' - "simpler" than TeX (except when it isn't.)

'''PhotoShop'''

'''PDF''' [''Does this refer to "Portable Document Format" , which is an abomination, or "Program Development Facility"?'']

'''E-commerce''' Built upon layers and layers of commerce and banking systems designed half a century ago or more, which were never intended to do even the most basic things such as verify whether or not a credit card is valid (without charging it).

'''IBM WebSphere (Web Content Management)''' - It's essentially about a dozen different services that kind of work together. While compartmentalizing allows a lot of flexibility for scaling and fail-proofing the hardware and servers, it sure the hell ramps up the administration costs and trouble-shooting time. Yes, it probably scales better than most of the stuff out there, but you pay the price if your shop is on a lean budget and lean staff. It seems it would be simpler to only use it for the high-traffic pages, such as the landing page, top products and/or news, and use something more nimble for low-traffic pages, even if mixing WCM vendors creates a bit of duplication. I would roughly compare this to the common practice of using Oracle or DB2 for the primary/master data, but SQL-Server or MySql for smaller department-specific projects. '''Doing BigIron right ain't cheap.'''

----
The statement at the front says "so complex that everybody should have known it wouldn't work", and the title says "the most complex which can be made to work".

As far as I can tell, nothing on this list meets either qualification. Some of them seem much more complex than they should be, but many of them, like PDF and LaTeX, seem quite reasonable to me. All of them work well almost all the time. In general, all of them are complex because they grew from simple beginnings. This includes Windows. They wouldn't have been nearly as complex if they hadn't been reusing a base, or if they hadn't been trying to be backwards compatible. But they wouldn't have been as successful if they hadn't been reusing a base or been backwards compatible. Their over-complexity is a product of the strategy that brought their success.

Software developers complain a lot about complexity, but by and large they don't understand why things are complex. I bet that, if we understood the socio-political environment of the space shuttle, we would realize that it is in fact the simplest thing that could possibly work, in spite of the fact that it is one of the most complex things that humans have ever created.

Also, almost nothing on the list is a "consumer software product". ''[True, only LaTeX qualifies ;-).]''

-- RalphJohnson

Maybe the space shuttle and similarly overcomplex things were made that way to satisfy psychological or socio-political forces. But maybe not. Maybe there's another explanation. Or maybe they were designed by people who sincerely thought they had to address psychological forces, but were mistaken. -- RichardKulisz

''Richard, the above WikiRefactoring is due to me. I have a copy of the original ThreadMess. Please let me know or edit away if you think the above does not do justice to your original comments. -- BenKovitz''

See EngineeringVsMarketing.
----
As long as we're talking about stuff that isn't consumer products, here are some non-software things that seem to be way too complex to ever work:

	* Any natural language.

	* Any legal system, especially one that has evolved in courtrooms through centuries of precedents.

	* Any real system of etiquette, including the WikiSocialNorms that have evolved over countless discussions on WikiPagesAboutWiki.

	* Marriage

	* Any free-market economy.

	* Any large city.

	* The complete rules to modern DungeonsAndDragons

	* The federal government of the UnitedStates ''[no, not applicable, doesn't work]''.

	* In summary: Pretty much all EmergentSystems ?

As with the software examples, these may all be at nearly maximal simplicity given the totality of forces that they address.
----
''I don't think products should have all of these irrational considerations (backwards compatibility, et cetera)''

See NetworkExternalities
----
Sometimes people say "complex" when they mean "confusing". To the right person, almost anything can be confusing, but complexity is more objective. I think "complex" means "many parts", and implies the many relationships that exist among the parts. Also implied is that the parts are not all the same. Complex machines make for complicated behavior, usually, although Chaos has shown that simple ones can also, when feedback loops are positive. Software gets complex when we add new parts to it. Non-essential complexity happens when slightly different parts were added when sameness could have been achieved instead. I've seen several complex products that were at the threshold between workable and not workable, and there's a dynamic that tends to hold such products right at that seemingly fragile balance point. The problem is that most overly complicated products can be demonstrated to work at least a little. That's enough to satisfy developers overwhelmed by complication, but not enough to satisfy paying customers over the long haul. I once had to oversee a product whose author deemed it unmaintainable. No one else would touch it either, nor would the company pay to rewrite it. Does life get any better than this? -- WaldenMathews
----
Fascinating discussion!

It seems that the definition of "working" is critical to the discussion. Does it meet the needs of the entity it is designed to serve? 

The space shuttle works by that definition. It does what it's supposed to do for the purposes for which it was built. It is complex, but not particularly confusing.

The federal government of the United States increasingly seems to not work in fulfilling the needs of the majority of its constituents all the time. It is definitely complex, as well as confusing. 

Much more primitive living things than mammals are incomprehensibly complex, and they all seem to work - my definition applies poorly to natural entities.

The Web - complex, confusing, inconsistently meets the needs of few. But then, what do people "need" from the web?
----
The mail functionality of LotusNotes is really complex. Take a database system, add lots of little add-on programs that listen on SMTP ports, write what comes in in a database, or two, convert to-and-fro between SMTP and Notes RTF, monitor that (those) database(s), move everything to another database or maybe talk to a router task depending on several criteria, keep all configuration and recipient names in another database.

Hmm. Maybe this isn't so complex after all, it's just Sendmail with databases instead of the file system.
----
maybe not so much "many parts" but "many interrelationships. There is distinction. A star topology with 100 endnodes is not complex (depends of course on usage etc) but the same nodes having all one-to-one connections definitely is..

''There's a distinction between reducible and irreducible complexity, which corresponds to compressibility in information theory. The star topology with a hundred end nodes can be compressed into "hub, then 100 x (end node + connection to hub)". The complete graph topology is a little harder. The complete graph topology where every link has random, specific characteristics with no abstractable relationships between them is much more complex still, from an information-theoretical standpoint.''
----
Lojban is trivial to learn. Its '''vocabulary, however, is quite another matter!''' --SamuelFalvo (http://www.lojban.org/)

Also, ''life.''
----
Any society... including this wiki's. Appears very simple on the forefront, but... then there are all of these written and '''unwritten''' rules and sh*t. Pretty soon there is a script that forces people not to comply, or is it comply?... but to what?... Certainly not to the written rules... And, for every written rule there is a contradictory rule... Yup, just like all societies... Depends on who is pulling the strings, or murdering to enforce power, etc...