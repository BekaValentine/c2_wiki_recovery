Things that are orthogonal to OO, but which have a confused/confusing relationship with OO such as GenericProgramming (it is less interesting to list all the things that are quite obviously orthogonal to OO)

Considering the brilliant (albeit slow, over the decades) success of OO and OO languages, I find it interesting that there are some powerful paradigms that are, or appear to be, or are controversially claimed to be, outside of the world of OO. OO programmers often dispute that there is any point to GenericProgramming, for instance, because it isn't immediately clear what it offers that is so different than what one does with an OO approach. "Double dispatch" is good enough. Perhaps, yet type safety issues arise: CollectionsArentOo.

This is about things that are potentially orthogonal to OO, not necessarily things that are opposed to OO. Relational vs OO databases is the only subject I know where something apparently opposed to OO is still clearly doing better than the OO approach. Even there, people do use OO programming with relational databases so part of that is still an orthogonality/complementary relationship.

For instance:
* CollectionsArentOo
* MvcIsNotObjectOriented
* GenericProgramming
* RelationalDatabases vs OO databases

The latter is an interesting case. People have for a long time been interested in creating OO databases, since OO is of proven value in non-DB programming, and to avoid the issues that come up with the various approaches to stuffing OO objects into relational DBs. But then smartasses like ChrisDate come along and point out various technical problems with OO databases. :-) Well, it would be nice to fix OO DBs  to avoid his critiques. But one must understand the critiques first, and a first step is to at least be able to differentiate "what is OO and what is not?", to figure out what is and is not an OO DB. That's not to say that someone who is already using some given DB necessarily needs to worry about the same issues.

Although it's a bit of fun to be a firebrand, since paradigms tend to involve zealotry and HolyWar''''''s, my real interest is in finding the natural limits of various paradigms, the natural joints at which paradigms should be carved, not to single out any particular paradigm to support or slam. I'm interested in a multi-paradigm approach to software, which makes me curious about the strengths and weaknesses of each individual approach. -- DougMerritt

This is therefore specifically '''not''' about ArgumentsAgainstOop. I think OO proved its worth decades ago.

''In specific areas only.''

[Please, top -- don't let's start Yet Another Rant over this, eh? Object-oriented approaches have helped pretty much everywhere they've been properly applied, and if the relational database field is the one standout exception then let's limit our discussion to that, shall we?]

I have a right to challenge a specific claim about OOP. If it grows too long, THEN you have a legitimate complaint and should request the details be linked instead. It is acceptable to point out disagreement with a statement. If you have evidence, I invite you to put it at OoEmpiricalEvidence and we can discuss it there. Fair? -t

{You only have a right to challenge specific claims if you back up the challenge with verifiable evidence.  Otherwise, you've got nothing but an opinion.  We all know what they say about opinions, right?}

* Okay, but that works both ways. You claimed, "OO proved its worth decades ago".  And anecdotal evidence is acceptable as long as one is not misleading about what it is. Related: EvidenceTotemPole. -t

And I will agree that OOP has provided another coding/paradigm ''option'' that may help in specific instances and domains. I just question the universality of it. It's another tool among many in the tool bag. (Tool set versus tool bag, oh boy :-) -t

----
Conceivably related:

* ComparingParadigms
* MixingParadigms
* MultiParadigmDatabase
* MultiParadigmDesign
* MultiParadigmLanguage
* MultiParadigmProgramming
* MultiParadigmProgrammingLanguage
* MultiParadigmWeenie
* ParadigmClassificationAttempts
* ParadigmMismatch
* ParadigmPissingMatch
* WhenToUseWhatParadigm

Are these in the category or not? With currently only three true backlinks, I'd say IntroduceCategoryLater. ''Seconded. That seems like an awfully small sample base on which to start a whole new category.''
----
CategoryCategory