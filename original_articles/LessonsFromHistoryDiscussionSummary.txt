I put a summary at the top of LessonsFromHistoryDiscussion, and that has now been turned into a sprawling mess.  Here it is again, but with some alterations to take into account the comments made there.  Perhaps if you'd like to comment on this it might be best to append your comment, with context if necessary.

This summary is intended to help find points of interest in the sprawling mess that is the LessonsFromHistoryDiscussion page.  It (namely this summary) is almost deliberately wrong.  It is intended almost as a caricature of the discussion, and as such to help the potential reader put things in context.  I originally put it at the top of that page because putting at the bottom is singularly pointless.  It's only of value if you read it '''before''' you get sucked into the morass, and it is intended to add value.  Would that all contributions to this wiki had that aim.

The "discussion" is one of the usual "More heat than light" interchanges that ensues when person A really doesn't get the point, person B tries to explain, person A goes into "scoring points debating" mode, and person B gets sucked into it.

Anyway ...

Closures are a tool.

Some people can't see the point of closures, and argue that they're basically useless.  There appears to be no evidence offered for this.
* See BlubParadox

Others might argue that until they become wide-spread and well-understood, people won't know how to use them and their benefits won't be realised. The point is argued from the analogy of GOTOs versus block-structured programming.

Some of those involved in the "debate" claim that the above summary is biased, misleading, inaccurate and implore readers to ignore it.  I suggest that those interested read the page and judge for themselves.  I hope the above helps to create a framework for understanding LessonsFromHistoryDiscussion.

I now hand you over to the same people as made the original page such a completely useless ThreadMess ...
----
In response to:
* ''The "discussion" is one of the usual "More heat than light" interchanges that ensues when person A really doesn't get the point, ...''
top replied:
* I've been accused of "not-understanding" many times, and in only about 1 in 10 of such cases has anybody proved me objectively wrong on the key arguments. (If you dispute that, please list my objective failures.) "Not-understanding" or "you don't get it" is the equivalent of GodwinsLaw in software engineering. In political debates you accuse one's views of being like Hitler, and in S.E. you accuse the other of not getting "it". Wolf! Wolf! Wolf! Cried the boy. "You don't get it" is usually a cop-out accusation of intellectually lazy people. If you have real objective evidence, it's usually pretty easy to slaughter somebody with logic and facts. (If any paradigm was objectively superior, I think after 30 years somebody would have proved it by now.) -- top
** Perhaps in about 1 in 10 cases could you actually understand and accept the objective proof that you were wrong. But, more often, you refuse to 'see' or 'understand' anything that would compromise your position.  And, even more often, you do nothing to prove yourself right; you just throw an idea you like onto the table as though it can defend itself - to which the ''correct'' response from others is: "I don't believe you.  Prove it."  You rely on contradictions like 'EverythingIsRelative' to support your positions, and you reject laws of logic (like the law of noncontradiction) whenever you find them inconvenient.  Then you have the arrogance to call other people "lazy" for not proving something to you after you've turned off ALL formal and objective reasoning? or even after you've failed to properly substantiate your own claims?  You '''really''' don't get it.
** ''If I'm really as messed up as you claim, I'm not aware of it and am massively delusional. I've been put on trial plenty of times (ObjectiveEvidenceAgainstTopDiscussion) and I've not seen a large quantity of pivotable objective logic mistakes come out of me at all. Only about 10% of those accusations carry any weight, most those just misunderstandings or sloppy typing on my part.''
** Again, that's 10% that carry weight in YOUR biased eyes.  You should at least be honest with yourself on this: when trying to defend yourself to other people, it's those OTHER PEOPLES' eyes that matter.  If you want a better count of how I see it: Go count up every argument you've ever made that relied on 'EverythingIsRelative' and drop them into the objective fallacy pile (violates law of noncontradiction).  Go count up every argument you've ended by arguing that you get to redefine everything and drop them into the objective sophistry and equivocation pile (HumptyDumpty).  Go count up every argument where you start by demanding counter-evidence rather than providing sufficient evidence, and drop them into the 'unsubstantiated argument' pile (alongside Creationism and the Great Spaghetti Monster).  I've only been on this wiki for a year or so, but nearly every big argument I've seen from you falls into one of those categories.  You say that YOU have not seen a large quantity of objective logic mistakes coming out of you, but how could you? Like checking for grammatical mistakes in your own writing, if your understanding of logic is flawed, you won't 'see' the mistakes even when you're looking at them.  Learning to see them requires a BookStop and some time with the "ivory tower" - items at which you proudly thumb your ever-raised nose.  Now, admittedly you ARE skilled when it comes to your domain of expertise - Business applications, effective uses of relational, etc.  If you count up the many pages you've written on that, even on the advantages of TableOrientedProgramming, I'll give you those.  But those are ''very rarely'' the causes of big arguments; those are ''very rarely'' the places you're actually accused of "not understanding".  That happens when you start making ignorant comments on type theory, language properties, philosophy in general, and especially various unqualified categorical statements that you defend with a vengeance until finally revealing (after pages of discourse) that "oh! by the way, when I said that, I really just meant regarding business apps in my little domain".  Are you massively delusional and unaware of it?  I'm no psychologist, but I can say for certain that you sometimes give that impression.

** Replies:

** Re: "Go count up every argument you've ended by arguing that you get to redefine" - I don't redefine, I only *interpret* a fuzzy definition the way I want to and can within what's given. This is legitimate. You do the same because one must with fuzzy. You just mistake your view for the center-of-the-universe.
** Ah, so you have self-justifications for your sophistry.  That doesn't make it legitimate.  (1) A lot of concepts you find "fuzzy" are actually just "abstract" or "foreign", such that you possess a murky understanding and thus think they are fuzzy.  Just because you're looking at something through a blurry lense doesn't mean it has the property of actually being blurry.  Same is true for me and everyone else.  Expertise makes some things clear that are "fuzzy" to other people.  Don't mistake ignorance for fuzziness.  This is doubly true when dealing with jargon the like of which you'll find in Computer Science and related fields (e.g. math, linguistics).  (2) If you try to use a "fuzzy" concept for any sort of logical discovery, be warned that your results based on implication will invariably be "fuzzy"-er than the original premises and definitions.  If you pretend or imply that they are somehow more meaningful, you commit sophistry.  (3) As with every other claim, if you claim that a concept is "fuzzy", you need to be ready to support that claim.  Otherwise the claim of fuzziness, itself, is unsubstantiated and belongs with that 'unsubstantiated argument' pile.  To do this, you need to have a formal (not fuzzy) operational definition of "fuzzy" that is acceptable to the other person.  I can help you here: in philosophy, the traditionally accepted formalization of "vague" is "a description is vague insofar as there are borderline cases".  By this definition, only descriptions and descriptors can be vague, but words are descriptors.  With this definition, proving vagueness requires pointing out at least one borderline case.  E.g. 'red' is vague because it's difficult to tell where one should stop calling something 'red' and start calling it 'brown', 'violet', 'orange', or 'pink'.  E.g. 'chair' is vague because there are constructs such that it is difficult to determine whether one should stop calling it a 'chair' and start calling it a 'stool' or 'couch'.  One should also note that 'vagueness' as defined here allows for both 'theoretical' vagueness and 'actual' vagueness (where one claims you need to find borderline cases ''in reality'' - e.g. "looks like a horse" wouldn't be 'actually' vague if "pony", "mule", and "zebra" weren't around).  'Fuzziness' as in fuzzy logic is consistent with this definition of 'vagueness', and you prove it the same way.  It's a more flattering interpretation than that provided by the English dictionary (whereby 'fuzzy' concept means 'incoherent' or 'confused') - though I wouldn't object to you claiming that you're often incoherent.  (4) Creating operational definitions is legit.  You can make valid logical deductions from operational definitions.  But pretending that they apply even a tiny little bit beyond their operational definition is equivocation.  Even ''implying'' they do so is sophistry.  But you need to make operational definitions clear - if not by context, then at least the moment someone asks for them. If you can't provide an operating definition at the drop of a hat, you're back to being HumptyDumpty - your word means exactly what you want it to mean, nothing more and nothing less.  So... ready to provide a definition for "useful objectivity" yet?  

** Re: "Go count up every argument where you start by demanding counter-evidence rather than providing sufficient evidence" - I don't make many universal objective claims, on purpose. You just try to manipulate the burden of evidence. If I claim there's no evidence that OOP is objectively better than p/r, that does NOT obligate me to show the opposite. (Is there a formal name for this fallacy?)
** You don't do it on purpose? Well, then you're certainly accident-prone.  As far as "burden of evidence" goes, it belongs to whoever makes the claim.  If you claim there's no evidence that OOP is objectively better than p/r, that DOES obligate you to provide support for "there is no evidence that OOP is objectively better than p/r".  That's actually rather supportable (trivially, by noting that "objectively" and "better" are mutually contradictory - 'better' being rather subjective when not stated relative to a goal with an inherent cost-function).  Similarly, if you say: "Closures provide no significant benefit", you ought to provide support for that claim, too.  You have a habit of making the latter sort of claim, then demanding other people to prove you wrong.  You probably think nothing of doing so, but burden of proof here is clear: without further support, those who disagree with you need do nothing but dismiss your 'claim' as 'unsubstantiated'.  And you have to actually provide the evidence, not invent statistics like '5%' off the top of your head.  The arrogance happens if one demands disproof of a claim for which no support was offered.  It's like walking out onto the forum and shouting: "A giant, invisible, Spaghetti Monster is controlling all your minds! and the Earth will be destroyed in exactly 1001.14441445 years by a swarm of rabid squirrels! now prove me wrong!".  That deserves ridicule, not respect.
*** ''You shift back and forth between anal pedanticy and "street meaning" as you please to make up bogus claims. Everyone (except the pedantic) know that to show something "objectively better", you describe what you are going to measure, describe how to measure it, and then describe why you are using that metric. Then you measure it. For further burden discussion, see SantaEverywhereFallacy.''
*** You're wrong.  Neither you nor 'everyone' (pedantic or otherwise) casually accepts someone else's choice of metrics for a sweeping statement like "objectively better".  I can see it now: "OOP is objectively better than Relational because it lets me ''far more efficiently create massive, convoluted, hierarchical data-structures''!  Yippee!".  Right.  If you want "objectively better for at completing <X> swiftly and without defects" or "objectively better at cost-efficiently <doing X>", then you can start a real discussion.  But until you've a goal with an inherent cost-function, you' can't make objective judgements as to what is 'better'.  All that aside: you focus on the digression.  
*** ''I never said people would agree with one's metrics. You are putting words in my mouth. But such is the START of real science, something that you don't seem to get. You've demonstrated nothing for the biz domain. We don't even have results from your stated metrics to haggle over because you expect one to just trust your anecdotal shit as if you can cash in your arrogance for results. '''Stop being pedantic about step 2 when step 1 is not even met'''.''
*** '''I''' have never claimed that Closures are significantly better in any general sense.  Only that they are better for encapsulation than many alternatives (e.g. dynamic strings), and the proof for that is rather straightforward (being based on the definition of 'encapsulation', which is all about control of information).  The proof has been provided many times by many authors, and I could repeat it again if you really need it.  As to whether "encapsulation" is better, that's a different question, and outside the scope of any of my claims.   '''YOU''', however, have claimed that Closures are NOT significantly better. I'm still awaiting ANY proof for your claim.
**** ''That is not the formal claim of mine. And, I am not comparing just dynamic strings versus closures, because sometimes one does not even need dynamic strings to achieve something almost as good or comparable as the closure version. Let's look at specific examples. Can you provide any examples of them making custom biz app code significantly better?''
**** A claim doesn't need to be 'formal' to demand support.  You ought to be ready to support ANY claim you make with sound reason or evidence.  Regarding the latter question: I lack sufficient experience in biz app code to know the issues involved there, but I would note that someone used various forms of lexical closures in the lean-code page to make multiple-instance code look more pseudo-code-like.  Does that qualify as 'significant'?  That probably depends on who is asking.  In other code, I use closures often in the form of functor-passing, mapping functions to lists, etc.  But I'm a communication systems programmer, not a biz-app programmer.
**** [''I was a business application developer for many years.  I have two questions.  Question 1: Why is "biz app code" being injected into this discussion?  Why not "matrix algebra code" or "game AI code" or "real-time 3D rendering code"?  Is there something special about business application code, or does one of the participants' particular interest in business applications warrant some special treatment in an otherwise general debate?  In either case, I would suggest moving this to a page entitled C''''''losuresInBusinessApplications, and I would suggest ''asking'' others for their views on closures in business application contexts.  Taking care to set appropriate framing for the discussion will surely elevate the level of discourse.  Question 2: What do you mean by "business application"?  To my mind, it could mean anything from CRUD-forms and data-entry validation, to implementing business rules, to coding reports or report generators, to implementing calculation engines such as schedule generators and payroll calculators, to implementing graphical data visualisation tools, to implementing statistical mechanisms for predicting sales & returns & future values, to...  Well, any software used in a business context, including language compilers, interpreters, debuggers, and other development tools.  Without some narrowing of scope, I would argue that "business applications" are synonymous with applications in general, and are distinguished only by being used in a business context -- as opposed to, say, being used for military, research or educational purposes -- and therefore can benefit from any language feature or paradigm that is deemed beneficial in '''any''' domain.  However, if we're just talking about (say) data-entry validation of point-of-sale systems, then that might be different.'']
**** Note that I said "custom" biz apps. Thus, compilers would not count. They are not biz-specific anyhow. If you want to present non-biz evidence, be my guest. However, I won't necessarily be able to evaluate other domains (although you may like it that way), especially if ChangePattern analysis is an issue. Further, many other domains are less likely to use databases because they have special performance or hardware constraints.
**** [''Having created two domain-specific languages and associated code-generators which were used in a business context -- where one was used on a number of projects and the other was project-specific (i.e., "custom") -- I'm not sure I'd exclude compilers from business applications.  However, it seems to me what you're really talking about are database-driven applications, which clearly include many business applications of a conventional sort (e.g., ERP systems, inventory, payroll, billing, etc.) as well as many non-business applications, such as almost any dynamic Web site.  In short, what we're dealing with here are two or three-tier client/server applications, where tier 1 is a DBMS; tier 2 is an application layer; and tier 3 (if present) is a presentation layer -- typically a Web browser.  Furthermore, we assume tier 1 and tier 3 are pre-existing, so that development is centered around configuration of tier 1 (i.e., defining a database schema and stored procedures) and developing code in tier 2 (using tier 1, tier 2, and optionally tier 3 languages) to implement application logic and leverage tier 1 and tier 3 functionality via pre-existing APIs.  Would that be accurate?'']
**** Databases are used for many biz apps because they work, not the other way around. Anyhow, I'd have to see more details about your compiler or code generator to make a judgement. But why choose an example that may be bordline? Why not go for something that is an indisputable custom biz app and provide evidence for say PayrollExample betterment, or what not? As a side note, what do you think of CodeGenerationIsaDesignSmell?
**** [''Sorry, I'm a bit baffled by your response.  I was seeking clarification on what you mean by "biz apps", because these can mean anything from database-driven applications, to decision support systems, to stock value predictors, to ...  Almost anything.  "Biz apps" is a broad church, and I'm frequently surprised to find the "biz apps" my colleagues develop are a whole different category from the "biz apps" I've developed.  I'd rather expected you to answer something along the lines of "Yes, you've got it!" or "No, I develop systems that ..."  Instead, I'm afraid your comment that "[d]atabases are used for many biz apps because they work ..." seems a non-sequitur; I don't recall choosing any example, borderline or otherwise; and what I think of code generation doesn't answer the question.  I'm happy to answer it elsewhere, but not here.  I think a clarification on what you mean by "biz apps" might go a long way toward clarifying your general point-of-view, with the intent of elevating the discourse from endless quibbles to a place where we all may learn from each other.''] 
**** I was in a long discussion about this roughly 2 years ago. I don't remember whether it was here or usenet. I'll see if I can find it...
**** [''I don't mean to pressure your search, but wouldn't a simple "Yes, you've got it!" or "No, I develop systems that ..." suffice?'']

*** And what you said DOES imply (very directly) that "Everyone (except the pedantic)" would agree that something is 'objectively better' if only they "describe what they are going to measure, describe how to measure and then describe why [they] are using that metric.  Then measure it."  I don't need to put any words in your mouth.  If your intent is other than what your wording implies, I suggest you go correct your wording.  And as far as real etrics being the START of real science: I agree.  But 'real science' doesn't START with a claim that something is "objectively better" (though they may start with the ''question'').  They, rather, END with a claim that something is "X is objectively better than Y at Z".  I.e. they'll have the goal with the inherent cost-function attached to that statement.
*** ''It was not meant as an exhaustive list to qualify as "objective", more like a prerequisite. I probably should have made that clear, especially around somebody as literal as you. I apologize.''


** Re: "If your understanding of logic is flawed, you won't 'see' the mistakes even when you're looking at them." - It's usually easy to bust bad objective logic. You just convert the sentences into formal logic and apply standard logic operations. But you can't do that because it would force you to objectify your assumptions or claims, which you guys are afraid of.  
** Actually, if we want to bust YOUR bad logic, we would need to objectify YOUR claims and assumptions, which is IMPOSSIBLE without ability to read your mind (seeing as your assumptions aren't making their way onto paper).  When you make a claim, we have a right to demand that YOU be responsible for providing your reasoning to the best of your ability.  That way we can examine it to see if it is sound.  If you can't be formal, we can choose to be dismissive, or we can choose to interpret what you do provide as formally as possible... and any holes we find are, indeed, holes in the argument you provided.  Of course, not every claim deserves this treatment.  It's the extraordinary claims that require extraordinary proof.  As far as "you guys" goes, I could point out many pages I've started that initiate by formalizing and objectifying my assumptions and claims.  I'm probably not at all in the "you guys" crowd.  I'm very much a fan of formal proofs, and I'm not at all in the crowd of OO weenies that harken to the paradigm like religious zealots.  But, since I'd rather maintain my pseudo-anonymity, I'll not be pointing out the pages I've written.

** Re: "Learning to see them requires a BookStop" - If you cannot use the formal logic in the books to do the above, then you either forgot what was in the book, or the book is merely a 400-page opinion. The authors are leaving you with emotions, but nothing real to show for it.
** I'm fairly sure you've long forgotten big chunks of what was in the formal logic book, top.  Otherwise you'd know to avoid 'EverythingIsRelative' like Russel's paradox.  And a formal logic argument regarding, say, type-theory WILL look like gibberish to you who chooses to avoid continuous post-graduate education.  Even I, who studies type-theory and language, often need to read the proofs a half-dozen times, hand-verify some of them, and consume the twenty pages explaining the proof, and do sample problems involving the theorem to really, truly grasp it.  Thus, when you "don't get it", perhaps it's simply because you're no genius.  You read it three times, give up, and judge it bogus.  Tell me, might thinking you're a genius capable of casually understanding monads and type-theory and whatnot qualify as 'massively delusional?' 
** ''I mean logic about real shit, like proving that closers are signif better (reduce code size, reduce change-points, etc.)''

----
Top wrote (note - some of this is quotation):
	 :	'' '''That's a complete mis-statement of my side of the story. Your penchant for twisted biased summaries is going too far this time. I don't know whether its blatantly done, or slop, or your cave-men emotions getting the best of you. I invite readers to ignore these biased summaries. ''' Interesting how you refer to PaulGraham's BlubParadox. Paul generally rejects OOP. You are picking and choosing his doctrine. -- top ''

Someone on the original page wrote (and this is what stared it all):
	 :	Closures are one of those things that look cool on paper, but are difficult to translate into significant practical benefits. They're borderline MentalMasturbation in my opinion.

If you don't think this is a claim that closures are effectively useless, and that the author can't see the point, then I'd like to hear why.

Actually, let me re-phrase that. I don't care. I think it's an accurate summary.  If you don't, then I offer the point of view that you have not expressed yourself clearly.

''You seem to be reading it different than I would. '''MentalMasturbation is not the same as "useless"''' in my opinion. It perhaps could be compared to "over-engineering". An over-engineered app is not necessarily useless, in fact may work just fine, but rather the "scenic route" has been taken to the goal. Plus, the statement in question is tempered with the word "borderline". This is because I feel that closures may improve the code slightly, or at least some aspects of it. It's just that it makes maintenance more difficult because it may catch some future reader off-guard. They have to mentally shift gears, or even read-up on the constructs. I feel a cost-versus-benefit analysis of labor over the longer run would not favor it most of the time. You may argue that it is good for the mind of a future maintainer, like vegetables, but that is not the goal given to you as a developer.''

[Over thirty years ago, precisely that argument was used against structured programming in favour of GOTOs.]

* Again, I put relational-versus-navigational in the same camp. Consistency and visual-cues are the best descriptive arguments I've seen for blocks over goto's, and these SAME issues apply to relational over navigational (OOP and XML) in most cases.

''{Top, making the source read like pseudo-code is quite arguably good for maintainers, and that is '''exactly''' what closures were being utilized for prior to your categorical statement.}''

* Could you provide a demonstration or open evidence of this more-pseudocode-ness claim?

''Maybe if the nature of the app or domain was such that closures would help multiple different parts, then it makes since because the gear-shift mentioned above will pay off over a larger set of usages. But, I doubt such animals are common in the biz app world (pending scenarios that show otherwise).''

[In the future, it might be helpful if you prefix categorical statements like "... closures are borderline MentalMasturbation" with "In my opinion, when developing typical CRUD-oriented business applications ..."  That would clearly indicate your general statements are intended only to apply to a specific domain.  You might also wish to indicate that you're assuming the requisite compilers, interpreters, user-interface components, DBMSes, and report-definition tools are pre-existing, lest someone mistakenly assume your claim also covers language implementations, UI frameworks, forms painters, DBMSes, report generators, and other systems software used to build business applications.  And, it might be a good idea to indicate that certain engines found in business software are excluded as well -- components like sales/returns/value forecasting mechanisms, employee/client schedule generators, unusual user-interfaces, etc. -- because these frequently resemble the systems software that you've agreed  elsewhere may benefit from OO, closures, and the like.]

I cannot tell which statement somebody will focus on. If I put disclaimers and scopes on every sentence, my writing would be about 5 times more verbose. Generally one should paraphrase a statement of issue in their own words. Example, "Let me see if I got this strait. You are saying that all X's are the same as all Y's under condition Z?".

''KeepCriticismNarrow, top.  It's your own advice, so you damn well ought to follow it.  If that means being 5 times more verbose, then be 5 times more verbose.  If I were to trade parsimony for precision, most of my responses to you would consist of two words: "You're wrong."''

I see nothing wrong with that one. There is informal speech, and formal speech. In its context, it was fairly clear which it was.

''Clear to you? the writer? well, that's half the job, I suppose.  Which "that one" do you speak of?  I can say for sure that your meaning regarding the 'closures are borderline MentalMasturbation' comment was far from clear in specifying your intended meaning, even given the context.  In the future, be 5 times more verbose if that's what it takes.''

It started off with "in my opinion". If it confused you, I apologize. And, no, I will NOT change my writing style just for you. Before going into anal lawyer mode, next time ASK first.

''If not "just" for me, why not change it to avoid hypocrisy (KeepCriticismNarrow)?  Why not change it for other people who read sweeping statements as just that?  And I'm always in anal lawyer mode; I don't need your permission for it.''

I don't find it effective. Reading sentences that have to state everything explicitly can be long and tedious to read. Good writers are not verbose writers IMO. Good writers know when and how to use context. Maybe a system of footnotes may be in order, but most find maintaining such too tedious. This is not a court of law, it's a wiki. It is less total "code" to ask for clarification or verification when needed rather than stuff every detail and disclaimer into every sentence. Your suggestion is not the most parsimonious.

''I don't believe "parsimony" to be a virtue worthy of greater pursuit than "clarity".  Your advice would have people saying: "You're wrong" and waiting for YOU to "ask for clarification or verification" - I disagree with this, even in a wiki; I believe that where you can anticipate the question and you think the audience should or will ask, you should provide the answer immediately.  As far as not being a 'court of law': if you make any bold claim on a wiki, you're foolish if you pretend your statement to not already be in a firing range.  And do you honestly believe yourself a 'good writer' who 'knows when and how to use context'?  I certainly don't share your high opinion of yourself.''

Sorry, I have to dissagree. I will gladly supply details if you ask about a given passage. Most people ignore 95% of what I say anyhow. I'm not going to work that hard to make sure a wall is 100% informed. Most people who get involved in debates with me here know that I limit the scope to biz apps anyhow. (Perhaps I should make a "TopmindsAssumptions" page or the like.)

''Please clarify: with which of my statements do you disagree?''

I don't want to argue this any more. If you can show that roughly 75% or more of wiki readers prefer your verbosity suggestion, with a sample size of at least 10, then I'll change my approach. Until then, I'll do it the same way.

[''I would certainly appreciate greater specificity, if nothing else.  If that requires greater verbosity, then greater verbosity is needed.  Instead of off-the-cuff provocation like "<x> is borderline MentalMasturbation in my opinion", or "<y> is over-sold", I think it would be of far greater value (i.e., you might convince people you're right, or at least foster some intelligent discussion about the topic) to argue along the lines of, "Many might choose to use approach or paradigm <x> when they encounter problem <p>, but that's perhaps because they're dealing with forces <a>, <b> and <c>.  I, however, am typically dealing with forces <d>, <e> and <f>, therefore I prefer to use approach or paradigm <y> when I encounter <p>, because it allows me to address <d> through <f> in ways that <x> does not.  Here are examples of <x> and <y> applied to <p> that illustrate the differences in their ability to deal with <a> through <f>:  <insert examples here>"'']

[''If less than ten of us vote, such that you are free to continue posting provocative but information-free statements like "<x> is borderline MentalMasturbation in my opinion", will you do so in order to enlighten and foster intelligent discussion, or will it be merely to get some frustration off your chest and/or fan flames?'']

Do you ask this question to all the other people who do the same thing?

* [''No, just those whose insistence on such behaviour is particularly persistent, pervasive, evasive, and resistant to reasonable suggestions for improvement.'']

''I imagine that it takes a special kind of person to gather enough attention that they get asked a question like that one: someone who is all over the place, bleating personal opinion and interjecting comments with such regularity, pomp, and arrogance that his or her name becomes burned into the brain.  RK comes to mind.''

* [''On more than one occasion, I asked RK essentially the same thing I asked Top.  One wonders if certain participants are more interested in seeking attention than exchanging ideas.'']
* Me arrogant? If I highlighted all the arrogant things my opponents said, the page would look like a school bus exploded. I declare double standards goin' on. --top
* [''I don't think arrogance is the primary issue here.  Lack of ''any'' support for off-the-cuff opinions, followed by endless quibbling that does nothing to defend said opinions is a bigger problem.'']
* Opinions don't really need support. If you wish for a more specific claim, then one should simply ask. I had asked for evidence that certain tools/features/paradigms are objectively and significantly better for custom biz apps. If you have no such evidence, then just say so. if you personally like certain doodads, that's fine; just don't imply a universe truth about their superiority until demonstrated with dissectable examples. It was not me who first used to the Goto comparison to imply superiority (at least within related topic group, for I had compared navigational with goto's long before the current goto catfight, but that was not what triggered this).
* "If you wish for a more specific claim, then one should simply ask."  - I see a problem there, top.  If you offer a more specific claim, you now have TWO claims you need to support.  
* ''One would be a more detailed version of the initial summary. The existence of a headline in a news article does not create two instances of the article. You are getting padantic again.''
* [''Perhaps, but to stretch the analogy:  You post a headline, and when people take issue with the headline you get into a lengthy squabble over it instead of posting the article that would make it all clear.  I don't get it -- what do you hope to achieve by posting unsupported opinions, other than getting some attention?'']

----
NovemberZeroSeven