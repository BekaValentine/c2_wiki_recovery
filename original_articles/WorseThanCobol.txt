What's worse than CobolLanguage? And no fair picking BefungeLanguage or InterCal.

For comparison, consider WhyWeHateCobol.

----
For production purposes, I'd say the kinds of BasicLanguage's packaged with most 8-bit computers.  No named procedures, short variable names, few control structures, few data structures.  Of course, most people didn't do anything important with them, so I suppose they don't count either.  Also, some in-house languages used by specific corporations can be somewhat excruciating to use. -- NickBensema

''Some of us think VisualBasic falls into this category as well, especially when you come across HungarianNotation, but usually whenever someone tries to do something useful within the confines of its syntax.''

'''''However...''' keep in mind that MicroSoft promulgated the use of HungarianNotation in VB when it foisted the "Microsoft Consulting Services Coding Standards for VB" upon an unsuspecting population. Even people who knew better wound up using it because their PointyHairedBoss said things like "It's from Microsoft. Do it that way or you're fired."'' 

Also keep in mind that HungarianNotation didn't start with VB.

BASIC are not too bad really (although, Forth is much better, clearly).
----
	* ASP, JSP, PHP, or any environment where HTML ''(including JavaScript!)'' is intertwined with procedural code. It's like dumping pepper in the sugar bowl. Just try to retrieve the pepper. ''(The mess of HTTP/HTML/CSS/etc itself is far worse than COBOL.)''
	* ObjectOrientedProgramming in PerlLanguage. Unfortunately, many folks just can't see what a back-hack this is.
	* JCL [JobControlLanguage] There is a theory that one JCL card deck was written in 1965 and every JCL program after that is a CopyAndPasteReuse of the original.

----
8-bit BASICs are bliss compared to the hair-pulling agony of IBM's RPG (RpgLanguage). RPG was just one of a number of so-called 4GLs popular on IBM mainframes and minicomputers in the 70's and 80's. Most of them had a fixed column syntax (so you can't even indent your code for readability) and had very limited flow control beyond IF and GOTO.

IF?  You had IF?  Luxury!  RPGII had only compare-and-branch semantics.  You had lines of code that would execute conditionally upon an "indicator" being set, said indicator being a boolean flag in memory numbered 1 through 99. You could set an indicator with a "compare" instruction or as a side effect of some other instructions such as a calculation or a keyed read.  It was just barely a HighLevelLanguage, with none of the actual advantages of assembler. Amazing.

	 :	''I had a job programming in RPG-II for 18 months.  That was all I could stand, then I fled back to graduate school.  I hated the language -- it made FortranLanguage seem high-level (and I'm talking about FORTRAN IV, 1966 vintage).  But I kind of grooved on the indicators, perhaps because they reminded me of the "statement success/statement failure" semantics of a language I really liked, namely SNOBOL4 (see SnobolLanguage). -- CameronSmith''

Long ago I heard about a guy who wrote a full working COBOL compiler in RPG! Obviously because...yes, COBOL is that much better than RPG. He must have been a RealProgrammer.

----
Using RPG (Report Program Generator) for anything other than generating reports is a misuse of the - er - language.  (Actually I considered RPG a utility.)  Also note that it's a generator, not a compiler. -- Gary

''IBM also had a version of RPG called DE/RPG which was used to write data entry programs for 5280 terminals. It was apparently even worse than RPG, if that was possible.''

----
Being asked to maintain COBOL programs while the rest of the world discovers the internet is WorseThanCobol. -- Pat Callahan

----
I think SQL has been affected by similar design mistakes. SqlFlaws.

''Well, obviously it suffers from the similar LetsAllProgramInEnglish syndrome, but SQL can never be as bad as COBOL for the simple reason that SQL isn't a full language, you have to e.g. embed SQL in the midst of a real language. It also doesn't suffer from self-modifying code, which is part of the COBOL standard (at least in the old days, as the usual implementation of EXECUTE PARAGRAPH A THROUGH D.)''

Actually, you do not necessarily have to embed SQL in the midst of a "real" language. SQL is a real programming language (and I have used it with such purpose; I use SQLite which is suitable both ways). Now it has a WITH command which can make it Turing-complete. It is much better than COBOL.

----
If we are talking about programming environments, (language + standard functions library + IDE), then the worst I have seen since late 80s was the leading commercial automated testing tool. Probably explained by the notion that "it's just a scripting language for testers", and probably this notion is alive and well because most users of this tool don't know better.

----

How about the infamous BancStarLanguage?

----

Propose a new scale:
* COBOL: Has inklings of this dreadful language. "Man, that's so COBOL."
* MegaCobol: Full-on COBOL dreadfulness. "This deadline is mega-COBOL."
* WorseThanCobol: You thought ''COBOL'' was bad? "I can't believe my boss. He's WorseThanCobol."
