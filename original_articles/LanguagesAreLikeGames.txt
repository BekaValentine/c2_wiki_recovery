Languages are like board games.

LispLanguage is like the GameOfGo.  An afternoon to learn, a lifetime to master.  There
are only about five rules to the whole game, but unfortunately there
are also five different flavors of the game, each with its own
different five rules.

CeeLanguage is like Chess.  A lifetime to learn, a lifetime to master.  The only
thing orthogonal about it is the board; each piece moves in its own
unique and endearing way.
* Disagree -- the rules of Chess are consistent from one game to the next.  CeeLanguage changes (some of) its rules depending on the compiler used.  It's more like Euchre, where everybody has their own "house rules".

CeePlusPlus is like a GamesWorkshop miniature game.  It looks incredibly cool, you spend more time working on building/sculpting units than you do on playing... and when you play you discover that the rules are freakishly complex and really not that much fun.

JavaLanguage is like Checkers.  Looks a little like chess, but easier for
children to learn.  Half the squares used by the board are just
overhead.

SmallTalk is like Diplomacy.  Looks simple, but most of the action is
actually happening off the game board.

Oracle PlSql is like Risk.  At first glance it seems like fun, but before you know it you find that you've been at it all day, everything seems to be happening pretty much at random, you're all tired, sleepy, and grouchy and just want to call it a game and go home.  But somehow there are tons of enthusiasts who insist on playing it all the time.

SqlServer is like SettlersOfCatan.  Despite being casually compared to Risk, it's quite a bit prettier and normal people can play without going bananas. Like many ''Strategy/Questing Leisure'' games, it's difficult or impossible to get people to switch to a different one once they start.

PrologLanguage is like TabooGame. You must describing your goal until the answer turns up all by itself.

ForthLanguage is like Nomic (http://www.nomic.net).  The primary activity of the game
is changing the rules of the game.  Getting anything done is a side
effect.

BasicLanguage is like Chinese checkers.  Everyone has played it at some point
or another, but it mostly sits in the back of the closet gathering
dust.

AssemblyLanguage is like a deck of cards.  You want a game?  Make one up
yourself. ''Assembler: one who drops his card deck.''

PerlLanguage is like Dungeons and Dragons. It has gone through several versions that are similar conceptually to each other. Each version has a variety of mandatory and optional rules. There are too many add-ons and extras to count. Unfortunately none of it actually makes sense.
* Then Parrot is like GURPS--you can convert your old Dungeons and Dragons modules, but also use sourcebooks from Exalted, Call of Cthulu, 40k...
PhpLanguage is like MagicTheGathering.  Borrowed some features from the above, and improved the usability and learn-ability.  Unfortunately, it is often hard to predict the interplay between cards (classes/objects), and there are still a lot of optional rules, so unforseen FeatureInteraction can ruin a good game.  There's never an add-on for what you want to do, but that's OK, though, because the game isn't really about in-character stuff, so no matter what you're doing, it plays out the same.  The end result makes it easy to do simple hack-'n-slash games (kludged programs), but almost impossible to do meaningful RP (good programs).  Also, there's not much you can do to play one module more than once, because there really aren't modules.
----
CategoryMetaphor CategoryWhimsy