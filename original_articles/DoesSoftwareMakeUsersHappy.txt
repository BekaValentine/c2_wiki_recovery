Of course it does when it is apt. -- PeterLynch

Inspired by PayingForSoftwareDevelopment where someone claims that he has written software that has made people happy.

----

'''Games'''

On this page, we specifically exclude computer games on the basis that programmers aren't responsible for the design of successful games. The best games are consistently created by designers and artists. The ones that aren't are failures.

And the fact that people don't "need" to play games doesn't mean that badly designed games don't make users miserable. It just means that they quit playing and if they manage to finish the game then they never, ever play it again.

Secondly, we're dealing with ''software'' and the software-aspect of something isn't the same thing as its business aspect or its game aspect. Just because people enjoy games and are indifferent to business doesn't mean that games software is any better than business software.

----

It's my observation that there are two kinds of users as regards this issue. Techies and everybody else.

'''Software makes techies happy'''

Software makes techies happy, even when the software is ill-conceived, badly designed and outright broken. Anything beyond this low state makes techies ecstatic. Case in point, Unix vs Windows.

Windows is outright broken. Unix is also outright broken, but to a slightly lower extent. As a result, techies who are new to Unix are ecstatic with it. Techies have ''accommodated'' to broken software to such an extent that even a slight ''relief from abuse'' is experienced with joy.

Almost all users are not techies, or if they are techies then they are so only for ''other'' software, so it matters much more what non-technical people think. I've never seen any normal user jump for joy because they have slightly better software. I have seen them groan in pain, misery and despair though.

'''Software makes non-techies miserable'''

Software frequently makes normal people utterly miserable. This is both a frequent occurrence and a frequently remarked upon phenomenon in popular culture. What's most curious is the pervasive lack of complaints and demands for improvements. There are no demonstrations, revolts, revolutions or lynchings. There aren't even any serious protests. This is not without precedent since, for example, Americans are uniformly unhappy with corporate government but there are no serious demands for better.

My theory is that users sublimate their everyday pain, anger and hatred so that they don't succumb to utter misery and despair. When someone is abused almost every single day, from the same source, and depends on that source to provide for their needs, Stockholm syndrome quickly sets in. Users are abused by software so uniformly and so constantly that they don't feel they have any right to demand better treatment. This is perfectly rational since an appreciation for how abusive software is to them would cause most people's minds to shatter like glass. Users are simply preserving their sanity.

Normal users learn to ''tolerate'' software, though not to accommodate it the way that techies do since this is simply beyond their resources, the way that many people learn to tolerate abusive behaviour in a spouse or parent. But they are hardly ''happy''.

-- RK

''This is a cynical techie's view of how non-techies must feel. Certainly what you're describing happens, and it's far too common, but on the other hand, there's watching the smile on my child's face because they can video chat with Grandma. I totally agree with you that there's a problem with people's low expectation of computers, and how they don't expect things to work. This is one reason why giving them something that actually does what they want is very satisfying.''

It's ludicrous how you call my view "a techie's view of how non-techies must feel" since I am a non-techie and I just described how '''I''' feel. With only minor adjustments made for the fact that I express my feelings instead of repressing them, and that my knowing that better alternatives are possible and working on such keeps me from going insane. -- RK

''A cynic's view, then. And an egotist's, since you're certain that your experience generalized to all cases.''

Oh, I know there are exceptions. But that's what they are, exceptions. And if non-techies have come up to you with big smiles then that just goes to show how much they appreciate that what you've done, which is nothing more than what should be done, is exceptional. You win one argument and you lose another. Personally, I'm delighted that you salvaged your own personal reputation at the cost of sinking your profession's. -- RK

''I'm not obligated to defend my profession's reputation, especially not to you since you've got a hard-set opinion on the subject. Regardless, the fact that I can make someone's day a little better with what I do does not mean that it was bad before - simply that it's better now. More importantly, the argument here is not whether software in general makes people happy, which it doesn't, but whether it's *capable* of doing so, and whether I personally am capable of making even one person happy with software I've written. You've claimed this is false, with your characteristically broad generalizations and insults. So either defend that statement or retract it.''

No, the argument is simply that software in general doesn't make people happy. I've retracted any statement about ''you'' in particular long ago.

----

'''Things that make me happy'''

* Does my quilt make me happy? Yes it does, it's very warm.
* Does my bed make me happy? Yes it does, it's very soft.
* Does my jacket make me happy? Yes it does, it's warm and very stylish.
* Does the selection in my grocery store make me happy? Yes it does, I can buy a reasonable assortment of prepackaged foods, with all the necessary sugars and fats.
* Does soy milk make me happy? Yes it does, it's liquid and healthy. There's even brands that don't taste like shit; the existence of brands that do taste like shit, with no clear labeling, made me very unhappy for a while.
* Does the location of my grocery store make me happy? It makes me satisfied since it's at the end of more than three direct bus lines that go directly from my home to the store. I would be happy if it were half the distance and ecstatic if it were next door.
* Does the transit system make me happy? It does on weekdays. On weekends it makes me miserable.
* Does my cell phone make me happy? Yes it does, it's quite old so there are no unnecessary or flashy features.
* Does my cell phone plan make me happy? Now that rates have actually become reasonable, I'm happy with it. Unfortunately, rates for data are 100x those for voice so I can't say the same about that. (Especially not the contempt the company shows me when it assumes I can't convert between the two.)
* Does my credit union make me happy? Yes it does, they've always given me good service, unlike Royal Bank.
* Does my bicycle make me happy? Yes it does, despite it being rusted out due to my abuse, having a saddle that's way too low and not being able to change gears.
* Does my ''can opener'' make me happy? It used to but it broke easily and had to be replaced. Now I got an expensive solid steel version of the same ergonomic design (with rubber inserts on the handgrips) that looks like it will last 20 years. I anticipate being very happy with it.
* Does broadband make me happy? Yes it does.
* Does human mortality make me happy? Yes it does, 5.9 billion idiots dying outweighs the possibility of my own death.
* Do nature documentaries make me happy? The good ones make me ecstatic.
* Do ''trees'' make me happy? Yes, the deciduous ones are pretty and they produce oxygen. I especially like the ones that have a nice black trunk which provides good contrast with the crown and where you can easily see the fractal pattern of the branches.
* Does the ''sky'' make me happy? Yes, it's a nice shade of blue and it's interesting to watch stormclouds moving freakishly fast.

'''Things that make me unhappy'''

* Do computer games make me happy? No, they do not, they're all ephemeral and pointless. I may enjoy playing them but I rarely enjoy ''having'' played them. Same with TV.
* Do books make me happy? No, they do not. They're expensive as hell and the ones that aren't have to be renewed and brought back to the library within a month. Plus, they don't have any bookmarking nor search functions and they're hard to read because they have small print and low contrast ratios.
* Does paper make me happy? No because it's impossible to archive, maintain and keep organized.
* Do cars make me happy? You mean the contraptions that try to kill me on a daily basis?
* Does broadband pricing make me happy? No, because it often makes broadband unjustifiable.

'''Software'''

* Does Windows make me happy? Fuck no, it's completely unusable for the majority of the things I want to do.
* Does Unix make me happy? Ditto.
* Does X Window make me happy? Hell no, I hate windows! Why would I be happy with software that creates overhead for me?
* Does my text editor (NoteTab) make me happy? It used to make me satisfied, now that the cursor is jumping around randomly it's making me utterly miserable.
* Does my web browser (Opera) make me happy? Only for the first couple of weeks until I ran into its limitations.
* Do web browsers make me happy? No, they do not. When viewing a site with many pages I want to save, to read offline, I have to save each individual fucking file!
* Does wiki make me happy? No, it does not, it's impossible for me to have private conversations with people I want to talk to or avoid people I hate.
* Does email make me happy? No, it does not, it makes me utterly miserable since I can only access it online and there's no good way to sync it.
* Does Winamp make me happy? No, it does not. I've got 681 files in the playlist editor and there's no organization to it, despite the fact that the files themselves are very well organized in the filesystem.
* Do I know of '''one measly piece of software''' that makes me happy? No. I'm happy with Smalltalk ''the language'' but unhappy with every implementation, so that counts as a no too.

Software generally earns from me the hatred I reserve for cops, government, corporations and religious fundamentalists. And there's a common thread through all these things; these ''stupid things'' tell '''me''' what to do!

Contrary to popular opinion (among programmers anyways) users don't want software servants or slaves. They don't want software to be "smart" if that means the software is a person. Users want software to be a ''thing'' that you ''use'' to ''do'' stuff with and which you do things ''to''. In special cases, users want a ''teller'' that does special things for them which they will never have to do ever again. People prefer to do routine banking by themselves at a machine and have special needs met by a teller.

And that's only ''in principle'' because ''in practice'' software never rises even to the status of an incompetent servant or slave. In practice, software is much closer to an evil overlord telling the user what to do and bossing them around.

* Do you really want to do this? Really? Are you really, really sure?" (confirmation dialogs)
* What you're doing is unimportant, it's really most important that you pay attention to the fact that ''I couldn't do what you told me to do''. (error dialogs)
* Don't look at that, I asked you a question! (modal dialogs)
* Papers! Nobody passes through this checkpoint without showing their papers! (username and password dialogs)
* Who are you? What do you want?! (registration / installation dialogs)
* What do you mean you don't know where form 864 is? I need it NOW! Go and find it! (file dialogs)
* When you say 'No' do you mean that you didn't not want to do this or that you did indeed not want to do this? (confusing options in dialogs)

Then there's the software that decides you really need to be somewhere else so it takes you there (steals the mouse pointer) without giving you a chance to voice a protest.

And that's not even going into the whole category of software ''things'' that are about as fun as double-ended chainsaws. Many of those never even do what you want them to do in the first place.

-- RK

----

Software makes non-techies happy.

* email allows us to keep in touch with friends and relatives who live far away, with little effort, and cheaply
* web browsers allow us to get more news from more sources, learn things from other cultures without having to spend large amounts of money to travel there (and hence cannot travel there)
* financial software allows us to see where we can better manage our income, and therefore save more, spend less, and enjoy life more.
* DVR software frees us from having to watch commercials on TV, and allows us to record the good stuff, regardless of when it's on.

''Which all goes to show that software meets people's '''material''' needs. Emotional needs are a whole other kettle of fish since software is frequently abusive and hateful to its users. Again, where does that entail that it makes people happy?''

"frequently abusive and hateful" does not mean always, so even you admit that software can be pleasant to use, and thus it can make users happy. QED.

''Not any software I've ever encountered. Not any software made exclusively by programmers as opposed to designers or conceptual artists. Excepting freak occurrences.''

Invalid generalization - your experience does not equal everyone's experience, nor does it touch even a fraction of the available software. Have you considered that '''you''' may be generally unhappy and are projecting this onto the software?

''Something isn't an invalid generalization just because you declare it to be. And I certainly am generally unhappy at having to deal with idiots like you.''

A generalization is made invalid by a counter example.

''And salvaged by dismissing the counter-example as an exception or simply out of bounds. You're new to wiki so you really should know that only intellectually dishonest pedants restrict generalizations to ''perfect'' generalizations. Imperfect generalizations are widely considered very useful. Further, nobody on this site has an obligation to "prove" something to a hostile reader's satisfaction. Especially not simple observations which will be blatantly obvious to so many others.''

That'd be fine if you restricted yourself to blatantly obvious generalizations rather than extremely sweeping ones, which you laden down with emotional rhetoric. There's a big difference between claiming that a lot of software is hard to learn and use, and calling all software hateful and abusive, and saying that a programmer has a constitutional obligation to make it so. Who's the hostile one here again? Tone it down or back it up.

''And if you're an interaction designer or even merely a designer, or hell even just a normal user, then it's obvious that software is hateful and abusive. The only people who don't think it's obvious are the techies who are in love with software and the programmers who are responsible for it. And while programmers might not ''literally'' have a constitutional duty to make software hateful and abusive, it certainly looks that way from a distance. But that's really a topic I don't want to go into here. The subject of why programmers behave the way they do and think the way they do is much too important a subject to be discussed as a tangent and frankly, it's not worth my time to discuss it openly at all. There would be too many freaks and easily offended sensibilities butting into a serious discussion to which they have nothing to contribute.''

It's worth pointing out that almost all corporate products have designers, even (especially?) the really lousy ones. It's not like there's a magic panacea. Furthermore, as a matter of put up or shut up, can you give any examples of really fantastically designed interfaces that work perfectly for everyone, and list the names of the designers who created them? It's pretty obvious that such a design would have a massive advantage over other, inferior ones so I'm wondering why I haven't heard of any. It's nice to hear that you know so much more than everyone else but can't phrase it in a way that actually withstands criticism, though.

''AllGoodDesignIsInteractionDesign, DirectManipulation, NakedObjects. There's a whole literature on HumanComputerInteraction which you're completely unaware of. And why don't you at least read TheInmatesAreRunningTheAsylum instead of demanding that I transcribe a copy for you? It's available at the library so you won't have to shell out money to AlanCooper for it. (And I hardly think you want to discuss an issue I've called Programmers Are Brain-Damaged, which is really very different from the interaction design issue which you also don't want to seriously learn about.)''

I've read a fair amount of the literature. I've certainly read the Wiki pages. I'm not unaware of it, but on the other hand little of it is actually supportable, and none of it has made it mainstream. Why not? It's not because of a conspiracy amongst all the hateful programmers. *If* software is hateful, and *if* only an interface designer can fix it, and *if* an interface designer can fix it, then why is there still hateful software? Why isn't there at least one well known piece of non-hateful software? Could is possibly be because the question isn't that simple? There's a whole body of literature, but these guys all write books about how we're screwing up instead of writing something people actually want to use. I didn't say show me a book, I said show me something *real*. At least TheHumaneInterface guys have a demo.

''Smalltalk hasn't gone mainstream. Why not? Who the fuck cares!''

If you don't know why Smalltalk hasn't gone mainstream, then you won't know why BlueAbyss or anything else you write won't either. You talk below about an instructive failure, take it to heart here too.

''You've read nothing. "I've certainly read the Wiki pages."? Give me a fucking break. I WROTE half those pages and I couldn't be bothered! You keep whining about a demo but you don't even know enough to look for it. Go on and git you lazy-ass mofo. Oh, and read HostileStudent because that is you.''

I'm not a student here because you've got nothing to *teach* me. I want you to either put up or shut up. You've taken 5 years to get to the point where you don't have anything to show anyone and if you can't do any better than that then maybe you're not as good as you think you are. Of course I know you wrote the wiki pages. I didn't say I've read them and agree with them and worship them as fonts of wisdom! I've read *your* views on "interaction" design, and while I don't disagree totally, but your claims are, at best, vastly overstated. Especially when you retreat into bullshit about how you're the only one who can save computing. Christ. I know what the interface/interaction designers are doing. I've read the literature. I'm not convinced. None of them has ever shown me anything that *I* want to use. They've never shown me anything that my non-programmer friends and relations want to use. I think they're a lot of egotism and hot air, and if there's more than that to be found I'd like them to demonstrate it. It's possible that we've all just been waiting the birth of the genius that will reform the way humans interact with computers, and that a new era is dawning. I'm skeptical, but I'm willing to be convinced. Convince me by showing me the vision of the future to come, not by scrawling hate filled invective on the bathroom wall of the Internet. The proof of an interface is in it's use, not in it's theory - it doesn't matter how many books your write or sell or even how many people read them if people don't want to use what you've come up with.

''If software is hateful, and if only an interface designer can fix it, and if an interface designer can fix it, then we have hateful software because of programmers. Because programmers have a lock-in into software development and they don't want to cede power.''

Wow. Programmers have a lock in to software development. Yeah, there's a whole cabal of programmer enforcers who will break your legs if you try to create a new interface. Just ask Jeff Raskin. You don't think he died of natural causes, do you?!

''At least you've given up on your ridiculous position that software isn't hateful and abusive. Too bad too since I was just about to annihilate it. It went something like this. Top 10 list of software: Unix, Windows, X Window, Microsoft Word, et cetera.''

That was accepting your point for the sake of argument. Note the use of the word "if". With emphasis even! To call software hateful is intellectually dishonest at best, but it's not like I expect you'll ever own up to that. Software can't be hateful because it's not a real thing. Therefore, you must be claiming that the programmers who make it are hateful, and embodying their creations with that quality, much as a racist might write a hateful book. That is so obviously and trivially discredited that no reasonable person could ever believe it, so I'm not really worrying so much about refuting your claims anymore. You can't "annihilate" the point, you can simply scream more invective. 

----

The norm never makes anyone happy - it's normal. Cars are a good example, as is running water or indoor plumbing. The first time a family got running water, it was great and made everyone really happy - no more carrying buckets! Now it's not even noticed unless it breaks. Electricity, too. Software is the same way. I think that Richard vastly over-characterizes the level of "abuse" software gives people - calling it abuse is simply one example - but even at it's best, software is used, not appreciated. Which is not to say that software, like a car, cannot stand out from the norm, either for good or bad. Perhaps a better measurement would be how unhappy someone would be if you removed it. -- Anon

No, it ''is'' abuse. And if you'd read TheInmatesAreRunningTheAsylum, you wouldn't call it anything else.

* ''I disagree, not least of which because the term abuse has emotional baggage. No doubt this is why the term is used. Any programmer-designed interface is optimal for at least one person - the programmer.''

* And since the programmer isn't a user of the software, that's irrelevant. And the emotional ''implications'' are intentional and they are entirely proper. Users are human beings, not disembodied brain entities.

* ''Who says programmers aren't users? Much software, including the software most often singled out for poor interface design, is written by programmers for themselves foremost, then shared with others.''

* This is only ''technically'' true. In reality, the overlap between programmer mentality and user mentality is far, far less than the overlap between programmer role and user role. Programmers aren't users in any meaningful sense.

* ''You're obviously using a definition of programmer here that is far more precise than I am. A programmer is someone who regularly writes programs. Especially in today's business world, no special technical knowledge or tinkering spirit is implied.''

* What that means for the previous point is that yes there are indeed some people in user roles who are perfectly happy with the software made by programmers. However, these people are freaks. It goes much farther than their being just freaks too, but again this is a serious discussion I don't want to have where idiots can simply barge in.

Software doesn't need to be appreciated to make people happy. That's because there's an important distinction between making people ''happy'' and making people happy ''about it''. Electricity and running water make people happy though they don't make people happy ''about them'' because these things have become beneath our notice. Software just makes people miserable all the time.

Even as I'm typing this, I'm anxious that the computer could spontaneously reset or the application / OS would crash and everything I've typed would be lost. Software that makes me anxious doesn't make me HAPPY. Other users have similarly negative reactions to other software or other aspects of software. It gets to the point where users are trained to feel generalized anxiety around all software.

* ''Hrm, someone deleted my response here. *I* am not anxious that my editor will crash here. In fact, I fumble fingered a shortcut and closed the window once while writing this, and restored it without a hitch. I am not anxious because I know that the likelihood of it crashing and my losing this post is no more likely than the ceiling tiles falling down and knocking me out. If *you* are anxious all the time, consider therapy.''

* ''Switch to Linux - much more stable, and you can get editors that do auto backups nicely''

* I'm using Linux, you fool! And I really don't care to spend 100 hours configuring a shitty OS to make it behave halfway correctly. Having to "configure" (waste time on overhead) something to make it work is a perfectly legitimate reason to be unhappy.

* [Do you curse pencils for needing sharpening?]

* Well, there's a reason I don't use pencils, isn't there? And then again, sharpening a pencil takes very little time and effort and you always know when it's done correctly, whereas configuring software takes massive amounts of time and effort and you never know when it's done correctly.

Cars make people miserable too. They need constant taking care of. You have to worry about parking and driving and accidents and maintaining them and paying $$$ for them. Cars do not make normal car owners happy.

* ''True, but...''

Bicycles make people happy if you exclude the anxiety induced by car drivers possibly smashing you into a pulp. But then, that's not the fault of the bicycle, it's the fault of cars. Even the most rusted out hulk of a bike makes you happy.

* ''A bicycle as the normal medium of transportation (and I used one as mine for years) has exactly the same problems. My bicycle made me very unhappy when it was raining. Or when I needed to carry more than I could easily fit in a bag. Or when the chain derailed, or a tire popped. All the same mechanical problems as cars have. If *everyone* used bicycles, such as in parts of China and Hong Kong, they're even more like cars - there's a much more serious theft problem, parking becomes an issue, you have to worry about making sure you chain it up, etc, etc, etc. Getting a car after years of using a bicycle made me very happy.''

* Come off it. Bicycles have far fewer mechanical problems than cars. When they do need attention, the problems are dead simple and obvious and often fixable by the user. And any mechanical problem with a bicycle will ALWAYS be vastly cheaper than a car's. And losing a 300$ bike isn't the same as losing a 30,000$ car. I've had bikes stolen from me and I just don't care.

Mass transit makes people ''very'' happy as long as it runs well and often, like in Europe or Toronto and not like in Ottawa. Trains make people much happier than buses. ''Unless a transit strike cripples the city'' which is entirely irrelevant. ''How so? Are not the people who normally ride the train now unhappy, having no other convenient mode of transport? Or do the citizens of Paris cheer when the Metro is shutdown?'' Oh right, because people never have their cars break down.

* ''I rode mass transit trains for a long time too, and I certainly can't say they made anyone happy, even when they knew it was objectively better than the alternatives. I didn't own a car at the time, from choice, walking and using mass transit everywhere, and I still complained. I liked not owning a car, I didn't like walking 10 blocks in 100 degree weather lugging groceries. But at the time, while the tradeoff was worth it, I would stop far short of saying it's always worth it. I own a car now and would be *vastly* unhappy without one.''

* Where do you live? I once lived about 100m from a supermarket, 1500m from 4 shopping plazas and 2 other supermarkets, and I was very happy. If anything, I would characterize myself at the time as "chortling with evil glee". As for lugging groceries, that's what saddlebags are for on a bike. Nowadays, everybody has them. Further, ''commuting'' on mass transit is unpleasant but no more unpleasant than commuting using a car. And really, it isn't the transit that makes you unhappy, it's commuting. Finally, owning a car would make me vastly unhappy. Especially the part about working half a year to buy one.

** ''I'm currently in the Kansas City area, which is terribly unfriendly to the carless. Where I lived when I was walking was the northeast coast of the US, which is quite friendly to the carless (high population density), but has inclement weather which still made it quite a burden at times.''

* [I'm sorry, but you are not a valid counterexample - walking obviously makes people unhappy in bad weather.]
** ''Presumably, therefore, in order to be happy with walking you must live somewhere where bad weather is rare. Sadly, this rules out large portions of the globe.''

* Since you only need to walk for groceries once a week, it hardly matters. ''As per your own comment above, the imperfect generalization about having to walk being unpleasant holds, your counterexample notwithstanding.'' Walking isn't unpleasant at all. Walking across a freeway, sure, but that's your own damned fault for being an American. Walking is something you do so you aren't a fat-ass slob.

* ''Nonsense again. Walking for pleasure or exercise is a modern trait that only arose because we have faster, more convenient alternatives. Walking because you must, especially long distances, with large loads, or in bad weather, is an unpleasant chore, not a pleasure. Anyone who thinks otherwise is no doubt a brain damaged Stockholmed moron who doesn't understand me.''

* I don't walk for pleasure or exercise. I don't bike for pleasure or exercise. I bike because I have to, in order to get to a destination. But I find biking far more pleasant than driving a car. And on the whole, bicycling is more or less equivalent in convenience and pleasure to a motorcycle. The freedom from parking and bureaucratic restrictions (licenses, insurance) compensates for having to plan shorter trips.

* Further, the difference between "programmers love software so everyone should learn to program then they would all love software too" and "bicyclists love to cycle so everyone should learn to cycle and then they would all love cycling" is that the latter is possible whereas the former is nonsense.

* The only thing preventing everyone from cycling is the dumb building patterns in North America, the presence of so many cars (a self-reinforcing vicious cycle) and the epidemics of fat Americans. There is nothing that can be done by users about the fact that they are made miserable by hateful and abusive software. Nor can programmers do anything about the fact that when left to their own devices they produce such software.

** ''There's certainly a difference there, but the one you state is totally, and obviously, wrong. For one thing, not having cars actually works best in areas of very tight urban sprawl, like Hong Kong, which are harmful for many other reasons. Furthermore, not everyone loves cycling, whether they've done it or not. Additionally, cycling, or any other non-covered mode of transportation is at a massive weakness anywhere the weather is not always (or mostly) moderate, which rules out most of the US.''

** Hardly. The thing that rules out cycling in the US is the lack of infrastructure (which includes fucked up building patterns) and effective transit alternatives. Cycling is a perfect complement to mass transit. Especially newer long buses and light rail where one can easily bring one's bike on board. A combination of cycling and transit provides greater freedom and convenience than automobiles in the city core.

** The only people who legitimately need to "go long distances" and "haul large loads" are construction workers or people living out in the country. These people buy pickup trucks, not sedans. And if you buy a car to help you out on moving day then you're an idiot; renting a van is much cheaper. 

** ''The number of loads too big for one person to carry, yet that fit easily in a car is almost infinite. Try 2 children, just as a start. Or groceries for those 2 children. Get it through your head that not everyone lives the life that you do, and that they have no obligation to. I've re-written this response 4 times now to avoid the ad-hominem attacks just waiting to come out, so please don't say anything stupid or provoking in response.''

** Letting children cycle to school is a lot easier than chauffering them in a car. So's dragging them through the subway, which they can usually learn to take on their own before adolescence. Just because you live in a retarded country where they build freeways between homes and schools doesn't mean that this is the way it has to be.

EditHint: could you move this discussion to a more relevant page, such as CarFree?
----

* Some exceptions are '''relevant''' because they point to the possibility of completely changing the situation at hand and simply negating the imperfect generalization, whereas others are simply irrelevant because there's nothing the principals involved can do about changing their own situation.

** ''Again, totally wrong. A user, for example, can learn to program and write his own software that suits his needs. This is highly unlikely, at least in our computing environment, but the effort and frustration is probably not any less than someone using only a bicycle for transportation in most of the US. It's also about as likely to happen as a massive, nationwide re-creation of all our urban areas to support bicycles while we all throw away our cars. Which is to say, not at all.''

** You really are so detached from users that you haven't the slightest clue what they can and cannot do. No, normal everyday users simply cannot learn to program and write their own software. Not even in Smalltalk. This was conclusively established by AlanKay when he performed this precise experiment.

** AlanKay tried to make a system/language which anybody could program. He failed, and the failure is instructive. A small minority of the students learned to program without needing any help. A large majority were never able to program no matter how much effort was wasted trying to teach them.

** ''They were *able* to program. They weren't able to "grok" programming, or to internalize it in the way a tinkerer/hacker/wizard can. This is very different from not being able to create programs.''

** This contrasts badly with cycling, which is easy to learn and to do. Upwards of 99% of the population can cycle, almost anyone who's able-bodied. And unlike learning to program, which requires a massive investment of time and effort, switching to cycling would entail a massive ''reduction'' of investment. Buying a bicycle pays for itself with just a year's car insurance premiums.

** ''Final point on the bike thing, since it's pretty clear I'm not going to convince you of anything. It's a reduction in your investment of *money* at the expense of an investment in time, inconvenience, etc. You may be fortunate enough to live in an area where the non-money costs are minimal, but that's not the general case''

** ''Yes, people are capable of writing their own software. Lots of them do it every day in applications like MS Office. Further, the programming skill to write/correct simple applications and behaviors is well within the abilities of the average person. They simply don't *want* to do such a thing.''

** We aren't interested in trivial programming where a user customizes this or that. If normal users don't learn to program full hog, they'll never acquire the brain damage that's required for them to LOVE software. Since this is impossible, as Alan Kay demonstrated to his chagrin, most users will simply never learn to love bad software.

** ''The hardest part of programming is not the technical differences between trivial programming and "full hog" programming. It's the conceptual ability to reduce problems to basic blocks and abstractions. See TeachMeToSmoke. Obviously, more complicated programs require greater abstractive ability, but the concepts are available to everyone. I know a lot of programmers who don't LOVE software, any more than an average cook LOVES an omelet - or a skillet. The LOVE thing you're talking about is a tinkerers mentality, and is a cause of being a programmer, not an effect.''

** This is false. More complicated programs don't require greater abilities at abstraction. Programming doesn't require abstraction at all. Further, what prevents normal users from programming is being able to subdivide goals into tasks. Normal users can do exploratory programming where they go one step ahead, but they can't think 15 steps ahead to the goal they're trying to reach. Normal users can do minor customization but not production of programs. And they'll never be able to do otherwise.

** ''I would consider the ability to "de-abstract" things an abstraction ability. This is probably just a definition issue so let it do.''

** "tinkerers mentality" is just an empty label and means absolutely nothing. It's orthogonal to programming and it's orthogonal to loving programming. I hate programming but I could easily argue that I have a "tinkerer's mentality" since I tinker with ideas.

** ''It expresses itself in different ways in different people, but as I see it it's the same urge - to take things apart, to put them back together, to see what happens when you put them together differently. What the "thing" is is just a matter of happenstance. Long before I was exposed to computers, I'd get my mom to buy old appliances at garage sales so I could take them apart. It's the same thing. Obviously, not all tinkerers become programmers, but it's a common outlet. It's the source of the "hacker mentality" that's so often talked about. There's a big difference between a "hacker" and someone who just puts programs together as a job. It's not even necessarily a difference of quality, although you will obviously tend to become much better at things that you love. And I wonder why you say you hate programming - there's a lot of different things that can be described that way. What is it that you hate? I assume from your other posts that you tend to think in wholescale concepts and abstractions rather than details; is it the need to break these apart into chunks that makes you uncomfortable?''

** The thing I don't like about programming is that it's comparatively boring. There's a lot of overhead (things I don't care about) involved so it takes a massive effort (learning the libraries, coding conventions, interfaces, even writing and testing my own methods) to get minimal reward (do something creative). So basically I don't want to do it, and I don't want to have to do it. But I do have to do it. And you can learn to hate something you resent doing very, very quickly.

** I'm not at the stage yet where I literally hate programming, but neither am I able to force myself to program when there are less boring alternatives around. People suffer for it too because I end up with coding delays and they don't get my software. But then again, they don't have to suffer my massively bad behaviour if I really hated what I was doing 24/7. I don't think the latter compensates for the former though.

** I think it does matter what the outlet is but I don't have any convincing arguments that it matters in general or why my caring exclusively about concepts (most people care about percepts, sensory experiences) should make a difference. The concept/percept thing is a fundamental difference orthogonal to intelligence. Upwards of 90% of gifted children care about percepts and do fine in enrichment programs. Only something like 7% suffer in them. I've always recognized myself in that 7%. But actually, it becomes obvious to me now when I consider programmers as caring about the perceptual experience of programming. Yeah, I think I see it now. So basically, 93% of tinkerers are fundamentally unlike the other 7%.

----

Software doesn't make user happy, but neither does any other tool.
Hammer doesn't make you happy. Knife doesn't make you happy. A cup doesn't make you happy. A phone doesn't make you happy. A typewriter doesn't make you happy. A pen doesn't make you happy.
What's the point?

''On the contrary, my cellphone makes me very happy. I don't use the other things.''

Is it really a cell phone that makes you happy? Is it actually not the conversation taking place that makes you happy? If we have a better medium of conversation, will cell phone still make you happy?
Compare to home phone, does home phone make you happy?
25 years ago, did home phone make you happy?
70 years ago, did having a concrete road make you happy?

* I don't have a home phone and it would cost me more than my cell phone. I also don't see the point about concrete roads, they still exist.
** ''The point of road is, if you have to travel somewhere, would you prefer going to where there is no road leading to it or one with road(s) leading to it? Also, if you were lost somewhere, you would be happy to walk by the road, knowing that a car might pass than lost in the forest with less chance of seeing someone accidentally. You don't feel anything any more with roads' existence. But in the old days, or even now, roads mean development. When roads reach a suburb, the market place grows, electricity comes. People are happy to have roads.''

* Also, it IS my cell phone that's making me happy and not the actual conversations. Any one of the actual conversations on it has minimal value and even in aggregate they don't have value. Their value comes from being connected with people. And that's what the cell phone provides.
** ''Then If PC provides Voice over IP phone software. You will be happy with PC? And if Cell phone were so hard to use like software made by programmer. Would you still be happy with Cell Phone? If you are happy because it can do the work. Then there is no reason Software can't make you happy, because software can do the work.''
** ''My cell phone has a crappy interface that makes me miserable. The convenience of portable communication is great, especially since I'm away from home a lot, but the interface of my phone is terrible. In my case, it's absolutely the communcation that makes me happy, and it's in spite of the actual phone itself, not because of it.'' -- ChrisMellon

No tool can make its users happy; it's the activity that comes from using it that makes user happy. Holding a phone in your hand wouldn't make you happy. 

Happy is just a thing of expectation. Once you know that it's always there, you are no longer happy about it anymore. People are never satisfied. 

A thing about software is that people expect so much about it. When software comes out with some little feature, one that it does well, you will be asking "Why can't it do that and that and that?". If it comes with thousands of features, you will be asking "Why does it come with so much thing to learn?" If it comes with configurable interface and programmable control, you will be asking "Why do I have to learn how to tell it what to do?" If it can automate most simple tasks for you, you will be asking "Why do I have to tell it that I want it to do this task now; why can't it just figure that it should do the task whenever I do XXX". 

On the other hand, nobody complains "Why does my bike not automatically slow down for me when I'm riding too fast?", "Why do my bike's tires not automatically change to rough surface when it's raining?", or "Why does my bike not automatically find the shortest path for me?"

Because you think bike is dumb mechanic thing. When you think someone is dumb, you are just so happy that it can do some works. But when you expect someone (PC) to be so smart, no matter what they do will never satisfy you.

''When software starts acting like it's a dumb material thing, then it will finally achieve people's expectations of it. Until then, it hasn't risen even that far.''

Right. But the only way I can see to achieve that is that we have a ClockOS that, when it boots up, can do nothing but telling time. : )

''I wouldn't count on even that working. I'll bet you that if you ask a typical programmer to write an application that does nothing but tell time, they'll still get it wrong.''

Then that's you have high expectation of how PC's tell time program would work. I see no difficulties in making a program that does nothing but tell time and have interface exactly like a digital clock.

''And how do you set it? How big would the digital clock be? What would it look like?''

MayZeroFive 