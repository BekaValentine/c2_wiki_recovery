One category of SoftwareExpertsIpersonallyRespect is inventors of truly new programming languages. This page lists a few languages and inventors. This page is part of the WikiWikiWeb's InformalHistoryOfProgrammingIdeas.

Some of these are not languages anyone would want to ever use again, but they represented new ways of looking at how to interact with computers. Especially considered in historical context, each of the languages and language creators listed here had a unique insight that changed the way we thought about programming.

----

'''Languages that Introduce New Idioms or Influenced Subsequent Idioms'''

	Langing & Zierler System:	Arguably the first algebraic compiler, implemented on the MIT Whirlwind in 1953-4.

	Information Processing Language (Allen Newell, Cliff Shaw and HerbertSimon, 1956):	Developed at RAND Corporation and the Carnegie Institute of Technology from about 1956. IPL included features intended to support programs that could perform general problem solving, including lists, associations, schemas (frames), dynamic memory allocation, data types, recursion, associative retrieval, functions as arguments, generators (streams), and cooperative multitasking. Newell had the role of language specifier/application programmer, Shaw was the system programmer and Simon took the role of application programmer/user. [Wikipedia]

	Fortran [FortranLanguage] (JohnBackus):	'''FORTRAN''' is the first widely used high-level programming language (high-level as compared to assembly language). [Note on "widely used": there is a thin line between a glorified assembler with a powerful macro processor, and a real programming language. Systems that allowed you to write Fortran-like expressions existed before. But they were always tied to a specific machine architecture: FORTRAN was the first language that really went beyond assembly in that it gave source-to-source compatibility between different platforms.] The main contribution of Fortran was that it could produce code as tight (or tighter) than that produced by hand, convincing the computing community of the practicality of high-level languages. 
** ''Isn't this the first "cross platform" language? That would be a significant trait. If not, which is?''

	Cobol [CobolLanguage] (GraceHopper):	'''COBOL''' was the first major language to support record types as they are known today.  Both this and the syntax are ground-breaking, although the syntax wasn't ground-breaking in a useful way. It could be taken as the genesis of LiterateProgramming. Cobol was the first language designed for commercial applications. At that time, since there was '''no''' language, any language was a ground breaking. COBOL was machine independent from specification, supposed to be readable by laypeople.

	Algol [AlgolLanguage] (PeterNaur e.a.):	AlgolSixty was the first language with a formally specified syntax, the first language with LexicalScoping, the first language which had CallByName, (its later dialect Algol68 was also the first language with full formally specified semantics). Strongly influenced the design of Pascal, PL/I [PliLanguage], C (via its ancestors (B)CPL and B), and, to some extent, Scheme [SchemeLanguage]. Most of the imperative languages we use today were shaped by it.
	 :	''(How about first language with "blocks" (like begin ... end or { }?)''
	 :	That is implied by lexical scoping. Lexical scoping means block-local variables. Another important contribution of Algol was the concept of platform independence. In practical terms, this meant that I/O was left up to individual implementers to develop, and platform ''de''pendence quickly set in.
	
	Lisp [LispLanguage] (JohnMcCarthy, 1958..today):	'''LISP'''. HigherOrderFunction''''''s, Functors, LexicalClosure''''''s, GarbageCollection, amazingly powerful macros (see LispMacro''''''s), MultipleDispatch, MetaObjectProtocol, Introspection and Reflection, Dynamic Objects, MethodCombination''''''s, MixIn''''''s, Code as Data, IncrementalCompilation, DoWhatImean, Continuations (see ContinuationExplanation), ExpertSystem Shells, Frames, LotsofIrritatingSillyParentheses, if-then-else statements (previous languages, such as Fortran, only had a conditional goto).  Note that LispLanguage predates CobolLanguage and AlgolLanguage. Mc''''''Carthy's original 1958 LISP interpreter had the if-then-else statement, and was the first language to implement it, as FortranLanguage of the time was quite primitive.
	 :	''By this reckoning, Algol started also in 1958. Most discussions about priority are moot, because JohnMcCarthy was involved in both projects.''
* When were '''implementations''' of Algol 58, Algol 60, and Algol 60 revised report 1962 actually released? Most sources just mention the dates of the reports. Lisp had a partial implementation (apply-based) running in late 1958, and a full implementation (eval-based) possibly in Dec 1958, no later than Mar 1959.

	Forth [ForthLanguage] (ChuckMoore):	First interactive stack-based language using RPN.  The first extensible language and the first metalanguage (no, Lisp predates Forth as both of these, but not by much (or am I misremembering? Lisp is late 50s, Forth early 60s, no?) ''Correct. In fact, in 1960 ChuckMoore took JohnMcCarthy's Lisp course.'' But the relevant question isn't Lisp 1.0 vs Forth 1.0, it's LispMacro''''''s vs IMMEDIATE words. But Lisp does still win; MacLisp introduced macros in 1963, at which point Forth's predecessor barely had procedures.)
	 :	''(...which led to PostScript)'' (actually not, according to John Warnock, inventor of PostScript.  See ForthPostscriptRelationship.)
	 :	Chuck's first Forth evolved between 1958-1968 from a simple equation interpreter (purely pragmatic; Chuck didn't want to have to reload his entire two racks of HollerithPunchCard''''''s everytime he wanted to solve equations for a different satellite) to a full language having parameter and call stacks, procedures, indirect threaded code, and implementations for dozens of different computers (and the name "FORTH").  Forth developed via ParallelEvolution many of the advantages of Lisp: interactive, platform independent, extensible compiler, code as data, HigherOrderFunction''''''s ( ' and EXECUTE), IncrementalCompilation.  Chuck's recollections of Forth's history are at http://colorforth.com/HOPL.html

	FP (Backus):	First pure FunctionalProgrammingLanguage.

	Java [JavaLanguage]:	First industrial language with built-in security features (class loaders, security managers, privileged operations, signed code/ProofCarryingCode). Also first language with InnerClass''''''es. Saved tons of programmers from the inadequacy of using C++ for business applications.  ''But what will save tons of programmers from the inadequacy of Java?'' I gotn the implicit smiley, but the fact of the matter is that we don't have any relevant evidence to show that java is inadequate for tons of programmers. It doesn't have any systemic problems, it doesn't have major expressiveness problems (for all but advanced domains, and those are unaccessible to the unwashed masses anyways), so ... In the worst case, you can still throw AOJ or NiceLanguage or other backward compatible extension, and the result is a very decent language even for PL weenies. And you get absolutely for free the benefits of the major effort behind HotSpot (and competing projects from IBM and BEA), something that would be nice for other languages to have but it is extremely difficult to achieve in a language that is distributed for free.
		 :	InnerClass''''''es are a form of lexically scoped closure, so are predated by Lisp and Algol.  Other languages, such as Smalltalk and Pascal, had a bytecode VM before Java.  The HotSpot VM was adapted for Java from a Smalltalk VM that itself descended from Self.	The only really interesting aspect of Java, from a programming language viewpoint, is the part that is used least by working Java programmers: the transfer and secure execution of untrusted code.  The features that support this existed in other languages before Java: EmeraldLanguage and MagicCap come to mind.

	ML [MlLanguage]:	ML was the first language with PolymorphicTypeInference.  The module system of Standard ML [SmlLanguage] provides type-safe functors (modules parameterized over modules).

	Simula [SimulaLanguage] (KristenNygaard & OleJohanDahl):	'''Simula 67''' Kristen Nygaard & Ole-Johan Dahl invented Simula I and developed it into Simula 67, which was the version that introduced CoRoutines (no, '''used''' coroutines; they were not invented for Simula, they were earlier), garbage collection, and -- most importantly -- genuine '''objects''' as we think of them today.

	ObjLanguage (JosephGoguen):	'''OBJ''' was the first language to implement parameterized programming and its module system influenced the designs of the Ada, C++ and ML module systems.

	PL/I [Programming Language/I, see PliLanguage] (the PL/I team at InternationalBusinessMachines):	PL/I was the first language with ''exceptions''. They also included a macro preprocessor, well known today from C and C++, although this was not IBM's first macro language - credit for this goes (I believe) to the FAP (FORTRAN Assembly Program) macro language on the IBM 704/709. They also invented the concept of a LanguageLawyer ;-).

	Prolog [PrologLanguage] (Robert Kowalski, Alain Colmerauer and Phillipe Roussel):	Kowalski invented LogicProgramming at Edinburgh University, and Prolog, the first logic programming language, was implemented at the University of Aix-Marseille in 1971.

	Smalltalk [SmalltalkLanguage] (AlanKay inventor, DanIngalls implementor, and AdeleGoldberg protagonist):	Live objects.  MetaClass''''''es.  Contexts.  CompiledMethod''''''s.  OverlappingWindows. Smalltalk introduced overlapping windows to the development community, and slightly predates (and was probably the inspiration for) the Lisp environments like Loops, Interlisp, and LispMachine''''''s.  The integrated environment is not strictly speaking part of the language, but the language supported a great deal of reflection and that was what led to "browser as class editor" and "debugger as context editor".  Even more notable is the introduction of blocks, more specifically, SmalltalkBlockReturn.

	Self [SelfLanguage] (DavidUngar and RandallSmith):	It uses a PrototypeProgramming paradigm instead of the more common class-based one. Self makes no distinction between member access and method calls: everything is just a slot. The caller doesn't need to know if a slot is (like a) read-write variable, a read-only value, or a method, and that can be redefined transparently in any object. The Self implementation was also groundbreaking in the level of performance it achieved in the absence of ManifestTyping.

	Icon [IconLanguage] (RalphGriswold):	Introduced entirely new semantics for expression evaluation based on generators, an explicit notion of expression failure (distinct from exceptions, which represent ''unexpected'' failure, or returning a distinguished value), goal-directed evaluation and backtracking, and coexpressions.  Traditional logical and relational expressions were recast into these new semantics; the traditional uses still work as in other languages, but broader and more versatile usage became possible.  The motivation for all of this was to produce a cleaner, more unified language with the string-processing power of SNOBOL [SnobolLanguage]; the result was a language that exposed the backtracking and goal-seeking behavior for use beyond string matching.  Many of Icon's concepts and mechanisms have made their way into other languages, but the combination of them (and the associated problem-solving styles) has not.

	APL [AplLanguage] (KenIverson, who later created J [JayLanguage]):	An early CollectionOrientedProgramming language that had Vectors and matrices as first class types. The same language both as interactive calculator and programming tool. (The first language to require its own keyboard?) ''I find it hard to read through http://home1.gte.net/res057qw/APL_J/IversonAPL.htm without being amazed at the ground that these languages have broken!'' It was also a different way of thinking. You should read his article accepting the TuringAward he earned for APL (that, by itself, should replace the language in the list)

	Short Code (by Mauchly in 1949):	The first AssemblyLanguage, however it was interpreted (byte-code based), and hand-assembled. The first working automated native assembler for a real hardware cpu was Autocode, by Alick Glennie on a Manchester Mark I computer. An order of magnitude improvement over hex/octal/binary value entry (also called hand-coded numeric-and-switch programming) in early computers. Today assembly languages are written for every new CPU. "Short Code ... both the first interpreted language and the first assembly language." http://www.thocp.net/timeline/1947.htm http://mbinfo.mbdesign.net/1937-1960.htm and http://radio.weblogs.com/0100945//2003/12/04.html

	VisiCalc:	The first two-dimensional language.  Spawned the most popular and pervasive language type (spreadsheets) in existence.  My vote goes to this one as the '''most''' groundbreaking language to date. I agree. Visicalc '''actually''' changed the world. Every small company wanted Visicalc and bought a computer because of that.
	* VisiCalc?  Do we count a spread sheet as an extremely domain specific language?  ''Sure.  It's declarative, interactive, graphical (well, 2D anyway).  Spreadsheets allow real people to do real work without talking to a programmer.  Every language should aspire to this ideal.'' I remember how Lotus-123 macros turned accountants into programmers of sorts. MicrosoftExcel ruined this trend. (See ComputerProgrammingForEverybody) ''Sure spreadsheet macros are a programming language -- We have sequence, selection, iteration; what else do we need ?'' I've been told that at one time more programs existed written in Lotus 123 macros than in any (other) programming language.
* If VisiCalc gets moved again, say why. I'm with JonBentley (ProgrammingPearls), who described why it should be viewed as a FourthGenerationLanguage, changing many people's view of it.
* ''It's a big difference to say that something is groundbreaking enough to make this list vs saying it's the '''most''' groundbreaking language. VisiCalc is fine, but it's no Lisp.''
** I'm not understanding this no-lisp comparison? It's listed for different reasons than lisp. 
* {I've seen its direct descendant, Lotus 1-2-3, almost succeed in ComputerProgrammingForEverybody (search for "Lotus").}

	SGML:	The first markup language. lead to today's HTML, XML and all the other markup lanaguages that make up today's document oriented programming approach.

	GraphicalProgramEditor:	Despite the name, the world's first GraphicalProgrammingLanguage, in 1966 by WilliamSutherland (IvanSutherland's brother, and of course strongly influenced by SketchPad -- which was a constraint based language itself, but not general purpose). See citations on this in GraphicalProgrammingLanguage.

----
''The following languages need to be better motivated before being (re)placed in the list. Only languages that were truly revolutionary should be in this list; just having some extremely cool implementation of an already existing feature, or just having some handy new feature in an otherwise unremarkable language, doesn't count.''

	Ada [MIL-STD 1815A] circa 1983.(?):		A language designed & mandated by the U.S. military. (Yes, Virginia, it's true.)  It was one of the first (the first? pls correct me...) with exception handling, generics, constraints,  multi-tasking (just try to do _that_ on MS-DOS!) plus a slew of other features that I forget. Ada is strongly typed.  It was hard as hell to write a govt "validated" Ada compiler and those programming teams who did actually achieve the coveted "MIL-STD 1815A Validated" title were talented indeed.  In the end Ada was just a stepping stone for other more mature (and better thought out) languages.  Ada pushed the art of compiler development significantly.  I'll also bet that Ada was one of the first compilers ever to be rated a "schedule B commodity" by the US, which meant it was a controlled piece of technology that couldn't be sent to Eastern bloc countries without special permission.  As for being groundbreaking, C++ borrows a lot from Ada, and Java might someday too. (sic)  The Ada "movement" of the 80's also gave prominence (hence funding) to OOP gurus such as Grady Booch of Rational, among other OOP luminaries.

	BASIC [BasicLanguage]:	The original one (John Kemeny and Thomas Kurtz) ''(...from FORTRAN, claim some)'' The first language to make strings as easy to handle as numbers, and for many programmers, their first language.  Remarkably easy to understand.
	* '''Q:''' Did BASIC introduce the idea of mandatory line numbers? This had a dual effect - it lowered the entry barrier for GOTO oriented programming, since the labels were there already, and it allowed computed GOTOs and GOSUBs (though I don't think all linenumbered BASIC dialects supported those). ''they did not, but there was also ON..GOSUB''
	* '''A:''' IIRC, in the original Dartmouth BASIC destinations of GOTOs required numeric labels (as in Fortran). The line-number nastiness evolved with interactive time-sharing systems, which required that every line be numbered in order to facilitate editing. For example, on your first pass typing in a program, lines might be automatically numbered in increments of 10. Then, if you discovered you had to insert a statement between lines 100 and 110, you could type '105' into the system and, hey presto, whatever followed was inserted between lines 100 and 110. 
* {The numbered line labels also made cross-platform editing easier because line numbers were used to indicate which line to replace. Users didn't have to learn a new input mechanism per brand.}

	BourneShell:	In the Unix environment of stdin-stdout connectable tools, created a new ad-hoc programming environment, leading to other shells, awk, Perl, TCL, Python, etc.  (See the Pipes section at http://cm.bell-labs.com/cm/cs/who/dmr/hist.html .  Pipes were revolutionary.)

	CPL:	Deserves some kind of mention for being the language that put functional programming and source code for a Tic-Tac-Toe program in the ScientificAmerican in 1966.  Its probably the only language that had predefined semantics.  It gave meaning to expressions like this:  ``area = pi * r * r where pi = 3.14159`` (the real syntax was different).

	Erlang [ErlangLanguage]:	Concurrency.  ''Erm, Erlang wasn't the first language with concurrency, not by a long shot.  It wasn't even the first language to use MessagePassingConcurrency, for that matter.  Erlang is an interesting and useful language; but I'm not sure about ground-breaking.''

	Haskell [HaskellLanguage]:	Haskell is ground-breaking by systematizing ad-hoc overloading using TypeClasses and constructor-classes. ''What was the first language with lazy evaluation? Maybe that's not too groundbreaking a feature, though.'' [I would say it counts as groundbreaking, but I'm pretty sure it was MirandaLanguage was the first, not Haskell.]

	HyperTalk:	The first object-based ScriptingLanguage integrated with a graphic interface. Graphical tools were part of the system for both the developer and users, thus providing a programmable drawing tools. This was the first environment to demonstrate a new paradigm of development '''HyperProgramming''' in which the directly manipulated objects on screen, were the program. HyperCard also simplified many aspects of development and became widely accessible to developers of all ages from four years upwards. For example, the architecture was simplified to use a stack of cards metaphor with fields and buttons, there was no concept of ''save'', everything was persistent, there was no concept of a network, since messages could simply be sent to objects in stacks on other computers to develop distributed Systems. The style of development pioneered in HyperCard live on in other languages such as AppleScript Serf (http://www.best.com/) MacroMindDirector's Lingo.

	Linda [LindaLanguage] (DavidGelernter):	Introduced the use of TupleSpace for distributed processing.

	Delphi/ Object Pascal (Anders Hejlsberg):	In the mid 90s, Object Pascal and its overarching IDE, Delphi, inspired the world for a short time and founded many of the underlying design principles that would eventually surface in the subtantially more-popular C# programming language (also Anders Hejlsberg).

	 :	Essentially an object oriented upgrade to Turbo Pascal with strong types, Object Pascal differed from its peers, such as Visual Basic, Paradox, Power Builder, and C++ which struggled to provide appropriate tools and class libraries for implementing modern GUI interfaces and database access. Rapid Application Development (RAD) was the buzz word of the time, and Delphi showed how strong types were essential to building large-scale applications quickly.  A truly compiled language requiring no run-time libraries or interpreters, it compiled in a fraction of the time of C or C++ compilers due to the modular design of its language.  It is currently in its 19th revision since Delphi 1.0 was released for Windows 3.1 and now supports Mac OSX, x64, and some open source cross platform variants have surfaced including Free Pascal and Lazarus.  Object Pascal introduced the "Property" keyword (which abstracts calls to getters and setters) and is still absent from C++ and Java.  Going beyond simple properties, Object Pascal introduced Indexed Properties which are abstracted arrays and supports multiple named indexers per class definition (which C# still does not support).  It also introduced "Published" level visibility for interacting with modern GUI design tools, and virtual constructors which make it easier to implement class factories.  Generics, Native Unicode strings, and operator overloading were implemented in later revisions, but many regard the language to be neglected/dead since it's chief architect, Anders Hejlsberg, was lured away, along with several other key developers from Borland, to join Microsoft in the late 90's.

	 :	At Microsoft, Anders most-notably created C#, which is most-popularly recognized as inspired by Java, but also takes much influence from Object Pascal.  

	Perl [PerlLanguage] (LarryWall):	Question: Is Perl's so-called "AutoVivification" a Perl original?  If not, I'd definitely nominate whichever language did first have this feature.  (I'll add a page with an AutoVivification example.)  ''Perl's emphasis on getting real-world tasks done with a minimum of effort, at the expense of elegance, feels to me like a real paradigm shift, but I am not that familiar with the history of programming languages.'' Also, is it groundbreaking that the language is "idiomatic" -- that the syntax is so extremely flexible that you can try to map your thinking into Perl almost directly? For example, think about all the ways you can structure an if statement: with "if" or "unless", with the conditional before or after the expression. It felt a little groundbreaking when I realized the implications of that.  ''First decent attempt at a context sensitive treatment of variables? First language to try to incorporate all language features known to mankind?  (At the time, most new languages took one new idea and thrashed it to death.  In fact, most of the languages being worshiped on this page just added one new feature then focused so hard on that as to be unusable for real work.  Whereas the work horse languages are shoved down here in the also-rans.  ;-)  And who says perl can't be elegant?  '' Question: What about perl's influence on Regular Expressions? or having hashes as one of the three main primitive types? If visicalc is on the list for being the first spreadsheet language, perl should be on the list because pretty much every modern web language yanked features from perl or developed restrictions as a reaction to perl (like python).

	PlanKalkuel (KonradZuse):	This is an entry sure to invoke controversy. Undoubtedly the first attempt at a programming language in the modern sense, and it had some influence on the development of AlgolLanguage, but as it was never implemented (until recently) does it really count?

	Prograph:	[PrographLanguage] (is there an ancestor? ''yes, see Sutherland above'') was an early commercial visual programming language in the sense that a program consists of interconnected visual building blocks from assignment, conditional and repetition statements upwards.

	Python [PythonLanguage] (GuidoVanRossum, 1989):	For making white space/indentation significant and for combining so many BigIdea''''''s in one simple and easy to learn design: for example the slice notation for accessing sequences, the unification of dictionaries and name spaces.  

	REBOL [RebolLanguage] (CarlSassenrath):	A multi-paradigm (symbolic, functional, OO) ''messaging'' language; designed for the semantic exchange of information between people and machines. Draws some concepts and features from other languages: Duality of code and data (Lisp), complete extensibility (Forth), raw usability and light syntax in a functional language (Logo). It is a meta-language like Forth, but with full reflective capabilities (it is a meta-circular language). Supports 40+ datatypes, including things like ''email'', ''url'', ''money'', ''pair'', and more. These are not classes or objects, they are native types recognized directly by their lexical form. In support of the messaging concept, REBOL contains a function called ''parse'' which you can use to build dialects (embedded languages). ''Parse'', itself, uses a  BNF-like dialect to specify grammars and you can use any of REBOL's datatypes as tokens to be recognized. The concept of pseudo-types, different than inheritance, is unique as well (AFAIK).

	SNOBOL [SnobolLanguage] (RalphGriswold, who later created Icon):	The first language (or one of the first) that implemented regular expression like patterns. Actually, SNOBOL patterns were more powerful than current regular expressions. The over all logic comes from Markov Algorithms.  It did not last long, but introduced regular expressions and was really cute.  ''Actually, a language named COMIT, which predates SNOBOL, already had the idea of matching strings against patterns, and extracting the matched substrings.  SNOBOL was intended to be, among other things, a better COMIT (in a sense similar to that in which Stroustrup says C++ was intended to be a better C).''

	SQL [StructuredQueryLanguage]:	The mathematical foundations of the language are dramatic.  OTOH, I don't know that something else did it first. SQL was not the groundbreaking thing, that was QUEL. However, SQL was highly influent. It put relational "on the map". There is also QBE. ''An interesting competitor to SQL near its birth was called Business System 12. It is reminiscent of functional programming in nature, making it easier to parse, dissect, and add to in manageable chunks IMO. See SqlFlaws'' ''Given the near universal usage of SQL, it must have broken some ground... First language give primacy to data?  First language with checkpointing and rollback?  Most universal? (Language with the most lines of code being run daily)'' It's arguably influenced by concepts found in PrologLanguage and APL.
** Dr. Codd's query language precursor was called "Alpha". I don't know if there is a single relational query language that was by itself "groundbreaking". Alpha was rather mathematical in nature, with "Englishness" gradually being applied to subsequent experimental languages. It appears that it was an evolution, with Alpha, QUEL, ISBL, and BusinessSystemTwelve influencing each other or later query languages until the industry settled on SQL (for good or bad).

----
''Guidelines for adding languages and refactoring:''
	* Feel free to add to the list above, but please keep the "truly new" and "ground-breaking" standard in mind.
	* Please explain after the language name, why you added it to the list. i.e. Enumerate its innovations.
	* Move languages that are insufficiently motivated to the "needs better motivation" section at the bottom of this page.

----
See: GroundBreakingLanguagesDiscussion
----
CategoryProgrammingLanguageComparisons CategoryHistory