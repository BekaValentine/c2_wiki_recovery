The phrase "small is beautiful" was coined by the Austrian and American philosopher LeopoldKohr (1909-1994, winner of the alternative Nobel prize 1986). He was a friend and teacher of ErnstFriedrichSchumacher who applied this principle to economics and made it famous. (http://en.wikipedia.org/wiki/Leopold_Kohr, http://en.wikipedia.org/wiki/E._F._Schumacher)

Small Is Beautiful may be used - and was always meant - as a general principle:
* small functions are better than huge functions (or modules).
* simple theories are better than complex theories (OccamsRazor).
* slim organizations are better than large bureaucratic organizations.
* small national states are better than a large association(argument against the European integration)
* small, simple languages (Forth, Tcl, Eiffel, Smalltalk, C, Lisp, Scheme, Ruby, Io, Erlang) are better than large, complex languages (PL/I, Ada, C++, Java, Perl, PHP).
* languages that enable you to create small, simple programs (Smalltalk, Perl, Ruby, PHP) are better than ones that make you create larger, more complex programs (C, Java, Eiffel, ...).
* Simple micro-frameworks are better than all-encompassing ultra-generic-striving frameworks (HelpersInsteadOfWrappers).

----

There seems to be some confusion above as to whether Lisp is small and simple or large and complex. Also if Perl is large and complex then it is less desirable than, for example, Eiffel in this dimension but it is apparently more desirable than Eiffel because it enables one to create small, simple programs. Most decisions are non-trivial because they are multidimensional where the optimum decision in one dimension often conflicts with the optimum decision in another dimension.

- BarryAllebone (1st October 2002)

''Lisp in 1963 was small and simple. SchemeLanguage is small and simple.''

''CommonLisp is neither. That doesn't make it a bad language.''

I assure you that, although the Lisp/Scheme community regards CommonLisp as huge and bloated compared with Scheme, by the standards of things like C++, Java, etc, CommonLisp is tiny, simple, and elegant, even including the standard library.

If you exclude the library, then CommonLisp is not that much bigger than Lisp 1.5. It's still mostly S-expressions, with just a few relatively simple syntactic extensions, and just a few semantic extensions that aren't all that hairy (macros, lexical scoping).

Well, the author of the simple/complex language examples is somewhat biased. Those examples are really bad categorized examples. Eiffel is much bigger and complex than Java (regarding the number of features), e.g. Io is a bad example because it is not ready to be used as a production environment, I think... etc.

----

''Small Is Beautiful: Economics As If People Mattered'', by E. F. Schumacher 

http://images.amazon.com/images/P/0881791695.01._PE_PI_SCMZZZZZZZ_.jpg
[ISBN: 0881791695]

----

	 :	''Smalltalk is beautiful!''

----

[non-programming content moved to SmallIsBeautiful on TheAdjunct]

----
I don't think that you can always say that small languages (C, Forth, ...) are always better than large (Java, C++, ...) ones. I think that ItDepends on the special requirements you have to achieve.
I agree, of course, in SmallIsBeautiful, but you can achieve smaller programs with higher (large) languages in special cases. So, for me, that's beautiful in this cases, in others (device drivers, ...) it's not.

COBOL mixed with inline self-modifying machine code is best if that's what the contract requires, but that's fairly nitpicky. So nitpicks aside, what's an example of a large language that is better/more beautiful than small languages? I think it requires such nitpicks to make this opposite point.
----
Small programs are more beautiful than large programs.

----
See SimpleIsBeautiful, LargeAndSmallLanguages, OccamsDebugger

----
CategoryWorldView, CategoryBook, CategoryLowEnd