(Note, I would put this in TopMind topic to follow wiki standards for on-going rants and long ThreadMode about narrow topics, but that is getting full. -- top)

''From ClientSideAppDataCaching:''

I'm willing to assume that you actually believe that, but your actions are actually the opposite, in that you will argue for *days* over something where you are objectively wrong. Examples:

* the fact that web interfaces are more constrained than client/server ones.

** I was talking about the amount of cache, not every feature, as described at ClientSideAppDataCaching.
*** You're still objectively wrong in this case. You have zero control over memory usage and allocation in the browser, being totally at the mercy of the runtime, with a client/server app you at least have the possibility of great control (even in Java).
*** ''In practice the language that one has to use is pre-mandated. True, if one has the luxury of using any language or tool of choice, they will have more opportunity to tune it for a specific need, even writing it in assembler, but that is a UselessTruth. If we are going with UselessTruth''''''s, then it is technically possible to write a web browser from scratch that is performance-tuned for a particular shop, so that game works both ways.''
*** It's true even without resorting to argument ad absurdia. It's possible there's extreme constraints on your client/server implementation (maybe you have to write it in COBOL and run in in a VAX simulator), but that's unlikely to be the case. The constraints of the browser are the common case, not the exception. This thread right here is what I'm referring to when I talk about you putting your fingers in your ears when presented with objective evidence.
*** ''It is also true that few developers are given free reign to use any client/server tool they want. Usually a given shop mandates one of VB, PowerBuilder, Delphi, Java, etc. That is not much different than mandating IE or Mozilla.''
*** In the context of your flexibility to address performance and memory constraints, it is *vastly* different. It's like being given your choice of trucks, or your choice of mopeds. Even a really fancy moped can't tow as much as a really crappy truck. It's the same in that your choice is constrained, but the limits of your constraints are greater.
*** ''Well at this point we should leave it to benchmarks to decide whether JavaScript in browsers is significantly crippled performance-wise to say VB and PowerBuilder.''
*** Don't forget notebook/tab controls, virtual drop down controls, grids and virtual grids, refreshless update, masked edit controls, embedded video, embedded charting/graphs, context menus, arbitrary drawing, custom controls, access to the local file system, access to remote file systems, masked edit controls, control of user action, and guaranteed data persistence, just to name a few features which are trivially exposed to client applications but are much more awkward and occasionally impossible in a browser. Don't forget that you lose all your caching if the user hits refresh, or a link, or a bookmark. The features that make a good web browser are opposed to the features that make a good thin client environment, and that's a fact that isn't going to change.
*** ''I think that is another topic altogether. Note that I don't think the current crop of browsers are anywhere near the ideal for HTTP-based clients. They grew out of the e-brochure paradigm and are ill suited for dynamic biz forms.''
*** It's exactly the topic. Web browsers are ill-suited for dynamic biz forms. Some hypothetical "business app browser" will of course be perfectly suited for business forms, since it's hypothetical.
*** ''But that is covered under BrowserAbuseSyndrome. The topic of context was more narrow: data caching, per topic title.''
*** You're the one who created the new topic titles while copying all my comments, not me. My original post was to, and was in the context of, and continues to be in, BrowserAbuseSyndrome. If you want to restrict the conversation *solely* to the manipulation of data sets, I'm still right and you're still wrong, though. Go ahead and compare the memory usage of a large dataset in Delphi vrs. one in JavaScript, and then see how far you can push each one. It's okay, I'll wait.
*** ''I thought the comments were only related to data caching and created the topic to address just the data-caching issue because it was getting long. Perhaps we can move the non-data-caching stuff back to the original topic. In the future, let's try to compartmentalize the issues to avoid unnecessary interweaving of them to reduce the chance of such confusion happening again.''

* your re-definition of the English word "syntax", 

** It was a "working definition" because the street definition is too vague. Sure, it is "rules" about how tokens are combined, but it gives no indication about what rules are included and excluded. I perhaps should have called it something else rather than overload an existing term. It was admittedly bad form on my part, but a minor sin and only about words, not objective software facts (if there is such a thing).

*** It was *incorrect*, and rather than capitulating early on, apologizing for you misuse of the word syntax and instead saying what you meant (which I'm still not clear on), the entire discussion was derailed for days as you argued that you were perfectly entitled to define "syntax" as "words" or whatever. -- ChrisMellon
*** ''Okay, I will agree it was "bad form" on my part from a communication/social standpoint. But that fiasco does not relate to anything material about any external truths [about software]. -- top''
*** [English definition of "syntax" is not an external truth?]
*** ''Well, it's inability to differentiate "syntax" rules from non-syntax rules is big enough to drive a convoy of trolls through. [the context got messed up here somehow.]''

* your insistence on a LanguageNeutralGui

** Insistence? It was a question: is a lang-neutral gui possible, and if not, why not? What exactly did I "insist" on?
*** Well, I said it wasn't, and you said it was. I think part of this is that I mean something different by language neutral than you do, because to me it's almost an oxymoron. I should note that I left that page fairly early on and a good portion of your responses are to someone other than me. I think the problem is that when someone tells me about a language neutral gui engine, I expect there to actually be an engine that is accessible from any language. You seem to mean something else, like serialization to a common format (eg, HTML), which I specifically addressed and dismissed in my initial comment. I know something about GUI engines at a low level and what it takes to implement one, and to interface it with other languages. I don't believe you do. -- ChrisMellon
*** ''As I said there, "language neutral" is probably continuous rather than discrete. It sounds like we first need a way to measure how neutral something is. As far as your alleged experience there, it is not of much use to readers unless you can turn it into SelfStandingEvidence.''
*** I don't believe it's continuous OR discrete, I think it's basically an oxymoron. The only way to do this involves language-specific bridges and/or serialization to a common format. Even component systems like COM do this, via InterfaceDefinitionLanguage.
*** ''If you want to suggest a more practical topic name, such as NotStartingFromScratchPerLanguageForGuis or the like, be my guest. Requiring bridges or adaptors is not a show-stopper, by the way.''
*** Are you actually interested in a technical explanation of the technical difficulties involved, and if I spend my time and effort to explain some of them will you read them with the understanding that these are actually how things are done, and if you think you have a better way then you owe it to the people you're talking with to actually attempt an implementation before talking in the abstract? There's some pointers on the original ProgrammingLanguageNeutralGui topic page you can use to find some current implementations. 

* and your re-invention of translation interfaces (InternationalUiExample)

** You make it sound like there is formal mathematical proof that says yours is the best and only way to make a translation system, and you did NOT find any objective flaws in my suggestions. My approach may not be in-style right now, but dammit, it works!
*** The objective flaw was that you were claiming that the existing way is wrong, and your way was better. *Does* your approach work? Do you actually have an approach? Because the conclusion I drew from that page is that you don't actually have a TOP translation system, and have no experience with any other translation system, and were talking totally in the abstract as opposed to your respondents (I wasn't the only one) who do have translation systems, which do work. The very best response you came up with is that if you're at an organization where everything is in a database, then translation files should be in a database and I suppose I can't argue with that. It might do you good to go back over that page and reread how you implicitly, without explicitly acknowledging it, kept narrowing the scope of your claims for the superiority of the database-backed design. -- ChrisMellon
*** ''If I remember correctly, I was *defending* a table-oriented implementation as a valid alternative, and NOT insisting it was objectively better. Your evidence was that from your PERSONAL experience, one is not going to need the features that a DB would make easier. That is not an objective argument because the reader cannot objectively verify your experience about what the user or team needed and didn't need from what you wrote alone. They have to trust you, in other words rely on ArgumentFromAuthority (and perhaps agree that it is a sufficient sample size to make conclusions about all of such needs). Note that I also used ArgumentFromAuthority there (The whole topic is essentially my AFA vs. your AFA), but the allegation is that I am objectively wrong, so that is moot to the topic.''
*** I remember the introduction differently, but I joined after the fact so I may be wrong there. Certainly over the course of the page you seemed to be claiming that a table based solution would be inherently superior to existing implementations, rather than an equivalent mechanism. If you didn't intend to present that, then I apologize. I'll concede this one about you being objectively wrong, though, although you certainly weren't objectively right, either.
*** ''The ideal format for that kind of discussion IMO would be to present both solutions and then a pro-con comparison. You can even put your anecdotes in the pro list for resource files if you want. Then, let the reader then make up their mind. Rather, it somehow turned into FlameWar. I don't know whose fault it is at this point. I did not intend what did happen.''
*** The main things I took umbrage at were that, initially, you seemed to be advocated the use of a database to provide translations at runtime, which I opposed as being unnecessarily complicated in the presence of existing tools which don't require the additional infrastructure. The second thing were your progressively more extreme rationalizations for storing the source information in a database instead of just in files, which I still find totally absurd, although I'll grant that, taken to a ridiculous extreme, in an environment where you want to store and search everything, performance and storage constraints are not an issue, and you're presumed to have developed or otherwise acquired tools to run on top of your database to provide content-specific functionality, then there's no problem with it and even some gains.
*** ''Re: "require the additional infrastructure". You seem to have the BigIron view of databases. I cut my teeth on TableOrientedProgramming with ExBase, a language that makes tables even '''easier to create and use than files'''. ExBase is a table-oriented query language with a procedural language added afterward over time, instead of the other way around found today. Further, if a DB is already being used for a project, then a few extra tables dedicated to language translation are relatively easy addons. --top''

are all circumstances where you've been objectively wrong, have had people with experience in the domain, which you lack, explain to you that you were wrong, and you have, at length, refused to admit it and retreated to contrived examples, definition arguments, and eventually just putting your fingers in your ears in an attempt to avoid having to admit any sort of incorrectness. 

''Wrong. They ''''thought'''' they were objectively correct, but on closer scrutiny could not provide public evidence, and thus resorted to ad hominem attacks on me.''

There comes a point when "you don't know what you're talking about" is the only reasonable response. You seem to define "objective evidence" as "evidence which convinces me" and therefore is totally useless. -- ChrisMellon

No, rather SelfStandingEvidence, evidence that is not a BookStop nor a need to trust you personally.

[In other words, you won't trust anyone else's experience on an issue, even in an area you don't have any experience of your own, nor are you interested in reading. How do you learn anything?]

PageAnchor: 765

''I will trust my experience over theirs. Most people do. It is possible others are purposely or accidentally omitting key factors. English is not a perfect transfer medium of information. The closest thing to "the complete story" is our own stories. In the case of the language translator example, going with a DB carries a small penalty for being the non-optimum solution. Thus, if the cost of failure (picking the non-optimum solution) is small, I will go with my own experience. The only potential monster I see is version control, which is immature in DB-land right now.''

[Just so I'm clear here, you will trust your experience when you have none? Or are you saying that you actually do have experience implementing language translation systems, which is something that was very unclear on the original page.]

* In the case of the translation thingy, a DB solution can easily be converted to your solution if done right. Thus, if I ignored your file-centric suggestion and it turned out not to work, then I can easily switch to a file-centric solution. The others I would take on a case-by-case basis. People tend to have biases toward certain approaches, I would try to find those biases by asking a lot of questions. For example, I am highly suspicious of your claim that you never needed any other grouping, searching, and tracking beyond what files and basic file utilities provide. That is rare in my experience. It raises an internal YellowAlert. It could just be a fluke.

** I can just as easily switch to from a file-based solution to a database one should it prove necessary. The major reason why I would not is the loss of the excellent file based toolset I have readily available. It's possible that I just have better tools than you're used to, but I think it's more than that - all of your hypothetical reasons for grouping and searching were foreign and most seemed absurd. At the current state of db engines, desktop operating systems and filesystems, working with files is is much simpler and more flexible than storing everything in a single database. This is especially important for distributed development, such as open source development. An IDE (or even a toolchain) for translations that parsed all the files into a NimbleDatabase and used that to implement the IDE functionality would be fine with me. But I'd insist that the definitive representation be in a flat file which I can distribute to other people, who can edit it with whatever editor they want, that I can store in any source control system, which can be migrated from place to place with minimal precautions or "exporting". It's a source file just as much as the .py or .cpp or .html files are. PowerOfPlainText.
** ''If both are easy to switch into and out of, then the solution choice is no big deal anyhow. Thus, why bother to make it a major case against me? Anyhow, it sounds like this will be a text file versus DB debate if we keep doing this. We need to find a better topic for such discussion so that we compare distribution issues, etc. Maybe GrepVsDatabase''
** This isn't the place for that discussion, of course. There's benefits and drawbacks to both sides, I know when I prefer to use which. Sometimes there's grey area. 

There's nothing wrong with ArgumentFromAuthority, assuming the authority is legitimate - you're the kind of annoying student who'd insist that a professor explain gravity from base principles because, seriously, who's this Newton guy anyway? Stop dismissing everyone else's experience and assuming that yours is adequate to grant you the grounds to argue on any field. -- ChrisMellon

[Note: I reformatted some of Chris's text to make it easier to reply to. As far as I know, I didn't change the meaning.]

You just said I was objectively wrong, and then appear to change your tune to defend ArgumentFromAuthority. You wouldn't need AFA if you were objectively right. -- top

[Separate but related concepts, not a change in tune. Where someone else has knowledge and experience, and you do not, they are an authority relative to you. Unless you have reason to suspect they're lying or otherwise acting in bad faith, you should accept what they say in that domain. If you're a student and/or interested in learning, then asking for clarification is perfectly acceptable. Note the use of ask, you're looking for clarification, not arguing. You can't argue because you aren't an authority.]
	
''Addressed above at PageAnchor 765.''

----
Should add topic about his understanding that Higher Order Function is so useless, also.

''Please stop bending my claims out of proportion. I claimed their value was exaggerated, '''NOT "useless"''', and asked those who claimed that FP "significantly reduces code" to provide realistic examples, which they failed. Some of them later narrowed their claims to "algorithmically-complex algorithms". If they said that at the beginning, it would have prevented a lot of battles. That is the facts Jacks. You guys hear only what you want to hear. -- top''
----

(from DaveFayram)

TopMind has a very specific algorithm for discussions on C2. I've talked with him enough to see it. (DaveFayram annotates in square brackets. Hooray for thread messes. DeleteWhenCooked - preferably soon. I also made all Top's comments and mine depth 3 items. The original algorithm is depth 2 and 1.) 

* Make a bizarre, but not totally outrageous claim (TOP can be a general purpose paradigm).
*** ''I believe you are referring to AreTablesGeneralPurposeStructures. Lispers claim EssExpressions as general-purpose structures. What is the difference? If you don't like the claim, then come up with some consensus criteria for being "general purpose" and show how tables fail. That is the respectable way to refute allegedly bad ideas.''
*** [Actually, we can apply it to many of your claims. Like your definition of syntax. Remember, bizarre but not totally outrageous. This is what separates you from someone like Robert Abitbol.]
*** '''Okay, I admit I WAS WRONG on the syntax definition. It was an error on my part, but it is not representative.''' Enough about that damned syntax def. It was meant as a working definition but Costin pasted it all over to embarrass me. He succeeded. He should be in politics.

* Give a limited example in the domain of report generation. 
*** ''Why is this a problem? Somebody suggested that "FP greatly reduces code size", and I gave them an example to prove it on. I see nothing sinister or misleading about that.''
*** [It's not a problem. It's just a step. We get to the problem shortly.]

* IF: People mention that this example is trivial and it would never work in another domain:
** Claim DomainDiscrimination and claim victory.
*** ''I believe it is the other way around. THEY claim biz apps is a illegitimate domain, not me.''
*** [That's exactly what this says. You claim that they discriminate against the domain you get paid to work on. Even if it's not true.]
*** This is a common problem in the industry and on C2 with ''everyone''. I don't know of any easy way to solve it. C2's reference system is just not powerful enough. Anyhow, why don't you suggest working together to solve this rather than trying to find personal faults with me. Solve problems instead bashing people. '''Be a fixer, not basher'''. --top

* IF: Others provide counter examples
** Complain about the choice of languages.
*** ''Incorrect. I asked for an English description of the requirements they were allegedly satisfying IN ADDITION TO the code. I never dismissed any language. That is false.''
*** [Soooooooooo not true. If I had a nickel for all the times that you complained about how people weren't using database-centric languages, I'd be able to inundate the western united states with coins.]
*** ''You are incorrectly interconfusing complaining about a language and rejecting it as evidence of some concept. I do a lot of the first, but it is NOT the same as the second. Someone can prove a '''specific point''' using BrainfuckLanguage, but that does not mean I or anyone will have to like BrainfuckLanguage in order to agree with the point made.''
*** [Read the bullet again. All I said you'd do is complain. Which you do. We get to the rejection in the next step.]
*** ''If by chance I get sidetracked, simply move it to a more relavant topic/section and gently remind me that I wondered from the topic. Learn to solve problems instead of complain about problems.''

** Complain the examples are not specific enough. 
*** [No. You're confused here. This item is just step one of the multi-tiered process for other's counter-examples.] 
*** ''I don't understand the source of this complaint. If you mean the "weather example" (ArrayDeletionExample), they refused to provide pivotal specifics, such as why the loop setup code *had* to be long. They claimed it was irreducible, but I don't want to take their word for it without seeing actual code or requirements that lead to it. They may have missed a shortcut. Is this unreasonable? If so, why?''
*** [ArrayDeletionExample, or any of the counter-claims to your arguments there. We gave you sufficient examples. Your job was to extend them into a real app. The only way you're going to get more than simple, quick examples from me is if you hire me as a tutor. My role is to tell you what I'm doing. You've continued to claim victory over this Challenge 6 vs. FP thing, but really it's a wash. No one has the time to devote to a medium sized project just so that we can further hammer the obvious into your head. It's unreasonable to even ask another professional for an example of that size. Use Google, for chrissakes.]
*** If you make a non-domain claim about FP making code significantly shorter, YOU are obligated to prove SelfStandingEvidence. That is the rules of evidence.
*** ''Actually, I don't have to prove anything to you. Tell you what. Deny it vocally, write reams about why it's wrong, and shout your message from the mountain! Fight the power. Meanwhile, I'm going to be writing kickass software, because I do my own homework. You can't expect to compete in this business if you don't self-educate.''
*** Moot. Developers tend to be faster with tools that fit their mind. But, that does not make the tool objectively superior.
*** [Keep telling yourself that. It means you're no longer competing against me, and I prefer it that way. Or let me phrase it another way. "My hammer drives in those screws just fine! You're just ''used'' to using a screwdriver. You can't objectively prove it's better."] 
*** I think it would be easy to prove that pounded screws have less holding strength than driven screws. Please find a better analogy.
*** [Ahh, and yet it fits so well, Top. You just never build houses where there are hurricanes, so you never stress your screws.]
*** Or perhaps invented the nail :-) Anyhow, show me real code (or something close to it) then that buckles like you claim. My domain is my domain. If it differs than your domain, then it differs. Most projects are not glamorous moon-shots. But, that does not make them not important to the overall economy. People still need software to track toilet paper for NASA's restrooms. (I'm not claiming this is what is happening here, but merely pointing out that even if it was the case, its moot. I've already agreed I'd use different techniques if I was writing for life-support medical equipment.)

** Pick a random, insignificant facet of the code and return to step 1, changing the subject.
*** ''Example?''
*** [I was talking to you about RubyOnRails and DependencyInjection, and you kept focusing on the Object-relational-mapping. I even asked you twice to stop focusing on it, but you had already moved to step 1.]
*** It appears somebody deleted it. 
*** [No. It's still there. Search for "rails" on TopMind.]
*** I admitted there that I couldn't figure out what your claim was. 
*** [There was no claim. I was just trying to mention something to you. Inform you. You know, casual engineering conversation. Half your problem, Top, is that you try to turn everything into some kind of grand last-stand for freedom, truth, and the tabular way.]
*** I thought I was just accused of changing the subject. Why was it pointed out as an example? 

* IF: Someone suggests you try what they're suggesting on your own.
** Claim that time is money and no one can be bothered to try anything without objective evidence.
*** ''If they make a claim, it is their obligation to provide evidence, not mine. Is the defendant obligated to make the plaintiff's case?''
*** PageAnchor cs-37
*** [Last time I checked, we were doing you the favor by telling you our techniques and how and why they work. But even then, you've hit a problem here. You say on the one hand that CompSci isn't a scientific discipline, but on the other you are requiring that people prove an objective case with legal-levels of supportability. You can't have it both ways. This is just a way for you to avoid ever having to admit you're wrong.]
*** '''Finally you have hit the nail on the head'''. I will let you think about this some more because if I stated it yet again, it probably wouldn't click right now anyhow.
*** [Oh real deep. :P Nice try, but no. Your conclusion only holds if we buy into the premise that ComputerScience can't really be treated like a science, because it's a "a vague, soft, fuzzy, chaotic grey art". Nothing precludes art from being scientific (or science from being beautiful or artistic). Nothing precludes science from working in the domain of the "vague, soft, fuzzy and chaotic." All aspects of the universe appear that way until we explore them. One need only listen to a beautiful piece of music, view a unique piece of architecture, examine a genetically engineered flower, or read a fun and inspiring piece of code to show that science and art are not orthogonal.]
*** Are you suggesting you can prove that a song is beautiful? Otherwise, it sounds like eastern mysticism disguised as parsable wisdom.
*** [Oh, of course beauty is in the eye of the beholder. That's beside the point here. Please refrain from trying to jump to Step 1. You claim that ComputerScience isn't like other sciences because... what? "vague, soft, fuzzy" and "chaotic" just mean we're still studying. It doesn't mean it's fundamentally unknowable. Simple Newtonian Physics were once the province of Angels, and now even young children hear that E = MC^2]
*** I didn't say it was "fundamentally unknowable". Stop putting words in my mouth. This is about the 5th time you have done it. I am only commenting on the current state of things.
*** [Either it's unknowable, or it's subject to the scientific method. Pick one or the other. Either we can analyze it, or we can't. Pick a stance, Top. Pick a stance and stick with it! I can't help it if you don't like what happens when we carry your arguments to their logical conclusion.]
*** The smartest person on earth couldn't say that ANYTHING was truly forever unknowable with a straight face. I am only commenting on the '''current''' state of things. Related: ObjectiveEvidenceNeverFound. --top

** IF: They then offer objective evidence then either return to step 1 or see LaynesLaw.
*** ''Sorry, but I seem to miss all this alleged "objective evidence". I suspect your personal biases make your brain interpret subjective results as objective.'' 
*** [It's never happened with me around, but several times people have shut down your arguments and you take the LaynesLaw escape. It's disappointing. I expect it of 1st year philosophy students. Not professional engineers.]
*** Without specific instances, I cannot comment. I suggest you pick one (besides the "syntax" thingy.)

* Immediately suggest that your definition, which is almost nonsensical and definitely atypical, is at least as valid as any other. See LaynesLaw.
*** ''Software is a vague, soft, fuzzy, chaotic grey art. That is not my fault. Some have failed to come to grips with this and I think that is a major philosophical failing on the part of some WikiZens. More on this below. As far as the "syntax definition" fiasco, see above.''
*** [We standardize definitions to give us common ground to talk, Top. This common ground is '''essential''' to communication. Make up your own words if you need them. There are lots of new ways to phrase your ideas, instead of polluting our namespace. Or, you could just refrain from talking.]
*** As far as I know, Costin created the new definition topics, not me. And, there is no Official Computer Science Dictionary that I know of anyhow. Most of my debates try to center around concrete things anyhow rather than definition battles. That is why I spent a lot of time on the "less code" claim because verifying it does not depend on definitions.

* Goto step 1. 
*** [And check it out, the very next sentence you write is an example. "You interpret everything I write in an evil, sinister way." Bizarre, but possible I suppose. Just... bizarre. I guess it's time to digress yet again.] {I reworded it below}

It is odd how you interpret much of what I write as an evil, sinister plot of mine. It is as if you go out of your way (subconsciously perhaps) to see my content in the worse possible light. Every miscommunication or subjective conclusion is interpreted from the angle that most makes me look evil and manipulative. Interesting, yet frustrating. I guess once somebody is "written off", you see them in a bad light regardless of what actually happens. People believe what they want to believe. Psychological tests have shown this.

Re: "You forgot: Make grandiose claims about how ComputerScience is not a proper scientific discipline subject to the ScientificMethod..."

I am not the only one who has claimed that. See DisciplineEnvy, a topic that I did NOT create I would note. Thus, '''I am not alone in that opinion'''. Also, I did not say that it wasn't subject to the scientific method, I said it has not been subjected to it at this point. It is likely capable of being subjected to it, but it has not for the most part. Again, you have twisted my real opinion. It keeps happening and the fault appears to be on your side. A convenient mutation happens to the restatement or interpretation of my opinion at just the right spot to make me sound sinister or wrong. 

Re: "citing scientists on their research as ArgumentFromAuthority"

Much of it is. That's life in "computer science". I am just the messenger. There is very little solid science in this industry. If you disagree, take it up in DisciplineEnvy, not here.

-- top

That's BS, TOP. The fact that you may not be alone in that opinion means that you're just as wrong as others. Grow up, and move further.

''Then why are you riding my ass and not theirs? They are allowed to commit such horrid sin without consequenced, but *I* get chewed out for it? Yet more evidence that you are simply baised against me.''

And by the way, your opinion is worth close to nothing, because you have no credibility. Show us some code that is is worth paying attention to and we may reconsider. Continue polluting wiki with endless logorrhea and you shoot your credibility even further. 

* Using "Credibility" is ArgumentFromAuthority. More evidence that my debate enemies rely too heavily on ArgumentFromAuthority. Caught you in fallacy again. -t

''I believe in SelfStandingEvidence. It is the content that matters, not who says it. I know you come from a the European tradition where trusted elites are to run everything, but that is not the wiki way.''

You are in no position to make any kind of sweeping characterization of computer science because your lack of culture in this domain is so blatant as to make you an impostor when you say anything about it. You don't know what you're talking about, TOP, it's as simple as that, but you '''pretend''' to know something. You complain about others making you sound evil or badly intentioned, well, Top, but it is time to realize that you put yourself in that position. Limit yourself to what you know and whatever you can talk about with a remote resemblance of competence, and the situation may change. 

''Odd, I was going to say the same about you.''

And by the way, nobody needs to respond to your claims, TOP, because they are worth nothing. How about you give us '''objective evidence''' that mathematics is not science that computing science is not science that your 2c are just as good as those of any computer scientist you complained about. All prima facie evidence is overwhelmingly against you. So you have a BurdenOfProof from which you excuse yourself assuming the BurdenOfTroll.

''Do you have counter evidence that it is a science? Both are technically null until one or the other shows otherwise.''

* No, TOP, if you claim this you just shoot your public image beyond redemption. Because only charlatans or complete idiots can say "both claims are technically null until proven otherwise". You do have the BurdenOfProof because on the other side there's an overwhelming propensity of external evidence. After all it is computer scientists that get research grants form NSF (which stands from national '''science''' foundation), DARPA, private institution, it is computer scientists that are generally recognized and respected as '''scientist''' in the wider scientific community, while you, poor TOP get nothing of this. As a matter of fact, computer science needs no justification at all to the ridiculous claims of one failed anonymous looser, they'll get their research grants and university position, and they'll be consulted by pentagon, NASA, Microsoft, Sun, and IBM regardless of your own petty opinion, while you, TOP, you'll continue writing your petty FoxPro style application. This is enough evidence to support that they may be doing real science after all, and if you want to claim otherwise then you assume the BurdenOfProof. Trying to keep your claims while discharging your BurdenOfProof dishonestly ( by the way of handwaving or ShiftingTheBurdenOfProof ) is beyond contempt and should be condemned as such.
* ''I was talking about science-vs-math above, not the "is computer-science a science" question there. This is reason #3 to not trust you as a wiki editor. '''You are sloppy'''. And, your response is classic ArgumentFromAuthority, by the way.''

Either you put up, swallow your own pill and give us "objective evidence" of the crap that you claim, 

''I generally attack objective claims, not make them. The whole FP bruha started when somebody else claimed that FP "significantly reduces code size", for example. THEY made the objective claim, but your type twists the truth to make it sound like I was the originator of the an objective claim.''

or we may start cleaning WardsWiki of your pollution, 

''You have not been elected God. '''I would accept some kind of consensus deletion, but not you'''. I remember how you kept calling an example something like "puny amateur toy example" over and over again, when it was MEANT to be a toy example to begin with. Yet, you kept referring to it using such derogatory language. This is evidence that you are either too sloppy to be a trusted editor or too mentally unbalanced. Thus, get your paws off of my stuff!''

and the best you can hope is for us not to proceed to outright deletion, but to quarantine your crap under pages labelled with your own brand, so that we have a clear distinction between wiki content and your trolls. If you think your opinion is so valuable, and the rest of us are so wrong, you'll be rewarded anyways by the attention you get from your fans. You wouldn't be ashamed of your brand, would you? -- CostinCozianu

''You F'd up the formatting when you moved it, BTW. Yet another reason why you can't be trusted as the Content God you think you are entitled to be. If I am all wrong like you paint me, then at worse I would be comparable to a mumbling village idiot. But your behavior is comparable to a terrorist: "My way or the bomb!". Which scales worse?''

No, TOP, there's no way your going to handwave your way out of this by attacking me, because you fail to convince WikiPubliOpinion. To begin with, a lot of people respect me for my modest contributions here, and a lot of other people whose contribution are valued here sided against you (not necessarily with me) on this one (you can see that I can enumerate ScottJohnson, DougMerritt, DanMuller, JonathanTang, and sorry for not enumerating others, without fearing that they will embarrass me by publicly disagreeing with me and siding with you on this one). Such people have made insightful contribution to this wiki, as well as they had public disagreements with me on technical issues of various subject, but what we're talking about here is a matter of '''overwhelming consensus''' of a large spectrum of wiki respected contributors. Plus you cannot accuse me of bias, since I've long held a reputation of RelationalWeenie so you cannot handwave about being persecuted by anti-relational bias, and your arguments make no sense. 

The only honorable exit strategy for you is to drop some of your ridiculous claims and scale back on others (or alternatively - which won't happen, by picking up the BurdenOfProof). Plus when I make coherent argumentation and you accuse me of being mentally unbalanced and proffer other cheap insults, you are loosing credibility even more. -- Costin

''If 50+% vote to delete my content, that is fine. I will accept that. But I will not accept it from small gang of info terrorist. In other words, if you are going to invoke Argument-By-Popularity, then let's do popularity-based-editing '''right'''. That is not asking too much. You use popularity when it suits you, and reject it when it does not.'' 

''By the way, Ward, the creator of this wiki, implies in DisciplineEnvy that the classification of our "discipline" is still up in the air. If you like to be fed credibility crackers instead of SelfStandingEvidence, there is a nicely buttered one for you to crunch on.''-- top


To begin with, you are severely confused. And besides not being able to write correctly your native language, 

''Why bother, you are just going to delete it all anyhow.''

you have a big problem reading it. Your "discipline", top, is not computer science, it can't be "computer science" unless you complete your studies, at best you can aspire to the status of software engineer. This is what DisciplineEnvy debated: SoftwareEngineering (read the introductory statement) as an engineering discipline. There's a big distinction between engineering discipline and scientific discipline as well as between SE and CS, so no cigar: you cannot honestly claim that Ward's statements back you up in your wild claims against computer science. You are still in the position of a charlatan challenging an established scientific community, so you still have a BurdenOfProof, and by the way, not even if Ward would claim that (CS is not science, which he wouldn't) that would not discharge you of the burden of proof. 

''Tell me, have SE or CS ever proven ANY software design objectively better outside of speed, code-size, and output? Can you name just one instance? IT's objectivity account is bankrupt and many are too stupid or blind to care, hiding behind institutional accolades because they have nothing else to rely on.''

What a funny troll you are. One would think that speed, code-size and "output" (correctness of results, I presume) are important enough criteria that cannot just be wished away by any wannabe who thinks he has something to say.

''You are trying to put words in my mouth. I excluded them because they generally have not been key debate issue. I have conceded many times that TOP is slower for certain things, for example. Those are CS's low-hanging fruit, but they have not worked their way up the tree yet.''

So you say CS is bankrupt. Well, any '''objective evidence''' (I mean not any kind of objective but the pompous SelfStandingEvidence) for that? Or it's because TOP says so.

''Stop playing word games and point to the evidence.''


No, TOP, this time you made the claim that CS is bankrupt and many are too stupid (presumably many wiki contributors as well) to realize. So you have a BurdenOfProof. Presumably, unlike us, you are very smart and those charlatans calling themselves computer scientists can't fool a smart guy like you. Now give us a proof ( SelfStandingEvidence) that you are really smart and not just a garden variety megalomaniac. 

(Removed angry content-free language.)

I didn't make the claim that FP reduces code volume or that software engineering is an objective science. The burden of proof is not on me.
----

Since my name was dropped in the above FlameWar, er, discussion; I will state again my position on this for the record. In short - yer both nuts. TopMind, I tend to agree with many of the other statements against you - you seem to feel that our discipline is all black-art and hocus-pocus, and that your claims and opinions are just as valid as those of DonKnuth or JohnReynolds or SimonPeytonJones or DrCodd or ChrisDate or BertrandMeyer. (That's a paraphrase, not a direct quote.) People will take you more seriously if you a) abandon the persistent "but that's ArgumentFromAuthority" posture; and b) actually act like you learn something. I've learned quite a bit here.

* I am just saying that scientific rigor has NOT been applied to many of their claims. The industry is too quick to accept ArgumentFromAuthority. Let's take Meyer (mentioned above), since I wrote a critique of his book. Where's the science on his claims? Please give citations. I have his OOSC2 book in my bookshelf such that I can look them up. --top

'''However:'''

Costin, I've said it before and I'll say it again. In bold-face. '''You act (especially in the past few weeks) like you own this place.''' Like this is CostinsWiki and not WardsWiki, and that you get to be the enforcer and delete/edit how you like - and if anybody dares oppose you they will have an EditWar on their hands. When it comes to the religious crap, I don't much care - it's OffTopic (sensitive or otherwise), and other than polluting RecentChanges it's irrelevant to me. OTOH, your aggressive posture to TopMind (and your recent tactics) kind of pisses me off. His content, although often wrong (and certainly prolific), is OnTopic; when it comes to OnTopic content '''on a site of this nature''', an expression of disagreement is probably better than deletion or a ForestFire.

In short, I would like to request that you stand down on this particular instance. TopMind may be a troll, but he's harmless.

-- ScottJohnson

Costin wrote back (on my HomePage, I hope you don't mind me moving them here for context):

''Now Scott, you have made some personal accusations against me (vis-a-vis TopMind)that are patently false, so you either scale them back because you made them in the heat of the moment and out of negligence. If you think it carefully you'll realize that you will not be able to back them up at close scrutiny.''

I'm not sure which comment of mine you think is personal; I didn't intend anything as an insult. Instead, it is my observations of your behavior, which I'm happy to discuss with you.

''You have all the right to disagree with me or anybody else about this or that technical subject, about this or that attitude, and I respect that. However you went way overboard in your accusations towards me, and if you still like to stand behind them, you'll have left me nothing but change the presumption of negligence into plain dishonesty and I would regret deeply to be forced to prove your dishonesty. Take a break, a deep breath and think it over.''

''As to what regards the attitude toward TopMind, I'll respond to that after you'll have clarified the above. In particular you were negligent in your perception of my attitude towards Top. I don't favor either wholesale deletion, nor ForestFire but you have failed to comprehend all the consequences of encouraging Top to pollute existing content. -- CostinCozianu''

I'm commenting on what I observe, modulated by what I think is right and wrong. I will modify one comment right away; I don't intend to suggest that you are moving ''everything'' of Top's to his HomePage; and happily stipulate that only a few pages are at issue. That said, I think such behavior is inappropriate for this site. The only other user I know of who was subjected to that was RA, and his behavior was far more egregious (and the sanction came after much community discussion). Again, as I stated above, it is better (in general) to explicitly express dissent (and say why) than to engage in such unilateral editing. And if you must edit in this fashion, then follow DeleteOnceRestoreOnce. I refactor Top's stuff quite a bit, and I don't get much resistance from him for it.

My impression of your actions are that you wish this site to become more of a meritocracy. While meritocracies are good things, I'm not sure that's what the community wants, or what Ward wants. Part of what makes this site interesting is the GoodFaith discussion that often occurs. Unfortunately, much discussion recently has been made in bad faith (and I'm not naming any names here; this comment is not intended towards any individual). I've had lots of interesting (to me) conversations with Top, and I do learn a few things from my interactions with him. Likewise with you. Your style, however, is like the bull in the china shop - which is fine if you're the bull, not so much if you're the china. And in the past few weeks (my observation), you seem to have escalated your tactics from CriticizeBluntly to this more aggressive posture, where you are determined that certain editorial manners shall be decided in the manner you consider appropriate (and you may be right), and if someone else tries to undo your handiwork you will redo it ad infinitum. That, of course, is how EditWar''''''s get started.

I certainly don't intend to offend you, and wish you no ill will. But I think some of your actions recently are unwise.

-- ScottJohnson

----

Here is a summary of the claims investigation as I interpret them:

* "the fact that web interfaces are more constrained than client/server ones."
** Misunderstanding about the scope/context
*** ''I made a bald statement of fact at the top of my statements and you responded with "I disagree", without qualification. You continuously narrowed the scope of your argument, until it got to a level you could dismiss as beyond your domain (benchmarking), but never were able to justify you viewpoint.''
*** The "disagreement" was over the "list" size. If that somehow led to confusion on your part, I apologize, but it was not intentional.

* "your re-definition of the English word "syntax","
** Bad form on my part. I admit "error" on this one. I didn't indicate "working definition" up front.
*** ''A fatuous apology if I've ever seen one. Maybe I should decide my "working definition" of a "computing device" is "An Intel based PC running Windows with a wireless keyboard" and argue over the implementation details of TuringMachine''''''s based on my personal definition.''
*** Using the GoldenRule, I have no problem with anybody making a working definition as long as it is stated as working only. Note that we still have no clear-cut definition of "syntax".

* "your insistence on a LanguageNeutralGui"
** Discussion still on-going
*** ''Once again, something I'm seeing you do a lot. You make a grand, sweeping generic statement like "Language Neutral". When called on it, you re-define it as something very specific (declarative web apps over HTTP, in this case). I'm not sure if this is intentionally dishonest or not, but your absolute refusal to learn anything about topics before inventing terminology often results in controversy. This is a you problem, Top, you should address this.''
*** Then work to clarify the scope, definitions, and topics rather than ONLY complain. DontComplainWithoutAlternatives. You claimed to be a GUI expert, but refused to provide enlightenment.
*** I didn't claim to be an expert, just that I have experience. You don't seem to have this experience, so I guess that makes me an expert relative to you. As the initiator of that conversation, it's up to you to use (or learn) correct terminology. As far as complaining goes, you asked for criticism here so you're getting it. I'm not complaining, because your pet theories and pet definitions don't harm me at all, and I perpetually hold out the hope that you'll have something new and exciting to say or teach me that I didn't know. 
*** ''Where the hell is this alleged Master Official IT Dictionary that you and Costin keep yammering about?''
*** I'm going to address this at the bottom of the page, because I feel like being verbose with an example from my past.

* "your re-invention of translation interfaces"
** Accuser seems to agree that under certain circumstances that he finds foreign to his experience, it is an acceptable solution.
*** ''Note that the circumstances required are far outside the scope of the initial statement, and that you added them as conditions only after a great deal of argument.''
*** The "initial scope" was not explicitly stated. I cannot read minds.
*** The maybe you should have said something about that *before* you wrote 1000 words on the subject. I generally assume that the scope is as stated, and anything not stated is not in scope, rather than assuming requirements that are not stated.
*** ''I probably did ask somewhere, I almost always do, but asking for more detail has almost never worked before and should be an assumed request if you want to debate specifics.''

* "his understanding that Higher Order Function is so useless"
** I didn't call them "useless". Mischaracterization of my opinion.

* "Claim DomainDiscrimination? and claim victory."
** I don't understand this claim, and it sounds vague. 
*** ''I didn't post this one, but let me clarify: Any topic that presents an actual use case, no matter how detailed, for any technique that isn't table based, you declare to be not relevant to your domain and therefore not important, despite entering the debate with sweeping statements. This is dishonest because if, truly, you don't care about stuff like HOFs or the performance characteristics of data structures or the implementation details of UI engines, there is no need whatsoever for you to talk about them.''
*** Gee, I remember it the other way around. You guys make the sweeping generalizations and then are forced to narrow the domain, and then bash biz apps as being for wimps. I should save those insults from now on because you seem to be suggesting I hallucinated it all.
*** I don't know why "you guys" are, because we aren't a cabal (seriously!). I react only to what I see, and I speak only for myself. If there are a lot of the same accusations made against you, perhaps you should think about what that means. LanguageNeutralGui was the most recent and obvious example of this, since what you were talking about (or at least what you eventually decided you were talking about) was neither language neutral nor a gui engine. --AnonymousDonor
*** ''Based on signed stuff, it is only a handful that I seem to tick off. I invited you to help define the term "language neutral", and you appeared to refuse and change the subject.''
*** I didn't ever see you ask that, and in any case I consider it to be self-defeating. You can't have language neutral anything, you can only have things which are easy to interface with other languages. This means (always!) either serialization to a third language (HTML), marshaling to/from a common data format (COM, but you can consider this a special case of the previous option), or a common binary format (C linkage and calling conventions).  --AnonymousDonor
*** Fairly early in the debate, I said, "Well, I perfectly agree that "language neutral" is a matter of degree rather than Boolean. The point is to explore those degrees. I am not claiming a final solution here, only kicking around ideas." -- top

* "Complain about the choice of languages."
** The topic is about being objectively wrong, not complaining. Saying I don't like something is not an objective claim.
** [Umm, you brought it here. Not me. I simply noted you always do this as part of your formula.]
** You are right on that. I apologize. That claim was not part of the original "objective" debate. However, that would make it off-topic.
** [You brought it here. Not me.]
** Good, close the books on that one.

* "Complain the examples are not specific enough."
** Author appears to have withdrawn this claim/complaint after investigating a specific instance, changing the subject to personal anecdotes instead.
** [ArrayDeletionExample, or the weather example I gave you. I couldn't be any more specific without violating my NDA. I think every ready but you understood what I was saying. No one else said it was unclear, and I clarified twice.] 
** Well, you are going to have to violate the NDA (Non-disclosure agreement) then if you want to continue to the use that example. An NDA over it makes it a poor example/scenario choice because you cannot supply details, and the devil is usually in the details. You have not given specifics on why the loop cannot be reduced, for example. Don't make the NDA my problem also. Pick a public-able example next time, please. '''That is bad form on your part'''. Admit error, like I did with the Syntax example, and move on. --top

* "Pick a random, insignificant facet of the code and return to step 1, changing the subject."
** Author appears to have withdrawn this, stating "There was no claim".
** [I didn't withdraw this at all. I tried to focus on one subject in my discussion of DependencyInjection, and you kept trying to change the subject to SQL wrapping. It's plain as day on TopMind. Grep for RubyOnRails.]
** Then who said, "there was no claim"?
** [You misunderstand. You thought I was trying to say something about table wrapping, because I didn't use raw SQL. So you kept harping on that code. Instead, I was talking to you about DependencyInjection. There was no claim about tables or even really about DependencyInjection. I was just pointing it out to you because you had a legit complain about some OO designs, and DI is how people address it. Instead, you ''continued'' to go off about SQL wrapping, despite repeated requests to stop focusing on that.]
** I admitted that I did not understand your point. Thus, I made no claims and there is nothing to debunk. Move on.

* "Claim that time is money and no one can be bothered to try anything without objective evidence."
** Subject drifted, cannot make summary.
** [Subject has a life, not beholden to Top's summary schedule.]

* "They then offer objective evidence then either return to step 1 or see LaynesLaw."
** No specific instance provided.
** [See ArrayDeletionExample. Denying it doesn't change its reality.]
** I see no full example that is less than 5%. Please place a PageAnchor next to any real claims.
** [You modified your examples on that page after the fact. Even then the original example which extended your technique was ''so long'' that it was removed to make the page more editable.]
** What? Are you saying I deleted the evidence? I deny ever deleting anything out of spite, at least not without an explanation and a place-marker. --top

* "Immediately suggest that your definition, which is almost nonsensical and definitely atypical, is at least as valid as any other. See LaynesLaw."
** Specific instance not given. I already admitted general guilt on the "syntax" thing.
** [Try "Language Neutral]
** ''For petesake! It is a TOPIC NAME, not a goddam definition. You are getting pedantic and ridiculous in your vain search to hang me.''
** [It's a whole page on the subject. Not just a topic name.]
** You are changing the complaint in mid-stream. The complaint is about "suggesting definitions", not content volume.

* "Make grandiose claims about how ComputerScience is not a proper scientific discipline subject to the ScientificMethod..."
** I did not claim it unsubjectable, only unsubjected. The nature of "computer science" is still a contention issue. I am preparing a long write-up on that. [[The context appears to have been lost here somehow in editing. May be related PageAnchor cs-37 -t]]
** [This explanation is so fragmented as to be nonsensical itself, making Top's defense of his argument method a startlingly recursive process.]
** There are already plenty of topics that debate this now (without resolution). I'll linkk them in as I encounter them. This topic is already TooBigTooEdit anyhow. And, I still have not seen a decent entry for the non-speed/resource-related "better" CS challlenge above. --top

Only 1 of 11 complaints, less than 10%, seems to have solid merit. I should be acquitted. -- top

[Top is borrowing a reality distortion field, but he is not as skilled a wielder as some.]

Well, somebody certainly is delusional. I reread the stuff it it is generally consistent with my summary characteristics, so I if I am delusional, at least my hallucinations are internally sound and consistent. -- top

[I'm wasting time here, Top. You can continue BSing around the wiki if you want. I regret even getting involved in this page, and I'm going to do my best to make up for it by never visiting it again. Please don't assume that this means I agree with you or that I've "given up." I just have better things to do with my lunch break.]

----

From the title, I thought this was a page debating whether was any objective evidence of TopMind's existence, using his typical style of argument to shoot down his futile offerings of objective evidence that he does in fact exist. That would have been a fun read.

''It could be that TopMind is an AI computer system that runs off tables.''

----
[top says]
''Where the hell is this alleged Master Official IT Dictionary that you and Costin keep yammering about?''

There isn't one, of course. There's several, and good old google define: can be amazingly helpful.

Let me share a story about myself. I worked in a theatre for several years, and I learned a lot about carpentry. I learned totally from experience, and pretty much on my own. I made sets and props and a lot of other things and I learned a lot. But I worked entirely with a couple different types of wood, which weren't especially high quality, due to the nature of what I was doing. Cheap pine and plywood, mostly. I wasn't doing fine carpentry, the object was "good enough for the stage" and we were under enormous budget and time constraints. I got really good at doing that. But I'm not a carpenter, and I'm especially not a fine carpenter. I can use a circular saw, and a table saw, and a bench saw, and a router, but I can't use a lathe. I wouldn't know how to carve with chisel. I've never worked with cherry wood and don't know anything about making well-hung cabinet doors. I don't know the right names for all the different times of carving tools, although I've seen them before. I and the other people I worked with invented our own terms for a lot of things, which caused some confusion at the hardware store when I was talking to professionals. Hopefully you can see the parallels I'm drawing here. The difference is that I never thought that my experience in the theatre qualified me as a craftsman of furniture. I don't even know if they have some special name for a furniture maker. If I wanted to be one of those, I'd have to learn more, and learn the vocabulary, before I started telling all them that it doesn't really matter if your cut is off by a sixteenth of an inch, because you can just shim it in and from a 10 feet away under lights you can't see the seam.

''Well, maybe eval and my type def are similarly "good enough" for my domain. Custom business software has a lot of pump-and-dump parallels. UseTheRightToolForTheJob. Being different from your domain is not a reason to be deleted, however. Someone who has been a "fine furniture craftsman" for life may similarly have a hard time adjusting to theatre construction because they will probably be anal-retentive about the wrong things at the wrong time. My techniques are probably poorly suited to systems software, I won't deny that may be the case. -- top''

''By the way, perhaps it is time for a wiki IT dictionary.''


There's actually a second part to the story, which is that later I ended up working with a a guy who's hobby was building furniture and it truly was a pain because he spent too much time worrying about details we didn't care about and he'd go over our time constraints, resulting in truly memorable instances like an opening night in a French farce with no doors, where all the gags relied on people going into and coming out of doors. They key point is that just as his aesthetics and professional constraints were inappropriate for what I was doing, mine were inappropriate for what he was doing - I can't make furniture at any level above "good enough for a college dorm room". The important thing is for people to recognize this and not to dismiss things out of hand because they don't apply. If you're inclined to do so, it's best to simply avoid the discussion in the first place. It would be just as in appropriate for me to lambast a cabinetmaker for his attention to detail as it would be for him to lambast me for my lack of same. But what I'm doing is less challenging, less precise, and in a very real way less difficult than what he's doing, with regards to carpentry. There are other challenges, of course - a large part of writing business apps is getting your users to actually cough up what the process and rules really are - but with regards to the computer science, or even software engineering, or even programming, the challenges are pretty minimal. Where they come into play is in exactly the areas you avoid, the implementation details you don't want to be bothered with, like how do you design and implement a component based architecture that allows you to call a component written in C++ from a Visual Basic application, or how to lay out database tables on disk for optimal performance, or how to write a graphing component that can draw itself without flickering. 

''You seem to be saying that custom biz apps are more about users than computers, and therefore the computer side is less "tested" or "stretched". From a hardware performance standpoint, I generally agree with you (but could fuss on the details). However, from an "info organization and management" viewpoint, that view couldn't be further from the truth. Such systems often have tons of attributes, business rules, and information (these may not be mutually exclusive) that are or can be interrelated to various degrees, the interrelations can change on a whim, and it often grows into a big mess. It may not necessarily stretch the hardware to its very limits, but it is stretching info organization management to its very limits. Hardware and "machine issues" are no longer the biggest bottleneck, so in some ways it is at the cutting edge of virtual world handling technology. We are constrained mostly by our imagination, NOT by flicker rates and C++ memory management. We have just about all the desk-space, pencils, paper, staplers, etc. that we need. We just need to find better ways to organize it all so that it works right using our rules and so we can find what we need to find. -- top''

My belief is that you're mainly doing management-level activities, rather than what I consider programming per se. Perhaps it's the way of the future, I don't know. But you want to manipulate information, not write tools to manipulate information. You aren't interested in how things get done, you just want to tell the computer what to do. There's nothing wrong with that, but there still has to be someone who's interested in how to actually implement the tools that you want. I think you would be surprised how much the hardware and the low-level things you dismiss can actually matter at the high end. In essence - you're talking to the wrong people in the wrong way here. The people you're telling to not bother you with low level details are the people who have to know these things in order to create the databases and relational tools and information management systems that are what you want to work with. I'm not sure we're constrained by our imaginations so much at all, it's really easy to imagine all the things I want when it comes to data manipulation. I watched StarTrek too, you know. Even if my own wasn't up to the task, I've had plenty of users tell me all sorts of insane things a system should do. Cracks about the DoWhatImean (DWIM) machine instruction are as old as computing. A good example is the weather system Dave (was it Dave?) showed you. You wouldn't implement that. You'd want someone else (like Dave) to implement it for you, and you'd use a system like the one he created to do your own data scrubbing and manipulation in a declarative manner. 

''No, I am not in management, and I have directly implemented many "data scrubbing" applications. Multiple times I have even built almost spreadsheet-like contraptions that had formulas stored in tables and dynamically executed using "eval"-like techniques. In one case it was a data conversion tool, and in another it was a kind of 3D spreadsheet. Existing spreadsheets didn't make it very easy to have formulas spanning dozens of sheets "deep", so I made one (specific to that need). And please stop mentioning that "weather" example unless more details are given (he claimed it was under a non-disclosure agreement, meaning it is legally locked away from public examination). I cannot respond to it better without more details. I gave several approaches to implemented it, and each and every allegedly has flaws that I cannot verify on my own without being there or seeing a detailed spec. "That won't work because I say so" won't cut it. Note that I am not saying that systems software is less important, but just that it is constrained and "shaped" by different issues. Wiki should accommodate both. -- top''
----

Top does not debate in order to either learn or to educate; he does it merely as a form of MentalMasturbation, one of the many terms he is very fond of. Take a look, for instance, at DynamicStringsVsFunctional. The tone of the page starts out generally civil and informative. (Note that an early section starting with "This is silly, of course, ..." was added later out of chronological sequence - more so than other interspersed comments.) 

''I generally mirror the treatment that I receive. If people are courteous to me, I am courteous back. If I slip into rudeness first, then I am at fault. But, I have not seen it in the case. You are highlighting my rudeness and bypassing that of those you agree with. If I remember correctly, in this case politeness came to an end when somebody called FoxPro a "toy language for dummies" or the like. That was first blood. (Refactoring has made it difficult to verify. Maybe the history can tell, but I don't want to get that pedantic today.) If by chance it was me who drew first blood, it was unintentional. I recall them firing first. Honest. -- top''

Top takes exception to very realistic complications to some of the problems posed ("You sure are going out of your way to bust this thing ..."), and offers only pseudo-code from his imagination versus concrete examples in an existing language, but there's nothing particularly offensive here.

* PayrollExample (added after the above was written) is real code in an existing language. You are welcome to objectively improve upon it with your favorite GoldenHammer. --top

''Sorry, but I did not find them "realistic" based my experience. See the link below for more details on patterns I see and don't see in the real world.''

Now search for the first occurrence of "MentalMasturbation". I marked this paragraph as being from "AnonymousDonor?", in order to keep the back-and-forth clearly labelled, but it is obviously by Top. We see the tone of the page starting to turn here. Note what prompted this. Neil, a Tcl programmer who joined the discussion to clarify some of Top's points and who provided some very informative, to-the-point (and civil!) information about how Tcl really works (something Top was too lazy to figure out for himself, in spite of using it Tcl as his counterexample in debate), comments that in fact Lisp's approach is cleaner and easier to work with. Top has lost ground in his argument - and so now he draws his usual debating tools from their sheaths:
* ''"What is an example, ..."'' (i.e. "can you give an example"): An example is provided (by me) immediately following - and the example is (perhaps deliberately) misinterpreted by Top. He focuses on the looping aspect rather than the ease of use of the closure, and makes no apparent effort to extrapolate on his own what can be done with it beyond the (admittedly oversimple) example.
* ''"... and how practical is it?"'': Whenever Top wishes not to acknowledge the value of a concept, he questions its practicality, regardless if other people assure him that they've found it useful. He's not interested in the general utility of language features, he's interested in what fits in Top's head for Top's uses, given Top's current and stubbornly static understanding of programming.

** I wrote about the issue of domains and examples at PageAnchor: Examples_Complaint under TopMind. -- top

* ''"Some of us ... suspect ..."'': The voice of the AnonymousChoir swells ... although it sounds strangely like a solo.
* ''"... that many closure/HOF tricks ..."'': Note that they're "tricks", not techniques. Evaluating a string isn't a trick, you see, it's somehow more natural to sometimes represent code as source code and sometimes as a string that looks like source code, rather than just representing code as source code all the time. (Tcl is unusual in that it apparently treats all source code as strings, all the time. But in spite of the choice of examples, it should be clear that we're not discussing Tcl or Lisp specifically.) Clearly, the latter is a trick.
* ''"... are mostly MentalMasturbation, ..."'': The descent has gained momentum. People who appreciate "tricks" are masturbators. They probably also worship Satan.

* ''".... or just minor improvements of a few percent code reduction."'': This is the first time that code size is mentioned on this page. Someone must've really ticked off Top with a comment about code size on some other page, because this has become the only metric that Top ever applies, and he wields it like a cudgel, bashing his opponents bloody with their failure to reduce code size by tens of percentage points as compared to ... err ... what? That's never made clear, of course.

** You may be correct. I may have mixed up debates. But they were not clear what they were comparing. If code-size was not the metric, then simply politely correct me and re-steer the topic. Don't turn J-walking into murder. I see content mistakes all the time from others. I either fix them myself (if appropriate) or try to '''politely point out the problem'''. You seem to be using your wide "sinister brush" again on me. -- top

** Re: "about code size on some other page, because this has become the only metric that Top ever applies". You are welcome to suggest and apply alternatives. You imply that I rejected other objective metrics, which is not the case. The problem is that it is hard to find objective ones (which is part of the reason why "computer science" is not a science IMO). -- top

PageAnchor: 3472 // I need references to find stuff in the editor

Things get worse from here on. The tone gets a bit more brittle:
* ''"... some of you anti-scientific types are happy with anecdotal evidence alone."'': This from the person who provides only pseudo-code based vaguely on Tcl. Seeing as there were very few contributors up to this point, and by far predominantly myself, I think I was understandably taken aback by this slur. This prompted an interloper who goads Top towards even less civility. 
** As far as who was rude first, see above. If you didn't like the pseudo-code, then just say that you want to see actual code. It may be laziness on my part, but it is not an evil plot to mislead the world.

Paradoxically, almost immediately after this, we have, from the same hand:
* ''"BenefitsAreSubjective is a legitimate viewpoint."'': Top obviously grasps whatever end of the stick is most convenient, moment by moment, driving debates in endless circles.
** I don't remember the context, but if by chance I wonder off topic, then point that out so that we can together get back on the road. ThreadMess usually takes at least two participants to create. Like I said above, I see others create context problems all the time. I don't turn it into a murder accusation, but either try help them fix it or live with.

More importantly, Top's counterarguments become more vague and inscrutable:

* ''"... it is easier to blur the distinction between interpreter and databases, which is what TableOrientedProgramming really wants in the long run."'': How the distinction between something that executes code/data and something that ''stores and manages'' data can be blurred (although the latter often ''includes'' an interpreter to assist with data management) is never made clear, not even on the entirely separate page that Top spins off here. More relevantly, Top never specifies why strings facilitate this desired blurring more than some other representation of code.
* ''Some seem to "get" DataAndCodeAreTheSameThing (a topic not created by me), and some don't. I don't know how to convey the concept so far. I admit I am stumped on how to articulate it well, and will take responsibility for that failing. If that is enough to delete me though, then delete others because it is a rampant problem on wiki, not just we me. -- top''

At this point my participation wanes, since there doesn't seem much more to be said in light of the vagueness of continuing objections. One KristofferLawson enters with some honest questions. He or someone else offers some examples in both Tcl and Lisp - which Top rejects (despite having practically demanded examples earlier), wanting now some sort of English requirements statement. 

* If you mean the "weather" example. It is waaaay too open ended. The author admitted they are limited by a NonDisclosureAgreement. That limit is NOT my fault. I already gave my objections and I feel they are strong. Eval would provide similar simplifications, but he claims it is too slow, which I cannot verify. I have agreed that it does not score high on performance and that is a failing of eval in some cases. But in practice I don't encounter slowness as a problem. Should I switch languages because it simplifies one out of every 10,000 functions? That is not logical. I gave several workaround. No language/paradigm is perfect in all situations. Thus, either we mix them, or live work around occasional rough spots.

PageAnchor: 4087

Again we have run into Top's quintessential resistance to learning - although he enjoys debating the merits of language features, he finds it absolutely impossible to allocate time to learn enough about just two very popular languages to follow the examples. Now, I did not myself take the time to look up more than just a little Tcl during the evolution of that page. But I also wasn't demanding examples. (Later on the page, he even labels the provision of code examples as ''rude!!!'')

* ''As far as "rude code examples", I said it was rude to not ALSO provide a written description ALONG with it. That seems like a perfectly reasonable request. I don't understand why you balk at that. I don't get it. Some complained that I did not document #6 well enough, '''and they were right!''' But at least I offered to answer questions, which is more than I got from the weather example, which the author admitted was subject to NDA's.''

* ''As far as not bother to learn your pet languages, you have not bothered to implement your version of challenge #6, claiming it "too boring". '''Don't play the laziness card unless you play it fair.''' ''

At this point I must admit that I re-entered the dialog and flamed Top soundly for demonstrating twice in quick succession his continuing complete and utter ignorance of how a closure actually works. (Although I only called him on one of the two gaffes.) It is quite inexcusable to argue against something without making even a minimal effort to understand it. It was a very mild flame, really, accompanied by a heartfelt and urgent suggestion to make the effort to understand more about topics that he's obviously interested in. Top's asinine answer revolves around his BookStop argument, which I saw the first time here, but which he had apparently already honed on other pages. From this point on, I must say, the accumulation of stupidity and rudeness on this and other pages led me to drop any interest in Top's goodwill, ideas, or opinions, and I felt free to "criticize bluntly", as Costin would say.

''It all started when people suggested that closures and related were objectively better. If it is "objective", then it can be measured. A number can usually be assigned to most objective metrics. In that case, it would '''not require understanding''' on my part. I have pointed this out many times, but you seem to disregard it as irrelevant. Well, it's not! I usually ignore suggestions that something is "more elegant", because that is almost impossible to objectively measure. It was the suggestions of objective benefits that alerted me to a topic I usually ignore. Thus, my understanding of your code is moot. I agree that such may aid in communication, but is still a side issue with regard to objective benefits.''

After this point, he keeps repeating his need for "objective proof". 

''This is a mischaracterization of my point. *IF* you claim objective benefits, such as "significantly less code", I will hold you to it. I personally think software is mostly about psychology, so there probably are no objective metrics outside of producing "correct" results, execution speed, and possibly productivity.''

The discussion above, and history on other pages, should make it apparent that, although the examples offered so far may not have been stellar, one would have very little hope of coming up with any examples that would cause even a momentary pause in the Toppish deluge. 

''Here is a novel suggestion: try examples outside of systems software and university lab puzzles. (And please, don't bring up that damned weather example, its spec was incomplete due to the NDA.)''

Thus there is little incentive to do the work - it's more fun to write this analysis. Even if one did come up with more complex examples, I'm fairly certain that they would be countered by more pseudo-code. I'm not sure if anyone on this wiki has actually seen evidence of any real programming language that Top is facile with. But that's really OK, because code examples would just be ''rude'' anyway!

-- DanMuller, in a peevish mood

Again, I find it very curious but frustrating how you see every little thing I do through sinister-plot-colored glasses. And, there is a lot of double-standarding. If I do X it is part of plot, but if you do X, then it is somehow a minor slip-up. I don't do my full homework, but neither do you. I sometimes wonder off topic, but so do you. I am sometimes rude, but so are you. 

And things such as implying that I said "code examples are rude" when I really said, "code examples without DESCRIPTIONS are rude" makes it '''appear''' to me you are purposely misquoting me to make me look bad. I don't have any direct evidence it was purposeful, but it seems to be pattern that is harder and harder to dismiss as just random innocent typos. (You omitted the description detail twice here.) And if it is just innocent typos, then fess up and accept at least SOME of the blame for the threadmess and rudeness in the process.

I find the examples irrelevant to actual software needs that I face. You get on my case for not being able to extrapolate to my domain (assuming it possible), and I get on your case for not finding business examples (that are not subjective to NDA's). '''This is the real impasse.''' All the personality bickering I can ignore and will try not to let it bother me. But we MUST do something about the Example Domain Impasse if we are to move forward. -- top

''It's not really the technical details that are putting people off, top, it's your manner. The most frustrating point about it is that it's really hard to pin down a few words to describe it, but the words "defensive", and "combative" come to mind. It has nothing to do with what you're saying, but how you're saying it. You may think that's shallow, petty, whatever, but it's how the world works. Most of us think you know exactly how you come off and think it's deliberate - I think that's what stokes the flames most. It ain't my prerogative to coach anyone on social skills, let alone you, but if I had to offer just two words of advice, they'd be '''Mellow out'''. Peace.''

{Usually my insults were defensive. I try hard to make sure the other guy insulted me first before I fire back, and try to keep my insult level at about 1/2. Thus, I insulted back about once per two of their insults. For some reason you guys are ignoring insults from your buddies. Is there a wiki flag I can use to point out insults toward me? I get no love.}

* And it's not about double standards us as long as Top does not recognize that the situation is '''asymmetrical'''. We had plenty of controversies here, but nobody complained about BookStop''''''s, very few people other than Top were accused of ShiftingTheBurdenOfProof, with Top it happens all the time. Why? Because Top never picks up BurdenOfProof he goes on cheap counter-attacks. You want to say something again prevailing wisdom, fine. But you pick the BurdenOfProof. You want to say that ComputerScience is no good, that math is not of science, and that books are not worthy to be read? That's fine also but as long as you pick the BurdenOfProof. Instead Top tries to ShiftTheBurdenOfProof by claiming that if we don't prove to him that CS is useful then he doesn't have to prove the opposite either, and therefore his opinion is just as legitimate.
* '''How can somebody objectively prove subjectivity? THAT IS AN IMPOSSIBLE REQUEST. -- top'''
* Regardless of his claim to honesty and good intentions, most other people view the above strategy as trolling.
* ''People tend to be biased when they disagree with somebody. I've seen it in evolution debates, political debates, etc. (and not just to me). -- top''

Ayee, I could go on forever about Top's responses above. Allow me to cherry-pick. I'll avoid the rudeness topics, except to note that I'll accept the "yeah but" excuse (no, that page has not been subjected to any major refactoring) as an apology. And I'll offer a weak one myself for the "code examples are rude" comments, since I may have misconstrued this. (Here's my own "yeah but": The relevant text is not as clear as Top implies). As to ''"I generally mirror..."'': '''Don't.''' The best way to destroy any discussion is to react to baiters, and many follow you around, no doubt in part because you take the bait. 

''"Don't turn J-walking into murder. I see content mistakes all the time from others."'': Please note that the analysis above is intended to be an example. You display the behaviors described above repeatedly, on many pages on this wiki, and also in other venues before and during your presence here. In this particular instance, why would I bother to "politely point out" that code space wasn't an issue, when I had seen you introduce the same issue into numerous other discussions? I of course assumed that its introduction was deliberate and, in your mind, relevant.

I agree that it is hard to find objective measures for programming language quality, and did not imply that you had rejected any others.

''I am curious. Why do YOU think objectivity is hard to come by? Doesn't that spark some big questions in ya?''

I get the issues around DataAndCodeAreTheSameThing just fine, thank you. But the fact remains that you didn't, and haven't, explained why non-string representations of code are undesirable for the purposes of TableOrientedProgramming, not even on TableMantraTakeToExtreme.

The weather data application had nothing to do with me and wasn't what I was referring to. I was referring to actual examples that people provided on the page. 

I haven't claimed that your "Challenge #6" is too boring. I have other reasons for not taking it. And my laziness is not equivalent in any way to yours; I did actually research Tcl enough to understand the examples given by Neil and others. In fact, I spent a fair amount of time making sure that I understood all of them.

'' It does not matter if your laziness is not equivalent, it is a hamper to the process. I don't want to learn more Lisp any more than you want to deal with #6. ''

I never used the term "objectively", on this or any other page. The fact that you've become obsessed with it or that others are is your problem. I did claim, in so many words, that closures are easier to use than similar techniques involving strings. I still hold by that claim. You can't deny it, because you don't take the time to understand the issues. More on this below.

I read your "Regarding FP Examples and Applicability", and it is again based on ignorance, ignorance that only you can remedy by expending a little more effort. With regard to the particular topic of closures, they can simplify exactly the sort of things that otherwise lead to the strings of IF statements that you mention. But you'll never see that if you don't take the time to understand even the simple examples that are presented to you. 

* The FP claim at hand in #6 was "less code". What is there to "understand"? FP will either produce less code or it won't. Which is it? Why are you complicating it here? If you changed metrics on me, I missed the context border. --top

'''And there is no point in writing more extensive examples''' when you won't take the first baby steps. You wouldn't understand them. You made it very clear on DynamicStringsVersusFunctional that you hadn't taken the time to understand the examples given.

I'm not interested in writing examples for the sole purpose of someone measuring how many lines, or characters, or tokens that they contain. I prefer the techniques that I do mainly because they make it easier to write code, which is about the process of translating concepts in my head into instructions for a computer. I think I made this pretty clear on that page. And I can't illustrate why I think so to someone who won't take the time to understand the techniques.

''If it is only about something that happens in your head, then it probably would not matter if I learned Lisp. You need to find better ways to describe why it is allegedly better, or admit it is really just internal to the way your head works. I used to think that other's thought process was similar to mine, and I learned the hard way that it is usually not. Maybe only about one in 20 think in a similar enough fashion to me to communicate on a thought-processing level.''

Another problem I have in communicating with you via examples, and this one is primarily my own problem, is that I am not well-versed in UI programming, particularly not in Lisp, which is the best vehicle I have at hand for illustrating these things. The kind of work I do is heavily involved with databases and application logic, but I generally leave the front-end stuff to others. (BTW, none of the examples on DynamicStringsVersusFunctional have anything to do with "systems software", a term that I think you apply too broadly.) Exactly because the real world is messy, it's hard for me to extract any smallish examples from my real work.

Nonetheless, more for my own amusement, I've got in mind an example of how closures would simplify the writing of UI code that makes liberal use of modeless dialogs, and I may at some point take a stab at turning it into incomplete Lisp code.

-- DanMuller


''Look no further than FranTk for functional GUI goodness. Port it to gtk and to a language with state like Ocaml or Clean (tho Clean has a pretty nice GUI lib itself), and then you're cooking with gas. Not that this will satisfy top. But frankly, why is anyone trying to bother satisfying him? We've given him plenty, he can do nothing but react with endless bitchy metadiscourse. I give up, so should all of you.''

I don't necessarily just want to see UI examples. There's a lot of batch processing in biz also. The weather example would perhaps be an okay example if more details were given. I should also point out that '''the biz community in general has rejected FP for the most part. It is not just me.''' FP'ers have done a crappy selling job. People will probably ignore it unless you give them convincing biz examples that show something more specific than "elegance". -- top

FP'er may have done crappy job at selling FP. But that doesn't mean what they sell is crap. Garbage collection has been rejected 10 years ago and C taking over. Look how many modern language today lacks GC. FP can raise programmer's productivity - but as same as monkey and human can use both stone to hunt but only human can use rifle - to use a tool that increases productivity requires a learning curve over it; where not everyone can easily grasp. The reason Biz app doesn't use much of FP because they want mass army of programmer which means in term of quantity not quality, and most of their app is just DB anyway; If all you want to eat is bananas, not deers, you can hire lots of monkeys instead of hard to find human. Only when we start to raise our level of trivialness in problem. Only when business start to put value added in their information, that FP will be out standing. It doesn't matter what language you use as long as the problem domain is "Hello World", does it? FP is catching up, new generation of programmer seems to know more about closure and OO than Top. Applications will do more than store/report data, they will do extensive analysis of data. So future will change. -- AnonymousDonor

* This is pure DomainPissingMatch, and I find it '''highly insulting'''. Similar complaints were leveled in LispUsersAreArrogant by somebody besides me. Yes, business managers often make seemingly silly judgement calls with regard to staffing, but managers in ALL domains do similar things. Look how stupid the Space Shuttle managers were TWICE. The stupidity of these managers with sci/eng. backgrounds cost 14 lives and tens of billions of dollars. CollectionOrientedProgramming also has a learning curve, I would note. -- top
* ''No it's not DomainPissingMatch. Only you claim it to be so every time someone discuss in high detail enough about HOF or anything. Only you Claim it every time someone try to show any benefit about HOF, yet you are the one ShiftingTheBurdenOfProof to everyone else. How do you think that's good learning process?''
* ''By the way, talking about doing crappy job selling programming paradigm. TOP would be the first crappy sell man on my list.''
* I think that is because paradigm benefits are mostly subjective, and some people just don't have TOP heads. I can live with that. By my shackles raise when others suggest that their pet approach is objectively better in all domains without providing evidence. The burden of proof is on them. You seem to think that evidence for domain X is by default applicable to domain Y. I question that default.

''Go take a look at darcs. A revision control system, written in haskell. It's actually being used for real-world projects that have nothing to do with FP. Oh, by the way, I saw the edit BEFORE you added this "largely rejected" stuff, so this is the '''very last''' response you'll get out of me here until I see that you can moderate your attitude - I already removed some previous material of mine before this commit, because you went and added this wholly gratuitous crack several minutes after committing your previous reply. This makes you no more than a troll in my eyes, and I'm becoming really sorry I took any effort to attempt to understand you.''

The last part makes no sense to me. Is there any particular thing about Darcs that shows clear benefits? Verifying that it "works" by itself does not tell us anything about FP. 

You guys are similarly frustrating to me, but on the other hand you are like an alien species that thinks vastly differently than I do. I find it that oddly fascinating, like a researcher trying to understand the Octopus brain. Unfortunately, you guys are frustratingly inarticulate, unable to convert claims such as "elegant" into something more precise, hoping that I will just "get it", bypassing the need to articulate and measure. It is as if the Octopus, which is otherwise bright, is missing a key brain articulation lobe or two. '''The fact that you cannot clearly articulate and measure the alleged benefits should bother you more than I bother you'''. But I have learned that this is probably yet another sign that there is no science in computer science and EverythingIsRelative whether we want it to be or not. -- top

''There's a big difference, top, between lack of ability to communicate and lack of desire to speak with someone as fundamentally unpleasant as yourself. I just wish the rest of wiki could see that as clearly as I now do.''

I would bet money that the number of insults directed at me exceeds those I directed. $40 is all my wife will let me bet. Takers? -- top
----

By the way, is there a more C-like or JavaScript-like language in which to illustrate your FP examples? I find Lisp difficult to mentally parse and concentrate on for reasons described in LispLacksVisualCues. It's lack of landmarks really tosses me. -- top

You were shown javascript examples already exactly for that reason, so you could read it, on the array deletion example page. Rather than look at the closure involved, you bitched about using an array and looping, which was completely irrelevant to the example. Until you understand those simple baby examples, you have no right to ask for more. You were so busy screaming about the array, you saw nothing else. Do you understand how ignorant it looks to be arguing against closures and higher order functions while claiming to prefer sql, a language made of 4 higher order functions Select/Insert/Update/Delete, that all take a closure called Where, and can be easily mixed and match via a higher order function called Join?

''I countered it with some FoxPro examples. I did not ignore it. I am not sure what your complaint is. And, it does not matter to a custom biz app developer how or who made the RDBMS as long as it works. I already agreed that FP may be better for making systems software, such as RDBMS. But that is moot to my domain.''

It is not moot, and it is not systems programming. It is real language creation, built into the language, that's what closures and higher order functions give you, the ability to create language, not dumb ass strings. Anything you do "will" benifit from adding these techniques, asp, aspx, html, whatever, this shit helps simplify code, period! Select isn't the only useful operator you know, we want Select/Detect/Reject/Collect/Do/Inject and all the rest too, and we want them everywhere, not just in the db. Higher order functions and closures are what enable CollectionOrientedProgramming you twit, don't you get that yet!

''Yeah this is really one annoying thing about him. SQL is so powerful as it is because it's the language which is made of higher order function as you said. However, while Top love so much about SQL, he at the same time understands almost none of the benefit of closure and Higher order function. -- AnonymousDonor''

Of course not, he's ignorant, if he studied even a little, his little pet wanna be language TQL would be done already, using higher order functions and closures on top another language, rather than passing strings and evaling them. Our bitching won't change him, that's pointless, but maybe it'll unite a few of us long enough to go on a cleaning spree removing his FUD and disinformation from all the pages he's ruined.

''If you are suggesting that FP makes it easier to *build* a CollectionOrientedLanguage and API's, I won't necessarily disagree with that. That is why it is used for SystemsProgramming. But, I am not a systems programmer by profession and you have not made a case for why non-SP's should care. We don't build languages and RDBMS for a living. '''Millions voted''' with their feet, not just me. Biz langs and tools obviously include less FP than your domain. The reasons for this seems to be one of:''

	1. Biz developers are stupid.
	2. FP adds too little a benefit to biz apps to justify the complexity of adding such features.

You seem to think it is the first, while I suggest it is the second. Being that I have yet to see a good example of it helping biz apps, it is not unreasonable for me to focus on #2. 

-- top

Actually it's option #3, you're too stupid, and everything outside of your extremely limited experience, you qualify as systems programming and dismiss. The rest of us actual biz app programmers use HOF daily for tons of Biz related stuff. You don't want samples or proof, you want to be right, unfortunately, you're an idiot without the capicity to understand your own ignorance, so you just blame all us "evil" programmers.

* Re: "The rest of us actual biz app programmers use HOF daily for tons of Biz related stuff". If that was the case, then you would certainly be able to find more convincing examples. You also imply that HOF is commonly-used in the industry. But, I have not seen it in practice. Our observations differ. What can I say? (I didn't say you are evil, just heavily biased by subjective preferences such that it distorts your judgement. It is a common human flaw to mistake personal preferences for objective truths (PersonalChoiceElevatedToMoralImperative). I do the same, but learned to be more sensative to it happening.)

Moved discussion to ChallengeSixVersusFpDiscussion.

----
Re: ''"I am curious. Why do YOU think objectivity is hard to come by? Doesn't that spark some big questions in ya?"''

Objective measures for programming language quality are hard to come by because software, software development, and software maintenance are all complex. There are many relevant factors, and yes, some of them are psychological and thus subjective. No big questions (or conspiracies) behind it.

There are a lot of similarities between programming and the other applied sciences, and math. 

''I disagree. In engineering, almost everything is measurable. Bridges that fall down or vibrate too much are objectively flawed. Rocket designs that explode too often or miss their mark are objectively flawed. They don't serve their intended purpose. But because of the TuringComplete thing, most languages/paradigms can produce the same desired output, so that is not really a factor to compare.''

Practitioners of an applied science tend to develop their own notation to concisely convey concepts that are important to their field. 

''That is documentation, not the product being measured.''

Programming languages are our notation. 

''But they can all deliver the same thing, per above, so we are forced to focus on the notation as a primary instead of as an artifact.''

If you look at all the programming languages out there, you'll see more similarities than differences, if you can learn to see past details of syntax. One of the reasons that I like both Lisp and (to a lesser degree) C++ is that they're multi-paradigm languages, providing ways to express a broad range of useful abstractions succinctly.

Because of 'Turing completeness', this range of expressivity is not ''necessary'', but it's useful, just as higher-level abstractions in physics or math notations are useful. Even more useful is a notation that makes it easy to define your own abstractions - that's why the concept of subroutines or functions arose, and are represented in some form in almost every modern programming language. 

''One caveat: if you let everybody design their own abstractions, then communication, and perhaps maintenance, suffers. Consistency is also important. All else being nearly equal, consistency should be chosen. For example, if every application has different collection handling idioms, then learning and communication between developers will be slower.''

These abstractions (built-in or user-defined) allow an author to write more concisely, and with practice I think that concise notation feeds back into the thought processes and allows one to ''think'' more concisely about difficult problems. 

'' "Conciseness" can be measured in terms of the volume of code, more or less. It is one of the few objective, or at least semi-objective, metrics we have. However, it does not seem to favor any one paradigm at this point. They all score roughly equal if given a broad range of problem types.''

I certainly feel that learning the various abstractions available in Lisp many years ago modified my thinking and made me a better programmer, able to tackle harder problems with confidence.

Can I prove that objectively? No, that would require fairly long-running experiments that involve controlling the education of groups of programmers and observing and measuring their abilities. 

''I assume you mean productivity rather than tests on concepts. The later tests processes rather than results and so is not necessarily a good metric. Good metrics focus on what is produced rather than how it is produced.''

Maybe I'm full of it, and just have a natural talent or some other characteristic that makes me, in some ways, a better than average software shoveler. 

''Perhaps because it does not affect the size of financial rewards for them, and you do it mostly out of love for the topic. Plus, companies get nervous when they have to hire other highly-skilled people to read your code. They prefer the middle ground so that developers are more easily swappable. I have been chewed out for trying to factor out repetition for just such reasons. It has dampened my desire pursue fancier programming from a career standpoint.''

Maybe I studied Lisp ''because'' of that characteristic, who knows? Does this uncertainty bother me? Well, it's annoying, but it doesn't seem like something that I'm suited to address, or particularly interested in addressing. It's never an issue unless I'm conversing with someone that's obsessed with 'winning' an argument over paradigms. (Top's not the only person in existence who tends in this direction, nor even the only one to argue in circles.) Most often, I can explain these concepts to someone, and they either do or don't show an interest. If they do, then they'll either ask more questions or go off and study it on their own. 

''Explaining concepts is probably easier than explaining benefits, I'm sure you will agree.''

This ability to think in higher-order abstractions is still applicable when using other programming languages, but it takes more effort to write them down. And that's a pity, because it's so unnecessary. That's why I get a bit cranked when I encounter someone who's interested in language design, but seems to ignore the great body of existing ''useful'' programming concepts.

-- DanM

''"Bridges that fall down or vibrate too much are objectively flawed."'': And programs that crash, or store data that violates requirements are objectively flawed. And in engineering, it is ''not'' always clear what should be measured, or how to measure something. There are difference, but there are also similarities. Your basis for disagreement is not null, but is also by no means absolutely true. And I did say that there were similarities, not that the fields were identical.
* You are right, the similarities are not all-or-nothing, but are very weak. Most software debates are not over correct output. Measuring that is the (relatively) easy part. In engineering the debates are far more attached to the physical world.

''"That is documentation, not the product being measured."'': In engineering, it is often ''design'' documentation, and a critical piece of the process of getting from concept to product, just as critical as programming languages are to software engineering. If the documentation is misunderstood by the participants, or is unable to capture all the essential characteristics, the product won't meet it's requirements. This is exactly the same in programming, the only difference being that the primary readers of our design documents are compilers or interpreters, who are not as bright as, but are more literal than, human readers.
* Actually "how to document" is one of those things tied to psychology as well. It is just like on wiki people bicker over whether DocumentMode or some other format is "better". Writing (spoken languages) and software writing have a lot in common.

''"But they [programming languages] can all deliver the same thing, per above, so we are forced to focus on the notation as a primary instead of as an artifact."'': See above. The design documentation is just as important in other disciplines. It's just that the steps between our "documentation" and our product are mostly automated, whereas they're is a lot more to do after the documentation in other disciplines. 

''"One caveat: if you let everybody design their own abstractions, then communication, and perhaps maintenance, suffers. Consistency is also important."'' Yes, which is why it's important that you can define new abstractions ''in the programming language'', which was my point. That way you can benefit from new abstractions, but those abstractions are well-defined in a way that the reader (or computer, in the case of software engineering) can reference. Excessive copy-and-paste programming is bad. If you've had managers that insisted on it, they were bad managers for a software engineering project.
* But there is the issue of inter-project and inter-shop consistency. It will slow things down if each shop or even if each language reinvents their own collection-handling API's, for example.

''"Conciseness" can be measured in terms of the volume of code, ... it does not seem to favor any one paradigm at this point. They all score roughly equal if given a broad range of problem types."'': Yes, conciseness can be measured somewhat, if you can agree on what to count. (Characters? Lines? Tokens? Expressions?) But it's not the only criteria. And for a given programming construct, different paradigms are not equal in their conciseness. Closures are a good example; they can be directly simulated by objects, but there's more textual overhead in doing so - and the simpler the closure and more trivial the task, the higher the overhead is, as a percentage. I'm painfully aware of this because I run into it all the time while programming in C++, in spite of knowing the language well enough to keep the overhead to the bare minimum necessary.
* I am not sure what your point is here. You seem to complain about the size metric, but mention it by saying that some languages are wordier than others for FP. I have already agreed that my techniques may not score well on cpu performance, but that is often not the bottleneck. I don't need to use Eval enough to make it a bottleneck, for example. 

''"I assume you mean productivity rather than tests on concepts."'': Yes, but not only. Other important things are maintainability and flexibility of the software. (The value of the latter is debatable and debated; agile and extreme programmers tend to discount it more than I do, you've called it into question based on market forces, and I acknowledge that it's open for debate and will depend on the expected lifetime and application of the software being designed. Estimating the importance of such factors is all part of the engineering process.)
* Yes, but those are hard to nail down to specific numbers. They are too fuzzy to be useful scientific metrics. I wish they were more measurable also, but they are not. It is probably because they are tied to much to individual psychology.

''"I have been chewed out for trying to factor out repetition for just such reasons."'': This is sad, but even more sad if you take it to heart as a guiding principle. I've seen a lot of software scrapped and rewritten because it became unmaintainable. Where's the economy in that? Nobody measures the long-term effects.
* See CopyAndPaste.

''Explaining concepts is probably easier than explaining benefits, I'm sure you will agree.'': Yes. Since some benefits are subjective, or only manifest themselves through an improvement in thought processes that can't easily be directly demonstrated, the concepts have to be transmitted first so that the receiver has the opportunity to experience the benefits for himself/herself. This is where many of our discussions break down, IMO.
* I can describe the psychology for my pet techniques. It is just that the factors I use are not important to others. I am a visual thinker while many are liguistical thinkers, for example, and I cannot change that. 

BTW, I wish you wouldn't answer by interspersing comments. You've complained about ThreadMess, and that's one of the major causes. (You're not the only one that does this chronically.) I realize that it makes it much easier to reply, but over time it makes it very hard to follow a discussion chronologically. Even over the near time, a discussion is hard to follow this way without using a quickDiff view. I once tried to refactor your comments after a long section of a commentary, but it's very difficult to do after the fact.
* It is hard to make everyone happy with regard to response style. Do you prefer that each level of reply spawn a new section? I personally do not like that because it violates OnceAndOnlyOnce and makes it hard to follow the "chain".

-- DanM

''"Most software debates are not over correct output."'': Well, yes, but ''you'' were the one that brought up project failures. This is a good example of how you debate circularly and illogically, and why everyone gets frustrated interacting with you.

* Sorry, but I have no idea what you are referring to. Perhaps you mean as part of the XP discussions. If a project fails, then generally it does not produce the correct output. More specificly, it does not fit user's needs. However, this is usually not because the wrong paradigm was used, but rather poor communication. "We could have saved this project with HOF and closures" is not very likely.

''"Yes, but those [maintainability and flexibility] are hard to nail down to specific numbers."'': The fact that they are hard to measure does not mean that they should be ignored.
* But if both of these depend on differing psychology, it will only end up in huge holy wars. I would suggest going after the low-hanging fruit on those, but let differences on subtleties live.

''"See CopyAndPaste."'': I did, and disagree strongly, based on extensive personal experience.

I think we can sum things up by saying that your philosophies on what's acceptable practice in software development, although not entirely unique to you, differ from that of most of the people that come to C2 wiki to discuss technical issues. Your support of copy and paste programming makes that pretty clear, 

* I find that a misleading summary of my opinion on that.

and I don't think any of the raging debates with you will ever come to a conclusion due to these truly massive differences.

Since that's the case, I respectfully would ask you to simply avoid debates on other programming techniques, since you see them all as undesirable, and the debates are cluttering the wiki awfully by dint of sheer volume. There's not much point, for instance, in starting a debate on evaluation of strings versus functional techniques when you're convinced a priori that anything more sophisticated than eval is too difficult for most programmers, or not acceptable to managers. 

* Not entirely accurate summary of my opinion on this either. The benefits-to-complexity ratio is too small. We can't jam every paradigm and philosophy into a language/project without creating a mess.

Think first carefully what would convince you to change a position, and if it's not something that anyone can provide, or is logically impossible (like reducing code size without increasing abstraction), then don't bother. Or simply state the criteria up front. Yeah, that's a good idea. No more debates without specifying up front what the relevant criteria are. Then readers can judge a priori whether it's worth engaging or not. 

The challenges are also pointless; anything that anyone would come up with that would meet your 'less code' metric would violate your prohibition on advanced abstraction. After all, how else can code size be reduced, other than using more powerful abstractions? There aren't too many ways, short of using shorter identifiers. (Ha ha.) Except in the case of complex algorithms, where the algorithm itself can sometimes be improved. But you're generally not interested in applications that involve complex algorithms.

* I am not quite sure what you mean here.

I assume that one of your ultimate goals is to expose people to the TOP paradigm. Rather than challenging other paradigms, you'd be better off just providing examples, and answering questions that people might have. Direct comparisons of alternative implementations are not very useful since people differ so much on what the desirable qualities of programs are.

-- DanM

---- 

My last post on this page, I am (and have been) as fed up as anyone else. Top interests me because, while I know a great many people with a similar skill set, a disinterest bordering on disdain for "pure" or "low level" programming, and no interest or need to expand their knowledge, 

''A lot of biz developers spend a lot of time on education and self-education. It is just that they are not very interested in the same tools that you find nice. Most are also from the MentalStateOfMissouri.''

[Sigh. I am so weak. I ''am'' a biz developer, you moron. But I am not ''only'' a biz developer, which is what makes me not you.]

* Then you are well qualified to provide some decent biz examples instead of keep settling for systems software and university contest examples.

** Stop the bullshiting, Top. You've been told how FP shines in '''algorithmically complex problems''' (which you confused time and again - proud ignorance - with SystemsProgramming which is different, and you do that after I corrected you 2 times: a sign that you '''never listen''' and '''never learn'''). Now because all you do in your business apps is PutTheDamnDataOnTheDamnScreen (hence your disdain for interesting algorithmics), that does not mean that all business applications are that simple. You've been provided before with an example of published reports on a complex financial application, and for your convenience I'll refer it again here: http://www.lexifi.com/faq.html. The '''published''' paper describing the application of FP to that domain can be found at: http://www.lexifi.com/Downloads/MLFiPaper.pdf . So you have a good company with a real product and a published paper describing some of the details. That's much more than the MS-Access code full of holes that you published to solve a boring problem.
** ''Isn't that the same as the FinancialContractExample? And, #6 is not MS-Access code. Caught you sloppin'. And, what is the purpose of calling it "boring"? It comes across as an insult, but I am not sure what it actually implies. If you need entertainment, go rent Girls Gone Wild II.''

Top is the only one who has all these attributes *combined* with the desire to debate with people who don't share them. I should mention that I don't think any of the first 3 attributes are bad, in and of themselves, although they don't lend themselves to skilled programming, but the last one really puts a point on things. I haven't seen any pages here where someone describes some cool technique and then tacks onto the end "By the way, this is impossible with tables, up yours Top", whereupon Top is obligated to defend his discipline. I've only seen Top interjecting that tables or collections or strings or whatever he's dealing with today are equal in power to whatever anyone is describing. 

''I see a lot of complaints about "arrogant Lispers/FP'ers" injecting their stuff. There is something like 4 topics complaining NOT started by me. This whole FP thing got started when I HAPPENED to spot some heavy bragging, the very kind you accuse me of making. Even the OO'ers are complaining, which is like Mussolini calling Hitler "evil". (I know I know, GodwinsLaw).''

[I call em like I see em. I see you, not FPers. Maybe they all left and went home, so you should shut up now?]

I know a bunch of Access and Excel gurus, none of which know a damn thing about programming any other sense or environment, but they don't troll Usenet or Wiki looking claiming that Excel could be used to better implement something, either. -- ChrisMellon

''They leave that to the FP and OO zealots instead. The bottom line is that you ignore your own evil and magnify mine. You think your views are the default and/or center of the universe, but they are not. '''I might not like Excel or Excel programmers, but I am not going to belittle them without first producing a good demonstration.''' ''

[Oddly enough, not a single one of the Excel gurus I know gets email from OO zealots, not are they accosted in the street. They're perfectly happy doing what they do. Not one of them would be offended by my description, either, none of them think of themselves as programmers or language designers or any thing except a businessman who knows how to use Excel. You think that TOP, which you have shown absolutely zero working, live, tested code for,]

Do you mean examples? Challenge#6 is runnable code.

[is all hot shit and compares equally to every other paradigm out there, to the point where hybrid paradigms are just as blasphemous as anything else. You argue and argue and argue from ignorance, expecting everyone else to educate you from raw principles, and simultaneously rejecting any information that's at odds with your preconceptions. You regularly mischaracterize and otherwise throw up strawmen.]

No, it is YOU. I have documented several cases of youses above mischaracterizing my opinion. How many times do I have to keep presenting evidence for your screw ups? You don't even apologize. You are so biased as to dismiss your errors and magnify mine to be mountain-size. You are so full of double standards.

[You play both sides of *every* logical fallacy out there.]

Bullshit. My logic is sound. 

[HOFs are only of minimal usage in rare circumstances, but it's worth rewriting an app to store all it's data in tables just in case the developlment team needs to handle billing at some point in the future.]

Managers ask for different things from the data in my experience. This is an accurate description of the world as I observe it. Maybe I am delusional and just imagined all those last-minute requests that resulted in my leaving the office late.

[You don't want to see code, but you demand specific examples. You're unable to generate a mental abstract of requirements from a short description,]

Hey, you guys complained that example #6 was poorly documented even though it looked pretty strait-forward to me.

[but expect everyone to swoon over your 8 line schemas. When all else fails you toss out the whiny "poor me, why am I so persecuted?" card. You aren't persecuted, you're just disliked. I don't know any of the other posters on this page, I've never met them, there's not #wehatetop IRC channel we all plot our attacks in. I became involved in discussions with you out of a genuine desire to (depending on the page and topic) either educate you about a question you were asking, point out an inaccuracy in your statements, or to request clarifiction on a claim you had made. Your behavior, and nothing more, has brought me to the point where I have a severe personal dislike for you. You might ask what it is about yourself that can take someone with zero previous experience with you to that point in such a short period of time. I suspect my story is not unique.]

People often end up hating people they disagree with. I already explained this. 

[Last point: There's a common maxim in lots of fields, from athletics to deportment to science. It goes something like this: Rebel from knowledge, not from ignorance. Learn the common, "correct" way first. Learn how things are done now, and become skilled within that method. Once you're skilled in the form, you have the knowledge of how to break the mold and perhaps lead the way to new territory.]

That would just create a higher and higher pyramid that is purposely kept high to protect holy turf from the onslaught of scrutiny. "We won't listen to you until you master our 5000 volumes of bullshit." Nice trick. The grandest of self-fulfilling prophecy.

''Kind of an annoying sort of Socrates, isn't he? Knows nothing when he talks, knows everything when you talk.''

That's right. You are good and smart and I am dumb and evil. Life is simple. -- top

----

How can you discuss with someone

* Who hates Language Feature Creep yet doesn't like HOF which is the very least feature that, if added, will get rid of any higher laguage construct.
** If you have found the GoldenHammer, congratulations. 
** ''It's not GoldenHammer. But it's that you are using your bear hand to work, that I introduce you some tool.''
* Yet he likes Eval, which is usually the last feature one will ever want to use, given choices. He fight for it against HOF, but when ever doubted, he said "I haven't used eval much either". Ehh... someone who haven't used eval much, doesn't know any shit about HOF, is arguing against 4-5 others prgrammers who used HOF massively (And yes they all know about Eval)?
** It is relative. I don't use it much per lines of code, but it has been very helpful for the dozens+ apps where it was needed. It is kind of like a flashlight: you don't use it that often, but it sure is useful when you do.
* Doesn't like try/catch (it's feature creep). He views it as "Nested If/Else" (what kind of expert is that? Try/catch is nested if?).
** Take it to relevant topic. No need to get into that here.
* Claim to want to expose runtime environment, yet doesn't like Reflection. He said Reflection is narrow-purpose Eval.
* Claiming to be expert in his DB/Biz field. (How can he not be expert when he even try to make up new programming paradigm) Yet doesn't even know a thing about Prepared Statement which is there in any DB Driver for like, what, 10 years? He is ignorant, unwilling to learn, even in his own field.
** Somebody else found your claim of commonness suspect also.
** ''Who is that somebody else?''
** Dan Muller
** ''Dan Muller suspect my claim about PS being broadly used. May be he haven't heard of it, just like Top. But that's where's the common ends. I didn't see Dan Muller claim afterwards that PS is not suitable over SQL string building, nor see him complain about it. He didn't know it and fine, he just admit so and learn. Top is the only one to argue that "What I don't use now must be bad!!!". He doesn't know much about Prepared statement yet he raise so much disadvantage of prepared statement (which doesn't even really exists). And instead of trying to learn PS as his new tool, he just go on fighting it. So in the end, may be week after this, Dan Muller will know what PS is and what it does. But Top will just stay like this. ... Nevertheless, he still claim that he is all ear to learn new things.''

** It was not relevant to the discussion at hand. Stop trying to make a mountain out of a molehill. I simply asked some probing questions because you kept talking about it, which you tried to turn into a conspiracy. You guys tend to lose focus on the big issues. To me it appears to be red herring play.

** ''Not relevant, TOP? Let me give you a clue: if somebody asked you at an interview and you didn't know about it, you'd be rejected on the spot for most projects in your favorite domain (business apps and SQL databases). So you have something to be thankful for. But rather than get a clue about it and learn, you immediately jumped in with the attitude "if I didn't know about it there must be something wrong with it, let's throw any argument and the kitchen sink and see what sticks". The same goes about higher order functions and eval, except that here you're lucky and the probability of somebody asking you about higher order functions or about eval, at an interview is much lower. But I can guarantee you that if you somehow landed at an interview with a project that needs more complex algorithmics and you'd try to seel the same crap about eval or the non-sensical comment you put about try/catch or similar stuff that '''you just don't know and refuse to learn''' you will likewise be rejected on the spot. The arguments have been brought to you on why eval is worse than HOF in most spots and how it relates with the prepared statements issue. But just like you did when you were first presented with prepared statements, you continued with trolling replies until the ThreadMess is so big you can conveniently pretend that no arguments were brought.''

** Like I said, I worked in at least 10 different shops of a wide variety of company/org sizes, large and small, and none of them used PS's in any significant quantities. As far as my techniques not being able to "handle complex algorithms", that remains to be seen. I have yet to see a good biz example of something that trips my techniques. When I see an example that trips my techniques, then I might change my belief system a bit. But another issue is that if one rarely encounters this nebulous beast you call "complex algorithms", then why should it matter? No tool does everything well and I don't claim mine does either. Note that you guys suggested something similar in GraphAlgorithmsWithTables, and I eventually showed a TOP-ish solution, proven them wrong. -- top

** ''Cool, I heard Top talking about focusing on Big issue. Cause in Dynamic string VS functional or any topic, no matter what example someone is showing to him, If it contains or used Array, he then bring DB in to and reject the example. So not red herring there.''
** Are you suggesting that I actually do use a lot of arrays (given a choice)? Or that not using arrays is somehow irrelevant? It is certainly conceivable that different styles may lead to different needs. I don't question that for YOUR style, FP may make a bigger difference, but why should anybody who doesn't use your style care?

* From all the features he feel comfortable with (procedural, no exception, no reflection, others goes to eval and DB) you can quite see the level of complexities in his program.
** This sounds like argument-by-intimidation.
* It makes me think he has a hard time understanding any concept more than "basic If/Else, Loop" construct. So it is really hard to explain anything higher level than that to him due to the limitation of his capability. Have you ever seen a kindergarten student trying to argue with a college student about a differential equation? The kid will never get it, and we can't teach him either. Because he has too much to learn before he and us have even a tiny piece of common knowledge.
** Did I touch off a nerve or what? Just produce convincing FP code relative to biz apps. Spend your vast genious doing that instead of personal insults. In other words, use code, not your mouth, to prove your point.
** No, I suggest that you FOCUS ON THE BIG ISSUE. In such example, the array represent any whatever collection there is in the world, be it linked list, hastable OR RESULT SET. Just because the collection doesn't come out of SQL query doesn't mean the whole topic on whatever the example is showing is moot. If we go ahead and change all the example you disagree to declare 'arr = new ResultSet' instead of 'arr = []' then will you suddenly agree with whatever topic the post raise there?
** ''I am not sure what example you are referring to, but in ChallengeSixVersusFpDiscussion there is talk of using SeparateIoFromCalculation that may be related.''

Moved discussion to BusinessSystemsAnalysis.

----

''Moved from TrollColoredGlasses:''

Top says, ''"Produce hard evidence, and I will go away."''

Someone else responds, "No you won't, you'll ignore it and pretend it never happened or was never shown."

Is this evidence of trollmanship, or just plain stubbornness? Should we be a little less apt to toss the T-word around? Patience called for, methinks.

I've seen the evolution of Top's posting in real time, where he starts with a standard neutral piece of his continuing Socratic dialog ("tell me this, I just don't know, show me that evidence, I can't see it...") and then minutes later, adds wholly gratuitous remarks to the same sentence that are nothing but snide and inflammatory. This is, dare I say it, objective evidence of trolling. Fact is, there's nothing better to do on this wiki than do battle with this CompellingVillain, so I suppose he'll continue to dominate discourse here even with some who actually see his trolling.

* I make it a point to not flame unless flamed first. I never consciously insulted somebody unless they FIRST insulted me. If I have, it was purely accidental and against my policy. Ideally, I should just ignore it and never even flame back even if I am not first, but I guess I am not Jesus...just yet. :-) -- top

''Are you saying that he commits an edit where he has only added reasonable dialogue, and then minutes later edits his previous edit to include inflammatory remarks? That is quite strange. If it was just plain trolling, I can't imagine why he wouldn't put the inflammatory remarks in the first commit.''

I'm saying exactly that, yes.

''I honestly never recall doing this. I sometimes edit my comments to add details, but never JUST to add insults. These accusations are rather strong and I am personally offended by them. For the record, '''I adamantly deny ever intentionally doing such'''. Perhaps it was somebody else trying to make me look bad, or just a misunderstanding. All these "wiki urban myths" are popping up about me.''

''Once I put a nasty message in Costin's personal page on a line by itself, and then removed it in the morning after I decided against it. Is this what you mean? It is the opposite though: subtraction, not addition. However, it does bring up the question of what is the proper protocol for changing my own replies in the middle of threads. Should one mark it as changed? Is there a standard wiki flag for that? -- top''

I compose my replies online, over several edits. Often, I add more attacks to my reply but the number and severity of actual insults always monotonically decreases over time. Revised replies are always calmer and less inflammatory, and almost always more elaborate and accessible. This is why adding insults over the course of a multi-edit reply seems distinctly sociopathic to me. It's an extremely serious charge and I simply don't believe it. -- RK

----
From SelfStandingEvidence:


It would be interesting to see Costin or anybody "prove" that relational is objectively better than navigational. I like relational, but I am not prepared to say it is objectively better. My evidence mostly depends on psychology assumptions, and thus is technically subjective.

''The relational calculus is considerably better established and understood than the SigmaCalculus or the other various formalisms for OO; thus, formal reasoning about RDBMSes is fairly straightforward for those who study it, while OO formalists are still largely trying to agree on their terminology. However, that does not necessarily imply that RC is a better design approach in actual practice; after all, lambda calculus is even better established, covers a much wider field of study than RC, and is the ''lingua franca'' computation theory, but programmers haven't exactly flocked to the FunctionalProgramming banner even for those aspects of software where it is demonstrably superior. -- JayOsako''

Well, that is the key: "actual experience". It is nice to have a lot of ways to reason about combinations of the base axioms of concepts, but that alone does not make it useful. Perhaps it is a necessary requirement, but not a sufficient one. Somebody can probably make a bunch of math out of most of the EverythingIsa'''''s if they spend enough time playing with them. -- top

''You may have a point. After all, MemTheory and CalculusOfIndications both frequently send classical mathematicians screaming into the night, but IIRC both of them have been proven to be TuringEquivalent computation models... hell, GameOfLife is TuringEquivalent, for that matter. -- JayOsako''

Re: "hell, GameOfLife is TuringEquivalent"

That has gotta make for some odd source code, along the lines of reading BrainFsck.

''Actually, GameOfLife implements simple NAND gates and memory cells using dozens of cells. So it's beneath even machine language.''

I think, this page should be cleaned up, probably >90% deleted.

''It could serve as a sample and/or warning for anybody who wants to bring up a series of similar charges in the future. However, perhaps it is TheAdjunct material.'

-------------

TopMind is a Usenet troll who would like to be thought of as a "controversial personality."  His current preferred groups appear to be comp.object and talk.origins where he recently (April 27, 2006) claimed "Perhaps I am delusional, but from my shoes it appears I win or draw about 90% of all key arguments." The consensus of objective observers is "delusional."

''I get a fair amount of emails that thank me and encourage me to take on the status-quo when I see problems. A.K.A. "fan mail". Are they also delusional?''

'''Ah yes, the great mass of supporters willing to send you email but otherwise completely undetectable.'''

* They seem to number almost as large as my detractors. (Of course you will probably accuse me of misjudging that because I am allegedly delusional.)

'''Interesting, isn't it, that your detractors are more than willing to post publicly and yet only you hear from your defenders.'''

* Some have said that after seeing the punishment I take, they decided to stay out. One guy confided that he was even going to write an anti-OOP book, but called it off when he saw the heat the topic generated and the nasty email's he got for a small article about it. Intimidation is a powerful tool. Unfortunately for you, it does not work on me. It just fuels my growing martyrdom complex. With the likes of web-stalkers like you around, it is hard not to have a martyrdom complex. I might be a topic-troll, but you are a personal-insult-harassment-troll. I think the second will fry in hell longer if there is such a place. --top

TopMind appears to be a classic instance of FerrousCranus (from the Flame Warriors list at http://redwing.hutman.net/%7Emreed/index.htm):

http://redwing.hutman.net/%7Emreed/Assets/ferouscranus.jpg

"Ferrous Cranus is utterly impervious to reason, persuasion and new ideas, and when engaged in battle he will not yield an inch in his position regardless of its hopelessness.  Though his thrusts are decisively repulsed, his arguments crushed in every detail and his defenses demolished beyond repair he will remount the same attack again and again with only the slightest variation in tactics."

* Can you give a specific example of where I was "crushed in every detail" but failed to acknowledge it? Please select something that is easy for the reader to verify rather than something complex with lots of nitty-gritty evidence on both sides. In otherwords, a clear-cut knock-out.

''In InternationalUiExample, you created a table-based solution to a task you '''by your own admission''' had never done, then were conclusively refuted by people who '''had''' done it (and done it professionally, not just a toy example). Those who had done it used flat files, never tables, and never an RDBMS. When challenged, your answers were a classic example of MovingGoalPosts. To everyone except those who rhinohide, it was a clear-cut knockout. You were crushed in every detail.'' 

** ''Ha ha ha. That is the best you can do? 1) I never said files wouldn't work. 2) How do you know tables won't work? 3) Others agreed that under certain circumstances, such as many language editors, a table-oriented approach would indeed make it easier to keep track of stuff. 4) You did not prove that tables objectively would not work. Where is the knockout in that? 5) Your argument could be seen as a variation of, "we always have used assembler and it worked, so we should always continue to use assembler". 6) Databases can do everything files can do, but not the other way around. What is wrong with presenting both a table view and a file view? There is not more than one way to do everything? Are you afraid of secondary viewpoints? Should I be punished by your harassment as if I was a MAMBLA member or a terrorist for mere database viewpoints? --top''

** Specific examples are available to anyone who bothers to read your Usenet posting history.  Experience shows that providing you with feedback is useless -- you will simply ignore evidence, focus on unimportant, tangential issues, and drag the discussion out beyond all human patience.

** ''Well, if they are all like that one above, I don't feel any threat. Tables Work and file systems are a tangled tree mess in every single org I have ever worked for or contracted with. If files are the pinnacle of info organization, then I am indeed delusional. Set theory is for superior minds that "get it". Trees are for swinging monkeys. El Neener neener neener. I suppose DrCodd is a "troll" also? Go stalk and vandalize his online presense also, you Great Punisher from God, you.''

* In your opinion, am I evil or delusional? If the second, then why the harsh language toward me? Would you mistreat somebody with Down's Syndrome just because they have busted brain? I find your accusations inconsistent unless you advocate harsh verbage toward mentally defective people. I welcome accusations, but only if they are specific. "toppie is really bad" does not tell me and readers much. --top

** In my opinion, you are a troll.  Trolling is annoying, disrespectful, dishonest behavior.  You should stop it.  I should stop feeding you.

** ''"Troll" is too vague to have any clear meaning. It is like calling somebody "stupid". It has no real floor as far as specifics. Plus, you didn't answer my question.''

*** Ah, your usual "words have no meaning" whine.  The evidence is out there for anyone who looks.  Numerous independent people have pointed out your trollish nature.  That fact that you are blind to it (allegedly) is immaterial.

*** ''Most of the complaints are either non-specific or invalid. Anyone who challenges popular notions (within a group) is usually harassed. It goes with the territory. For example, the person who used to defend Microsoft here was heavily harassed despite not insulting people personally (unlike you).''

TopMind has expressed a desire that his identity not be explicitly revealed here, in order to prevent potential employers from knowing his true technical opinions. This should be honored because as a long standing participant who is universally known as "Top", he clearly falls into the tolerated exception category. There is nothing to be gained by trying to "out" him, especially as he's asked to remain pseudonymous, and his real name -- should anyone care -- is relatively easy to find.

'''No.  You're already hiding, badly, behind a pseudonym to prevent potential employers from finding out pertinent information about you.  There is no justification for hiding information about yourself from other netizens.'''

* What a hypocrit. What is YOUR identity, dear Mr. Stalker?

** I'm just one (or more) of the many people you've annoyed with your behavior.  Does being called on it annoy you?  I certainly hope so.

** ''I am sorry you are annoyed, but I have a right to state my opinion. I generally don't spread gossip and insult people personally (unless they strike first) but instead focus on the TOPIC. If you don't like what I say about a topic, then simply ignore it. There are a lot of annoying people on the web and making a personal Jihad against each and every one is just plain dumb. If you don't have the stomach for odd personalities on the web, then leave it and go for a walk in the park or see a movie. Life is too short to spend your time trying to punish people who rub you wrong. --top''

---

''Moved from TopMind''

TopMind is a Usenet troll who would like to be thought of as a "controversial personality."  His current preferred groups appear to be comp.object and talk.origins where he recently (April 27, 2006) claimed "Perhaps I am delusional, but from my shoes it appears I win or draw about 90% of all key arguments." The consensus of objective observers is "delusional."

TopMind appears to be a classic instance of FerrousCranus (from the Flame Warriors list at http://redwing.hutman.net/%7Emreed/index.htm):

http://redwing.hutman.net/%7Emreed/Assets/ferrouscranus.jpg

"Ferrous Cranus is utterly impervious to reason, persuasion and new ideas, and when engaged in battle he will not yield an inch in his position regardless of its hopelessness.  Though his thrusts are decisively repulsed, his arguments crushed in every detail and his defenses demolished beyond repair he will remount the same attack again and again with only the slightest variation in tactics."

* If I can be so wrong and not know it, then isn't it possible for you to also suffer from the same defect?  Why is your internal assessment mechanism assumed to be superior to mine? Are you closer to the center of the universe than I am or something?

TopMind has expressed a desire that his identity not be explicitly revealed here, in order to prevent potential employers from knowing his true technical opinions. This should be honored because as a long standing participant who is universally known as "Top", he clearly falls into the tolerated exception category. There is nothing to be gained by trying to "out" him, especially as he's asked to remain pseudonymous, and his real name -- should anyone care -- is relatively easy to find.

''Please take complaints about TopMind'''''s debate style to ObjectiveEvidenceAgainstTopDiscussion, and complaints about RealNamesPlease to PseudonymityAndHonesty, where it has already been discussed in detail.''

'''No.  You're already hiding, badly, behind a pseudonym to prevent potential employers from finding out pertinent information about you.  There is no justification for hiding information about yourself from other wikizens.'''

What a bizarre approach to privacy you have. There's no public interest in exposing his identity. As far as I can tell, you're only doing it as a (rather pathetic) attempt to do harm; "I disagree with your views/approach so I will reveal your identity despite your expressed wish otherwise" is just plain rude.  --AnonymousDonor
----
This has '''got''' to be one of the most useless, totally content-free pages on C2. Why do '''any''' of you care?

Because the issues have a tendency to keep reoccuring. It is better to keep them in a side topic ("discussion" page) than to keep reinventing the wheel. If the same issues start brewing, this acts as a been-there-done-that page.

''The "issues" are meaningless. Don't feed the troll.''

Fortunately for the world, you are not the sole god of "meaningless" judgement.

[I (MartySchrader, and ''not'' afraid to let the world know my identity) would like to know who this clown is so that I can avoid him in professional circles. I'd prefer not to get on to a gig and then find out that the IT side of the house is run by a paranoid, delusional, egocentric, melodramatic nitwit who has no clue about modern software development schema and thinks the software development universe revolves around him. The two things I absolutely '''can not tolerate''' in a business environment are incompetence and bullshit. Topper satisfies both of those conditions, so I would like to know if he is there up front so I can turn a gig down.]

Just avoid people who ask difficult questions and aren't afraid to take on others' HolyCow''''''s. Stick to comfortable ArgumentFromAuthority. --top

{If you were to actually "take on others' HolyCow''''''s" with compelling evidence and persuasive logic, you might be onto something.  From the readers' perception, however, you merely quibble.  Whilst you and the farmer bicker, the HolyCow''''''s stand chewing cud, placidly unthreatened.}

I cannot do that because ProgrammingIsInTheMind, and every mind is different. You should have known that about my position if you bothered to learn. Software is a tool to communicate between humans and computers; and how best to communicate varies per individual's WetWare. The computer doesn't care how software is organized, it just follows literal instructions like a savant. The difference maker is on the human side, not the machine side (outside of performance issues). I don't claim my pet technologies are "objectively better", only that nobody can show them objectively worse. If people imply something is clearly and objectively better, I will hold them to it, even if it irritates them so much that they call me nasty names. Complaints about OOP, such as the ones I have been making, are now becoming recognized by the industry and OOP is falling out of favor as a primary GoldenHammer.   --top

{Your response almost entirely sidesteps my point.  The only one here who has consistently and persistently claimed something is "clearly and objectively better" is you, about TableOrientedProgramming.  The remainder of us tend to be much more objective.}

That's a fat falsehood. I'm tempted to call it a "lie", but perhaps you are just confused and dazed or blinded by irrational hatred.

{No, I certainly don't hate you.  I find it difficult to hate what, from my point of view, is merely text on my screen.  I'm simply reporting what I've observed -- and what others have observed, apparently, given the very existence of this page.}

'''I deny I claimed TOP was "objectively better"''' ANY time in the last 5 years. I have been falsely accused. (I may have held that view a long time ago before I realized that programming is mostly about WetWare and not objective properties of the universe. However, I am not aware of any such claim remaining on this wiki, and if it is, it is very uncommon.) -t
----
I think the main reason why many hear don't like my content is that I include a relational/TOP point of view in just every key topic, and some don't want to hear it. There are at least 3 possibilities and sub-possibilities why they don't want to hear it:

* Just not interested
* Feel it is too small a viewpoint to document
** Con: There are a fair amount of relational fans. Lerry Ellison is usually among the top 5 or 10 richest men in the world. If they are not voting with their mouth, they are certainly voting with their wallets.
** Pro: Using tables on a small scale or app-level (TOP) is not very common, or at least not well documentd.
*** Con: What is wrong with documenting a niche viewpoint? Different viewpoints can be useful for looking at things even if you don't want to use them in production.
* Upset about the way I go about it
** Allegedly rude
*** Con: I try to reflect the behavior around me. I am nice to the nice.
** Difficult to understand
*** Con: If you see difficult passages, please point them out and I will rework them.
** Poorly factored
*** Con: In some cases this is true, but the solution is suggest a factoring layout. (Part of it is the complaint that I create too many topics already. I can't find a clean factoring without creating more topics in many cases, thus a catch-22.)
** ?
----
* Modular Writing --MopMind

''A long and winding debate that I don't chop things up small enough and my I preference for dynamic or weak typing violates some fundimental rule of the universe. --top''

No, you said "but that is getting full" and you created this module. I was congratulating you for creating another module - as apparently you didn't realize that by seeing a page was full and moving it here, you were using modular techniques. You always take things as an attack,  don't you? And strong static typing is not a feature that modular programming requires - although it helps to clarify specifications with an interface in each module, which is easier to do with a more declaritive type system.

''"Clear writing" is at least as important as "modular writing". That bullet was not clear.''
----
* (I have two cents about TopMind, that I find his views rather interesting. I'm almost shocked, I think, to see him labelled as a troll, although I can see that sometimes his perspective is rather out of left field--but I value this stuff. He shouldn't be putting up with any abuse whatsoever, in my opinion, none of this 'you are a classic etc.' I've risked my first comment to this wiki to say so--perhaps that will have people thinking ononotanotherone (certainly not).)
* ''It is a common pattern for people to defend TopMind until they've spent a few weeks trying to engage him in meaningful argument. I've seen no fewer than four people follow that pattern, independently, each with best intentions, none heeding the advice of those who came before them. Myself included. TopMind isn't a troll, but he is a crank and a HostileStudent. But don't let me dissuade you; I'll be happy to watch a fifth person follow this pattern. For science!''
* {Your first mistake is that you insist I am your "student". I am NOT your student. We are "debate partners". Science? You guys mostly reject science, relying on ArgumentFromAuthority instead. You guys don't have any objective evidence against me, just "trust me, I'm smarter" kind of evidence. SHOW you are smart, don't claim it. Kill me with objective and clear evidence that anybody can see and study on the screen, not ArgumentFromAuthority. Slam me with clear facts and clear logic, not insults. See BagSetImpedanceMismatchDiscussion? It was never stated how the developer would know the key is unstable. You guys just kept changing the subject. --top}
* ''Any argument of the form "Top is not an irrational crank unless you can use logic to convince Top he's an irrational crank" is just as moronic as "My pet is not a rock unless you can use rhetoric to convince my pet it's a rock." There's no point in trying to convince TopMind of anything, much less his own fallacy. Assuming the claim didn't already align with his beliefs, Top would call BookStop and demand SelfStandingEvidence if you argued the sky was blue. Then he'd shift to how `blueness is relative` (EverythingIsRelative) and `it's all in the mind` (ObjectivityIsAnIllusion) and `the definition of blue is an ArgumentFromAuthority`. Trust me, he's a crank.''
* {Maybe notions or convictions you hold dear or universal are indeed subjective. It's not my fault you can't handle the truth about software. Machines don't care how we organize our code, partition modules, name our variables, etc.; they just follow orders. Blueness is indeed relative, but at least we can survey people to form a probability curve(s) over what people call "blue". We can probably do this with software also, but it's more comparable to the field of psychology and physiology than to physics. Other WikiZens have stated opinions similar this also. I'm not alone. Note that if people say, "In my observation programmers are more likely to do X than Y" and it differs from my observation, I can respect that observation, letting both of our differing observations be stated and stand as two observations.}
* ''In my observation, TopMind isn't a troll, except when he's looking for an excuse to throw a tantrum. The off topic sentences about my convictions and the truth about software (whatever those are) serve as relatively clear examples of trolling.''
* {Off-topic? What's the topic again?}
* ''The topic is certainly NOT `the truth about software`. Surely you are able to read and answer your own question.''
* {YOU brought up topics such as EverythingIsRelative, which takes us to the common debates here about measuring the "value" of different software techniques because that's where EverythingIsRelative is mostly discussed.}
* ''I mentioned EverythingIsRelative, but I made it neither subject nor topic. Perhaps you should work on your literacy.''
* {If you use it as evidence against me, I'm allowed to address it. Perhaps you should work on your common courtesy.}
* ''Your address only supported my point. The validity of the EverythingIsRelative hypothesis was not the reason I mentioned it.''
* {Come back when you grow a real point then. Your round-about written logic is mirroring your round-about software "logic" here.}
* ''My point wasn't for you, TopMind. Not my problem if you can't see it. And I'll never explain to someone who won't play the willing student.''
* (If your point was for me, I have to say, that from where I sit, it does kind of look like 'work on your common courtesy' trumps 'work on your literacy'. I don't see TopMind's sentences about your convictions and the truth about software as examples, let alone relatively clear examples, of trolling. There's some ill-feeling around here, obviously. Some history.)
* ''There is history. I cannot offer TopMind a clean slate. And demanding courtesy after butting into someone else's conversation and attempting to direct it off-topic strikes me hypocrisy.''
* (I had claimed that I found TopMind's views 'rather interesting'. Note, that I'm not trying to convince him of anything, perhaps my own supply of patience will also run out, if/when I do. What I find interesting, is that there's a certain assumed common inheritance to being a mainstream programmer, to which TopMind is convinced he has something relevant/important to add. This common inheritance includes knowing hash tables, linked lists, trees, binary search trees, directed and undirected graphs, and being ready to implement (or extend?) an algorithm that operates on these data structures. This also, includes the ability to search for an element, to add an element, to remove an element. And then, knowing two paradigms, as it were, could mean knowing both the imperative and functional versions of each algorithm. I'm talking about the common data structures and algorithms. Or, if not common, then at least rare yet unreasonably effective. And beyond knowing a specific algorithm, or data structure, there is understanding how to design algorithms. And, here is another gap, this time between the ideal and the nitty-gritty--that is, between an algorithm, and its implementation. And there are many other things to understand, even restricting myself to the common inheritance of working programmers. There is networking, there is security, along those lines there is cryptography, there are operating systems, computer architecture, there is software testing, parallelism, lots gets categorized as software engineering issues, there is hmmm..there is discrete mathematics. There are programming languages. There's system administration. There's the Unix philosophy. I'll stop, too late, it's already beginning to seem like I'm going to give an inventory of all the pages on this wiki. But I don't expect to be asked to prove, that I could go on. The thought, however, that TopMind has got me thinkin', is that programmers often enough reimplement a database system within a larger software system. Do they/we understand the fundamental data structures and algorithms that power a database engine? I see evidence from my own experience, that TopMind has got a point. One example, of sorts, is a project that I was involved in several years ago now, which involved converting an application's database back-end to Hibernate. I learned a thing or two, and to make a long story short, got much more skeptical about Hibernate. Which, we probably are all familiar with Hibernate? It facilitates the storage and retrieval of Java domain objects via Object/Relational Mapping. Which is great, if we're all about enabling developers to utilize POJO-style domain models in their applications. Great, we have something that takes care of the mapping from Java classes to database tables (and from Java data types to SQL data types). That's worth something, perhaps..if it provides data query and retrieval facilities? Yes? Well now we're really cookin' w/gas. I had ample opportunity to meditate, while I was working on a team, and being paid more than my time is worth now, about how working with both object-oriented software and relational databases can be cumbersome and time consuming, and also, I observed that you do not need a strong background in SQL to use Hibernate. And I wondered, at the end, whether an investment in relational technology and knowledge might not have been more valid. This is a very breezy executive summary, but still I think it's better to have some concrete examples to get into, when pondering these abstract issues. For me, this was one example. I'm a professional. M.S. in Computer Science. Years of experience. I'm perfectly willing to assume, as much or more, of the others posting to this site. I'm a middle-aged man, wasted my young adult years twiddling the dials on this crap--if I have a right to an opinion about anything, etc., and I am not posting to encourage anybody to patronize TopMind. The notion that 'object-oriented overrated', hey that's easy. The notion that lots of programmers are running around, who know almost as much as they think they do, but not much about databases, that's easy too. The fundamentals of TopMind's case strike me as being quite strong. Never met him, quite possibly wouldn't warm to him, and my views are in flux. But I understand something of where he's coming from, that it appears to me, others don't give him that much credit. Relational algebra and relational calculus stand out as exceptional success stories. To wield some big words, w/apologies, I can give other personal examples, of how programmers working in the same room as me, including me, just didn't actually have a reasonable mechanism for coming up with and encoding the design of, and constraints upon, a software artifact. We had UML. But, in short, I think it might be edifying to reflect further, upon ways in which databases are too useful to ignore, and I'm totally serious, for what it's worth. This may seem like a very personal torque upon TopMind's schtick, much more of me than of him, but actually, I dunno, I've been reading more of his posts, and I think I get him pretty well. He's a bit pugnacious, doesn't mind the back-and-forth too much, though it can get a bit macho, but I think I get pretty well, that he's confident about a point or two, and the relevance therof, and I think he's pretty imaginative, and I take this seriously. Further discussion, might best revolve around more concrete stuff. I have plenty of that, though I may not be bothered, it's that or goof around w/some of my new hobbies (configuring vim, etc.), but remember that we're talking about complicated stuff, issues that have lots of aspects to them, would be my next two cents..)
*(I guess I can make a bit more of an effort. I note, that on TwentyFiveOrSoRulesToBuildSoftwareThatWorksAndWhichIsEasyToMaintain, TopMind has posted 27 Database-centric Procedural Design Rules of thumb. A few of these that I find interesting, especially in the sense of being rather 'top-ish': 'Sets are often better than trees and graphs for managing "variations-on-a-theme" types of problems for non-trivial and non-local variations..' And: 'Information about domain nouns goes mostly in the database, not code.' To take the second point first, it relates to the OoLacksConsistencyDiscussion, where we find: 'OO lacks a consistent big-picture organizational principle comparable to verbs-in-code-nouns-in-DB often found in procedural designs.' Also on this page, is the point that '(M)aybe this topic can somehow be merged with BigSoupOfClasses'. And, as to the first point, now here, a few I think uncontroversial points. Object technology encourages the designer to think of data as objects, not as tables. And, while it is the case, that with SQL, relational databases established a standard data access language, in the mid-80's an almost religious conviction in some parts of the IT industry held that all the theoretical problems of data had now been solved (and soon all practical problems would be solved as well). Perhaps that is a controversial observation, in which case, less controversial is that it wasn't the case. Now, early OO languages gave no thought to data storage, but a variety of object database products emerged on the market, and were met with a good deal of initial enthusiasm. And meanwhile, relational databases represented data as being held in simple two-dimensional tables. Perhaps the point here, is that relational database vendors had already gained momentum and market penetration. Or is there more to it than that? Perhaps it is true, not only that relational databases representated data as being held in simple two-dimensional tables, but also true as well, that this is an effective way to represent a lot of data in a way that programmers can easily understand. We have a logical and physical structure, one that is application neutral, one that works well for many business applications. And, in any case, automated data management means business can scale, and compete, in ways that it can't without it. So. What's a savvy business technologist to do? To bring this back to TopMind, and those design rules of thumb, and specifically, the first one that I quoted, that '(S)ets are  ofter better than trees and graphs for managing "variations-on-a-theme" types of problems for non-trivial and non-local variations..', I think TopMind perceives correctly, that he's arguing w/people who are convinced, that relational databases are constrained in their capabilities, in some ways, and that, to take TopMind's side, maybe this is less true than is suspected. Here is a concrete example. Consider a bus route. I mean, a simple, ordered list of bus stops. An object-oriented programmer has no problem with an ordered list, and needs no index. An index being, in this context, perceived by our hero, the mainstream object-oriented programmer, as an artificial creation, one that exists only because of the limits of relational data structures. Relational databases only hold tables as unordered lists. Because, they suck. And, they can retrieve an ordered list only if a specially built index is added. Because, etc. Another concrete example? A bill of materials. I'm enough of an object-oriented programmer myself, to know that mouths are watering--if we've got a product and its components, like in a manufacturing system, then the components themselves may have components, that in turn may have components and so on. And oh no a relational database table of all parts, wattanightmare, it will not express the relationships of the parts to the parts of parts. And so on. These relationships express important data! You want to query a database for a product and all its components, that won't be straightforward, but it should be! My (object-oriented programmer me) job of answering this simply query, is made nneccesarily complex and difficult. Similarly, with a map and its roads, rivers, landmarks. Similarly with a web site and all its pages, links, graphics. I think it might simply seem, I'm fairly confident of this, as I've traveled a good ways in my own views, it might simply seem to the generic object-oriented programmer, that the more complex the collection of information is, the more levels of hierarchy and cross relationships, that is, well, the less possible it is to represent it within the structures of a relational database. These structures being thought of, that is, as simple table structures. But, as an object-oriented programmer, I have no such limitation. I was born, indeed, to address this very kind of problem. And, the fundamental data structure that relational databases use, can be construed as in fact a problem. This thinking can be rather confidently done, by those who don't know why this design technique was introduced, in any case. And fast-forward things a bit, now we’ve seen persistent growth in the adoption of object technology in every area of software development. Database, let's call that the last area to hold out, shall we? Which is a problem, because this design technique, which was introduced for whatever reason, I dunno, is not capable of representing all the relationships and structures that data can have. However, let's leave complex data management aside, for the moment, put a pin in that, I have more, I think, to say about that, but..what about other advantages of relational databases, humour me what if they were to include good transactional performance, ease of management, rapid development, flexible query capability, standard data access interface, and suitability for business intelligence applications? That would be quite a lot. And then, coming back to complex data management, we have this design principle: 'Sets are often better than trees and graphs for managing "variations-on-a-theme" types of problems for non-trivial and non-local variations..' Is that true, and if so why? I will reason backwards, from first principles, here. The first principle, is this a controversial point? is that coupling is 'the root of all evil' when it comes to software development. This is perhaps not so familiar a statement, although I think I read it somewhere. Call it an argument from authority, my authority, if you disagree. I can explain further, this is fairly abstract, but will start sounding like familiar common sense, I hope, that by 'coupling' I mean some measure of the degree of dependence between two items. As in, the more highly coupled two things are, the greater the chance that a change in one will require a change in another. In any case, in a database schema, it is taken widely to be the case, that the more things it is coupled to, the harder it is to maintain and to evolve. At least to a DBA, this will all sound familiar, and relational databases can be coupled to lots of things. To application source code, is one, or two, if we consider your application source code, and other application source code, separately. Then there is data load source code, there is data extract source code, there are data migration scripts, test code, documentation. There are persistence frameworks/layers. There is 'itself'. Which is to say, coupling exists within your database. A simple change could result in several changes throughout your database. So ok, coupling is a serious issue. And when the concept of coupling is ignored, that will make matters worse. And, by whom, in this little story, is it ignored? Who is ignoring our greatest enemy? Well, I was dialing out upon this design principle: '(S)ets are often better than trees and graphs for managing "variations-on-a-theme" types of problems for non-trivial and non-local variations..' I've seen some interesting stuff posted by TopMind, which isn't in my experience really the kind of thing that is covered in excruciating detail in most database theory books even, about when coupling becomes a serious issue, which he takes to be when you start to consider behavior issues. CODE. I'd do better to give a TopMind quote here, but I think he'd be on the same page, if I attribute to him a thought, that you potentially need to use multiple models to develop software--because each model describes a single aspect of your software. And that, depending on the exact nature of the software you are developing, you will require at least a subset of the models. Different systems, different subsets. That, if you will, over time the variety of jobs you perform will require you to use each tool at some point, just like every fixit job at home doesn't require you to use every tool available to you in your toolbox. That, just like you use some tools more than others, you will use some types of models more than others. TopMind has given some details, regarding the wide range of modeling artifacts available to our hero, the mainstream OO programmer. One thing that I take '(S)ets are often better than trees and graphs for managing "variations-on-a-theme" types of problems for non-trivial and non-local variations..' to mean, is don't overbuild your software. Have the courage that you don't need to overmodel your system today, that you can model based on your existing requirements today--keep your models as simple as possible. Assume simplicity, that's a brilliant idea, we don't want to leave that idea to TopMind, screaming it from the rooftops. That's my idea, man. He stole it. As you develop you should assume that the simplest solution is the best solution. TopMind has a point, I think, about how taking this to be a core principle, is reflected by advanced use of RDBMS's (so is 'embrace change', so is 'incremental change', so is 'enabling the next effort is your secondary goal', some design principles of my own, if nobody wants to claim them). Now not everybody has read TopMind's more extended discussions/examples concerning what this has to do with '(S)ets are often better than trees and graphs etc..' But what it boils down to, for me, is that there is such a thing, and it's a sophisticated thing, as set theory. Meanwhile, is there such a thing as object-oriented modelling? Yes, there is, and in my experience, it refers to the process where you are designing how the code will look like. You were expecting something about creating an abstraction of a problem? About a way of representing something in the real world? Sure, fine, you win, but only to the degree that it draws from traditional set theory (do i have to give 'and classification theory'? no you don't getme). In which case, it would not be limited to computer-related elements (in which case, for starters, you wouldn't be using UML). I only want to stimulate curiosity here, if possible, about set theory. Is this something that everybody already values as the only thing worth knowing about? Then my comments are redundant. What is never, in my experience, redundant, however, is when I feel that something isn't going to work, that a few things are inconsistent with one another, that something doesn't 'smell right'. And my instincts, have become sharper. And what my instincts are telling me, at this point in my life, is that I'd have done well, before now, to have spent some time reviewing concepts and operations from set theory. Such as, 'set'. 'superset'. 'union'. 'subset'. 'cartesian product'. I see, looking back over this, that I'm getting warmed up. I certainly have no conviction, that this is the right page for more in this vein. But I'm wasn't bluffing when I claimed that i could go on. One simple point, is that in my experience of different work settings, the better resourced, larger companies, have more in-house database expertise. The little startups always have plenty of Object Oriented knowitalls. And go oob. I don't want to generalize too hastily, from my own experience..)
* ''Apologies, but I really can't motivate myself to read paragraphs of this size. Perhaps you can organize and trim a bit? Meanwhile, I'll respond to what I gleaned from skimming them.''
* ''I agree that many of TopMind's opinions are interesting, and I even agree with many of them. From my observation, TopMind is a concrete and intuitive thinker - he takes his examples, he feels his way through them, and more often than not he reaches good conclusions. Yet in those cases where I disagree, asking for a justification will get me pages of fallacy. And, it turns out, the same happens someone else asks for justification of a point I agree with - at which point I often felt some obligation to stomp his pitiful excuse for argument, even though I could have presented a cogent argument for the same point. He has learned to ask for logical justification (`kill me with logic`, he says) but he's just as bad at grasping a logical argument as presenting them, and he has developed his own irrational and hypocritical standards to armor himself against the logic and evidence raised against his points. It is these properties that has earned his ire on WikiWiki, and earned title as a `crank` - a man who cannot be turned.''
** You guys have been given many opportunities to show where I have been clearly logically or objectively wrong, and failed. I've asked you to turn your claims of my wrongness into numbered-item formal logic to make it clear where I was wrong. But you keep failing. When carefully dissected, things you originally took as absolutes often turn into probabilistic claims ("mostly", "rarely", etc.) such that they are no longer in the realm of traditional logic, and you are not comfortable with such probabilistic claims, or else observations are needed to assign an objective (3rd party) probability rating. It appears to me you are full of shit. -t
* ''Ultimately, Top spends his time either preaching to the choir - those who agree with him already - or building a thorough case against himself - to those who disagree. He'd be better off recognizing his own weakness in this area and sticking to examples, anecdotes, and intuitions. Meanwhile, even though his conclusions are sometimes good, his impact on WikiWiki is deeply negative.''
* {Maybe the real problem is ArgumentFromAuthority bumping up against RaceTheDamnedCar. You fit the first group. Authoritarians never like the empiricists. -t}
** Are you an empiricist?  Empirically speaking, OOP has pretty much killed table oriented programming. Since OOP has empirical evidence going for it, like hard statistics of how many people use OOP...how can you possibly be against OOP, since OOP has empirical evidence and statistics to support it? Be warned, that empiricists can be prone to ArgumentFromPopularity. Empirically, Islam may be a fast growing religion - the statistics support this. But that is ArgumentFromPopularity. Empirical evidence can be manipulated to prove silly things. Empirically Islam is good since so many people follow it.  Is it good? No. On the other hand, lots of people use computers - are computers good? yes. Empirical evidence can be twisted to suit your agenda, just as statistics can be twisted and cherry picked.
** {ArgumentFromPopularity is not necessarily empirical, but it does depend on the claim being tested. You have to state what you are testing, why you are testing it, and then produce or perform the test. -t}

* ''I'm happy with empirical evidence. Maybe, one day, you'll even provide some.''
* It's usually YOU (and your purist buddies) who makes the absolutist claims. Thus, the burden of evidence is on you. If you claim bags are objectively worse than sets-only, the burden's on you show so, for example.
*(I'm certainly sympathetic about the length of my paragraphs, really. You're too lazy to read them, I'm too lazy to work them into more accessible shape, but I'm sympathetic about laziness. However, I'm not impressed with the level of substance in these replies. I see, that the replies to my last post(s) are easily categorized as petty bickering. Frankly, I'm a bit disappointed in TopMind, that when he sees somebody coming to his defense, he interjects over my shoulder that 'you are full of etc.'. Not helping. I see that my comment about this being like 'observing a bad marriage' has been deleted. I'm willing to stipulate that my comments can be improved, but I'll make that observation again. But of course my original reason for posting was to remonstrate w/top's enemies, and, sadly, that has fallen on deaf ears, as I read in reply about his irrational and hypocritical standards, that he's just as bad at grasping a logical argument as presenting them, that he's a crank, that his effect is deeply negative (that sure is extreme, c'mon, really?), etc. If you're going to go on like this in reply to me, then I actually would prefer it if you actually read my posts. In an ideal world, I'd prefer not to have them edited, either. I remember living w/my mother, and it being her house, she'd come into my room anytime she liked, and clean up. Truly, I'm a slob. In fact, it was her house. Nevertheless, what was wrong w/her? Edit me, if your only intention is to get me po'd. Otherwise, well, I guess you have your reasons don't we all. I'd like to pick up the thread--I'd quite interested in arguments that the object oriented approach is ad hoc in nature. I think it's underemphasized, in mainstream OO circles in which I have traveled, that unrestricted functional dependencies and functional blobs negate the quality of design. Even talking about functional dependencies, that's a concept that is underemphasized.  The types of anomalies which a database may suffer from, that's an interesting subject to me that programmers don't tend to be clear on. That there are concepts of database design and management, that this is a big subject, I can probably get agreement on this much. However, I mean more than that it’s not difficult to find an online tutorial on creating a database, and it’s not hard to find a tutorial on how to create queries. Nor do I mean, simply that  it’s not hard to find tutorials on syntax for SQL, on the differences of data types, and on which database is best for what purposes. I think, that, and here I'm sticking my neck out, I don't think this is widely understood, I think that theories of designing, developing, and maintaining a quality database, even to the degree that this isn't difficult, I think that programmers tend to lack confidence-I'm generalizing. There are  some very orderly and sound rules to follow, but this isn't widely understood. This is my biggest issue, it's how I get into reading TopMind w/interest. The point that he's 'intuitive', well, you might have something there, although he's methodical and scholarly enough to have posted a detailed critize of the Bertrand Meyer book--I've spent some time w/his work here, and really, I think it's pretty worthwile, worth more time than I've yet given it. I've seen this side of him, he's smart enough for me so I say again that I think he's rather interesting.)
* ''Keep it on-topic. If you want to argue the merits and demerits of OO, there are pages for that. If you want to discuss anomalies in SQL, there are pages for that. If you want to discuss why TopMind should be banned from WikiWiki, you're in the right place. If you want someone to follow you on a tangent, you'll need to bait it better.''
* ''Deeply negative? Yes, I mean that. It seems to me that the vast majority of changes over the last five or six years have been TopMind bickering with one fellow or another, polluting page after page with toxic words. It doesn't even matter whether his message is right or wrong or relative or whatever - his message is ''buried'' and nobody will dig through the offal to see it. TopMind is not well served by WikiWiki, and WikiWiki is not well served by TopMind.''
** I'm all for improving such dialogs. Do you have any '''concrete''' suggestions? It honestly appears to me that most the fault is with the other side. They talk the value of logic, but don't actually show logic. Number the clauses and keep the clauses short and clear: 1) All bats are mammals. 2) All Fleppers are bats, 3) Therefore, all Fleppers are mammals per 1 & 2 using logic rule Foo, etc.  -t
** ''My recommendation would be to build a blog, present your arguments as for an audience rather than a dialogue. Stick to examples and graphics. Your best work has always been that way, but on WikiWiki people tend to inject comments and your message gets spread apart.''
*** I did. WikiZens mostly ignored it. http://www.geocities.com/tablizer/oopbad.htm (it's a little dated now) [NoteAboutGeocities] -t
*** ''And yet, it is still a better resource for your ideas than WikiWiki. Who cares about WikiZens anyway? There's like ten of them now. Appeal to redd.it''
*** {If it is outdated, then update it and put it into a wiki or  a blog that can be updated continually. Once upon a time, Fabian Pascal linked to your criticism of OOP but he then removed the link to your site when he found out about your other views on programming such as liking ExBase}
*** If it was ignored before, it will probably be ignored again, even if updated. As far as ExBase, he seems to focus on BigIron/critical domains/apps such that I can see why he would not want to see mention of ExBase. And it's more about ExBase having good ideas than it is ExBase being fully "good". -t
*** ''Is the attention of WikiZens more important to you than creating a message people can grasp?''
*** Feedback is nice. But a better approach may be to refactor the wiki pages to keep long discussions separate from summaries.
*** ''I understand it is difficult to create an unbiased summary that won't gather its own objections from one participant or another. How well has this worked for you in the past?''
*** Not well. I split one into two summaries into which each side can modify as they wish, though.
** ''And just because people don't meet your alleged standards for structuring a logical argument (which even you don't follow) doesn't mean they fail to show logic.'' 
** Why keep using the same failed approach if it only causes friction? You seem to be admitting that you don't present clear logic. Admission is the first step at AA. As far as me not following it? I tend not to make objective claims. Remember, I believe ProgrammingIsInTheMind (WetWare). Psychology is too soft a science to apply "mechanical" logic so far.  -t
** ''Clarity is also in the mind. I don't believe logic will be clear in your mind no matter how it is presented.''
** That's just an excuse for not presenting logic well. Don't knock it til you try it. If I reject formal logic, THEN you have a REAL against me. -t
** ''You already reject the law of the excluded middle. Feel free to lead the way if you want people to present formal arguments. Hmm... Might be interesting to create a Wiki designed around the notion of building structured mind-maps of arguments.''
** Where did I commit this sin?
** ''Where don't you? How about you look up the law of the excluded middle and tell me how to reconcile it with EverythingIsRelative. But it isn't a huge sin - there are formal IntuitionisticLogic''''''s (and the more dubious ParaconsistentLogic''''''s) that reject the law of excluded middle. My own preference is for intuitionistic logics, which are a subset of classical logic.''
** Do you have a specific wiki case we could explore this against? Let's avoid terminology battles and pick a "better tool" issue instead.
** ''I'm not interested in seeking an argument for its own sake.''
** Your accusation is too vague. I suggest illustrating it with a specific instance.
** ''So you accuse, vaguely. I have better ways to spend my time than trying to convince a fool of his fallacy. For example, I could teach a willing student, or engage in stimulating discourse with a peer.''
** Knock yourself out.
* ''Now I will leave you. I'm not especially interested in seeing comments about your mother bulking up an already too large paragraph.''
* (I'm concerned about staying on-topic. I'm also concerned about making myself understood, if you could try to meet me halfway. I'm saying that I find food for thought in this stuff. I've mentioned my scepticism about the notion, which I think some people totally believe, to the degree that they're surprised that anybody disagrees, that object oriented database is clearly more advantageous for highly complex data management requirements. I think that is very much a matter for debate. In a nutshell, I categorize TopMind as being quite reluctant to go along with the idea that the success of relational database Management Systems is limited to certain types of applications. Even that RDBMS's have been very successful, I think there is more food for thought in this than many realize (though they can't deny).  I tried mentioning some of my experience with attempts to remove the mapping layer required by relational databases to interpret data, in order to supposedly dramatically enhance throughput, capacity, scalability--to me, this experience is objective evidence, I wish I could offer better off the cuff, but I'm open to the notion that object oriented programmers hit a wall, one that can be measured, and the model and architectural differences that cause it can, I suspect, be explained, and this can be foreseen, and avoided. I might get into how the hierarchical data model organizes data in a tree structure, and how hierarchical DBMSs were popular from the late 1960s, with the introduction of IBM's Information Management System (IMS) DBMS, through the 1970s, how this doesn't work, and how object oriented programming can be categorized therefore as a piece of naivete. Truly, another page would be better for this, surely. This page, however, is superlame, anyways. There is no objective evidence against top.)
** Well RDBMS is not doing so well in the GUI department (OOP seems to suit GUI widgets more). So RDBMS is limited to certain applications. However, a lot of applications deal with data, and people often use IniFile, XML, stringlists, associative arrays, dictionaries, not RDBMS. So RDBMS indeed suits a lot of applications that we currently don't use it for. It's mostly because sending SQL strings and setting up the DB takes too much work and is too inconvenient for the customer. So the relational language needs to be built into our existing languages, in addition to having a language we can send by string, like SQL.  
** {That's why I'd like to see DynamicRelational in action. The existing flavor of RDBMS is too "rigid" and "static" for some uses. We got both "strict" app languages and "scripty" app languages, why not something similar on the database side? -t}
** ''It's really got nothing to do with being Dynamic.  One can still have a static strong typed RAD tool, so you could still have a RAD database tool inside your language - instead of STRUCTS and ARRAYS in CeeLanguage, you would have TABLES. Instead of just IF, WHILE, and GOTO, you would now have relational reserved words such as WHERE, SELECT, FROM, etc. There are many rigid strong typed RAD tools like Delphi, so why can't there be rigid data tools that are still RAD. Of course there can be.''
** Does Delphi tablize the GUI? That's the issue, not the existence of a GUI tool, if I am not mistaken.
** ''Your claim was that we need something more dynamic and scripty. My claim is that it's got NOTHING to do with being scripty or dynamic: if it had something to do with being scripty or dynamic, why are the visual rad gui tools like delphi not scripty and dynamic?''
** It was in response to: "Well RDBMS is not doing so well in the GUI department (OOP seems to suit GUI widgets more)". Delphi uses OOP to manage GUI's, not tables, if I am not mistaken. -t
** Continue discussion at TableOrientedGuiDiscussion.
* WhenAreDatabasesNotAppropriate may be related.

topical in MayZeroSix (together with all the other TopMind pages) and MarchTwelve

----
See also: IsTopTheNewRichardKulisz
----
CategoryDiscussion CategortMetaDiscussion