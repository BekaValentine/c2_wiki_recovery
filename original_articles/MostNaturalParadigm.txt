Person '''A''': ''...I long ago came to the conclusion that 'pure functional' is not a good thing for the whole of a language because people - programmers - don't think in that manner.''

Person '''B''': People--programmers--think in whatever manner they've learned to think in. Because of the arbitrary choice of Von Neumann-style processors,...

(AnonymousDonor''''''s from ThereAreExactlyThreeParadigms)

It's my opinion that people do indeed tend to think "naturally" in a sequential style. Whether it's inborn or cultural doesn't matter much for the sake of the discussion. I don't think it has much to do with hardware history, but rather they way popular western literature is written and presented. Food recipes and bicycle assembly instructions are written in a step-by-step fashion, for example.

''I think this is a space where clear, directed, scientific research is absolutely needed, yet no one wants to step beyond hypothesis. We need better information on exactly how people think, how people who end up becoming programmers thinks, and how it relates to programming language ideals and paradigms. Not just theory, but direct, repeatable experiment.''

* I wholeheartedly agree, but we don't have such research, so all both sides can do is speculate and give anecdotal evidence and citations of others' opinions at this time.

To deviate from this goes against years of being exposed to such a technique. This is largely why functional languages don't catch on as the primary paradigm despite being around longer than the minicomputer. Further, it has yet to be demonstrated that there is a significant upside in making functional the primary paradigm for a given app or system. (I'm not disputing the value of ''some'' FP mixed in, please note.)

It makes sense to have one paradigm be the "primary" paradigm, or at least the "glue" paradigm. Mixing them up such that each has roughly equal sway is too messy. Further, outside of familiarity issues, '''no paradigm has a clear advantage over the other'''; the code size and code change impact counts would be roughly the same if a master(s) in each paradigm coded up a given app in their respective paradigm specialty. 

However, there is indeed value in mixing them because certain aspects of a given app can sometimes take advantage of a given paradigm.

If you put these all together, then it points to having imperative as the primary paradigm, because it has the lowest learning curve, with the others sprinkled in to assist with various aspects. 

Imperative is made the primary paradigm ''not'' because it is inherently the best paradigm, but because we have to make ONE paradigm the primary, and imperative has a slight edge in familiarity due to cultural influence and/or human-specific psychology.

It's roughly comparable to having 3 very good and equally qualified employees vying for the single new management position. The tie will probably go with the one who's been with the company the longest, largely out of familiarity and bonding.

--top

''The secret cabal of programmers that created the "Top" AI laugh gleefully at this, the latest output of their pure-functional masterpiece.''

Warning: Do not trigger its "revenge" module.
----
See:
* EveryWare

------
CategoryMultiparadigm

